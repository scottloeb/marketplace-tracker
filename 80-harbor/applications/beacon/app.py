"""
Beacon - Graph Database Visualization and Pattern Detection

A Flask-based web application for exploring and visualizing Neo4j graph databases.
Part of the H.A.R.B.O.R. (Human Analytics, Research, Business Operations, Research) ecosystem.

This application provides an intuitive interface for exploring graph data through:
- Interactive graph visualization with D3.js
- Pattern detection and analysis
- Database connection management
- Real-time query execution
- Custom pattern library

The application uses a middleware layer generated by the Module Generator to interact with Neo4j.

Author: H.A.R.B.O.R. Project Team
Version: 1.0
"""

import os
import sys
from flask import Flask, render_template, request, jsonify, redirect, url_for, session
import json
from datetime import datetime
import importlib.util

# Add the module-generators/neo4j directory to the path
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
module_dir = os.path.join(parent_dir, 'generated')
sys.path.append(module_dir)

# Add PWD environment variable for Windows compatibility
if 'PWD' not in os.environ:
    os.environ['PWD'] = os.getcwd()

# Make utils directory accessible
utils_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'utils')
sys.path.append(utils_dir)

# Try to import the database manager
try:
    from db_manager import db_manager
    print("Successfully imported Database Manager")
except ImportError as e:
    print(f"Warning: Could not import Database Manager: {e}")
    print("Make sure you've created the db_manager.py file in the utils directory")
    sys.exit(1)

# Try to import the modulegenerator
try:
    # First make sure neo4j is installed
    import neo4j
    # Then import the generator
    from modulegenerator_claude import generate_module
    print("Successfully imported Module Generator")
    module_generator_available = True
except ImportError as e:
    print(f"Warning: Could not import Module Generator: {e}")
    print("Please make sure the 'neo4j' package is installed using 'pip install neo4j'")
    module_generator_available = False

# Initialize Flask application
app = Flask(__name__, 
            static_folder='static',
            template_folder='templates')

# Set a secret key for session management
app.secret_key = 'beacon-secret-key'  # In production, use a proper secret key

# Initialize components
db_manager = db_manager
pattern_library = PatternLibrary()
pattern_detector = PatternDetector()

# Home page route
@app.route('/')
def index():
    """Landing page with connection options"""
    return render_template('index.html', title="Beacon - Graph Explorer")

# Database connection settings route    
@app.route('/connect', methods=['GET', 'POST'])
def connect():
    """Database connection page"""
    if request.method == 'POST':
        # Get connection details from form
        uri = request.form.get('uri', 'bolt://localhost:7687')
        username = request.form.get('username', 'neo4j')
        password = request.form.get('password', 'beacon')
        database = request.form.get('database', 'neo4j')
        
        try:
            # Test connection
            success = db_manager.test_connection(uri, username, password, database)
            if success:
                # Store connection details in session
                session['db_uri'] = uri
                session['db_username'] = username
                session['db_password'] = password
                session['db_database'] = database
                session['connected'] = True
                
                # Generate or load middleware
                middleware_name = f"beacon_{database}"
                middleware_path = db_manager.generate_middleware(uri, username, password, database, middleware_name)
                
                if middleware_path:
                    session['middleware_path'] = middleware_path
                    session['middleware_name'] = middleware_name
                    return redirect(url_for('dashboard'))
                else:
                    return render_template('connect.html', error="Failed to generate middleware")
            else:
                return render_template('connect.html', error="Connection failed")
        except Exception as e:
            return render_template('connect.html', error=f"Connection error: {str(e)}")
    
    return render_template('connect.html')

# Add this new method to get database info directly using connection details
def get_database_info_direct(connection_details):
    """Get database information directly using connection details."""
    try:
        from neo4j import GraphDatabase
        
        uri = connection_details['uri']
        username = connection_details['username']
        password = connection_details['password']
        
        driver = GraphDatabase.driver(uri, auth=(username, password))
        
        with driver.session() as session:
            # Get node count
            result = session.run("MATCH (n) RETURN count(n) AS node_count")
            node_count = result.single()["node_count"]
            
            # Get relationship count
            result = session.run("MATCH ()-[r]->() RETURN count(r) AS rel_count")
            rel_count = result.single()["rel_count"]
            
            # Get node labels
            result = session.run("CALL db.labels() YIELD label RETURN label")
            node_labels = [record["label"] for record in result]
            
            # Get relationship types
            result = session.run("CALL db.relationshipTypes() YIELD relationshipType RETURN relationshipType")
            relationship_types = [record["relationshipType"] for record in result]
            
            # Node count by label
            node_count_by_label = {}
            for label in node_labels:
                try:
                    query = f"MATCH (n:{label}) RETURN count(n) AS count"
                    result = session.run(query)
                    node_count_by_label[label] = result.single()["count"]
                except:
                    node_count_by_label[label] = 0
            
            # Relationship count by type
            rel_count_by_type = {}
            for rel_type in relationship_types:
                try:
                    query = f"MATCH ()-[r:{rel_type}]->() RETURN count(r) AS count"
                    result = session.run(query)
                    rel_count_by_type[rel_type] = result.single()["count"]
                except Exception as e:
                    print(f"Error counting relationship type {rel_type}: {str(e)}")
                    rel_count_by_type[rel_type] = 0
            
            # Combine total and type-specific counts
            relationship_counts = {'total': rel_count}
            relationship_counts.update(rel_count_by_type)
            
            return {
                'node_labels': node_labels,
                'relationship_types': relationship_types,
                'node_count': node_count_by_label,
                'relationship_count': relationship_counts
            }
    except Exception as e:
        print(f"Error getting direct database info: {str(e)}")
        return None

# Dashboard route
@app.route('/dashboard')
def dashboard():
    """Main dashboard for graph exploration"""
    if not session.get('connected'):
        return redirect(url_for('connect'))
    
    try:
        # Load middleware
        middleware_path = session.get('middleware_path')
        middleware_name = session.get('middleware_name')
        
        if not middleware_path or not os.path.exists(middleware_path):
            return redirect(url_for('connect'))
        
        # Import the generated middleware
        spec = importlib.util.spec_from_file_location(middleware_name, middleware_path)
        middleware = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(middleware)
        
        # Get database statistics
        stats = db_manager.get_database_stats(middleware)
        
        return render_template('dashboard.html',
            title="Beacon - Dashboard",
            stats=stats,
            middleware_name=middleware_name
        )
    except Exception as e:
        return render_template('dashboard.html', error=f"Error loading dashboard: {str(e)}")

@app.route('/patterns')
def patterns():
    """Pattern exploration page"""
    if not session.get('connected'):
        return redirect(url_for('connect'))
    
    try:
        # Get available patterns
        patterns = pattern_library.get_all_patterns()
        
        return render_template('patterns.html',
            title="Beacon - Pattern Explorer",
            patterns=patterns
        )
    except Exception as e:
        return render_template('patterns.html', error=f"Error loading patterns: {str(e)}")

@app.route('/pattern/<pattern_id>')
def pattern_detail(pattern_id):
    """Individual pattern detail page"""
    if not session.get('connected'):
        return redirect(url_for('connect'))
    
    try:
        # Get pattern details
        pattern = pattern_library.get_pattern(pattern_id)
        if not pattern:
            return render_template('pattern_detail.html', error="Pattern not found")
        
        # Load middleware for pattern execution
        middleware_path = session.get('middleware_path')
        middleware_name = session.get('middleware_name')
        
        if middleware_path and os.path.exists(middleware_path):
            spec = importlib.util.spec_from_file_location(middleware_name, middleware_path)
            middleware = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(middleware)
            
            # Execute pattern
            results = pattern_detector.execute_pattern(pattern, middleware)
            pattern['results'] = results
        
        return render_template('pattern_detail.html',
            title=f"Beacon - {pattern['name']}",
            pattern=pattern
        )
    except Exception as e:
        return render_template('pattern_detail.html', error=f"Error loading pattern: {str(e)}")

@app.route('/api/execute_pattern', methods=['POST'])
def api_execute_pattern():
    """API endpoint for pattern execution"""
    if not session.get('connected'):
        return jsonify({'error': 'Not connected'}), 401
    
    try:
        data = request.get_json()
        pattern_id = data.get('pattern_id')
        
        if not pattern_id:
            return jsonify({'error': 'Pattern ID required'}), 400
        
        # Get pattern
        pattern = pattern_library.get_pattern(pattern_id)
        if not pattern:
            return jsonify({'error': 'Pattern not found'}), 404
        
        # Load middleware
        middleware_path = session.get('middleware_path')
        middleware_name = session.get('middleware_name')
        
        if middleware_path and os.path.exists(middleware_path):
            spec = importlib.util.spec_from_file_location(middleware_name, middleware_path)
            middleware = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(middleware)
            
            # Execute pattern
            results = pattern_detector.execute_pattern(pattern, middleware)
            
            return jsonify({
                'success': True,
                'pattern': pattern,
                'results': results
            })
        else:
            return jsonify({'error': 'Middleware not available'}), 500
            
    except Exception as e:
        return jsonify({'error': f'Execution error: {str(e)}'}), 500

@app.route('/api/database_stats')
def api_database_stats():
    """API endpoint for database statistics"""
    if not session.get('connected'):
        return jsonify({'error': 'Not connected'}), 401
    
    try:
        middleware_path = session.get('middleware_path')
        middleware_name = session.get('middleware_name')
        
        if middleware_path and os.path.exists(middleware_path):
            spec = importlib.util.spec_from_file_location(middleware_name, middleware_path)
            middleware = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(middleware)
            
            stats = db_manager.get_database_stats(middleware)
            return jsonify({'success': True, 'stats': stats})
        else:
            return jsonify({'error': 'Middleware not available'}), 500
            
    except Exception as e:
        return jsonify({'error': f'Error getting stats: {str(e)}'}), 500

@app.route('/logout')
def logout():
    """Logout and clear session"""
    session.clear()
    return redirect(url_for('index'))

if __name__ == '__main__':
    # Start the development server
    app.run(debug=True, host='0.0.0.0', port=5000)