"""
newgraph.py - Auto-generated Neo4j interface module

This module provides a Python interface to a Neo4j graph database,
abstracting the Cypher query language and Neo4j driver details.

Generated on: 2025-03-08T09:36:30.790000000+00:00
Generated with: modulegenerator version 0.1.0
Neo4j driver version: 4.4.0
"""

import datetime
import neo4j
from neo4j import GraphDatabase


# Neo4j connection details
NEO4J_URI = "bolt://localhost:7687"
NEO4J_USERNAME = "neo4j"
NEO4J_PASSWORD = "neo4j-dev"
NEO4J_DATABASE = "neo4j"

# Dan the human added this line of code manually because he made a mistake
# somewhere up the pipeline lol. He's leaving it in because it's a beautiful
# metaphor, if you think about it -- this was the only code left to fix
# by hand, it's the natural entry point for learning to write code, and
# it's a perfect first lesson in understanding Python. 
profile = {
    'uri': NEO4J_URI,
    'username': NEO4J_USERNAME,
    'password': NEO4J_PASSWORD
}

def _authenticated_driver(uri=profile['uri'], username=profile['username'], password=profile['password']):
    """
    Internal method to set up an authenticated driver.

    Parameters
    ----------
    uri: str
        neo4j connection string
    username: str
        username for the neo4j account
    password: str
        password for the neo4j account
    
    Returns
    -------
    neo4j.GraphDatabase.Driver instance to connect to the database.
    """
    return GraphDatabase.driver(uri, auth=(username, password))

def _query(query_text=None, query_params=None):
    """
    Submits a parameterized Cypher query to Neo4j.

    Parameters
    ----------
    query_text: str
        A valid Cypher query string.
    query_params: list(str)
        A list of parameters to be passed along with the query_text.

    Returns
    -------
    A tuple of dictionaries, representing entities returned by the query.
    """
    with _authenticated_driver().session() as session:
        return session.run(query_text, query_params).data()

def _server_timestamp():
    """
    Retrieves a timestamp from the neo4j instance and prints a message 
    to the screen. 

    Parameters
    ----------
    None

    Returns
    -------
    str:
        Timestamp from server.
    """
    text, params = Queries.server_timestamp()
    return _query(query_text=text, query_params=params)[0]['timestamp'].iso_format()

def _neo4j_node_to_dict(node):
    """
    Convert a neo4j Node or dictionary to a standardized Python dictionary.
    
    Parameters
    ----------
    node: neo4j.Node or dict
        The Neo4j node or dictionary to convert
        
    Returns
    -------
    Dict:
        A dictionary with keys 'uuid', 'labels', and 'props'
    """
    # Handle case where node is already a dictionary
    if isinstance(node, dict):
        # If it has the expected structure, just return it
        if 'uuid' in node and 'labels' in node and 'props' in node:
            return node
            
        # Otherwise, attempt to extract the necessary information
        props = node
        uuid = props.get('uuid', None)
        labels = props.get('labels', [])
        
        # If there's a special 'elementId' field, it's a Neo4j result dictionary
        # which might have labels under a different form
        if '_labels' in props:
            labels = props['_labels']
        elif 'labels' in props and isinstance(props['labels'], list):
            labels = props['labels']
            
        return {
            'uuid': uuid,
            'labels': labels,
            'props': props
        }
    
    # Handle Neo4j Node objects
    try:
        # Create a dictionary from the node
        props = dict(node.items())
        # Get the uuid (if it exists)
        uuid = props.get('uuid', None)
        # Get the labels
        labels = list(node.labels)
        
        return {
            'uuid': uuid,
            'labels': labels,
            'props': props
        }
    except (AttributeError, TypeError):
        # As a last resort, if neither approach works
        return {
            'uuid': None,
            'labels': [],
            'props': {} if not isinstance(node, dict) else node
        }

def _neo4j_relationship_to_dict(rel):
    """
    Convert a neo4j Relationship to a standardized Python dictionary.

    Unlike nodes, relationships in neo4j can only have a single type.
    
    Parameters
    ----------
    rel: neo4j.Relationship
        The Neo4j relationship to convert
        
    Returns
    -------
    Dict:
        A dictionary with keys 'uuid', 'type', and 'props'
    """

    # Handle case where rel is already a dictionary
    if isinstance(rel, dict):
        # If it has the expected structure, just return it
        if 'uuid' in rel and 'type' in rel and 'props' in rel:
            return rel
        
        # Otherwise, attempt to extract the necessary information
        props = rel 
        uuid = props.get('uuid', None)
        reltype = props.get('relationshipType', '')

        # If there's a special elementId field, it's a Neo4j result dictionary
        # which might have labels under a different form
        if '_type' in props:
            rel_type = props['_type']

        return {
            'uuid': uuid,
            'relType': rel_type,
            'props': props
        }
    
    try:
        # Create a dictionary from the relationship
        props = dict(rel.items())
        # Get the uuid (if it exists)
        uuid = props.get('uuid', None)
        # Get the type
        type = rel.type
        
        return {
            'uuid': uuid,
            'relType': type,
            'props': props
        }
    except (AttributeError, TypeError):
        # As a last resort, if neither approach works
        return {
            'uuid': None,
            'relType': '',
            'props': {} if not isinstance(rel, dict) else rel
        }

class Queries:
    def server_timestamp():
        text = 'RETURN datetime() AS timestamp;'
        params = None
        return text, params
    
    def node(label, **props):
        """
        Node interface cypher -- given a neo4j label (can be a multi-
        label separated by colons, e.g., Label1:Label2) and a dictionary
        of propNames and propValues, construct a parameterized Cypher query 
        to return a list of nodes with that label matching those properties.
        """        
        text = f"""MATCH 
            (n:{label} 
            {'{' if props else ''} 
            {', '.join(f"{prop}: ${prop}" for prop in props)}
            {'}' if props else ''}) 
            RETURN n;"""

        return text, props
    
    def node_labels():
        text = 'CALL db.labels() YIELD label RETURN collect(label) AS labels;'
        params = None
        return text, params
    
    def node_type_properties():
        text = """
        CALL db.schema.nodeTypeProperties() YIELD nodeLabels, propertyName, propertyTypes
        UNWIND nodeLabels AS nodeLabel
        UNWIND propertyTypes AS propertyType
        RETURN
            DISTINCT nodeLabel,
            propertyName,
            collect(propertyType) AS propertyTypes;
        """
        params = None 
        return text, params
    
    def rel_type_properties():
        text = """
        CALL db.schema.relTypeProperties() YIELD relType, propertyName, propertyTypes
        UNWIND propertyTypes AS propertyType
        RETURN
            DISTINCT relType,
            propertyName,
            collect(propertyType) AS propertyTypes;"""
        params = None
        return text, params
    
    def node_properties(label, limit=None):
        text = f"""
            MATCH 
                (n:{label}) 
            WITH n 
            {f"LIMIT {limit}" if limit is not None else ""}
            UNWIND keys(n) AS key
            RETURN DISTINCT key, apoc.meta.type(n[key]) AS type;
        """
        params = None
        return text, params
    
    def edge_types():
        text = 'CALL db.relationshipTypes() YIELD relationshipType RETURN collect(relationshipType) AS relationshipTypes;'
        params = None
        return text, params
    
    def edge_properties(type, limit=1000):
        text = f"""
            MATCH ()-[e:{type}]->()
            WITH e
            {f"LIMIT {limit}" if limit is not None else ""}
            UNWIND keys(e) AS key
            RETURN DISTINCT key, apoc.meta.type(e[key]) AS type;
        """
        params = None 
        return text, params
    
    def edge_endpoints(type, limit=1000):
        text = f"""
            MATCH (a)-[e:{type}]->(b)
            WITH a, e, b
            {f"LIMIT {limit}" if limit is not None else ""}
            RETURN DISTINCT labels(a) AS startLabels, labels(b) AS endLabels;
        """
        params = None 
        return text, params
    
    def edge(type, **props):
        """
        Edge interface cypher -- given a neo4j relationship type and a dictionary
        of propNames and propValues, construct a parameterized Cypher query 
        to return a list of relationships with that type matching those properties.
        """
        text = f"""MATCH 
            (source)-[r:{type} 
            {'{' if props else ''} 
            {', '.join(f"{prop}: ${prop}" for prop in props)}
            {'}' if props else ''}]->(target) 
            RETURN source, r, target;"""

        return text, props


# Metadata about the Neo4j graph
METADATA = {
    "node_labels": [
        "Movie",
        "Person",
        "Category",
        "Product",
        "Supplier",
        "Customer",
        "Order",
        "Ceremony",
        "Studio",
        "Production",
        "Review",
        "GeneratedByClaudeAI",
        "CarModel",
        "Prop",
        "Soundtrack",
        "FilmingLocation",
        "Organization",
        "Institution",
        "Equipment",
        "Costume",
        "EnvironmentalFactor",
        "AcademicField",
        "CulturalMovement",
        "TechCompany",
        "Attraction",
        "Merchandise",
        "EducationalProgram",
        "DigitalProject",
        "FanCommunity",
        "Book",
        "Scene",
        "Business",
        "Award",
        "ProductionChallenge",
        "Collectible",
        "FinancialRecord",
        "DistributionPlan",
        "MarketingCampaign",
        "FinancialStructure",
        "LegalDocument",
        "ProductionLogistics",
        "DistributionNetwork",
        "InsurancePolicy",
        "ArchiveRecord",
        "LaborAgreement",
        "LicensingProgram",
        "CommercialDeal",
        "PostProductionFacility",
        "FilmLaboratory",
        "Manual",
        "Part",
        "Chapter",
        "Message",
        "Concept",
        "Topic",
        "CognitiveState",
        "Algorithm",
        "AnimationStudio",
        "TechnicalInnovation",
        "FinancialService"
    ],
    "node_properties": {
        "Movie": {
            "title": "STRING",
            "released": "INTEGER",
            "tagline": "STRING",
            "dreamLevels": "INTEGER",
            "boxOfficeNA": "INTEGER",
            "boxOfficeEurope": "INTEGER",
            "boxOfficeAsia": "INTEGER",
            "boxOfficeOther": "INTEGER",
            "filmingLocationLong": "double[]",
            "filmingLocationLat": "double[]",
            "budget": "INTEGER",
            "certifications": "String[]",
            "genres": "String[]",
            "ratings": "double[]",
            "digitalRelease": "ZonedDateTime",
            "rating_avg": "FLOAT",
            "runtime_minutes": "INTEGER",
            "revenue": "INTEGER",
            "releaseDate": "LocalDate",
            "isOscarWinner": "BOOLEAN",
            "animationStudioLong": "double[]",
            "animationStudioLat": "double[]",
            "preservationRegistry": "STRING",
            "digitalRestoration": "ZonedDateTime",
            "isPreservationRegistry": "BOOLEAN",
            "preservationDate": "LocalDate",
            "initialReviews": "String[]",
            "technicalInnovations": "String[]",
            "festivalsWon": "String[]",
            "originalLanguage": "STRING",
            "boxOfficeInternational": "INTEGER",
            "subtitleLanguages": "String[]",
            "isInternational": "BOOLEAN",
            "temperatureUnit": "STRING",
            "extremeTemperatures": "long[]",
            "filmingDuration": "DurationValue",
            "filmingConditions": "STRING",
            "narrators": "String[]",
            "isDocumentary": "BOOLEAN",
            "musicalNumbers": "INTEGER",
            "digitalRemastering": "INTEGER",
            "iconicScenes": "String[]",
            "renderingHours": "INTEGER",
            "is3D": "BOOLEAN",
            "motionCapturePercentage": "INTEGER",
            "merchandisingSales": "INTEGER",
            "culturalImpact": "STRING",
            "culturalMilestones": "String[]",
            "isAnimated": "BOOLEAN",
            "animationStyles": "String[]",
            "renderedFrames": "INTEGER",
            "isIndie": "BOOLEAN",
            "festivalWins": "INTEGER",
            "filmingDays": "INTEGER",
            "specialEffectsAwards": "INTEGER",
            "rereleaseDates": "LIST",
            "iMAXSequences": "INTEGER",
            "posthumousAwards": "INTEGER",
            "nonLinearStructure": "BOOLEAN",
            "martialArtsStyles": "String[]",
            "practicalEffectsPercentage": "INTEGER",
            "sequelNumber": "INTEGER",
            "volumeNumber": "INTEGER",
            "homageFilms": "String[]",
            "visualEffectsBreakthrough": "BOOLEAN",
            "adaptationFidelity": "STRING",
            "periodAccuracy": "STRING",
            "isAdaptation": "BOOLEAN",
            "sourceAuthor": "STRING",
            "historicalAccuracy": "STRING",
            "iMAXPercentage": "INTEGER",
            "iMAXFilming": "BOOLEAN",
            "cgiBreakthroughs": "String[]",
            "specialEffectsBreakthrough": "BOOLEAN",
            "westernRemakes": "STRING",
            "filmPreservation": "STRING"
        },
        "Person": {
            "born": "INTEGER",
            "name": "STRING",
            "residenceLat": "FLOAT",
            "activeYears": "DurationValue",
            "typicalFilmLengthHrs": "FLOAT",
            "oscarNominations": "INTEGER",
            "nationality": "STRING",
            "isActive": "BOOLEAN",
            "lastDirected": "ZonedDateTime",
            "birthdate": "LocalDate",
            "residenceLong": "FLOAT",
            "preferredAspectRatios": "String[]",
            "collaborators": "String[]",
            "filmCountCrime": "INTEGER",
            "filmCountRomance": "INTEGER",
            "filmCountWestern": "INTEGER",
            "residenceLongs": "double[]",
            "filmCountThriller": "INTEGER",
            "residenceLats": "double[]",
            "filmCountDrama": "INTEGER",
            "oscarWins": "INTEGER",
            "netWorth": "INTEGER",
            "typicalShootScheduleMonths": "INTEGER",
            "languages": "String[]",
            "actingRangeScore": "FLOAT",
            "heightInMeters": "FLOAT",
            "firstOscarWin": "LocalDate",
            "filmography_roles": "String[]",
            "filmography_years": "long[]",
            "filmography_titles": "String[]",
            "typicalDay": "LocalTime",
            "oscarCeremony": "LocalDateTime",
            "firstFilm": "ZonedDateTime",
            "acceptedFilmStart": "OffsetTime",
            "height": "INTEGER",
            "activityDays": "String[]",
            "activityTypes": "String[]",
            "activityDurations": "long[]",
            "isCurrentlyFilming": "BOOLEAN",
            "weight": "INTEGER",
            "methodActingScore": "FLOAT",
            "marriageDate": "LocalDate",
            "oscarWinDate": "LocalDate",
            "filmCountComedy": "INTEGER",
            "filmCountSciFi": "INTEGER",
            "typicalRolePreparationMonths": "FLOAT",
            "spouseName": "STRING",
            "directorDebut": "LocalDate",
            "knighted": "LocalDate",
            "classicalTraining": "BOOLEAN",
            "documentaryCount": "INTEGER",
            "careerLength": "DurationValue",
            "lastFilm": "ZonedDateTime",
            "genres": "String[]",
            "deathdate": "LocalDate",
            "musicianSince": "LocalDate",
            "musicalInstruments": "String[]",
            "musicCareerStart": "LocalDate",
            "voiceActingScore": "FLOAT",
            "musicGenres": "String[]",
            "specialization": "STRING",
            "yearsInIndustry": "INTEGER",
            "animationBackground": "BOOLEAN",
            "designStyle": "STRING",
            "cameraPreference": "STRING",
            "visualStyle": "STRING",
            "musicStyle": "STRING",
            "awardWins": "INTEGER",
            "awardNominations": "INTEGER",
            "instrumentsPlayed": "INTEGER",
            "studioLocation": "STRING",
            "significance": "STRING",
            "died": "INTEGER",
            "skillSets": "String[]",
            "filmingStyle": "STRING",
            "internationalRecognition": "String[]",
            "fieldworkLocations": "String[]",
            "academicDegrees": "String[]",
            "background": "STRING",
            "collaborationsWithBong": "INTEGER",
            "technicalPreferences": "String[]",
            "innovations": "String[]",
            "technicalInnovations": "String[]",
            "voiceType": "STRING",
            "narratorRanking": "INTEGER",
            "voiceRecognition": "FLOAT",
            "martialArtsTraining": "BOOLEAN",
            "collaborations": "INTEGER",
            "voiceRange": "STRING",
            "musicalSkills": "String[]",
            "cameramanship": "STRING",
            "significantContribution": "STRING",
            "typecastEffect": "STRING",
            "directorRanking": "STRING",
            "deepSeaExperience": "BOOLEAN",
            "motionCaptureExperience": "BOOLEAN",
            "culturalImpact": "STRING",
            "genreSpecialty": "String[]",
            "directorStyle": "STRING",
            "voiceActingExperience": "BOOLEAN",
            "visualAesthetics": "STRING",
            "musicalBackground": "BOOLEAN",
            "wineBusinessOwner": "BOOLEAN",
            "characterImmersion": "STRING",
            "posthumousAwards": "INTEGER",
            "musicianExperience": "BOOLEAN",
            "genreVersatility": "FLOAT",
            "writerDirectorDuality": "BOOLEAN",
            "lighting_style": "STRING",
            "camera_preference": "STRING",
            "nickname": "STRING",
            "oscarHonoraryAward": "BOOLEAN",
            "writerSkill": "FLOAT",
            "adaptationCredits": "String[]",
            "politicalCareer": "BOOLEAN",
            "governorYears": "STRING",
            "westernInfluence": "STRING",
            "globalInfluence": "STRING",
            "paintingBackground": "BOOLEAN",
            "actingStyle": "STRING",
            "collaborationsWithKurosawa": "INTEGER",
            "actingInfluence": "STRING",
            "methodActingPioneer": "BOOLEAN",
            "athleticBackground": "BOOLEAN",
            "sportsPassions": "String[]",
            "directorCredits": "INTEGER",
            "militaryService": "STRING",
            "photographyExhibits": "INTEGER",
            "bookAuthor": "BOOLEAN",
            "book_years": "long[]",
            "screenplay_credits": "String[]",
            "mafia_knowledge": "STRING",
            "firstNovel": "ZonedDateTime",
            "book_titles": "String[]",
            "lastNovel": "ZonedDateTime",
            "novelistFirst": "BOOLEAN",
            "composition_style": "STRING",
            "musical_education": "STRING",
            "compositionsCount": "INTEGER",
            "collaboration_directors": "String[]",
            "collaboration_years": "String[]",
            "research_methodology": "STRING",
            "designPhilosophy": "STRING",
            "design_specialties": "String[]",
            "family_origin": "STRING",
            "public_titles": "String[]",
            "activities": "String[]",
            "livedInSicily": "BOOLEAN",
            "lastPublicAppearance": "ZonedDateTime",
            "firstPublicAppearance": "ZonedDateTime",
            "memoirAuthor": "BOOLEAN",
            "writing_style": "STRING",
            "lastReview": "ZonedDateTime",
            "critical_philosophy": "STRING",
            "criticalApproach": "STRING",
            "books": "String[]",
            "firstReview": "ZonedDateTime",
            "oscarInfluence": "STRING",
            "reviewCount": "INTEGER",
            "publications": "String[]",
            "working_style": "STRING",
            "technical_expertise": "STRING",
            "editingStyle": "STRING",
            "dialect_expertise": "String[]",
            "teaching_methodology": "STRING",
            "film_appearances": "String[]",
            "appearance_years": "long[]",
            "sicilianNative": "BOOLEAN",
            "dialectsKnown": "INTEGER",
            "actingCredits": "INTEGER",
            "negotiation_style": "STRING",
            "production_titles": "String[]",
            "production_years": "long[]",
            "education": "STRING",
            "businessBackground": "STRING",
            "firstProduction": "ZonedDateTime",
            "business_background": "STRING",
            "lastProduction": "ZonedDateTime",
            "key_productions": "String[]",
            "studioExecutive": "BOOLEAN",
            "studio_role": "STRING",
            "acquisition_strategy": "STRING",
            "business_entities": "String[]",
            "leadership_years": "String[]",
            "business_titles": "String[]",
            "corporateRole": "STRING",
            "firstPosition": "ZonedDateTime",
            "tradePublicationLeadership": "BOOLEAN",
            "executiveRole": "STRING",
            "journalismBackground": "BOOLEAN",
            "development_years": "long[]",
            "career_positions": "String[]",
            "position_years": "String[]",
            "key_developments": "String[]"
        },
        "Category": {},
        "Product": {},
        "Supplier": {},
        "Customer": {},
        "Order": {},
        "Ceremony": {
            "established": "LocalDate",
            "locationLat": "FLOAT",
            "viewership2022": "INTEGER",
            "viewership2023": "INTEGER",
            "name": "STRING",
            "typicalDurationHrs": "FLOAT",
            "viewership2020": "INTEGER",
            "viewership2021": "INTEGER",
            "nickname": "STRING",
            "locationHeight": "INTEGER",
            "categories": "String[]",
            "isPrestigious": "BOOLEAN",
            "nextCeremony": "ZonedDateTime",
            "locationLong": "FLOAT",
            "ceremonyTime": "LocalTime",
            "attendance2022": "INTEGER",
            "attendance2023": "INTEGER",
            "typicalDurationDays": "INTEGER",
            "attendance2019": "INTEGER",
            "attendance2021": "INTEGER",
            "attendance2020": "INTEGER",
            "historicalWinners": "String[]",
            "historicalYears": "long[]",
            "historicalSignificance": "STRING"
        },
        "Studio": {
            "studioLotsLong": "double[]",
            "studioLotsLat": "double[]",
            "name": "STRING",
            "distributionMarkets": "String[]",
            "founded": "LocalDate",
            "yearlyRevenue2020": "INTEGER",
            "subsidiaries": "String[]",
            "digitalStreamingDate": "ZonedDateTime",
            "yearlyRevenue2021": "INTEGER",
            "headquartersLat": "FLOAT",
            "marketShare": "FLOAT",
            "yearlyRevenue2022": "INTEGER",
            "headquartersLong": "FLOAT",
            "isPublic": "BOOLEAN",
            "isActive": "BOOLEAN",
            "notableYears": "long[]",
            "peakMarketShare": "FLOAT",
            "notableFilms": "String[]",
            "acquisitionDate": "LocalDate",
            "yearlyRevenue1992": "INTEGER",
            "yearlyRevenue1991": "INTEGER",
            "relaunch": "LocalDate",
            "bankruptcyDate": "LocalDate",
            "internationalOffices": "String[]",
            "internationalPresence": "INTEGER",
            "yearlyRevenue2019": "INTEGER",
            "parentCompany": "STRING",
            "conservationContributions": "INTEGER",
            "conservationPartners": "String[]",
            "documentaryFocus": "String[]",
            "releasedTitles": "String[]",
            "releasedYears": "long[]",
            "archivalFootageHours": "INTEGER",
            "dissolved": "LocalDate",
            "historicalSignificance": "STRING",
            "keyFigures": "String[]",
            "digitalArchiveCreation": "ZonedDateTime",
            "studioLotsHistorical": "String[]",
            "peakYear": "INTEGER",
            "reestablished": "LocalDate",
            "peakYearlyRevenue": "INTEGER",
            "acquisitionAmount": "INTEGER",
            "acquiredBy": "STRING",
            "acquired": "LocalDate",
            "yearlyRevenue2018": "INTEGER",
            "studioAge": "INTEGER",
            "mountainLogo": "BOOLEAN",
            "indieFilmFocus": "BOOLEAN",
            "awardWinningFilms": "INTEGER",
            "independentFocus": "BOOLEAN",
            "yearlyRevenue1996": "INTEGER",
            "yearlyRevenue1995": "INTEGER",
            "yearlyRevenue1994": "INTEGER",
            "foundedBy": "String[]",
            "divested": "LocalDate",
            "employeeCount": "INTEGER",
            "mountain_logo": "BOOLEAN",
            "production_heads": "String[]",
            "distribution_markets": "String[]",
            "totalSoundstages": "INTEGER",
            "yearlyRevenue1973": "INTEGER",
            "yearlyRevenue1972": "INTEGER",
            "yearlyRevenue1971": "INTEGER",
            "filmReleases1972": "INTEGER",
            "reorganized": "LocalDate",
            "chairmen_history": "String[]",
            "totalStudioLots": "INTEGER",
            "founded_for": "STRING",
            "annualBudget": "INTEGER",
            "production_years": "long[]",
            "namedFor": "STRING",
            "officeSpace": "INTEGER",
            "companyType": "STRING",
            "headquarters": "STRING",
            "officeSpaceUnit": "STRING",
            "company_structure": "STRING",
            "studio_partnerships": "String[]",
            "production_titles": "String[]"
        },
        "Production": {
            "scheduleTimes": "String[]",
            "scheduleDurations": "long[]",
            "weatherPoor": "INTEGER",
            "startDate": "LocalDate",
            "isCompleted": "BOOLEAN",
            "scheduleActivities": "String[]",
            "budgetEquipment": "INTEGER",
            "weatherGood": "INTEGER",
            "startTime": "LocalTime",
            "budgetPersonnel": "INTEGER",
            "durationDays": "INTEGER",
            "budgetVFX": "INTEGER",
            "weatherAcceptable": "INTEGER",
            "durationMonths": "INTEGER",
            "budgetOther": "INTEGER",
            "endDate": "LocalDate",
            "budgetLocations": "INTEGER",
            "name": "STRING",
            "productionPhases": "String[]",
            "phaseStartDates": "String[]",
            "phaseDurationsMonths": "double[]",
            "renderingHours": "INTEGER",
            "budgetVoiceActing": "INTEGER",
            "budgetTechnology": "INTEGER",
            "budgetRendering": "INTEGER",
            "renderFarmServers": "INTEGER",
            "animatorsCount": "INTEGER",
            "technicalInnovations": "String[]",
            "innovationImpact": "double[]",
            "budgetSets": "INTEGER",
            "customSets": "String[]",
            "setConstructionDays": "long[]",
            "equipmentSuccessRate": "double[]",
            "environmentalChallenges": "String[]",
            "challengeSeverity": "double[]",
            "specialEquipment": "String[]",
            "crewRotations": "INTEGER",
            "budgetSurvival": "INTEGER",
            "extremeConditionDays": "INTEGER",
            "budgetTransport": "INTEGER",
            "budgetMusic": "INTEGER",
            "locationCountries": "String[]",
            "studioRestrictions": "String[]",
            "technicalSuccesses": "INTEGER",
            "motionCaptureStages": "INTEGER",
            "budgetMotionCapture": "INTEGER",
            "technicalChallenges": "INTEGER",
            "filmingCountries": "String[]",
            "guerrillaFilming": "BOOLEAN",
            "replicas": "String[]",
            "setLocation": "STRING",
            "castingDisputes": "STRING",
            "studioInterference": "STRING",
            "citiesFilmed": "String[]",
            "iMAXCameras": "INTEGER",
            "independentFilming": "BOOLEAN",
            "filmingDays": "INTEGER",
            "challengingLocations": "String[]",
            "wireworkDays": "INTEGER"
        },
        "Review": {
            "readerLocationsLong": "double[]",
            "readerLocationsLat": "double[]",
            "title": "STRING",
            "aspectDirection": "FLOAT",
            "commentTimestamps": "LIST",
            "keywords": "String[]",
            "stars": "FLOAT",
            "time": "OffsetTime",
            "aspectMusic": "FLOAT",
            "aspectPlot": "FLOAT",
            "aspectVisuals": "FLOAT",
            "isVerified": "BOOLEAN",
            "reviewText": "STRING",
            "date": "LocalDate",
            "aspectActing": "FLOAT",
            "upvotes": "INTEGER",
            "aspectVoiceActing": "FLOAT",
            "aspectAnimation": "FLOAT",
            "academicCitations": "INTEGER",
            "modernReassessmentDates": "LIST",
            "sightAndSoundRankings": "long[]",
            "rankingYears": "long[]",
            "historicalReassessmentDate": "LocalDate",
            "aspectWriting": "FLOAT",
            "aspectInnovation": "FLOAT",
            "historicalRelevance": "STRING",
            "aspectSocialCommentary": "FLOAT",
            "translationLanguages": "String[]",
            "familyRecommendationScore": "FLOAT",
            "aspectCinematography": "FLOAT",
            "aspectEducationalValue": "FLOAT",
            "aspectNarration": "FLOAT",
            "aspectEmotionalImpact": "FLOAT",
            "assessmentYears": "long[]",
            "historicalSignificanceRatings": "double[]",
            "culturalImpactAssessments": "LIST",
            "culturalImpact": "STRING",
            "influenceRatings": "double[]",
            "filmSchoolReferences": "INTEGER",
            "aspectTension": "FLOAT",
            "historicalReassessments": "LIST",
            "aspectWorldBuilding": "FLOAT",
            "aspectCulturalImpact": "FLOAT",
            "aspectAtmosphere": "FLOAT",
            "aspectSubtlety": "FLOAT",
            "aspectMusicScore": "FLOAT",
            "aspectScore": "FLOAT",
            "aspectDialogue": "FLOAT",
            "aspectStructure": "FLOAT",
            "aspectEmotionalDepth": "FLOAT",
            "aspectMartialArts": "FLOAT",
            "wordCount": "INTEGER",
            "criticalInfluence": "STRING",
            "author": "STRING",
            "publication": "STRING"
        },
        "GeneratedByClaudeAI": {
            "dreamLevels": "INTEGER",
            "boxOfficeNA": "INTEGER",
            "boxOfficeEurope": "INTEGER",
            "boxOfficeAsia": "INTEGER",
            "boxOfficeOther": "INTEGER",
            "filmingLocationLong": "double[]",
            "filmingLocationLat": "double[]",
            "budget": "INTEGER",
            "certifications": "String[]",
            "genres": "String[]",
            "ratings": "double[]",
            "tagline": "STRING",
            "digitalRelease": "ZonedDateTime",
            "released": "LocalDate",
            "rating_avg": "FLOAT",
            "title": "STRING",
            "runtime_minutes": "INTEGER",
            "revenue": "INTEGER",
            "releaseDate": "LocalDate",
            "isOscarWinner": "BOOLEAN",
            "residenceLat": "FLOAT",
            "activeYears": "DurationValue",
            "typicalFilmLengthHrs": "FLOAT",
            "oscarNominations": "INTEGER",
            "nationality": "STRING",
            "isActive": "BOOLEAN",
            "lastDirected": "ZonedDateTime",
            "birthdate": "LocalDate",
            "born": "INTEGER",
            "name": "STRING",
            "residenceLong": "FLOAT",
            "preferredAspectRatios": "String[]",
            "collaborators": "String[]",
            "filmCountCrime": "INTEGER",
            "filmCountRomance": "INTEGER",
            "filmCountWestern": "INTEGER",
            "residenceLongs": "double[]",
            "filmCountThriller": "INTEGER",
            "residenceLats": "double[]",
            "filmCountDrama": "INTEGER",
            "oscarWins": "INTEGER",
            "netWorth": "INTEGER",
            "typicalShootScheduleMonths": "INTEGER",
            "languages": "String[]",
            "actingRangeScore": "FLOAT",
            "heightInMeters": "FLOAT",
            "firstOscarWin": "LocalDate",
            "filmography_roles": "String[]",
            "filmography_years": "long[]",
            "filmography_titles": "String[]",
            "typicalDay": "LocalTime",
            "oscarCeremony": "LocalDateTime",
            "firstFilm": "ZonedDateTime",
            "acceptedFilmStart": "OffsetTime",
            "height": "INTEGER",
            "activityDays": "String[]",
            "activityTypes": "String[]",
            "activityDurations": "long[]",
            "isCurrentlyFilming": "BOOLEAN",
            "weight": "FLOAT",
            "established": "LocalDate",
            "locationLat": "FLOAT",
            "viewership2022": "INTEGER",
            "viewership2023": "INTEGER",
            "typicalDurationHrs": "FLOAT",
            "viewership2020": "INTEGER",
            "viewership2021": "INTEGER",
            "nickname": "STRING",
            "locationHeight": "INTEGER",
            "categories": "String[]",
            "isPrestigious": "BOOLEAN",
            "nextCeremony": "ZonedDateTime",
            "locationLong": "FLOAT",
            "ceremonyTime": "LocalTime",
            "studioLotsLong": "double[]",
            "studioLotsLat": "double[]",
            "distributionMarkets": "String[]",
            "founded": "LocalDate",
            "yearlyRevenue2020": "INTEGER",
            "subsidiaries": "String[]",
            "digitalStreamingDate": "ZonedDateTime",
            "yearlyRevenue2021": "INTEGER",
            "headquartersLat": "FLOAT",
            "marketShare": "FLOAT",
            "yearlyRevenue2022": "INTEGER",
            "headquartersLong": "FLOAT",
            "isPublic": "BOOLEAN",
            "scheduleTimes": "String[]",
            "scheduleDurations": "long[]",
            "weatherPoor": "INTEGER",
            "startDate": "LocalDate",
            "isCompleted": "BOOLEAN",
            "scheduleActivities": "String[]",
            "budgetEquipment": "INTEGER",
            "weatherGood": "INTEGER",
            "startTime": "LocalTime",
            "budgetPersonnel": "INTEGER",
            "durationDays": "INTEGER",
            "budgetVFX": "INTEGER",
            "weatherAcceptable": "INTEGER",
            "durationMonths": "INTEGER",
            "budgetOther": "INTEGER",
            "endDate": "LocalDate",
            "budgetLocations": "INTEGER",
            "readerLocationsLong": "double[]",
            "readerLocationsLat": "double[]",
            "aspectDirection": "FLOAT",
            "commentTimestamps": "LIST",
            "keywords": "String[]",
            "stars": "FLOAT",
            "time": "OffsetTime",
            "aspectMusic": "FLOAT",
            "aspectPlot": "FLOAT",
            "aspectVisuals": "FLOAT",
            "isVerified": "BOOLEAN",
            "reviewText": "STRING",
            "date": "LocalDate",
            "aspectActing": "FLOAT",
            "upvotes": "INTEGER",
            "methodActingScore": "FLOAT",
            "marriageDate": "LocalDate",
            "oscarWinDate": "LocalDate",
            "filmCountComedy": "INTEGER",
            "filmCountSciFi": "INTEGER",
            "typicalRolePreparationMonths": "FLOAT",
            "spouseName": "STRING",
            "attendance2022": "INTEGER",
            "attendance2023": "INTEGER",
            "typicalDurationDays": "INTEGER",
            "attendance2019": "INTEGER",
            "attendance2021": "INTEGER",
            "manufactureLocationLong": "FLOAT",
            "vehicleType": "STRING",
            "manufactureLocation": "STRING",
            "productPlacementCost": "INTEGER",
            "featuredInMovies": "String[]",
            "manufactureLocationLat": "FLOAT",
            "maxSpeed": "INTEGER",
            "featuredInYears": "long[]",
            "featured": "BOOLEAN",
            "introduced": "LocalDate",
            "maxSpeedUnit": "STRING",
            "copiesMade": "INTEGER",
            "isIconic": "BOOLEAN",
            "weightUnit": "STRING",
            "screenTime": "DurationValue",
            "movie": "STRING",
            "material": "STRING",
            "auctionValue": "INTEGER",
            "createdDate": "LocalDate",
            "duration": "DurationValue",
            "salesUnits": "INTEGER",
            "peakChartPosition": "INTEGER",
            "recordingStudio": "STRING",
            "composer": "STRING",
            "recordingStudioLong": "FLOAT",
            "recordingStudioLat": "FLOAT",
            "trackCount": "INTEGER",
            "streamingCount": "INTEGER",
            "longitude": "FLOAT",
            "latitude": "FLOAT",
            "climate": "STRING",
            "permitCurrency": "STRING",
            "firstUsed": "LocalDate",
            "permitCost": "INTEGER",
            "elevationUnit": "STRING",
            "region": "STRING",
            "country": "STRING",
            "lastUsed": "LocalDate",
            "elevation": "INTEGER",
            "animationStudioLong": "double[]",
            "animationStudioLat": "double[]",
            "directorDebut": "LocalDate",
            "knighted": "LocalDate",
            "classicalTraining": "BOOLEAN",
            "documentaryCount": "INTEGER",
            "careerLength": "DurationValue",
            "lastFilm": "ZonedDateTime",
            "deathdate": "LocalDate",
            "musicianSince": "LocalDate",
            "musicalInstruments": "String[]",
            "musicCareerStart": "LocalDate",
            "voiceActingScore": "FLOAT",
            "musicGenres": "String[]",
            "notableYears": "long[]",
            "peakMarketShare": "FLOAT",
            "notableFilms": "String[]",
            "acquisitionDate": "LocalDate",
            "yearlyRevenue1992": "INTEGER",
            "yearlyRevenue1991": "INTEGER",
            "relaunch": "LocalDate",
            "bankruptcyDate": "LocalDate",
            "productionPhases": "String[]",
            "phaseStartDates": "String[]",
            "phaseDurationsMonths": "double[]",
            "renderingHours": "INTEGER",
            "budgetVoiceActing": "INTEGER",
            "budgetTechnology": "INTEGER",
            "budgetRendering": "INTEGER",
            "renderFarmServers": "INTEGER",
            "animatorsCount": "INTEGER",
            "aspectVoiceActing": "FLOAT",
            "aspectAnimation": "FLOAT",
            "attendance2020": "INTEGER",
            "yearlyProductions": "FLOAT",
            "specialization": "STRING",
            "awardWins": "INTEGER",
            "employeeCount": "INTEGER",
            "animationStyle": "STRING",
            "technologyBudget": "INTEGER",
            "yearsInIndustry": "INTEGER",
            "animationBackground": "BOOLEAN",
            "designStyle": "STRING",
            "cameraPreference": "STRING",
            "visualStyle": "STRING",
            "fanfictionCount": "INTEGER",
            "expansion2049": "LocalDate",
            "largestEventAttendance": "INTEGER",
            "academicPapers": "INTEGER",
            "contentCreators": "INTEGER",
            "memberCount": "INTEGER",
            "annualConventions": "INTEGER",
            "fanArtCount": "INTEGER",
            "onlinePlatforms": "INTEGER",
            "industryAwards": "INTEGER",
            "adoptionRate": "FLOAT",
            "secondaryApplications": "INTEGER",
            "mainApplication": "STRING",
            "technicalPapersPublished": "INTEGER",
            "teamSize": "INTEGER",
            "developmentCost": "INTEGER",
            "patented": "LocalDate",
            "developedDate": "LocalDate",
            "musicStyle": "STRING",
            "awardNominations": "INTEGER",
            "instrumentsPlayed": "INTEGER",
            "studioLocation": "STRING",
            "preservationRegistry": "STRING",
            "digitalRestoration": "ZonedDateTime",
            "isPreservationRegistry": "BOOLEAN",
            "preservationDate": "LocalDate",
            "initialReviews": "String[]",
            "technicalInnovations": "INTEGER",
            "festivalsWon": "String[]",
            "originalLanguage": "STRING",
            "boxOfficeInternational": "INTEGER",
            "subtitleLanguages": "String[]",
            "isInternational": "BOOLEAN",
            "temperatureUnit": "STRING",
            "extremeTemperatures": "long[]",
            "filmingDuration": "DurationValue",
            "filmingConditions": "STRING",
            "narrators": "String[]",
            "isDocumentary": "BOOLEAN",
            "significance": "STRING",
            "died": "INTEGER",
            "skillSets": "String[]",
            "filmingStyle": "STRING",
            "internationalRecognition": "String[]",
            "fieldworkLocations": "String[]",
            "academicDegrees": "String[]",
            "background": "STRING",
            "collaborationsWithBong": "INTEGER",
            "technicalPreferences": "String[]",
            "innovations": "String[]",
            "internationalOffices": "String[]",
            "internationalPresence": "INTEGER",
            "yearlyRevenue2019": "INTEGER",
            "parentCompany": "STRING",
            "conservationContributions": "INTEGER",
            "conservationPartners": "String[]",
            "documentaryFocus": "String[]",
            "releasedTitles": "String[]",
            "releasedYears": "long[]",
            "archivalFootageHours": "INTEGER",
            "dissolved": "LocalDate",
            "historicalSignificance": "STRING",
            "keyFigures": "String[]",
            "digitalArchiveCreation": "ZonedDateTime",
            "studioLotsHistorical": "String[]",
            "peakYear": "INTEGER",
            "reestablished": "LocalDate",
            "peakYearlyRevenue": "INTEGER",
            "innovationImpact": "double[]",
            "budgetSets": "INTEGER",
            "customSets": "String[]",
            "setConstructionDays": "long[]",
            "equipmentSuccessRate": "double[]",
            "environmentalChallenges": "String[]",
            "challengeSeverity": "double[]",
            "specialEquipment": "String[]",
            "crewRotations": "INTEGER",
            "budgetSurvival": "INTEGER",
            "extremeConditionDays": "INTEGER",
            "budgetTransport": "INTEGER",
            "academicCitations": "INTEGER",
            "modernReassessmentDates": "LIST",
            "sightAndSoundRankings": "long[]",
            "rankingYears": "long[]",
            "historicalReassessmentDate": "LocalDate",
            "aspectWriting": "FLOAT",
            "aspectInnovation": "FLOAT",
            "historicalRelevance": "STRING",
            "aspectSocialCommentary": "FLOAT",
            "translationLanguages": "String[]",
            "familyRecommendationScore": "FLOAT",
            "aspectCinematography": "FLOAT",
            "aspectEducationalValue": "FLOAT",
            "aspectNarration": "FLOAT",
            "aspectEmotionalImpact": "FLOAT",
            "historicalWinners": "String[]",
            "historicalYears": "long[]",
            "earliestPreservedFilm": "STRING",
            "digitalPreservationBudget": "INTEGER",
            "earliestPreservationYear": "INTEGER",
            "earliestFilmYear": "INTEGER",
            "preservedFilmsCount": "INTEGER",
            "digitalizedFilmsCount": "INTEGER",
            "preservationCriteria": "String[]",
            "criteriaWeights": "double[]",
            "nextPreservationAnnouncement": "ZonedDateTime",
            "annualBudget": "INTEGER",
            "isGovernmentFunded": "BOOLEAN",
            "memberOrganizations": "INTEGER",
            "voiceType": "STRING",
            "narratorRanking": "INTEGER",
            "voiceRecognition": "FLOAT",
            "digitalArchiveSize": "INTEGER",
            "courseCount": "INTEGER",
            "facultyCount": "INTEGER",
            "digitalArchiveUnit": "STRING",
            "filmArchiveSize": "INTEGER",
            "studentCount": "INTEGER",
            "featureImpact": "double[]",
            "manufactured": "LocalDate",
            "revolutionaryFeatures": "String[]",
            "manufacturerLong": "FLOAT",
            "purchaseYear": "INTEGER",
            "cost": "INTEGER",
            "technicalSpecifications": "STRING",
            "manufacturerLat": "FLOAT",
            "designed": "LocalDate",
            "constructionHours": "INTEGER",
            "designer": "STRING",
            "colorPalette": "String[]",
            "paletteMeaning": "String[]",
            "materialTypes": "INTEGER",
            "costumeBudget": "INTEGER",
            "symbolismRating": "FLOAT",
            "costumePieces": "INTEGER",
            "location": "STRING",
            "daylight": "STRING",
            "windSpeedMax": "INTEGER",
            "windSpeedAverage": "INTEGER",
            "precipitationAnnual": "INTEGER",
            "averageTemperature": "INTEGER",
            "extremityIndex": "FLOAT",
            "windSpeedUnit": "STRING",
            "precipitationUnit": "STRING",
            "mostCitedTheories": "String[]",
            "annualPublications": "INTEGER",
            "digitalArchives": "INTEGER",
            "institutionsCount": "INTEGER",
            "peerReviewedJournals": "INTEGER",
            "theoriesDevelopmentYears": "long[]",
            "scholarCount": "INTEGER",
            "influentialDirectors": "INTEGER",
            "academicStudies": "INTEGER",
            "criticalReception": "STRING",
            "internationalFestivals": "INTEGER",
            "periodStart": "LocalDate",
            "periodPeak": "LocalDate",
            "geographicalSpread": "STRING",
            "majorAwards": "INTEGER",
            "oscarsWon": "INTEGER",
            "technologyPatents": "INTEGER",
            "annualRevenue": "INTEGER",
            "proprietarySoftware": "INTEGER",
            "computingUnit": "STRING",
            "technicalAwards": "INTEGER",
            "computingPower": "INTEGER",
            "opened": "LocalDate",
            "visitorCapacity": "INTEGER",
            "historicalArtifacts": "INTEGER",
            "interactiveElements": "INTEGER",
            "sizeUnit": "STRING",
            "visitorDuration": "DurationValue",
            "exhibitSize": "INTEGER",
            "annualVisitors": "INTEGER",
            "contributionPercentage": "FLOAT",
            "retailPrice": "FLOAT",
            "conservationContribution": "FLOAT",
            "manufacturerLocationLong": "FLOAT",
            "priceCurrency": "STRING",
            "manufacturerLocationLat": "FLOAT",
            "educationalMaterials": "BOOLEAN",
            "productionRun": "INTEGER",
            "ageRange": "STRING",
            "manufacturer": "STRING",
            "developed": "LocalDate",
            "scholarlyEndorsements": "INTEGER",
            "educatorRating": "FLOAT",
            "languagesAvailable": "INTEGER",
            "courseDuration": "DurationValue",
            "institutionsAdopting": "INTEGER",
            "materialFormats": "String[]",
            "targetEducationLevels": "String[]",
            "totalLessonHours": "INTEGER",
            "storageSizeUnit": "STRING",
            "finalMasterUnit": "STRING",
            "resolutionOutput": "STRING",
            "finalMasterSize": "INTEGER",
            "completed": "LocalDate",
            "colorDepth": "STRING",
            "storageSizeRaw": "INTEGER",
            "originalNegativeUsed": "BOOLEAN",
            "started": "LocalDate",
            "martialArtsTraining": "BOOLEAN",
            "collaborations": "INTEGER",
            "constructionCost": "INTEGER",
            "reactivation": "LocalDate",
            "musicalNumbers": "INTEGER",
            "digitalRemastering": "INTEGER",
            "iconicScenes": "String[]",
            "is3D": "BOOLEAN",
            "motionCapturePercentage": "INTEGER",
            "merchandisingSales": "INTEGER",
            "culturalImpact": "STRING",
            "culturalMilestones": "String[]",
            "isAnimated": "BOOLEAN",
            "animationStyles": "String[]",
            "renderedFrames": "INTEGER",
            "isIndie": "BOOLEAN",
            "festivalWins": "INTEGER",
            "filmingDays": "INTEGER",
            "voiceRange": "STRING",
            "musicalSkills": "String[]",
            "cameramanship": "STRING",
            "significantContribution": "STRING",
            "typecastEffect": "STRING",
            "directorRanking": "STRING",
            "deepSeaExperience": "BOOLEAN",
            "motionCaptureExperience": "BOOLEAN",
            "genreSpecialty": "String[]",
            "directorStyle": "STRING",
            "voiceActingExperience": "BOOLEAN",
            "visualAesthetics": "STRING",
            "musicalBackground": "BOOLEAN",
            "acquisitionAmount": "INTEGER",
            "acquiredBy": "STRING",
            "acquired": "LocalDate",
            "yearlyRevenue2018": "INTEGER",
            "studioAge": "INTEGER",
            "mountainLogo": "BOOLEAN",
            "indieFilmFocus": "BOOLEAN",
            "awardWinningFilms": "INTEGER",
            "budgetMusic": "INTEGER",
            "locationCountries": "String[]",
            "studioRestrictions": "String[]",
            "technicalSuccesses": "INTEGER",
            "motionCaptureStages": "INTEGER",
            "budgetMotionCapture": "INTEGER",
            "technicalChallenges": "INTEGER",
            "filmingCountries": "String[]",
            "guerrillaFilming": "BOOLEAN",
            "assessmentYears": "long[]",
            "historicalSignificanceRatings": "double[]",
            "culturalImpactAssessments": "LIST",
            "influenceRatings": "double[]",
            "filmSchoolReferences": "INTEGER",
            "aspectTension": "FLOAT",
            "historicalReassessments": "LIST",
            "aspectWorldBuilding": "FLOAT",
            "aspectCulturalImpact": "FLOAT",
            "aspectAtmosphere": "FLOAT",
            "aspectSubtlety": "FLOAT",
            "lyricist": "STRING",
            "weeksAtNumberOne": "INTEGER",
            "stringsOnly": "BOOLEAN",
            "tourismIncrease": "INTEGER",
            "studioOwned": "BOOLEAN",
            "filmCount": "INTEGER",
            "tourismRevenueCurrency": "STRING",
            "tourismRevenue": "INTEGER",
            "revival": "LocalDate",
            "annualTours": "INTEGER",
            "singAlongEvents": "INTEGER",
            "historicalSites": "INTEGER",
            "lengthUnit": "STRING",
            "routeLength": "INTEGER",
            "limitedEdition": "BOOLEAN",
            "packagingInnovation": "STRING",
            "specialFeatures": "INTEGER",
            "collectorValue": "STRING",
            "specialEffectsAwards": "INTEGER",
            "rereleaseDates": "LIST",
            "iMAXSequences": "INTEGER",
            "posthumousAwards": "INTEGER",
            "nonLinearStructure": "BOOLEAN",
            "martialArtsStyles": "String[]",
            "wineBusinessOwner": "BOOLEAN",
            "characterImmersion": "STRING",
            "musicianExperience": "BOOLEAN",
            "genreVersatility": "FLOAT",
            "writerDirectorDuality": "BOOLEAN",
            "independentFocus": "BOOLEAN",
            "yearlyRevenue1996": "INTEGER",
            "yearlyRevenue1995": "INTEGER",
            "yearlyRevenue1994": "INTEGER",
            "foundedBy": "String[]",
            "divested": "LocalDate",
            "replicas": "INTEGER",
            "setLocation": "STRING",
            "castingDisputes": "STRING",
            "studioInterference": "STRING",
            "citiesFilmed": "String[]",
            "iMAXCameras": "INTEGER",
            "independentFilming": "BOOLEAN",
            "challengingLocations": "String[]",
            "wireworkDays": "INTEGER",
            "aspectMusicScore": "FLOAT",
            "aspectScore": "FLOAT",
            "aspectDialogue": "FLOAT",
            "aspectStructure": "FLOAT",
            "aspectEmotionalDepth": "FLOAT",
            "aspectMartialArts": "FLOAT",
            "culturalInfluence": "STRING",
            "purpose": "STRING",
            "buildingAccess": "STRING",
            "lighting_style": "STRING",
            "camera_preference": "STRING",
            "oscarHonoraryAward": "BOOLEAN",
            "annualEvents": "INTEGER",
            "materialQuality": "STRING",
            "marketingTagline": "STRING",
            "practicalEffectsPercentage": "INTEGER",
            "sequelNumber": "INTEGER",
            "volumeNumber": "INTEGER",
            "homageFilms": "String[]",
            "visualEffectsBreakthrough": "BOOLEAN",
            "adaptationFidelity": "STRING",
            "periodAccuracy": "STRING",
            "isAdaptation": "BOOLEAN",
            "sourceAuthor": "STRING",
            "writerSkill": "FLOAT",
            "adaptationCredits": "String[]",
            "historicalAccuracy": "STRING",
            "iMAXPercentage": "INTEGER",
            "iMAXFilming": "BOOLEAN",
            "cgiBreakthroughs": "String[]",
            "specialEffectsBreakthrough": "BOOLEAN",
            "politicalCareer": "BOOLEAN",
            "governorYears": "STRING",
            "westernRemakes": "STRING",
            "filmPreservation": "STRING",
            "westernInfluence": "STRING",
            "globalInfluence": "STRING",
            "paintingBackground": "BOOLEAN",
            "actingStyle": "STRING",
            "collaborationsWithKurosawa": "INTEGER",
            "actingInfluence": "STRING",
            "methodActingPioneer": "BOOLEAN",
            "athleticBackground": "BOOLEAN",
            "sportsPassions": "String[]",
            "directorCredits": "INTEGER",
            "militaryService": "STRING",
            "photographyExhibits": "INTEGER",
            "bookAuthor": "BOOLEAN",
            "book_years": "long[]",
            "screenplay_credits": "String[]",
            "mafia_knowledge": "STRING",
            "firstNovel": "ZonedDateTime",
            "book_titles": "String[]",
            "lastNovel": "ZonedDateTime",
            "novelistFirst": "BOOLEAN",
            "film_rights_cost": "INTEGER",
            "cultural_impact_rating": "FLOAT",
            "wordCount": "INTEGER",
            "publicationDate": "LocalDate",
            "themes": "String[]",
            "literary_awards": "String[]",
            "publisher": "STRING",
            "languages_translated": "INTEGER",
            "genre": "STRING",
            "published": "INTEGER",
            "initialPrintRun": "INTEGER",
            "advancePayment": "INTEGER",
            "isbn": "STRING",
            "totalSales": "INTEGER",
            "weeksOnBestsellerList": "INTEGER",
            "pageCount": "INTEGER",
            "historicalContext": "STRING",
            "district": "STRING",
            "culturalSignificance": "STRING",
            "breed": "STRING",
            "handlerCount": "INTEGER",
            "type": "STRING",
            "isImprovised": "BOOLEAN",
            "animal": "STRING",
            "isConsumed": "BOOLEAN",
            "propMaster": "STRING",
            "composition_style": "STRING",
            "musical_education": "STRING",
            "compositionsCount": "INTEGER",
            "collaboration_directors": "String[]",
            "collaboration_years": "String[]",
            "research_methodology": "STRING",
            "designPhilosophy": "STRING",
            "design_specialties": "String[]",
            "preservationEfforts": "BOOLEAN",
            "academicContributions": "INTEGER",
            "formalized": "LocalDate",
            "endowment": "INTEGER",
            "prestigeRanking": "INTEGER",
            "politicalImpact": "STRING",
            "influentialWorks": "INTEGER",
            "culturalInstitutions": "INTEGER",
            "family_origin": "STRING",
            "public_titles": "String[]",
            "activities": "String[]",
            "livedInSicily": "BOOLEAN",
            "lastPublicAppearance": "ZonedDateTime",
            "firstPublicAppearance": "ZonedDateTime",
            "memoirAuthor": "BOOLEAN",
            "locationCount": "INTEGER",
            "animalsUsed": "INTEGER",
            "stuntsRequired": "INTEGER",
            "actors": "INTEGER",
            "interiorsOnly": "BOOLEAN",
            "dialogueLines": "INTEGER",
            "sceneNumber": "INTEGER",
            "extras": "INTEGER",
            "specialEffectsComplexity": "STRING",
            "scriptPages": "INTEGER",
            "digitalTransformation": "LocalDate",
            "marketValueUSD": "INTEGER",
            "publiclyTraded": "BOOLEAN",
            "ceoCompensation": "INTEGER",
            "globalOffices": "INTEGER",
            "tickerSymbol": "STRING",
            "employees": "INTEGER",
            "supervisionLevel": "STRING",
            "criticalInfluence": "STRING",
            "author": "STRING",
            "publication": "STRING",
            "writing_style": "STRING",
            "lastReview": "ZonedDateTime",
            "critical_philosophy": "STRING",
            "criticalApproach": "STRING",
            "books": "String[]",
            "firstReview": "ZonedDateTime",
            "oscarInfluence": "STRING",
            "reviewCount": "INTEGER",
            "publications": "String[]",
            "heightUnit": "STRING",
            "category": "STRING",
            "presentedBy": "STRING",
            "awardMaterial": "STRING",
            "awardWeight": "FLOAT",
            "applicationRequired": "BOOLEAN",
            "recipients": "INTEGER",
            "firstAwarded": "LocalDate",
            "awardHeight": "FLOAT",
            "monetary": "BOOLEAN",
            "physicalAward": "BOOLEAN",
            "prestige": "FLOAT",
            "working_style": "STRING",
            "technical_expertise": "STRING",
            "editingStyle": "STRING",
            "industryLessons": "STRING",
            "documentationLevel": "STRING",
            "scheduleImpact": "DurationValue",
            "productionPhase": "STRING",
            "budgetImpact": "INTEGER",
            "resolutionSuccess": "FLOAT",
            "departmentsAffected": "INTEGER",
            "severityLevel": "FLOAT",
            "dialect_expertise": "String[]",
            "teaching_methodology": "STRING",
            "film_appearances": "String[]",
            "appearance_years": "long[]",
            "sicilianNative": "BOOLEAN",
            "dialectsKnown": "INTEGER",
            "actingCredits": "INTEGER",
            "dimensions": "STRING",
            "valuation_currency": "STRING",
            "creationDate": "LocalDate",
            "condition": "STRING",
            "insured": "BOOLEAN",
            "appraised_value": "INTEGER",
            "dimensionUnit": "STRING",
            "authenticity_verified": "BOOLEAN",
            "negotiation_style": "STRING",
            "production_titles": "String[]",
            "production_years": "long[]",
            "education": "STRING",
            "businessBackground": "STRING",
            "firstProduction": "ZonedDateTime",
            "business_background": "STRING",
            "lastProduction": "ZonedDateTime",
            "key_productions": "String[]",
            "studioExecutive": "BOOLEAN",
            "studio_role": "STRING",
            "acquisition_strategy": "STRING",
            "business_entities": "String[]",
            "leadership_years": "String[]",
            "business_titles": "String[]",
            "corporateRole": "STRING",
            "firstPosition": "ZonedDateTime",
            "tradePublicationLeadership": "BOOLEAN",
            "executiveRole": "STRING",
            "journalismBackground": "BOOLEAN",
            "development_years": "long[]",
            "career_positions": "String[]",
            "position_years": "String[]",
            "key_developments": "String[]",
            "mountain_logo": "BOOLEAN",
            "production_heads": "String[]",
            "distribution_markets": "String[]",
            "totalSoundstages": "INTEGER",
            "yearlyRevenue1973": "INTEGER",
            "yearlyRevenue1972": "INTEGER",
            "yearlyRevenue1971": "INTEGER",
            "filmReleases1972": "INTEGER",
            "reorganized": "LocalDate",
            "chairmen_history": "String[]",
            "totalStudioLots": "INTEGER",
            "founded_for": "STRING",
            "namedFor": "STRING",
            "officeSpace": "INTEGER",
            "companyType": "STRING",
            "headquarters": "STRING",
            "officeSpaceUnit": "STRING",
            "company_structure": "STRING",
            "studio_partnerships": "String[]",
            "ceo_tenure": "STRING",
            "business_sectors": "String[]",
            "key_subsidiaries": "String[]",
            "annual_reports": "long[]",
            "marketValueUSD1972": "INTEGER",
            "conglomerateStructure": "BOOLEAN",
            "annualRevenue1972": "INTEGER",
            "globalOperations": "INTEGER",
            "acquired_paramount": "LocalDate",
            "diversificationLevel": "STRING",
            "major_overages": "String[]",
            "completion_bond": "INTEGER",
            "overage_amounts": "long[]",
            "department_amounts": "long[]",
            "tracking_system": "STRING",
            "insurance_costs": "INTEGER",
            "currency": "STRING",
            "revisions": "INTEGER",
            "department_allocations": "String[]",
            "contingency_amount": "INTEGER",
            "preservation_status": "STRING",
            "accounting_firm": "STRING",
            "total_amount": "INTEGER",
            "audit_status": "STRING",
            "finalized": "LocalDate",
            "final_approval": "LocalDate",
            "accounting_standard": "STRING",
            "line_items": "INTEGER",
            "created": "LocalDate",
            "peak_theaters": "INTEGER",
            "weeks_in_release": "INTEGER",
            "market_revenues": "long[]",
            "revenue_amounts": "long[]",
            "theatrical_runs": "INTEGER",
            "updated": "LocalDate",
            "final_certification": "LocalDate",
            "revenue_streams": "String[]",
            "top_markets": "String[]",
            "theatrical_windows": "STRING",
            "distribution_partners": "INTEGER",
            "release_strategy": "STRING",
            "domestic_theaters_wide": "INTEGER",
            "key_markets": "String[]",
            "release_dates": "String[]",
            "censorship_issues": "String[]",
            "territories": "INTEGER",
            "implemented": "LocalDate",
            "subtitled_versions": "INTEGER",
            "marketing_territories": "INTEGER",
            "print_count_domestic": "INTEGER",
            "print_count_international": "INTEGER",
            "dubbed_versions": "INTEGER",
            "language_versions": "INTEGER",
            "domestic_theaters_initial": "INTEGER",
            "international_territories": "INTEGER",
            "tv_networks": "String[]",
            "key_visuals": "String[]",
            "campaign_phases": "String[]",
            "channel_allocation": "long[]",
            "key_publications": "String[]",
            "creative_agencies": "INTEGER",
            "media_buyers": "INTEGER",
            "publicists": "INTEGER",
            "marketing_channels": "String[]",
            "markets": "STRING",
            "launched": "LocalDate",
            "taglines": "INTEGER",
            "press_events": "INTEGER",
            "premieres": "INTEGER",
            "awards_campaign": "BOOLEAN",
            "total_budget": "INTEGER",
            "target_demographics": "STRING",
            "recoupment_priority": "String[]",
            "risk_mitigation": "STRING",
            "financial_triggers": "String[]",
            "trigger_payments": "long[]",
            "funding_sources": "String[]",
            "funding_amounts": "long[]",
            "legal_counsel": "STRING",
            "banking_partner": "STRING",
            "tax_structures": "STRING",
            "secondary_investors": "STRING",
            "primary_investor": "STRING",
            "structure_type": "STRING",
            "gap_financing": "STRING",
            "executed": "LocalDate",
            "completion_guarantor": "STRING",
            "template_sources": "String[]",
            "contract_counts": "long[]",
            "legal_disputes": "INTEGER",
            "dispute_resolutions": "String[]",
            "governing_law": "STRING",
            "contract_types": "String[]",
            "key_signatories": "String[]",
            "legal_jurisdictions": "INTEGER",
            "pages_total": "INTEGER",
            "amendments": "INTEGER",
            "confidentiality_level": "STRING",
            "storage_location": "STRING",
            "document_count": "INTEGER",
            "dispute_mechanisms": "STRING",
            "signatories": "INTEGER",
            "fleet_counts": "long[]",
            "location_shooting_days": "long[]",
            "location_days": "long[]",
            "soundstages": "INTEGER",
            "primary_locations": "String[]",
            "location_types": "String[]",
            "transportation_fleet": "String[]",
            "equipment_vendors": "INTEGER",
            "locations": "INTEGER",
            "catering_services": "INTEGER",
            "total_shooting_days": "INTEGER",
            "crew_size": "INTEGER",
            "hotel_room_nights": "INTEGER",
            "extras_total": "INTEGER",
            "cast_members": "INTEGER",
            "vehicles_used": "INTEGER",
            "international_awards": "INTEGER",
            "subtitled_markets": "INTEGER",
            "activated": "LocalDate",
            "market_distributors": "String[]",
            "censorship_countries": "String[]",
            "marketing_localization": "INTEGER",
            "box_office_reporting": "STRING",
            "material_delivery_date": "LocalDate",
            "censorship_challenges": "INTEGER",
            "international_prints": "INTEGER",
            "dubbed_markets": "INTEGER",
            "excluded_risks": "String[]",
            "policy_extensions": "INTEGER",
            "special_endorsements": "String[]",
            "premium_allocations": "long[]",
            "coverage_types": "String[]",
            "coverage_limits": "long[]",
            "underwriter": "STRING",
            "premium_total": "INTEGER",
            "expiration": "LocalDate",
            "issued": "LocalDate",
            "claims_paid": "INTEGER",
            "policy_number": "STRING",
            "deductible": "INTEGER",
            "broker": "STRING",
            "effective": "LocalDate",
            "coverage_limit": "INTEGER",
            "claims_filed": "INTEGER",
            "claims_total": "INTEGER",
            "access_requests_annual": "INTEGER",
            "storage_facilities": "String[]",
            "restoration_years": "long[]",
            "restoration_technologies": "String[]",
            "physical_elements": "INTEGER",
            "material_types": "String[]",
            "material_counts": "long[]",
            "storage_locations": "INTEGER",
            "historical_designation": "STRING",
            "scholarly_access": "STRING",
            "access_level": "STRING",
            "digital_elements": "INTEGER",
            "preservation_budget": "INTEGER",
            "climate_controlled": "BOOLEAN",
            "public_exhibitions": "INTEGER",
            "restoration_projects": "INTEGER",
            "disaster_recovery_plan": "BOOLEAN",
            "materials_cataloged": "INTEGER",
            "payroll_totals": "long[]",
            "agreement_variations": "String[]",
            "payroll_categories": "String[]",
            "overtime_hours": "INTEGER",
            "contract_variations": "INTEGER",
            "work_stoppages": "INTEGER",
            "total_union_members": "INTEGER",
            "union_agreements": "String[]",
            "compliance_audit": "LocalDate",
            "grievances_filed": "INTEGER",
            "payroll_service": "STRING",
            "negotiated": "LocalDate",
            "pension_contributions": "INTEGER",
            "signatory_unions": "INTEGER",
            "grievances_resolved": "INTEGER",
            "meal_penalties": "INTEGER",
            "health_contributions": "INTEGER",
            "design_guidelines": "STRING",
            "logo_treatments": "INTEGER",
            "licensee_advances": "long[]",
            "quality_control": "STRING",
            "license_term": "DurationValue",
            "approval_process": "STRING",
            "royalty_rates": "STRING",
            "product_categories": "String[]",
            "product_lines": "String[]",
            "marketing_support": "STRING",
            "program_manager": "STRING",
            "minimum_guarantees": "INTEGER",
            "renewal_options": "INTEGER",
            "licensees": "INTEGER",
            "compensation_values": "long[]",
            "contract_pages": "INTEGER",
            "brand_names": "String[]",
            "compensation_types": "String[]",
            "screen_placements": "long[]",
            "screen_time_total": "DurationValue",
            "cash_compensation": "INTEGER",
            "in_kind_value": "INTEGER",
            "negotiation_rounds": "INTEGER",
            "legal_review_hours": "INTEGER",
            "director_approvals": "STRING",
            "brands_featured": "INTEGER",
            "authenticity_restrictions": "STRING",
            "anachronism_avoidance": "STRING",
            "placement_seconds": "long[]",
            "facility_names": "String[]",
            "service_durations_unit": "STRING",
            "technical_systems": "String[]",
            "deliverable_formats": "String[]",
            "editing_suites": "INTEGER",
            "service_categories": "String[]",
            "service_durations": "long[]",
            "facility_locations": "INTEGER",
            "mixing_rooms": "INTEGER",
            "screening_rooms": "INTEGER",
            "dailies_processed": "INTEGER",
            "dailies_unit": "STRING",
            "technical_staff": "INTEGER",
            "sound_stages": "INTEGER",
            "creative_staff": "INTEGER",
            "final_runtime": "DurationValue",
            "engaged": "LocalDate",
            "equipment_value": "INTEGER",
            "processing_capacity": "INTEGER",
            "facility_size_unit": "STRING",
            "film_formats": "STRING",
            "project_engaged": "LocalDate",
            "industry_leadership": "STRING",
            "project_completed": "LocalDate",
            "capacity_unit": "STRING",
            "processing_standards": "String[]",
            "client_list": "String[]",
            "facility_size": "INTEGER",
            "equipment_types": "String[]",
            "equipment_counts": "long[]",
            "chemical_systems": "String[]",
            "quality_control_points": "INTEGER",
            "processing_systems": "STRING",
            "technical_certifications": "INTEGER",
            "services_provided": "String[]",
            "report_recipients": "String[]",
            "compliance_frameworks": "String[]",
            "record_retention": "STRING",
            "chart_of_accounts": "STRING",
            "accounting_system": "STRING",
            "fiscal_year": "STRING",
            "invoices_processed": "INTEGER",
            "report_types": "String[]",
            "audits_conducted": "INTEGER",
            "financial_reports": "INTEGER",
            "transactions_processed": "INTEGER",
            "accounting_staff": "INTEGER",
            "payroll_transactions": "INTEGER",
            "tax_filings": "INTEGER",
            "software_systems": "String[]",
            "banking_relationships": "String[]"
        },
        "CarModel": {
            "name": "STRING",
            "manufactureLocationLong": "FLOAT",
            "vehicleType": "STRING",
            "manufactureLocation": "STRING",
            "productPlacementCost": "INTEGER",
            "featuredInMovies": "String[]",
            "manufactureLocationLat": "FLOAT",
            "maxSpeed": "INTEGER",
            "featuredInYears": "long[]",
            "featured": "BOOLEAN",
            "introduced": "LocalDate",
            "maxSpeedUnit": "STRING"
        },
        "Prop": {
            "copiesMade": "INTEGER",
            "weight": "INTEGER",
            "isIconic": "BOOLEAN",
            "weightUnit": "STRING",
            "screenTime": "DurationValue",
            "movie": "STRING",
            "material": "STRING",
            "name": "STRING",
            "auctionValue": "INTEGER",
            "createdDate": "LocalDate",
            "constructionCost": "INTEGER",
            "breed": "STRING",
            "handlerCount": "INTEGER",
            "type": "STRING",
            "isImprovised": "BOOLEAN",
            "animal": "STRING",
            "acquisitionDate": "LocalDate",
            "isConsumed": "BOOLEAN",
            "propMaster": "STRING",
            "replicas": "INTEGER"
        },
        "Soundtrack": {
            "duration": "DurationValue",
            "salesUnits": "INTEGER",
            "peakChartPosition": "INTEGER",
            "title": "STRING",
            "released": "LocalDate",
            "recordingStudio": "STRING",
            "composer": "STRING",
            "recordingStudioLong": "FLOAT",
            "recordingStudioLat": "FLOAT",
            "trackCount": "INTEGER",
            "streamingCount": "INTEGER",
            "lyricist": "STRING",
            "weeksAtNumberOne": "INTEGER",
            "stringsOnly": "BOOLEAN",
            "culturalInfluence": "STRING"
        },
        "FilmingLocation": {
            "longitude": "FLOAT",
            "name": "STRING",
            "latitude": "FLOAT",
            "climate": "STRING",
            "permitCurrency": "STRING",
            "firstUsed": "LocalDate",
            "permitCost": "INTEGER",
            "elevationUnit": "STRING",
            "region": "STRING",
            "country": "STRING",
            "lastUsed": "LocalDate",
            "elevation": "INTEGER",
            "tourismIncrease": "INTEGER",
            "studioOwned": "BOOLEAN",
            "filmCount": "INTEGER",
            "purpose": "STRING",
            "buildingAccess": "STRING",
            "historicalContext": "STRING",
            "district": "STRING",
            "culturalSignificance": "STRING"
        },
        "Organization": {
            "established": "LocalDate",
            "earliestPreservedFilm": "STRING",
            "digitalPreservationBudget": "INTEGER",
            "headquartersLat": "FLOAT",
            "earliestPreservationYear": "INTEGER",
            "earliestFilmYear": "INTEGER",
            "name": "STRING",
            "preservedFilmsCount": "INTEGER",
            "digitalizedFilmsCount": "INTEGER",
            "preservationCriteria": "String[]",
            "criteriaWeights": "double[]",
            "nextPreservationAnnouncement": "ZonedDateTime",
            "annualBudget": "INTEGER",
            "headquartersLong": "FLOAT",
            "isGovernmentFunded": "BOOLEAN",
            "memberOrganizations": "INTEGER"
        },
        "Institution": {
            "digitalArchiveSize": "INTEGER",
            "courseCount": "INTEGER",
            "facultyCount": "INTEGER",
            "digitalArchiveUnit": "STRING",
            "filmArchiveSize": "INTEGER",
            "name": "STRING",
            "annualBudget": "INTEGER",
            "founded": "LocalDate",
            "studentCount": "INTEGER",
            "headquartersLong": "FLOAT",
            "headquartersLat": "FLOAT",
            "endowment": "INTEGER",
            "prestigeRanking": "INTEGER"
        },
        "Equipment": {
            "name": "STRING",
            "weightUnit": "STRING",
            "featureImpact": "double[]",
            "manufactured": "LocalDate",
            "historicalSignificance": "STRING",
            "weight": "INTEGER",
            "revolutionaryFeatures": "String[]",
            "manufacturerLong": "FLOAT",
            "purchaseYear": "INTEGER",
            "cost": "INTEGER",
            "technicalSpecifications": "STRING",
            "manufacturerLat": "FLOAT"
        },
        "Costume": {
            "designed": "LocalDate",
            "constructionHours": "INTEGER",
            "designer": "STRING",
            "colorPalette": "String[]",
            "paletteMeaning": "String[]",
            "name": "STRING",
            "materialTypes": "INTEGER",
            "costumeBudget": "INTEGER",
            "symbolismRating": "FLOAT",
            "costumePieces": "INTEGER"
        },
        "EnvironmentalFactor": {
            "longitude": "FLOAT",
            "name": "STRING",
            "temperatureUnit": "STRING",
            "latitude": "FLOAT",
            "location": "STRING",
            "daylight": "STRING",
            "windSpeedMax": "INTEGER",
            "windSpeedAverage": "INTEGER",
            "precipitationAnnual": "INTEGER",
            "averageTemperature": "INTEGER",
            "extremityIndex": "FLOAT",
            "windSpeedUnit": "STRING",
            "precipitationUnit": "STRING"
        },
        "AcademicField": {
            "established": "LocalDate",
            "mostCitedTheories": "String[]",
            "annualPublications": "INTEGER",
            "digitalArchives": "INTEGER",
            "institutionsCount": "INTEGER",
            "peerReviewedJournals": "INTEGER",
            "theoriesDevelopmentYears": "long[]",
            "name": "STRING",
            "scholarCount": "INTEGER"
        },
        "CulturalMovement": {
            "name": "STRING",
            "influentialDirectors": "INTEGER",
            "academicStudies": "INTEGER",
            "established": "LocalDate",
            "criticalReception": "STRING",
            "internationalFestivals": "INTEGER",
            "periodStart": "LocalDate",
            "periodPeak": "LocalDate",
            "geographicalSpread": "STRING",
            "majorAwards": "INTEGER",
            "politicalImpact": "STRING",
            "influentialWorks": "INTEGER",
            "culturalInstitutions": "INTEGER",
            "formalized": "LocalDate"
        },
        "TechCompany": {
            "oscarsWon": "INTEGER",
            "technologyPatents": "INTEGER",
            "annualRevenue": "INTEGER",
            "proprietarySoftware": "INTEGER",
            "computingUnit": "STRING",
            "technicalAwards": "INTEGER",
            "employeeCount": "INTEGER",
            "founded": "LocalDate",
            "name": "STRING",
            "computingPower": "INTEGER",
            "headquartersLong": "FLOAT",
            "headquartersLat": "FLOAT"
        },
        "Attraction": {
            "locationLat": "FLOAT",
            "opened": "LocalDate",
            "developmentCost": "INTEGER",
            "visitorCapacity": "INTEGER",
            "name": "STRING",
            "historicalArtifacts": "INTEGER",
            "interactiveElements": "INTEGER",
            "sizeUnit": "STRING",
            "visitorDuration": "DurationValue",
            "locationLong": "FLOAT",
            "exhibitSize": "INTEGER",
            "annualVisitors": "INTEGER",
            "historicalSites": "INTEGER",
            "lengthUnit": "STRING",
            "routeLength": "INTEGER"
        },
        "Merchandise": {
            "contributionPercentage": "FLOAT",
            "retailPrice": "FLOAT",
            "conservationContribution": "FLOAT",
            "manufacturerLocationLong": "FLOAT",
            "priceCurrency": "STRING",
            "manufacturerLocationLat": "FLOAT",
            "educationalMaterials": "BOOLEAN",
            "released": "LocalDate",
            "name": "STRING",
            "productionRun": "INTEGER",
            "ageRange": "STRING",
            "manufacturer": "STRING",
            "limitedEdition": "BOOLEAN",
            "packagingInnovation": "STRING",
            "specialFeatures": "INTEGER",
            "collectorValue": "STRING",
            "materialQuality": "STRING",
            "marketingTagline": "STRING"
        },
        "EducationalProgram": {
            "developed": "LocalDate",
            "scholarlyEndorsements": "INTEGER",
            "educatorRating": "FLOAT",
            "languagesAvailable": "INTEGER",
            "name": "STRING",
            "courseDuration": "DurationValue",
            "institutionsAdopting": "INTEGER",
            "materialFormats": "String[]",
            "targetEducationLevels": "String[]",
            "totalLessonHours": "INTEGER"
        },
        "DigitalProject": {
            "storageSizeUnit": "STRING",
            "name": "STRING",
            "finalMasterUnit": "STRING",
            "budget": "INTEGER",
            "resolutionOutput": "STRING",
            "finalMasterSize": "INTEGER",
            "completed": "LocalDate",
            "colorDepth": "STRING",
            "teamSize": "INTEGER",
            "storageSizeRaw": "INTEGER",
            "originalNegativeUsed": "BOOLEAN",
            "started": "LocalDate",
            "supervisionLevel": "STRING"
        },
        "FanCommunity": {
            "established": "LocalDate",
            "fanfictionCount": "INTEGER",
            "name": "STRING",
            "expansion2049": "LocalDate",
            "largestEventAttendance": "INTEGER",
            "academicPapers": "INTEGER",
            "contentCreators": "INTEGER",
            "memberCount": "INTEGER",
            "annualConventions": "INTEGER",
            "fanArtCount": "INTEGER",
            "onlinePlatforms": "INTEGER",
            "reactivation": "LocalDate",
            "tourismRevenueCurrency": "STRING",
            "tourismRevenue": "INTEGER",
            "revival": "LocalDate",
            "annualTours": "INTEGER",
            "academicStudies": "INTEGER",
            "singAlongEvents": "INTEGER",
            "annualEvents": "INTEGER",
            "preservationEfforts": "BOOLEAN",
            "academicContributions": "INTEGER",
            "formalized": "LocalDate"
        },
        "Book": {
            "film_rights_cost": "INTEGER",
            "cultural_impact_rating": "FLOAT",
            "wordCount": "INTEGER",
            "publicationDate": "LocalDate",
            "themes": "String[]",
            "literary_awards": "String[]",
            "publisher": "STRING",
            "languages_translated": "INTEGER",
            "genre": "STRING",
            "published": "INTEGER",
            "initialPrintRun": "INTEGER",
            "advancePayment": "INTEGER",
            "isbn": "STRING",
            "totalSales": "INTEGER",
            "title": "STRING",
            "weeksOnBestsellerList": "INTEGER",
            "pageCount": "INTEGER"
        },
        "Scene": {
            "duration": "DurationValue",
            "locationCount": "INTEGER",
            "animalsUsed": "INTEGER",
            "stuntsRequired": "INTEGER",
            "movie": "STRING",
            "actors": "INTEGER",
            "interiorsOnly": "BOOLEAN",
            "dialogueLines": "INTEGER",
            "sceneNumber": "INTEGER",
            "extras": "INTEGER",
            "specialEffectsComplexity": "STRING",
            "name": "STRING",
            "scriptPages": "INTEGER"
        },
        "Business": {
            "name": "STRING",
            "founded": "LocalDate",
            "headquartersLat": "FLOAT",
            "digitalTransformation": "LocalDate",
            "annualRevenue": "INTEGER",
            "marketValueUSD": "INTEGER",
            "headquartersLong": "FLOAT",
            "publiclyTraded": "BOOLEAN",
            "ceoCompensation": "INTEGER",
            "globalOffices": "INTEGER",
            "tickerSymbol": "STRING",
            "employees": "INTEGER",
            "acquisition_strategy": "STRING",
            "ceo_tenure": "STRING",
            "business_sectors": "String[]",
            "key_subsidiaries": "String[]",
            "annual_reports": "long[]",
            "marketValueUSD1972": "INTEGER",
            "conglomerateStructure": "BOOLEAN",
            "annualRevenue1972": "INTEGER",
            "globalOperations": "INTEGER",
            "acquired_paramount": "LocalDate",
            "diversificationLevel": "STRING"
        },
        "Award": {
            "name": "STRING",
            "heightUnit": "STRING",
            "category": "STRING",
            "weightUnit": "STRING",
            "presentedBy": "STRING",
            "awardMaterial": "STRING",
            "awardWeight": "FLOAT",
            "applicationRequired": "BOOLEAN",
            "recipients": "INTEGER",
            "firstAwarded": "LocalDate",
            "awardHeight": "FLOAT",
            "monetary": "BOOLEAN",
            "physicalAward": "BOOLEAN",
            "prestige": "FLOAT"
        },
        "ProductionChallenge": {
            "name": "STRING",
            "industryLessons": "STRING",
            "documentationLevel": "STRING",
            "endDate": "LocalDate",
            "scheduleImpact": "DurationValue",
            "productionPhase": "STRING",
            "budgetImpact": "INTEGER",
            "resolutionSuccess": "FLOAT",
            "startDate": "LocalDate",
            "departmentsAffected": "INTEGER",
            "severityLevel": "FLOAT"
        },
        "Collectible": {
            "dimensions": "STRING",
            "type": "STRING",
            "material": "STRING",
            "valuation_currency": "STRING",
            "weightUnit": "STRING",
            "creationDate": "LocalDate",
            "condition": "STRING",
            "weight": "INTEGER",
            "insured": "BOOLEAN",
            "appraised_value": "INTEGER",
            "dimensionUnit": "STRING",
            "authenticity_verified": "BOOLEAN",
            "acquisitionDate": "LocalDate",
            "name": "STRING"
        },
        "FinancialRecord": {
            "major_overages": "String[]",
            "completion_bond": "INTEGER",
            "overage_amounts": "long[]",
            "department_amounts": "long[]",
            "tracking_system": "STRING",
            "insurance_costs": "INTEGER",
            "currency": "STRING",
            "revisions": "INTEGER",
            "department_allocations": "String[]",
            "contingency_amount": "INTEGER",
            "preservation_status": "STRING",
            "accounting_firm": "STRING",
            "total_amount": "INTEGER",
            "audit_status": "STRING",
            "finalized": "LocalDate",
            "final_approval": "LocalDate",
            "accounting_standard": "STRING",
            "line_items": "INTEGER",
            "name": "STRING",
            "created": "LocalDate",
            "peak_theaters": "INTEGER",
            "weeks_in_release": "INTEGER",
            "market_revenues": "long[]",
            "revenue_amounts": "long[]",
            "theatrical_runs": "INTEGER",
            "updated": "LocalDate",
            "final_certification": "LocalDate",
            "revenue_streams": "String[]",
            "top_markets": "String[]"
        },
        "DistributionPlan": {
            "theatrical_windows": "STRING",
            "distribution_partners": "String[]",
            "release_strategy": "STRING",
            "domestic_theaters_wide": "INTEGER",
            "key_markets": "String[]",
            "release_dates": "String[]",
            "censorship_issues": "String[]",
            "territories": "INTEGER",
            "implemented": "LocalDate",
            "subtitled_versions": "INTEGER",
            "marketing_territories": "INTEGER",
            "print_count_domestic": "INTEGER",
            "print_count_international": "INTEGER",
            "dubbed_versions": "INTEGER",
            "language_versions": "INTEGER",
            "name": "STRING",
            "domestic_theaters_initial": "INTEGER",
            "international_territories": "INTEGER",
            "created": "LocalDate"
        },
        "MarketingCampaign": {
            "currency": "STRING",
            "tv_networks": "String[]",
            "key_visuals": "String[]",
            "campaign_phases": "String[]",
            "created": "LocalDate",
            "name": "STRING",
            "channel_allocation": "long[]",
            "key_publications": "String[]",
            "creative_agencies": "INTEGER",
            "media_buyers": "INTEGER",
            "publicists": "INTEGER",
            "marketing_channels": "String[]",
            "markets": "STRING",
            "launched": "LocalDate",
            "taglines": "INTEGER",
            "press_events": "INTEGER",
            "premieres": "INTEGER",
            "awards_campaign": "BOOLEAN",
            "total_budget": "INTEGER",
            "completed": "LocalDate",
            "target_demographics": "STRING"
        },
        "FinancialStructure": {
            "recoupment_priority": "String[]",
            "risk_mitigation": "STRING",
            "financial_triggers": "String[]",
            "trigger_payments": "long[]",
            "currency": "STRING",
            "funding_sources": "String[]",
            "funding_amounts": "long[]",
            "legal_counsel": "STRING",
            "banking_partner": "STRING",
            "total_amount": "INTEGER",
            "tax_structures": "STRING",
            "secondary_investors": "STRING",
            "primary_investor": "STRING",
            "structure_type": "STRING",
            "gap_financing": "STRING",
            "executed": "LocalDate",
            "completion_guarantor": "STRING",
            "created": "LocalDate",
            "name": "STRING"
        },
        "LegalDocument": {
            "name": "STRING",
            "template_sources": "String[]",
            "created": "LocalDate",
            "executed": "LocalDate",
            "contract_counts": "long[]",
            "legal_disputes": "INTEGER",
            "dispute_resolutions": "String[]",
            "governing_law": "STRING",
            "contract_types": "String[]",
            "key_signatories": "String[]",
            "legal_jurisdictions": "INTEGER",
            "pages_total": "INTEGER",
            "amendments": "INTEGER",
            "confidentiality_level": "STRING",
            "storage_location": "STRING",
            "document_count": "INTEGER",
            "dispute_mechanisms": "STRING",
            "signatories": "INTEGER"
        },
        "ProductionLogistics": {
            "fleet_counts": "long[]",
            "location_shooting_days": "long[]",
            "location_days": "long[]",
            "soundstages": "INTEGER",
            "primary_locations": "String[]",
            "location_types": "String[]",
            "transportation_fleet": "String[]",
            "equipment_vendors": "INTEGER",
            "implemented": "LocalDate",
            "locations": "INTEGER",
            "catering_services": "INTEGER",
            "total_shooting_days": "INTEGER",
            "crew_size": "INTEGER",
            "hotel_room_nights": "INTEGER",
            "extras_total": "INTEGER",
            "name": "STRING",
            "completed": "LocalDate",
            "cast_members": "INTEGER",
            "vehicles_used": "INTEGER",
            "created": "LocalDate"
        },
        "DistributionNetwork": {
            "release_dates": "String[]",
            "censorship_issues": "String[]",
            "distribution_partners": "INTEGER",
            "established": "LocalDate",
            "international_awards": "INTEGER",
            "language_versions": "INTEGER",
            "territories": "INTEGER",
            "key_markets": "String[]",
            "subtitled_markets": "INTEGER",
            "activated": "LocalDate",
            "market_distributors": "String[]",
            "censorship_countries": "String[]",
            "marketing_localization": "INTEGER",
            "box_office_reporting": "STRING",
            "name": "STRING",
            "material_delivery_date": "LocalDate",
            "censorship_challenges": "INTEGER",
            "international_prints": "INTEGER",
            "dubbed_markets": "INTEGER"
        },
        "InsurancePolicy": {
            "excluded_risks": "String[]",
            "policy_extensions": "INTEGER",
            "special_endorsements": "String[]",
            "premium_allocations": "long[]",
            "coverage_types": "String[]",
            "coverage_limits": "long[]",
            "underwriter": "STRING",
            "premium_total": "INTEGER",
            "currency": "STRING",
            "expiration": "LocalDate",
            "issued": "LocalDate",
            "claims_paid": "INTEGER",
            "policy_number": "STRING",
            "deductible": "INTEGER",
            "broker": "STRING",
            "effective": "LocalDate",
            "name": "STRING",
            "coverage_limit": "INTEGER",
            "claims_filed": "INTEGER",
            "claims_total": "INTEGER"
        },
        "ArchiveRecord": {
            "access_requests_annual": "INTEGER",
            "established": "LocalDate",
            "name": "STRING",
            "storage_facilities": "String[]",
            "restoration_years": "long[]",
            "restoration_technologies": "String[]",
            "physical_elements": "INTEGER",
            "material_types": "String[]",
            "material_counts": "long[]",
            "storage_locations": "INTEGER",
            "historical_designation": "STRING",
            "scholarly_access": "STRING",
            "access_level": "STRING",
            "digital_elements": "INTEGER",
            "preservation_budget": "INTEGER",
            "climate_controlled": "BOOLEAN",
            "public_exhibitions": "INTEGER",
            "updated": "LocalDate",
            "restoration_projects": "INTEGER",
            "disaster_recovery_plan": "BOOLEAN",
            "materials_cataloged": "INTEGER"
        },
        "LaborAgreement": {
            "payroll_totals": "long[]",
            "agreement_variations": "String[]",
            "payroll_categories": "String[]",
            "overtime_hours": "INTEGER",
            "contract_variations": "INTEGER",
            "work_stoppages": "INTEGER",
            "total_union_members": "INTEGER",
            "union_agreements": "String[]",
            "compliance_audit": "LocalDate",
            "grievances_filed": "INTEGER",
            "payroll_service": "STRING",
            "negotiated": "LocalDate",
            "pension_contributions": "INTEGER",
            "signatory_unions": "INTEGER",
            "grievances_resolved": "INTEGER",
            "name": "STRING",
            "meal_penalties": "INTEGER",
            "effective": "LocalDate",
            "expiration": "LocalDate",
            "health_contributions": "INTEGER"
        },
        "LicensingProgram": {
            "design_guidelines": "STRING",
            "logo_treatments": "INTEGER",
            "territories": "INTEGER",
            "established": "LocalDate",
            "licensee_advances": "long[]",
            "activated": "LocalDate",
            "quality_control": "STRING",
            "license_term": "DurationValue",
            "approval_process": "STRING",
            "royalty_rates": "STRING",
            "product_categories": "INTEGER",
            "product_lines": "String[]",
            "marketing_support": "STRING",
            "program_manager": "STRING",
            "name": "STRING",
            "minimum_guarantees": "INTEGER",
            "renewal_options": "INTEGER",
            "licensees": "INTEGER",
            "top_markets": "String[]",
            "market_revenues": "long[]"
        },
        "CommercialDeal": {
            "compensation_values": "long[]",
            "contract_pages": "INTEGER",
            "brand_names": "String[]",
            "compensation_types": "String[]",
            "screen_placements": "long[]",
            "screen_time_total": "DurationValue",
            "cash_compensation": "INTEGER",
            "in_kind_value": "INTEGER",
            "negotiation_rounds": "INTEGER",
            "legal_review_hours": "INTEGER",
            "director_approvals": "STRING",
            "brands_featured": "INTEGER",
            "authenticity_restrictions": "STRING",
            "negotiated": "LocalDate",
            "anachronism_avoidance": "STRING",
            "name": "STRING",
            "placement_seconds": "long[]",
            "product_categories": "String[]",
            "executed": "LocalDate"
        },
        "PostProductionFacility": {
            "facility_names": "String[]",
            "service_durations_unit": "STRING",
            "technical_systems": "String[]",
            "deliverable_formats": "String[]",
            "editing_suites": "INTEGER",
            "service_categories": "String[]",
            "service_durations": "long[]",
            "facility_locations": "INTEGER",
            "mixing_rooms": "INTEGER",
            "screening_rooms": "INTEGER",
            "dailies_processed": "INTEGER",
            "dailies_unit": "STRING",
            "technical_staff": "INTEGER",
            "sound_stages": "INTEGER",
            "creative_staff": "INTEGER",
            "final_runtime": "DurationValue",
            "completed": "LocalDate",
            "name": "STRING",
            "engaged": "LocalDate",
            "equipment_value": "INTEGER"
        },
        "FilmLaboratory": {
            "established": "LocalDate",
            "processing_capacity": "INTEGER",
            "facility_size_unit": "STRING",
            "film_formats": "STRING",
            "project_engaged": "LocalDate",
            "industry_leadership": "STRING",
            "employees": "INTEGER",
            "project_completed": "LocalDate",
            "capacity_unit": "STRING",
            "processing_standards": "String[]",
            "client_list": "String[]",
            "name": "STRING",
            "facility_size": "INTEGER",
            "equipment_types": "String[]",
            "equipment_counts": "long[]",
            "chemical_systems": "String[]",
            "quality_control_points": "INTEGER",
            "processing_systems": "STRING",
            "technical_certifications": "INTEGER",
            "services_provided": "String[]"
        },
        "Manual": {},
        "Part": {},
        "Chapter": {},
        "Message": {},
        "Concept": {},
        "Topic": {},
        "CognitiveState": {},
        "Algorithm": {},
        "AnimationStudio": {
            "yearlyProductions": "FLOAT",
            "specialization": "STRING",
            "awardWins": "INTEGER",
            "name": "STRING",
            "employeeCount": "INTEGER",
            "headquartersLong": "FLOAT",
            "headquartersLat": "FLOAT",
            "animationStyle": "STRING",
            "technologyBudget": "INTEGER",
            "founded": "LocalDate"
        },
        "TechnicalInnovation": {
            "name": "STRING",
            "industryAwards": "INTEGER",
            "adoptionRate": "FLOAT",
            "secondaryApplications": "INTEGER",
            "mainApplication": "STRING",
            "technicalPapersPublished": "INTEGER",
            "teamSize": "INTEGER",
            "developmentCost": "INTEGER",
            "patented": "LocalDate",
            "developedDate": "LocalDate"
        },
        "FinancialService": {
            "report_recipients": "String[]",
            "compliance_frameworks": "String[]",
            "record_retention": "STRING",
            "chart_of_accounts": "STRING",
            "accounting_system": "STRING",
            "fiscal_year": "STRING",
            "invoices_processed": "INTEGER",
            "report_types": "String[]",
            "audits_conducted": "INTEGER",
            "financial_reports": "INTEGER",
            "transactions_processed": "INTEGER",
            "accounting_staff": "INTEGER",
            "engaged": "LocalDate",
            "service_categories": "String[]",
            "payroll_transactions": "INTEGER",
            "tax_filings": "INTEGER",
            "software_systems": "String[]",
            "completed": "LocalDate",
            "banking_relationships": "String[]",
            "name": "STRING"
        }
    },
    "edge_types": [
        "ACTED_IN",
        "DIRECTED",
        "PRODUCED",
        "WROTE",
        "FOLLOWS",
        "REVIEWED",
        "PART_OF",
        "FINANCED",
        "FOR_MOVIE",
        "NOMINATED_FOR",
        "KNOWS",
        "WORKED_WITH",
        "ADMIRES",
        "INSPIRED_BY",
        "FEATURED_IN",
        "USED_IN",
        "COMPOSED_FOR",
        "FILMED_AT",
        "CINEMATOGRAPHY_FOR",
        "NARRATED",
        "DISTRIBUTED",
        "PRESERVED_BY",
        "TEACHES_WITH",
        "IMPACTED",
        "INFLUENCED_BY",
        "CULMINATED_WITH",
        "PROVIDED_SERVICES_FOR",
        "BASED_ON",
        "DERIVED_FROM",
        "ANALYZES",
        "PRESERVED",
        "ENGAGED_WITH",
        "DESIGNED_COSTUMES_FOR",
        "INFLUENCED",
        "ADMIRED",
        "CELEBRATES",
        "DIRECTED_ACTOR",
        "DEFINED_BY",
        "PARENT_OF",
        "COLLABORATED_WITH",
        "ADAPTED_INTO",
        "AUTHORED",
        "COMPOSED",
        "CONSULTED_FOR",
        "MERCHANDISED",
        "AWARDED_TO",
        "EDITED",
        "AFFECTED",
        "COACHED_DIALECTS_FOR",
        "ROMANTICALLY_INVOLVED_WITH",
        "EXECUTIVE_PRODUCED",
        "CORPORATE_OVERSIGHT",
        "DEVELOPED",
        "STUDIO_PRODUCED",
        "PRODUCTION_COMPANY_FOR",
        "CORPORATE_PARENT_OF",
        "ULTIMATE_OWNER",
        "FINANCIAL_PLAN_FOR",
        "FINANCIAL_PERFORMANCE_OF",
        "DISTRIBUTION_STRATEGY_FOR",
        "MARKETED",
        "LEGAL_FRAMEWORK_FOR",
        "OPERATIONS_FOR",
        "INSURED",
        "PRESERVES",
        "LABOR_FRAMEWORK_FOR",
        "MERCHANDISE_RIGHTS_FOR",
        "BRAND_INTEGRATION_FOR",
        "POST_PRODUCED",
        "VOICED_IN",
        "CO_PRODUCED",
        "ANIMATED",
        "CO_DIRECTED",
        "COMPOSED_MUSIC_FOR",
        "LABORATORY_SERVICES_FOR",
        "FINANCIAL_SERVICES_FOR"
    ],
    "edge_properties": {
        "ACTED_IN": {
            "roles": "String[]",
            "awardNominations": "INTEGER",
            "endDate": "LocalDate",
            "awardWins": "INTEGER",
            "screenTimeMinutes": "INTEGER",
            "startDate": "LocalDate",
            "psychologicalPreparation": "STRING",
            "audienceScore": "INTEGER",
            "criticScore": "INTEGER",
            "scheduleConflicts": "BOOLEAN",
            "salary": "INTEGER",
            "emotionalImpact": "STRING",
            "characterDepth": "STRING",
            "performanceRating": "FLOAT",
            "stuntPerformed": "BOOLEAN",
            "trainingPeriodWeeks": "INTEGER",
            "dualRoleComplexity": "STRING",
            "makeupHoursDaily": "INTEGER",
            "ageTransformationYears": "INTEGER",
            "languagesSpoken": "String[]",
            "stuntPercentage": "INTEGER",
            "martialArtsPerformed": "BOOLEAN",
            "physicalDemands": "STRING",
            "collaborationNumber": "INTEGER",
            "characterComplexity": "STRING",
            "reunionWithDirector": "BOOLEAN",
            "songsPerformed": "INTEGER",
            "careerDefiningRole": "BOOLEAN",
            "physicalTrainingMonths": "INTEGER",
            "motionCaptureHours": "INTEGER",
            "stuntTrainingHours": "INTEGER",
            "dialectCoaching": "BOOLEAN",
            "ageAtFilming": "INTEGER",
            "underwaterScenes": "INTEGER",
            "characterImmersion": "STRING",
            "characterEvolution": "STRING",
            "studioOpposition": "BOOLEAN",
            "martialArtsTraining": "STRING",
            "characterIconicity": "STRING",
            "iconicScenes": "String[]",
            "period_costume_discomfort": "STRING",
            "characterReversal": "STRING",
            "catchphraseIconicity": "STRING",
            "physicalTraining": "STRING",
            "improvisationLevel": "STRING",
            "swordTraining": "STRING",
            "bonuses": "STRING",
            "methodPreparation": "STRING",
            "physicalPreparation": "STRING",
            "improvisation": "STRING",
            "intensityLevel": "STRING",
            "loyaltyPortrayal": "STRING",
            "characterSubtlety": "STRING",
            "legalResearch": "STRING",
            "outsiderPerspective": "STRING",
            "characterArc": "STRING",
            "sequelDevelopment": "STRING"
        },
        "DIRECTED": {
            "completionDate": "LocalDate",
            "satisfaction": "FLOAT",
            "daysOnSet": "INTEGER",
            "premiereEvent": "ZonedDateTime",
            "isFirstCollaboration": "BOOLEAN",
            "durationMonths": "INTEGER",
            "year": "INTEGER",
            "awardNominations": "INTEGER",
            "techChallengeRatings": "double[]",
            "originalRuntime": "DurationValue",
            "finalRuntime": "DurationValue",
            "scriptChanges": "INTEGER",
            "technicalChallenges": "String[]",
            "consultants": "String[]",
            "consultationHours": "long[]",
            "age": "INTEGER",
            "isFirstFeatureFilm": "BOOLEAN",
            "studioPressure": "STRING",
            "personalThemes": "String[]",
            "isFirstInternationalBreakout": "BOOLEAN",
            "awardWins": "INTEGER",
            "daysInAntarctica": "INTEGER",
            "scientificConsultants": "INTEGER",
            "isFirstMajorDocumentary": "BOOLEAN",
            "fieldworkPhases": "INTEGER",
            "coDirector": "STRING",
            "isLowBudget": "BOOLEAN",
            "studioInterference": "STRING",
            "blackAndWhiteDecision": "STRING",
            "developmentYears": "INTEGER",
            "isTechnicalInnovation": "BOOLEAN",
            "marvelInvolvement": "STRING",
            "culturalConsultants": "INTEGER",
            "improvisation": "STRING",
            "isPersonalStory": "BOOLEAN",
            "budgetOverruns": "BOOLEAN",
            "scheduleOverruns": "BOOLEAN",
            "castingBattles": "STRING",
            "studioFights": "BOOLEAN",
            "practicalEffectsPercentage": "INTEGER",
            "iMAXUsage": "STRING",
            "nonLinearExperiment": "BOOLEAN",
            "scriptToScreen": "STRING",
            "actionChoreography": "STRING",
            "crossCulturalChallenges": "BOOLEAN",
            "creativeControl": "STRING",
            "sequelPressure": "STRING",
            "scriptDevelopmentYears": "INTEGER",
            "originalConcept": "BOOLEAN",
            "directorStyleForming": "STRING",
            "studioConflicts": "BOOLEAN",
            "homageLevel": "STRING",
            "genreBlending": "STRING",
            "crossCulturalInsight": "STRING",
            "genreDeparture": "BOOLEAN",
            "iMAXInnovation": "STRING",
            "sequelVision": "STRING",
            "technicalInnovations": "STRING",
            "militaryPrecision": "STRING",
            "weatherChallenges": "BOOLEAN",
            "paintingStoryboards": "BOOLEAN"
        },
        "PRODUCED": {
            "producerShare": "FLOAT",
            "topCastShare": "FLOAT",
            "roi": "FLOAT",
            "marketingStart": "ZonedDateTime",
            "marketingBudget": "INTEGER",
            "investment": "INTEGER",
            "directorShare": "FLOAT",
            "return": "INTEGER",
            "contractSigned": "LocalDate",
            "studioShare": "FLOAT",
            "isProfitable": "BOOLEAN",
            "breakEvenDate": "LocalDate",
            "studioRisk": "STRING",
            "marketingStartDate": "ZonedDateTime",
            "heartNegativePressureLevel": "FLOAT",
            "executiveSupport": "STRING",
            "controversyHandling": "STRING",
            "internationalMarketingBoost": "ZonedDateTime",
            "hitchcockDeal": "STRING",
            "indieBreakoutStatus": "BOOLEAN",
            "coProduction": "STRING",
            "executiveOpposition": "BOOLEAN",
            "franchiseEntry": "INTEGER",
            "festivalStrategy": "STRING",
            "internationalFocus": "BOOLEAN",
            "sequelStrategy": "STRING",
            "marketingInnovation": "STRING",
            "twoPartRelease": "BOOLEAN",
            "riskAssessment": "STRING",
            "gamblePayoff": "STRING",
            "marketingApproach": "STRING",
            "day_to_day_involvement": "STRING",
            "budget_secured": "INTEGER",
            "award_acceptance": "STRING",
            "production_company": "STRING",
            "crisis_management": "STRING",
            "studio_relationship": "STRING",
            "production_challenges": "String[]",
            "profit_percentage": "FLOAT",
            "marketing_input": "STRING",
            "career_impact": "STRING",
            "key_decisions": "String[]",
            "role": "STRING"
        },
        "WROTE": {
            "date": "LocalDate",
            "isVerified": "BOOLEAN",
            "wordCount": "INTEGER",
            "timeSpentMinutes": "INTEGER",
            "submissionTime": "OffsetTime",
            "isRetroReview": "BOOLEAN",
            "publicationName": "STRING",
            "coWriter": "STRING",
            "inspirationSources": "String[]",
            "writingCompletionDate": "LocalDate",
            "scriptNominations": "INTEGER",
            "scriptWins": "INTEGER",
            "finalPageCount": "INTEGER",
            "draftCount": "INTEGER",
            "year": "INTEGER",
            "controversyLevel": "STRING",
            "writingStartDate": "LocalDate",
            "thematicElements": "String[]",
            "awardNominations": "INTEGER",
            "awardWins": "INTEGER",
            "adaptationYears": "INTEGER",
            "diaryKept": "BOOLEAN",
            "fidelityBalance": "STRING",
            "adaptationSource": "STRING",
            "studioNotes": "STRING",
            "keyContributions": "String[]",
            "scriptChanges": "STRING",
            "perspectiveApplied": "STRING",
            "researchConducted": "STRING",
            "recognitionReceived": "STRING",
            "editorialChanges": "STRING",
            "paymentReceived": "INTEGER",
            "timeSpentWriting": "DurationValue",
            "laterReassessments": "STRING",
            "influenceLevel": "STRING",
            "originalMaterial": "STRING",
            "sequelChallenges": "String[]",
            "narrativeInnovations": "String[]"
        },
        "FOLLOWS": {},
        "REVIEWED": {
            "summary": "STRING",
            "rating": "INTEGER"
        },
        "PART_OF": {
            "shooting_location": "STRING",
            "viewer_reaction": "STRING",
            "filmingChallenges": "String[]",
            "controversies": "STRING",
            "story_significance": "STRING",
            "runningOrder": "INTEGER",
            "filmingDays": "INTEGER",
            "production_cost": "INTEGER",
            "trivia": "STRING",
            "character_development": "STRING",
            "cultural_impact": "STRING",
            "timeIndex": "OffsetTime",
            "symbolic_meaning": "STRING",
            "technical_specifications": "String[]",
            "exposition_method": "STRING",
            "directing_technique": "STRING"
        },
        "FINANCED": {
            "paymentDate3": "LocalDate",
            "paymentAmount3": "INTEGER",
            "transferTime3": "ZonedDateTime",
            "paymentAmount2": "INTEGER",
            "transferTime2": "ZonedDateTime",
            "paymentDate2": "LocalDate",
            "transferTime1": "ZonedDateTime",
            "paymentAmount1": "INTEGER",
            "contractDate": "LocalDate",
            "amount": "INTEGER",
            "isFullyPaid": "BOOLEAN",
            "paymentDate1": "LocalDate",
            "transferTime4": "ZonedDateTime",
            "paymentDate4": "LocalDate",
            "paymentAmount4": "INTEGER",
            "executiveOversight": "STRING",
            "hitchcockOwnPercentage": "INTEGER",
            "unusualDeal": "BOOLEAN",
            "costOverrunConcerns": "STRING",
            "budgetControl": "STRING",
            "producerOversight": "STRING",
            "tentpoleStatus": "BOOLEAN",
            "tightControls": "BOOLEAN",
            "independentBudgeting": "BOOLEAN",
            "completion_guarantee": "STRING",
            "payment_schedule": "STRING",
            "audit_rights": "STRING",
            "banking_relationships": "STRING",
            "financial_close_process": "STRING",
            "funding_approvals": "STRING",
            "cash_flow_management": "STRING",
            "financial_reporting_requirements": "STRING",
            "financing_method": "STRING",
            "financial_controls": "STRING",
            "profit_definition": "STRING",
            "insurance_coverage": "STRING",
            "tax_considerations": "STRING",
            "deal_structure": "STRING",
            "currency_hedging": "STRING"
        },
        "FOR_MOVIE": {
            "durationDays": "INTEGER",
            "durationMonths": "INTEGER",
            "locationCount": "INTEGER",
            "scheduleAdherence": "FLOAT",
            "isCompleted": "BOOLEAN",
            "weatherDelaysDays": "INTEGER",
            "dailyAverageCost": "INTEGER",
            "originalScheduledEnd": "LocalDate",
            "publicationDateTime": "ZonedDateTime",
            "isPublished": "BOOLEAN",
            "views": "STRING",
            "featuredDurationDays": "INTEGER",
            "shares": "INTEGER",
            "comments": "INTEGER",
            "technologyDelaysDays": "INTEGER",
            "renderingHours": "INTEGER",
            "animationFrames": "INTEGER",
            "animationStudios": "INTEGER",
            "digitalArchiveDate": "LocalDate",
            "reprintCount": "INTEGER",
            "soundstageCount": "INTEGER",
            "setCount": "INTEGER",
            "technicalChallengesOvercome": "INTEGER",
            "innovationSuccessRate": "FLOAT",
            "customSetsBudget": "INTEGER",
            "perfectShotTakes": "INTEGER",
            "totalTakes": "INTEGER",
            "scientificValueRating": "FLOAT",
            "footageUnit": "STRING",
            "equipmentMalfunctions": "INTEGER",
            "scheduleExtensions": "INTEGER",
            "extremeConditionDays": "INTEGER",
            "totalFootage": "INTEGER",
            "locationFilmingPercentage": "INTEGER",
            "musicalNumbersFilmed": "INTEGER",
            "crewSize": "INTEGER",
            "studioFilmingPercentage": "INTEGER",
            "secrecyLevel": "STRING",
            "blackAndWhiteFormat": "BOOLEAN",
            "scheduleOverrun": "FLOAT",
            "budgetOverrun": "FLOAT",
            "studioInterference": "STRING",
            "castingDisputes": "STRING",
            "iMAXPercentage": "INTEGER",
            "practicalEffects": "STRING",
            "improvisationLevel": "STRING",
            "castChemistry": "STRING",
            "culturalContext": "STRING",
            "criticalImpact": "STRING",
            "historicalValue": "STRING",
            "criticPerspective": "STRING",
            "industryInfluence": "STRING",
            "anthologized": "BOOLEAN",
            "publicationPage": "STRING",
            "academicCitations": "INTEGER"
        },
        "NOMINATED_FOR": {
            "presenter2": "STRING",
            "announcementTime": "LocalTime",
            "presenter1": "STRING",
            "ceremony": "INTEGER",
            "category": "STRING",
            "year": "INTEGER",
            "isWinner": "BOOLEAN",
            "votesAgainst": "INTEGER",
            "ceremonyDate": "LocalDate",
            "votesFor": "INTEGER",
            "speechDuration": "DurationValue",
            "wins": "INTEGER",
            "categories": "INTEGER",
            "controversyLevel": "STRING",
            "historicalReassessment": "STRING",
            "reasonForAbsence": "STRING",
            "coRecipient": "STRING",
            "historicalSignificance": "STRING",
            "attendance": "BOOLEAN",
            "audienceReaction": "STRING",
            "ovationLength": "DurationValue",
            "memorableQuote": "STRING",
            "translatorUsed": "BOOLEAN",
            "audienceShareDuringAnnouncement": "FLOAT",
            "significanceRating": "STRING",
            "reactionDuration": "DurationValue",
            "screeningVenue": "STRING",
            "screeningTime": "LocalTime",
            "screeningDate": "LocalDate",
            "culturalImpact": "STRING",
            "producerAccepting": "STRING",
            "previousWinYear": "INTEGER",
            "previousWin": "BOOLEAN",
            "competitionWinner": "STRING",
            "techAwards": "INTEGER",
            "culturalMilestone": "BOOLEAN",
            "secondGenerationWinner": "BOOLEAN",
            "totalOscars": "INTEGER",
            "recordTying": "BOOLEAN",
            "quotedLine": "STRING",
            "speechMemorable": "BOOLEAN",
            "controversies": "STRING",
            "emotionalImpact": "STRING",
            "acceptedBy": "STRING",
            "posthumousAward": "BOOLEAN",
            "indieBreakthrough": "BOOLEAN",
            "independentCelebration": "BOOLEAN",
            "additionalNominations": "INTEGER",
            "broadestRecognition": "STRING"
        },
        "KNOWS": {
            "lastContact": "ZonedDateTime",
            "relationship": "STRING",
            "since": "LocalDate",
            "nextMeeting": "ZonedDateTime",
            "projects": "INTEGER",
            "project1": "STRING",
            "year1": "INTEGER",
            "year2": "INTEGER",
            "project2": "STRING",
            "durationYears": "INTEGER",
            "lastCollaboration": "LocalDate",
            "lastMeeting": "LocalDate",
            "commonFriends": "INTEGER",
            "commonProjects": "INTEGER",
            "commonGenres": "String[]",
            "commonAwards": "INTEGER",
            "commonEvents": "INTEGER",
            "industryEvents": "INTEGER",
            "mutualRespectLevel": "STRING",
            "technicalExchanges": "INTEGER",
            "mutualAdmiration": "BOOLEAN",
            "festivalEncounters": "INTEGER"
        },
        "WORKED_WITH": {
            "firstProject": "STRING",
            "firstYear": "INTEGER",
            "relationship": "STRING",
            "chemistry": "FLOAT",
            "jointSceneMinutes": "INTEGER",
            "interviews": "INTEGER",
            "nextProjectPlanned": "LocalDate",
            "projects": "INTEGER",
            "reunionAttempts": "INTEGER",
            "awards": "String[]",
            "filmedDays": "INTEGER",
            "awardsCelebrated": "INTEGER",
            "reunionDiscussions": "INTEGER",
            "iconic_confrontations": "STRING",
            "screen_fights": "INTEGER"
        },
        "ADMIRES": {
            "relationship": "STRING",
            "since": "LocalDate",
            "projects": "INTEGER",
            "influencedWorks": "String[]",
            "inspirationLevel": "FLOAT",
            "lastContact": "LocalDate"
        },
        "INSPIRED_BY": {
            "favouriteFilm": "STRING",
            "since": "LocalDate",
            "influencedWorks": "String[]",
            "impactLevel": "FLOAT",
            "mentionedInInterviews": "INTEGER"
        },
        "FEATURED_IN": {
            "contractDate": "LocalDate",
            "screenTimeSeconds": "INTEGER",
            "firstAppearance": "OffsetTime",
            "isProminentPlacement": "BOOLEAN",
            "lastAppearance": "OffsetTime",
            "sceneCount": "INTEGER",
            "characterCount": "INTEGER",
            "designAwards": "INTEGER",
            "symbolicElements": "String[]",
            "characterClassIndication": "String[]",
            "costumesPerCharacter": "long[]",
            "elementPurpose": "String[]",
            "original_cost": "INTEGER",
            "hammer_price": "INTEGER",
            "auction_date": "LocalDate",
            "exhibition_history": "String[]",
            "competing_bidders": "INTEGER",
            "restoration": "STRING",
            "significance": "STRING",
            "total_price": "INTEGER",
            "auction_house": "STRING",
            "scenes": "String[]",
            "screen_minutes": "INTEGER",
            "cultural_significance": "STRING",
            "buyer_premium": "INTEGER",
            "provenance": "STRING",
            "exhibition_dates": "LIST",
            "auction_lot": "INTEGER"
        },
        "USED_IN": {
            "firstAppearance": "OffsetTime",
            "significance": "STRING",
            "isCloseup": "BOOLEAN",
            "lastAppearance": "OffsetTime",
            "sceneCount": "INTEGER",
            "scenes": "String[]",
            "successScore": "FLOAT",
            "industryInfluence": "STRING",
            "fullIntegrationDate": "LocalDate",
            "developmentPhases": "INTEGER",
            "testingIterations": "INTEGER",
            "subsequentAdopters": "INTEGER",
            "successMetric": "STRING",
            "implementationDate": "LocalDate",
            "operator": "STRING",
            "techniqueInfluence": "FLOAT",
            "setupTime": "DurationValue",
            "innovationSuccess": "double[]",
            "signatureShots": "String[]",
            "technicalInnovations": "String[]",
            "maintenanceEvents": "INTEGER",
            "unitCount": "INTEGER",
            "operationalDays": "INTEGER",
            "historicalAccuracy": "STRING",
            "propOrigin": "STRING",
            "culturalImpact": "STRING",
            "isImprovisedElement": "BOOLEAN",
            "directorNote": "STRING",
            "symbolism": "STRING",
            "merchandisingValue": "STRING",
            "propContinuity": "STRING",
            "quotableConnection": "STRING"
        },
        "COMPOSED_FOR": {
            "wonAwards": "String[]",
            "youtubeViews": "INTEGER",
            "contractDate": "LocalDate",
            "completion": "LocalDate",
            "spotifyStreams": "INTEGER",
            "nominatedAwards": "String[]",
            "iconicSongs": "String[]",
            "platinumRecords": "INTEGER",
            "goldRecords": "INTEGER",
            "recordingDays": "INTEGER",
            "culturalInfluence": "STRING",
            "iconicTracks": "String[]",
            "stringInstrumentCount": "INTEGER",
            "vocalistFeatured": "STRING",
            "diamondCertification": "BOOLEAN",
            "orchestraSize": "INTEGER",
            "culturalResonance": "STRING",
            "disqualificationReason": "STRING",
            "iconicThemes": "String[]",
            "ethnicInfluences": "STRING",
            "emotionalImpact": "FLOAT",
            "directorCollaboration": "STRING",
            "recordingSessions": "INTEGER",
            "thematicElements": "String[]",
            "mainInstrumentation": "String[]"
        },
        "FILMED_AT": {
            "characterPresent": "String[]",
            "totalDays": "INTEGER",
            "logisticsCost": "INTEGER",
            "crewSize": "INTEGER",
            "endDate": "LocalDate",
            "startDate": "LocalDate",
            "sceneCount": "INTEGER",
            "weatherDelayDays": "INTEGER",
            "accommodationCost": "INTEGER",
            "touristSiteToday": "BOOLEAN",
            "setsBulit": "INTEGER",
            "setPreservationStatus": "STRING",
            "touristVisitsAnnually": "INTEGER",
            "iconicSet": "STRING",
            "specialRequirements": "STRING",
            "setConstruction": "STRING",
            "waterTankGallons": "INTEGER",
            "buildingsUsed": "String[]",
            "helicopterShots": "INTEGER",
            "streetClosures": "INTEGER",
            "permitDifficulties": "STRING",
            "localReaction": "STRING",
            "securityChallenges": "BOOLEAN",
            "scenesFilmed": "String[]",
            "locationAccuracy": "STRING",
            "logisticalChallenges": "STRING",
            "authenticDialect": "BOOLEAN",
            "localParticipation": "BOOLEAN",
            "visualAuthenticity": "STRING"
        },
        "CINEMATOGRAPHY_FOR": {
            "awardWins": "INTEGER",
            "signature_shots": "String[]",
            "year": "INTEGER",
            "awardNominations": "INTEGER",
            "completionDate": "LocalDate",
            "startDate": "LocalDate",
            "cameras": "String[]",
            "lenses": "String[]",
            "lighting_setups": "INTEGER",
            "technicalChallengesOvercome": "INTEGER",
            "innovationsTested": "String[]",
            "signatureTechniques": "String[]",
            "innovationsSuccessRate": "double[]",
            "filmedOnLocation": "BOOLEAN",
            "aspectRatio": "STRING",
            "colorProcess": "STRING",
            "televisionExperience": "BOOLEAN",
            "blackAndWhiteFilmStock": "STRING",
            "underwaterChallenges": "BOOLEAN",
            "epochalCinematography": "BOOLEAN",
            "academicStudies": "INTEGER",
            "colorScheme": "STRING",
            "innovationLevel": "STRING",
            "cinematographic_influence": "STRING",
            "challenges_overcome": "String[]",
            "technical_innovations": "String[]",
            "studio_conflicts": "STRING",
            "filmStock": "STRING",
            "signature_techniques": "String[]"
        },
        "NARRATED": {
            "recordingCompletionDate": "LocalDate",
            "rerecordingRequired": "BOOLEAN",
            "recordingDays": "INTEGER",
            "year": "INTEGER",
            "language": "STRING",
            "audienceImpactRating": "FLOAT",
            "scriptPages": "INTEGER",
            "recordingSessionHours": "INTEGER",
            "studioLocation": "STRING"
        },
        "DISTRIBUTED": {
            "returnOnInvestment": "FLOAT",
            "marketingStart": "ZonedDateTime",
            "marketingBudget": "INTEGER",
            "acquisitionDate": "LocalDate",
            "territories": "String[]",
            "conservationDonation": "INTEGER",
            "educationalProgramCreated": "BOOLEAN",
            "acquisitionCost": "INTEGER",
            "isProfitable": "BOOLEAN",
            "familyMarketingFocus": "FLOAT",
            "international_critical_reception": "STRING",
            "revenue_split_structure": "STRING",
            "cultural_impact_variance": "STRING",
            "distribution_head": "STRING",
            "latin_american_coordination": "STRING",
            "piracy_protection_measures": "STRING",
            "european_distribution_headquarters": "STRING",
            "subtitle_quality_control": "STRING",
            "box_office_collection_methods": "STRING",
            "global_strategy": "STRING",
            "dubbing_supervision": "STRING",
            "international_premiere_approach": "STRING",
            "distribution_model": "STRING",
            "materials_provided": "String[]",
            "asian_distribution_headquarters": "STRING",
            "censorship_negotiation_strategy": "STRING",
            "currency_repatriation_challenges": "STRING"
        },
        "PRESERVED_BY": {
            "year": "INTEGER",
            "preservationDate": "LocalDate",
            "preservationMedium": "String[]",
            "digitalFormat": "STRING",
            "restorationDate": "LocalDate",
            "restoration": "BOOLEAN",
            "preservationRound": "INTEGER",
            "restorationCost": "INTEGER",
            "selectionCriteria": "String[]",
            "criteriaScore": "long[]"
        },
        "TEACHES_WITH": {
            "coursesUsedIn": "INTEGER",
            "yearAdded": "INTEGER",
            "studentPapersCount": "INTEGER",
            "primaryFocus": "String[]",
            "requiredForDegrees": "String[]",
            "teachingHoursAnnually": "INTEGER",
            "mostCommonAnalysisTopics": "String[]",
            "teachingValue": "FLOAT",
            "restorationPartnership": "BOOLEAN",
            "preservationEfforts": "STRING",
            "originalMaterialsAccess": "STRING",
            "technicalDeconstruction": "String[]",
            "alumniConnections": "STRING",
            "preservationPartnership": "BOOLEAN"
        },
        "IMPACTED": {
            "adaptationSuccessRates": "double[]",
            "daysExperienced": "INTEGER",
            "humanEnduranceLimit": "DurationValue",
            "documentaryValueAdded": "FLOAT",
            "equipmentFailureRate": "FLOAT",
            "rotationalSchedule": "STRING",
            "equipmentAdaptations": "String[]",
            "footageLostToCold": "STRING",
            "crewmedicalIncidents": "INTEGER"
        },
        "INFLUENCED_BY": {
            "criticalTheoriesGenerated": "String[]",
            "canonicalSurveys": "INTEGER",
            "theoryInfluence": "double[]",
            "yearFirstStudied": "INTEGER",
            "surveyYears": "long[]",
            "academicPapersCount": "INTEGER",
            "canonicalPosition": "INTEGER",
            "textbookReferences": "INTEGER",
            "percentageCoursesTeaching": "INTEGER",
            "mediaCoverage": "STRING",
            "culturalImpact": "STRING",
            "culturalShift": "STRING",
            "subsequentPortrayals": "STRING",
            "significanceRating": "FLOAT",
            "languageContributions": "String[]",
            "controversyLevel": "STRING",
            "identityEffects": "String[]",
            "communityReactions": "String[]",
            "authenticityClaims": "STRING",
            "academicAnalyses": "INTEGER"
        },
        "CULMINATED_WITH": {
            "boxOfficeMultiplierEffect": "FLOAT",
            "subtitleAcceptanceIncrease": "FLOAT",
            "filmSchoolAdoption": "STRING",
            "subsequentDistributionDeals": "INTEGER",
            "newFilmmakersInspired": "STRING",
            "academicAnalyses": "INTEGER",
            "globalImpact": "STRING",
            "koreanFilmExportsIncrease": "FLOAT",
            "significanceRating": "FLOAT",
            "culturalBarrierReduction": "STRING"
        },
        "PROVIDED_SERVICES_FOR": {
            "transformationQuality": "FLOAT",
            "visualizationAccuracy": "STRING",
            "footageProcessed": "INTEGER",
            "footageUnit": "STRING",
            "serviceType": "String[]",
            "contractValue": "INTEGER",
            "workDuration": "DurationValue",
            "teamSize": "INTEGER",
            "temperatureExtremesVisualized": "BOOLEAN",
            "proprietaryTechniquesUsed": "INTEGER",
            "year": "INTEGER"
        },
        "BASED_ON": {
            "filmHistoryContextualization": "STRING",
            "entertainmentFocus": "FLOAT",
            "educationalFocus": "FLOAT",
            "audienceRating": "FLOAT",
            "filmElementsFeatured": "String[]",
            "originalPropsCurated": "INTEGER",
            "filmingTechniqueDemonstrations": "INTEGER",
            "culturalImpactMetrics": "String[]",
            "reproductionProps": "INTEGER",
            "rosebudSymbolismExhibits": "INTEGER",
            "historicalContextualization": "STRING",
            "songPerformanceLocations": "INTEGER",
            "economicContribution": "INTEGER",
            "filmingLocationAccuracy": "STRING",
            "originalSitesCurated": "INTEGER"
        },
        "DERIVED_FROM": {
            "educationalImpact": "STRING",
            "licensingDeal": "LocalDate",
            "unitsSold": "INTEGER",
            "retailersCarrying": "INTEGER",
            "merchandisingLongevity": "STRING",
            "sequelMerchandisingEffect": "STRING",
            "geographicalDistribution": "String[]",
            "brandRecognition": "FLOAT",
            "conservationFundsRaised": "INTEGER",
            "salesDistribution": "double[]",
            "digitalCodeInclusion": "BOOLEAN",
            "specialContentHours": "FLOAT",
            "collectibleResaleValue": "INTEGER",
            "reissueVersions": "INTEGER",
            "anniversarySalesBumps": "INTEGER",
            "collectibleStatus": "STRING",
            "valentinesPeaks": "INTEGER"
        },
        "ANALYZES": {
            "culturalComprehensionExpansion": "STRING",
            "focusAreas": "String[]",
            "filmmakingTechniquesExamined": "INTEGER",
            "criticalThinkingDevelopment": "STRING",
            "studentFeedbackScore": "FLOAT",
            "globalAdoption": "STRING",
            "analyticalApproaches": "String[]",
            "academicPaperGeneration": "INTEGER",
            "crossCulturalDialoguePromotion": "STRING",
            "focusDistribution": "double[]",
            "filmTechniqueRecognition": "STRING",
            "filmStudiesImpact": "STRING",
            "shotByShot": "BOOLEAN"
        },
        "PRESERVED": {
            "historicalConsultants": "INTEGER",
            "frameCorrectionCount": "INTEGER",
            "audioSamplingUnit": "STRING",
            "audioSamplingRate": "INTEGER",
            "challengeComplexity": "double[]",
            "frameTotalCount": "INTEGER",
            "preservationStandard": "STRING",
            "originalDamagePercentage": "FLOAT",
            "restorationFidelity": "FLOAT",
            "audioChannelsPreserved": "INTEGER",
            "primaryRestorationChallenges": "String[]",
            "academicValidation": "STRING",
            "technologiesUsed": "String[]",
            "archivalStorageLocations": "String[]",
            "directorInvolvement": "STRING",
            "physicalPreservationCopies": "INTEGER",
            "publicReception": "STRING",
            "cinematographerConsultation": "STRING"
        },
        "ENGAGED_WITH": {
            "reissuesCampaigns": "INTEGER",
            "reviewsSubmitted": "INTEGER",
            "preReleaseEvents": "INTEGER",
            "anticipationScore": "FLOAT",
            "postReleaseEvents": "INTEGER",
            "theoriesGenerated": "INTEGER",
            "merchandiseSales": "INTEGER",
            "onlineDiscussions": "INTEGER",
            "averageRating": "FLOAT",
            "sequelAnticipation": "FLOAT",
            "commemorationEvents": "String[]",
            "digitalPlatformRevival": "STRING",
            "debateTopics": "String[]",
            "museumExhibits": "INTEGER",
            "fanTheories": "INTEGER",
            "shipwreckExpeditions": "INTEGER",
            "romanticFocus": "FLOAT",
            "historicalFocus": "FLOAT",
            "anniversaryCelebrations": "INTEGER"
        },
        "DESIGNED_COSTUMES_FOR": {
            "awardWins": "INTEGER",
            "costumesCreated": "INTEGER",
            "year": "INTEGER",
            "awardNominations": "INTEGER",
            "completionDate": "LocalDate",
            "startDate": "LocalDate",
            "budget": "INTEGER",
            "researchHours": "INTEGER",
            "specialCostumes": "String[]",
            "conceptualDesigns": "INTEGER",
            "historicalAccuracy": "STRING",
            "fabricsUsed": "INTEGER",
            "blackAndWhiteConsiderations": "BOOLEAN",
            "psychologicalSignificance": "STRING",
            "costumesSubmerged": "INTEGER",
            "functionalDesign": "BOOLEAN",
            "characterEmphasis": "STRING",
            "batSuitIterations": "INTEGER",
            "colorSymbolism": "STRING",
            "specificChallenges": "String[]",
            "characterProgression": "STRING",
            "fabricsSourced": "String[]",
            "fabricCost": "INTEGER"
        },
        "INFLUENCED": {
            "influenceStrength": "STRING",
            "directInfluence": "BOOLEAN",
            "cinematicTechniques": "String[]",
            "mentionedInInterviews": "INTEGER",
            "startYear": "INTEGER",
            "culturalConnection": "STRING",
            "technicalInfluence": "STRING",
            "academicRecognition": "STRING",
            "industryImpact": "STRING",
            "styleContinuity": "STRING",
            "aspectsInfluenced": "String[]",
            "directorsAcknowledged": "BOOLEAN",
            "eastAsianCinemaLegacy": "STRING",
            "crossCulturalImpact": "STRING",
            "mutualRespect": "STRING",
            "cinematic_techniques": "String[]",
            "laterSupport": "STRING",
            "publicAcknowledgement": "BOOLEAN",
            "narrativeApproaches": "String[]",
            "narrativeConnection": "STRING",
            "creativeTeamOverlap": "FLOAT",
            "expandedThemes": "String[]",
            "academicAnalysis": "STRING",
            "continuityElements": "String[]",
            "criticComparison": "STRING"
        },
        "ADMIRED": {
            "commonTechniques": "String[]",
            "since": "LocalDate",
            "techniqueOverlap": "double[]",
            "cinematicInfluence": "STRING",
            "mutualRespect": "BOOLEAN",
            "publicStatements": "INTEGER"
        },
        "CELEBRATES": {
            "recreationsPerformed": "STRING",
            "yearsActive": "INTEGER",
            "culturalPreservation": "STRING",
            "tourLocations": "String[]",
            "archivalCollections": "INTEGER",
            "songbooksPublished": "INTEGER",
            "merchandiseSales": "INTEGER",
            "annualFestivals": "INTEGER",
            "generationalAppeal": "STRING",
            "academicConferences": "INTEGER",
            "merchandisingSales": "INTEGER",
            "dialogueMemorizationLevel": "STRING",
            "educationalPrograms": "String[]",
            "commemorationEvents": "String[]",
            "quotationContests": "BOOLEAN",
            "preservationDonations": "INTEGER",
            "culturalDefenseActivities": "STRING",
            "documentaryProductions": "INTEGER",
            "memorabiliaValue": "STRING",
            "anniversaryCelebrations": "INTEGER",
            "tourismImpact": "STRING"
        },
        "DIRECTED_ACTOR": {
            "firstYear": "INTEGER",
            "conflicts": "STRING",
            "chemistry": "FLOAT",
            "films": "INTEGER",
            "futurePlans": "STRING",
            "reconciliation": "BOOLEAN",
            "firstFilm": "STRING",
            "intensityLevel": "STRING",
            "collaborationQuotes": "STRING",
            "artisticPartnership": "STRING",
            "characterCreation": "STRING",
            "characterOwnership": "STRING",
            "respectLevel": "STRING",
            "inspirationLevel": "STRING",
            "collaborationLongevity": "STRING",
            "museCategorization": "BOOLEAN",
            "mutualRespect": "STRING",
            "physicalDemands": "STRING",
            "languageBarrier": "STRING"
        },
        "DEFINED_BY": {
            "independentFilmIncrease": "FLOAT",
            "dialogueRevolution": "STRING",
            "narrativeExperimentation": "STRING",
            "boxOfficeMultiplierEffect": "FLOAT",
            "genreSubversionTechniques": "STRING",
            "filmSchoolAdoption": "STRING",
            "subsequentDistributionDeals": "INTEGER",
            "newFilmmakersInspired": "STRING",
            "academicAnalyses": "INTEGER",
            "significanceRating": "FLOAT",
            "globalImpact": "STRING"
        },
        "PARENT_OF": {
            "jointInterviews": "INTEGER",
            "publicDiscussions": "INTEGER",
            "firstCollaborationYear": "INTEGER",
            "childBorn": "LocalDate",
            "familyLegacy": "STRING",
            "influenceLevel": "STRING",
            "firstCollaboration": "STRING",
            "mentorRelationship": "BOOLEAN"
        },
        "COLLABORATED_WITH": {
            "firstProject": "STRING",
            "firstYear": "INTEGER",
            "projects": "INTEGER",
            "publicPerception": "STRING",
            "genreDefining": "BOOLEAN",
            "lastProject": "STRING",
            "financialSuccess": "STRING",
            "lastYear": "INTEGER",
            "iconicCharacters": "INTEGER"
        },
        "ADAPTED_INTO": {
            "contractSigned": "LocalDate",
            "adaptationFidelity": "FLOAT",
            "authorInvolvement": "STRING",
            "publicReception": "STRING",
            "adaptation_quality": "STRING",
            "adaptationRights": "INTEGER",
            "novelSalesAfterFilm": "INTEGER",
            "significantChanges": "String[]",
            "preservedElements": "String[]"
        },
        "AUTHORED": {
            "writingCompletionDate": "LocalDate",
            "personalConnection": "STRING",
            "initialExpectations": "STRING",
            "royaltyPercentage": "FLOAT",
            "literaryAim": "STRING",
            "inspirationSources": "String[]",
            "writingStartDate": "LocalDate",
            "researchMethods": "String[]",
            "advance": "INTEGER"
        },
        "COMPOSED": {
            "originalPieces": "INTEGER",
            "year": "INTEGER",
            "themes": "INTEGER",
            "compositionPeriod": "DurationValue",
            "compositionMethod": "STRING",
            "recordingSupervision": "BOOLEAN",
            "directorFeedback": "STRING",
            "collaborators": "String[]",
            "adaptedPieces": "INTEGER",
            "themeInspirations": "String[]",
            "instrumentsPlayed": "String[]"
        },
        "CONSULTED_FOR": {
            "publicAcknowledgement": "BOOLEAN",
            "year": "INTEGER",
            "laterComments": "STRING",
            "informationFlow": "STRING",
            "legalDistancing": "BOOLEAN",
            "culturalAuthenticity": "STRING",
            "accuracyContribution": "STRING",
            "indirectConsultation": "BOOLEAN",
            "areasAdvised": "String[]",
            "compensation": "INTEGER",
            "officialCapacity": "BOOLEAN"
        },
        "MERCHANDISED": {
            "digitalExpansion": "STRING",
            "contractStart": "LocalDate",
            "productRevenues": "long[]",
            "highestGrossingProduct": "STRING",
            "totalRevenue": "INTEGER",
            "intellectualPropertyRights": "STRING",
            "anniversaryReleases": "long[]",
            "productCategories": "String[]",
            "globalDistribution": "STRING",
            "licensingPartnerships": "INTEGER",
            "initialProducts": "String[]",
            "expandedProducts": "String[]",
            "contractEnd": "LocalDate"
        },
        "AWARDED_TO": {
            "acceptedBy": "STRING",
            "controversies": "STRING",
            "industryImpact": "STRING",
            "historicalContext": "STRING",
            "competitor4": "STRING",
            "mediaHeadlines": "STRING",
            "competitor2": "STRING",
            "votingPercentage": "FLOAT",
            "competitor1": "STRING",
            "competitor3": "STRING",
            "acceptanceSpeechLength": "DurationValue",
            "presentedBy": "STRING",
            "ceremonyNumber": "INTEGER",
            "awardDate": "LocalDate"
        },
        "EDITED": {
            "initialCutLength": "DurationValue",
            "directorSessions": "INTEGER",
            "footageReviewed": "INTEGER",
            "controversies": "STRING",
            "cuttingRatio": "FLOAT",
            "footageUnit": "STRING",
            "year": "INTEGER",
            "finalCutLength": "DurationValue",
            "editingSessions": "INTEGER",
            "completionDate": "LocalDate",
            "editingSystems": "String[]",
            "significantEdits": "String[]",
            "directorRelationship": "STRING",
            "narrativeContributions": "String[]",
            "editingApproach": "STRING"
        },
        "AFFECTED": {
            "historicalLegacy": "STRING",
            "challengeRatings": "double[]",
            "castingBattles": "String[]",
            "keyAdvocates": "String[]",
            "victoriousDecisions": "String[]",
            "compromisesMade": "String[]",
            "chiefChallenges": "String[]",
            "studioConflicts": "STRING",
            "locationProblems": "String[]",
            "resolutionStrategies": "String[]",
            "riskedCancellation": "BOOLEAN"
        },
        "COACHED_DIALECTS_FOR": {
            "audienceReception": "STRING",
            "startDate": "LocalDate",
            "culturalContextTeaching": "STRING",
            "year": "INTEGER",
            "completionDate": "LocalDate",
            "trainingHours": "INTEGER",
            "actorsTrained": "String[]",
            "caseDifferences": "String[]",
            "languagesTaught": "String[]",
            "dialectSpecifics": "String[]",
            "pronunciationAccuracy": "FLOAT",
            "methodsUsed": "String[]"
        },
        "ROMANTICALLY_INVOLVED_WITH": {
            "collaboration_years": "long[]",
            "endDate": "LocalDate",
            "on_screen_chemistry": "STRING",
            "relationship_end": "STRING",
            "met_on_set": "STRING",
            "professional_collaborations": "INTEGER",
            "collaborative_projects": "String[]",
            "relationship_duration": "DurationValue",
            "media_coverage": "STRING",
            "public_disclosure": "LocalDate",
            "startDate": "LocalDate",
            "relationship_impact": "STRING"
        },
        "EXECUTIVE_PRODUCED": {
            "corporate_pressure_handling": "STRING",
            "personal_stake": "STRING",
            "boardroom_battles": "INTEGER",
            "role": "STRING",
            "retrospective_assessment": "STRING",
            "budget_approval": "LocalDate",
            "authority_level": "STRING",
            "risk_assessment": "STRING",
            "key_contributions": "String[]",
            "studio_opponents": "String[]",
            "studio_advocates": "String[]",
            "marketing_strategies": "String[]"
        },
        "CORPORATE_OVERSIGHT": {
            "financial_analysis_commissioned": "STRING",
            "quarterly_reports_impact": "STRING",
            "investment_approval": "BOOLEAN",
            "corporate_interference": "STRING",
            "shareholder_communication": "STRING",
            "budget_concerns": "STRING",
            "reaction_to_success": "STRING",
            "profit_expectations": "STRING",
            "executive_chain": "STRING",
            "key_interventions": "String[]",
            "company_role": "STRING",
            "corporate_strategy_impact": "STRING"
        },
        "DEVELOPED": {
            "price_currency": "STRING",
            "internal_advocacy": "STRING",
            "development_start": "LocalDate",
            "price_negotiated": "INTEGER",
            "project_champion": "BOOLEAN",
            "script_development_supervision": "STRING",
            "production_notes_provided": "STRING",
            "key_negotiations": "String[]",
            "creative_insights": "STRING",
            "director_selection_influence": "STRING",
            "book_rights_advocate": "BOOLEAN",
            "novel_acquisition": "LocalDate",
            "project_timeline_oversight": "STRING",
            "executive_role": "STRING"
        },
        "STUDIO_PRODUCED": {
            "corporate_tension": "STRING",
            "distribution_commitment": "STRING",
            "theatrical_distribution_strategy": "STRING",
            "special_insurance": "STRING",
            "production_facilities_provided": "String[]",
            "marketing_budget_initial": "INTEGER",
            "project_greenlight": "LocalDate",
            "profit_participants": "String[]",
            "production_account": "STRING",
            "marketing_budget_expanded": "INTEGER",
            "completion_guarantor": "STRING",
            "financial_risk_assessment": "STRING",
            "insurance_underwriter": "STRING",
            "total_investment": "INTEGER",
            "roi": "FLOAT",
            "return": "INTEGER",
            "profit_sharing_tiers": "String[]"
        },
        "PRODUCTION_COMPANY_FOR": {
            "signatory_status": "STRING",
            "company_formed_for_film": "BOOLEAN",
            "cost_reporting_frequency": "STRING",
            "production_account_number": "STRING",
            "paramount_deal_terms": "STRING",
            "production_bank": "STRING",
            "company_responsibilities": "String[]",
            "completion_bond": "INTEGER",
            "legal_entity_type": "STRING",
            "office_location": "STRING",
            "overhead_budget": "INTEGER",
            "paramount_oversight_level": "STRING",
            "liability_coverage": "INTEGER",
            "contract_signed": "LocalDate",
            "production_staff": "INTEGER"
        },
        "CORPORATE_PARENT_OF": {
            "price_currency": "STRING",
            "corporate_synergy_requirements": "STRING",
            "autonomy_level": "STRING",
            "profit_expectation": "FLOAT",
            "ownership_percentage": "FLOAT",
            "conglomerate_portfolio_position": "STRING",
            "board_seats": "INTEGER",
            "financial_reporting_requirements": "STRING",
            "expectation_unit": "STRING",
            "acquisition_price": "INTEGER",
            "acquisition_date": "LocalDate",
            "quarterly_reviews": "INTEGER",
            "investment_approval_threshold": "INTEGER",
            "capital_allocation_committee": "STRING",
            "annual_investment": "INTEGER",
            "corporate_representatives": "String[]"
        },
        "ULTIMATE_OWNER": {
            "project_code": "STRING",
            "stock_impact": "STRING",
            "quarterly_reports_mentioned": "INTEGER",
            "shareholder_questions": "STRING",
            "annual_report_highlight": "STRING",
            "financial_oversight": "STRING",
            "board_approval": "LocalDate",
            "corporate_prestige_factor": "STRING",
            "conglomerate_synergy_attempts": "STRING",
            "risk_assessment": "STRING",
            "executive_visits": "INTEGER",
            "corporate_resources_allocated": "STRING",
            "financial_impact_rating": "STRING",
            "investment_category": "STRING"
        },
        "FINANCIAL_PLAN_FOR": {
            "distribution_advance": "INTEGER",
            "cost_categories": "String[]",
            "actual_spend": "INTEGER",
            "cost_overrun_approval": "LocalDate",
            "authorized_by": "STRING",
            "initial_budget": "INTEGER",
            "daily_shooting_costs": "INTEGER",
            "set_construction_costs": "INTEGER",
            "key_talent_costs": "String[]",
            "financial_reporting_cycle": "STRING",
            "accounting_code": "STRING",
            "studio_overhead_allocation": "INTEGER",
            "prepared_by": "STRING",
            "category_allocations": "long[]",
            "final_budget": "INTEGER",
            "variance_percentage": "FLOAT",
            "transportation_logistics": "INTEGER",
            "location_fees": "INTEGER"
        },
        "FINANCIAL_PERFORMANCE_OF": {
            "platform_release": "BOOLEAN",
            "profit_participants": "String[]",
            "exhibitor_split_percentage": "INTEGER",
            "opening_theaters": "INTEGER",
            "profit_tiers": "String[]",
            "tracking_start": "LocalDate",
            "profit_calculation_method": "STRING",
            "profit_participation_payments": "INTEGER",
            "weeks_at_number_one": "INTEGER",
            "breakeven_date": "LocalDate",
            "studio_net_profit": "INTEGER",
            "tracking_end": "LocalDate",
            "distribution_fee_percentage": "INTEGER",
            "domestic_total": "INTEGER",
            "wide_release_theaters": "INTEGER",
            "wide_release_date": "LocalDate",
            "peak_weekly_gross": "INTEGER",
            "international_total": "INTEGER",
            "opening_weekend": "INTEGER"
        },
        "DISTRIBUTION_STRATEGY_FOR": {
            "nationwide_date": "LocalDate",
            "run_length_guarantee": "STRING",
            "exhibition_terms": "STRING",
            "release_pattern": "STRING",
            "censorship_negotiations": "STRING",
            "booking_approach": "STRING",
            "initial_markets": "String[]",
            "plan_architect": "STRING",
            "release_pattern_success_metrics": "STRING",
            "logistics_base": "STRING",
            "expansion_timeline": "STRING",
            "distribution_team_size": "INTEGER",
            "print_strategy": "STRING",
            "international_strategy": "STRING",
            "theaters_targeted": "STRING"
        },
        "MARKETED": {
            "promotional_partnerships": "STRING",
            "publicity_focus": "STRING",
            "preview_screenings": "INTEGER",
            "campaign_director": "STRING",
            "media_strategy": "STRING",
            "controversy_management": "STRING",
            "magazine_insertions": "INTEGER",
            "billboard_locations": "INTEGER",
            "secondary_tagline": "STRING",
            "radio_spot_count": "INTEGER",
            "merchandising_limited": "STRING",
            "campaign_concept": "STRING",
            "tv_spot_count": "INTEGER",
            "primary_tagline": "STRING",
            "media_impressions": "INTEGER",
            "press_coverage_inches": "INTEGER",
            "key_art_development": "STRING",
            "newspaper_insertions": "INTEGER",
            "premiere_strategy": "STRING"
        },
        "LEGAL_FRAMEWORK_FOR": {
            "novel_rights_acquired": "LocalDate",
            "pacino_final_terms": "STRING",
            "contract_execution_timeline": "STRING",
            "brando_contract_special_terms": "STRING",
            "rights_purchase_price": "INTEGER",
            "rights_additional_terms": "STRING",
            "chief_counsel": "STRING",
            "legal_department_staffing": "STRING",
            "rights_chain_documentation": "STRING",
            "director_compensation": "STRING",
            "guild_agreements": "STRING",
            "music_rights_clearances": "STRING",
            "completion_guarantor_contract": "STRING",
            "director_contract_executed": "LocalDate",
            "pacino_contract_negotiations": "STRING",
            "key_agreements": "String[]",
            "location_agreement_challenges": "STRING"
        },
        "OPERATIONS_FOR": {
            "first_assistant_director": "STRING",
            "production_office_locations": "String[]",
            "equipment_package": "STRING",
            "average_wrap_time": "STRING",
            "dailies_review": "STRING",
            "company_moves": "INTEGER",
            "permit_challenges": "STRING",
            "overtime_frequency": "STRING",
            "shooting_order": "STRING",
            "accommodation_strategy": "STRING",
            "production_manager": "STRING",
            "safety_incidents": "STRING",
            "crew_composition": "STRING",
            "daily_call_times": "STRING",
            "shooting_schedule": "STRING",
            "catering_approach": "STRING",
            "mafia_interactions": "STRING",
            "location_manager": "STRING",
            "insurance_claims": "INTEGER",
            "security_concerns": "STRING",
            "sicily_logistics": "STRING",
            "weather_delays": "INTEGER",
            "communication_systems": "STRING",
            "transportation_coordination": "STRING"
        },
        "INSURED": {
            "script_breakdown_analysis": "STRING",
            "stunt_coordination_review": "STRING",
            "location_risk_surveys": "STRING",
            "international_coverage_extensions": "STRING",
            "special_risk_assessment": "STRING",
            "policy_adjustments": "STRING",
            "claim_incidents": "String[]",
            "claim_resolutions": "String[]",
            "completion_bond_integration": "STRING",
            "policy_holder": "STRING",
            "premium_payment_schedule": "STRING",
            "risk_management_program": "STRING",
            "certificate_holders": "INTEGER",
            "brando_medical_examination": "LocalDate",
            "additional_insureds": "String[]",
            "coverage_territories": "STRING",
            "medical_underwriting": "STRING",
            "exclusions_negotiated": "STRING"
        },
        "PRESERVES": {
            "preservation_status": "STRING",
            "digital_scan_resolution": "STRING",
            "preservation_elements_created": "STRING",
            "audio_preservation": "STRING",
            "color_timing_reference": "STRING",
            "cultural_significance_documentation": "STRING",
            "preservation_partners": "STRING",
            "original_negative_condition": "STRING",
            "technical_history_documentation": "STRING",
            "cinematographer_consultation": "STRING",
            "access_copies_available": "STRING",
            "registered_cultural_heritage": "STRING",
            "restoration_philosophy": "STRING",
            "rights_documentation": "STRING",
            "future_preservation_plan": "STRING",
            "conservation_treatments": "STRING",
            "director_involvement": "STRING",
            "paper_materials_digitization": "STRING"
        },
        "LABOR_FRAMEWORK_FOR": {
            "compliance_documentation": "STRING",
            "residual_structure": "STRING",
            "payroll_processing": "STRING",
            "union_business_representatives": "String[]",
            "work_rules_modifications": "STRING",
            "special_conditions_negotiated": "String[]",
            "credit_requirements": "STRING",
            "jurisdictional_agreements": "STRING",
            "foreign_levies": "STRING",
            "guarantor": "STRING",
            "grievance_procedure": "STRING",
            "international_travel_accommodations": "STRING",
            "per_diem_rates": "STRING",
            "labor_relations_director": "STRING",
            "signatory_production_company": "STRING",
            "labor_peace_commitment": "STRING",
            "pension_and_health_calculations": "STRING",
            "working_condition_provisions": "STRING"
        },
        "MERCHANDISE_RIGHTS_FOR": {
            "royalty_collection": "STRING",
            "minimum_guarantees_structure": "STRING",
            "program_evolution": "STRING",
            "program_approach": "STRING",
            "licensing_director": "STRING",
            "international_adaptation": "STRING",
            "top_performing_licensee": "STRING",
            "second_phase_activation": "STRING",
            "quality_control_process": "STRING",
            "key_licensed_categories": "String[]",
            "marketing_coordination": "STRING",
            "contract_term": "STRING",
            "retail_distribution_channels": "STRING",
            "legacy_program_development": "STRING",
            "prohibited_categories": "String[]",
            "rights_restrictions": "STRING",
            "intellectual_property_elements": "String[]",
            "approval_chain": "STRING"
        },
        "BRAND_INTEGRATION_FOR": {
            "integration_director": "STRING",
            "negotiation_priority": "STRING",
            "brand_approval_restrictions": "STRING",
            "beverage_integration_parameters": "STRING",
            "deal_structure_innovation": "STRING",
            "product_supply_logistics": "STRING",
            "legal_clearance_process": "STRING",
            "additional_consideration": "STRING",
            "clothing_supplier_arrangement": "STRING",
            "historical_consistency_review": "STRING",
            "contemporaneous_promotion_prohibition": "STRING",
            "screen_credit_provisions": "STRING",
            "placement_philosophy": "STRING",
            "integration_subtlety_requirement": "STRING",
            "period_authenticity_requirement": "STRING",
            "future_rights_limitations": "STRING",
            "automobile_supplier_agreement": "STRING"
        },
        "POST_PRODUCED": {
            "delivery_requirements": "STRING",
            "post_supervisor": "STRING",
            "editor_collaboration_approach": "STRING",
            "post_schedule_adherence": "STRING",
            "editorial_process": "STRING",
            "foley_recording": "STRING",
            "primary_editing_location": "STRING",
            "workprint_creation": "STRING",
            "optical_effects_house": "STRING",
            "orchestra_size": "INTEGER",
            "music_recording_studio": "STRING",
            "screening_schedule": "STRING",
            "dailies_processing": "STRING",
            "sound_design_facility": "STRING",
            "edit_decision_workflow": "STRING",
            "sound_mixing_approach": "STRING",
            "title_design_process": "STRING",
            "color_timing_supervision": "STRING",
            "lab_processing": "STRING",
            "technical_challenges": "STRING"
        },
        "VOICED_IN": {
            "endDate": "LocalDate",
            "performanceRating": "FLOAT",
            "recordingDays": "INTEGER",
            "recordingSessions": "INTEGER",
            "linesCount": "INTEGER",
            "roles": "String[]",
            "salary": "INTEGER",
            "startDate": "LocalDate"
        },
        "CO_PRODUCED": {
            "marketingContribution": "INTEGER",
            "roi": "FLOAT",
            "return": "INTEGER",
            "profitDate": "LocalDate",
            "investment": "INTEGER",
            "marketingStart": "ZonedDateTime",
            "contractSigned": "LocalDate",
            "studioShare": "FLOAT",
            "isProfitable": "BOOLEAN"
        },
        "ANIMATED": {
            "totalFrames": "INTEGER",
            "startDate": "LocalDate",
            "endDate": "LocalDate",
            "renderingHours": "INTEGER",
            "teamSize": "INTEGER",
            "technicalInnovations": "String[]",
            "softwareUsed": "String[]",
            "leadAnimators": "INTEGER"
        },
        "CO_DIRECTED": {
            "satisfaction": "FLOAT",
            "awardWins": "INTEGER",
            "premiereEvent": "ZonedDateTime",
            "completionDate": "LocalDate",
            "daysOnProject": "INTEGER",
            "durationMonths": "INTEGER",
            "year": "INTEGER",
            "awardNominations": "INTEGER",
            "responsibility": "STRING",
            "isFirstDirectingRole": "BOOLEAN"
        },
        "COMPOSED_MUSIC_FOR": {
            "completionDate": "LocalDate",
            "instrumentsUsed": "INTEGER",
            "year": "INTEGER",
            "tracksComposed": "INTEGER",
            "recording_studios": "INTEGER",
            "collaboratingArtists": "INTEGER",
            "electronicallyProduced": "BOOLEAN",
            "signature_themes": "String[]",
            "startDate": "LocalDate",
            "recordingDays": "INTEGER"
        },
        "LABORATORY_SERVICES_FOR": {
            "processing_schedule": "STRING",
            "release_print_order": "INTEGER",
            "print_runs": "STRING",
            "services_contracted": "String[]",
            "negative_developing_process": "STRING",
            "special_processing_instructions": "STRING",
            "amber_tone_development": "STRING",
            "technical_challenges": "STRING",
            "process_innovations": "STRING",
            "technical_documentation": "STRING",
            "archival_elements_created": "STRING",
            "print_specification": "STRING",
            "dailies_turnaround": "STRING",
            "lab-studio_relationship": "STRING",
            "print_quality_control": "STRING",
            "lab_contact": "STRING",
            "quality_control_process": "STRING",
            "confidentiality_protocols": "STRING",
            "color_timing_approach": "STRING"
        },
        "FINANCIAL_SERVICES_FOR": {
            "daily_cost_reporting": "STRING",
            "accounting_team_structure": "STRING",
            "cash_flow_management": "STRING",
            "purchase_order_system": "STRING",
            "vendor_payment_terms": "STRING",
            "petty_cash_controls": "STRING",
            "financial_controls_implementation": "STRING",
            "payroll_processing": "STRING",
            "audit_trails_maintenance": "STRING",
            "profit_participation_accounting": "STRING",
            "monthly_financial_review": "STRING",
            "completion_bond_reporting": "STRING",
            "cost_containment_measures": "STRING",
            "final_cost_reporting": "STRING",
            "weekly_financial_meetings": "STRING",
            "production_accountant": "STRING",
            "banking_structure": "STRING",
            "chart_of_accounts_customization": "STRING",
            "accounting_system_implementation": "STRING",
            "tax_withholding_management": "STRING"
        }
    },
    "edge_endpoints": {
        "ACTED_IN": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "DIRECTED": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "PRODUCED": [
            [
                "Studio",
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "WROTE": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "Review",
                "GeneratedByClaudeAI"
            ]
        ],
        "FOLLOWS": [
            [
                "Person"
            ],
            [
                "Person"
            ]
        ],
        "REVIEWED": [
            [
                "Person"
            ],
            [
                "Movie"
            ]
        ],
        "PART_OF": [
            [
                "GeneratedByClaudeAI",
                "Scene"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "FINANCED": [
            [
                "Studio",
                "FinancialStructure",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "Production",
                "GeneratedByClaudeAI"
            ]
        ],
        "FOR_MOVIE": [
            [
                "Review",
                "Production",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "NOMINATED_FOR": [
            [
                "Movie",
                "GeneratedByClaudeAI",
                "Person"
            ],
            [
                "GeneratedByClaudeAI",
                "Ceremony"
            ]
        ],
        "KNOWS": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Person",
                "GeneratedByClaudeAI"
            ]
        ],
        "WORKED_WITH": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Person",
                "GeneratedByClaudeAI"
            ]
        ],
        "ADMIRES": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Person",
                "GeneratedByClaudeAI"
            ]
        ],
        "INSPIRED_BY": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Person"
            ]
        ],
        "FEATURED_IN": [
            [
                "Costume",
                "Collectible",
                "GeneratedByClaudeAI",
                "CarModel"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "USED_IN": [
            [
                "TechnicalInnovation",
                "Prop",
                "GeneratedByClaudeAI",
                "Equipment"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "COMPOSED_FOR": [
            [
                "Soundtrack",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "FILMED_AT": [
            [
                "Movie",
                "GeneratedByClaudeAI"
            ],
            [
                "FilmingLocation",
                "GeneratedByClaudeAI"
            ]
        ],
        "CINEMATOGRAPHY_FOR": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "NARRATED": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "DISTRIBUTED": [
            [
                "Studio",
                "DistributionNetwork",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "PRESERVED_BY": [
            [
                "Movie",
                "GeneratedByClaudeAI"
            ],
            [
                "GeneratedByClaudeAI",
                "Organization"
            ]
        ],
        "TEACHES_WITH": [
            [
                "Institution",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "IMPACTED": [
            [
                "GeneratedByClaudeAI",
                "EnvironmentalFactor"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "INFLUENCED_BY": [
            [
                "AcademicField",
                "GeneratedByClaudeAI",
                "CulturalMovement"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "CULMINATED_WITH": [
            [
                "GeneratedByClaudeAI",
                "CulturalMovement"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "PROVIDED_SERVICES_FOR": [
            [
                "TechCompany",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "BASED_ON": [
            [
                "GeneratedByClaudeAI",
                "Attraction"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "DERIVED_FROM": [
            [
                "GeneratedByClaudeAI",
                "Merchandise"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "ANALYZES": [
            [
                "EducationalProgram",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "PRESERVED": [
            [
                "DigitalProject",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "ENGAGED_WITH": [
            [
                "FanCommunity",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "DESIGNED_COSTUMES_FOR": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "INFLUENCED": [
            [
                "Person",
                "Movie",
                "GeneratedByClaudeAI"
            ],
            [
                "Person",
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "ADMIRED": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Person",
                "GeneratedByClaudeAI"
            ]
        ],
        "CELEBRATES": [
            [
                "FanCommunity",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "DIRECTED_ACTOR": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Person",
                "GeneratedByClaudeAI"
            ]
        ],
        "DEFINED_BY": [
            [
                "GeneratedByClaudeAI",
                "CulturalMovement"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "PARENT_OF": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Person",
                "GeneratedByClaudeAI"
            ]
        ],
        "COLLABORATED_WITH": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Person",
                "GeneratedByClaudeAI"
            ]
        ],
        "ADAPTED_INTO": [
            [
                "Book",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "AUTHORED": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Book",
                "GeneratedByClaudeAI"
            ]
        ],
        "COMPOSED": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Soundtrack",
                "GeneratedByClaudeAI"
            ]
        ],
        "CONSULTED_FOR": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "MERCHANDISED": [
            [
                "GeneratedByClaudeAI",
                "Business"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "AWARDED_TO": [
            [
                "Award",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "EDITED": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "AFFECTED": [
            [
                "GeneratedByClaudeAI",
                "ProductionChallenge"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "COACHED_DIALECTS_FOR": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "ROMANTICALLY_INVOLVED_WITH": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Person",
                "GeneratedByClaudeAI"
            ]
        ],
        "EXECUTIVE_PRODUCED": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "CORPORATE_OVERSIGHT": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "DEVELOPED": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "STUDIO_PRODUCED": [
            [
                "Studio",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "PRODUCTION_COMPANY_FOR": [
            [
                "Studio",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "CORPORATE_PARENT_OF": [
            [
                "GeneratedByClaudeAI",
                "Business"
            ],
            [
                "Studio",
                "GeneratedByClaudeAI"
            ]
        ],
        "ULTIMATE_OWNER": [
            [
                "GeneratedByClaudeAI",
                "Business"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "FINANCIAL_PLAN_FOR": [
            [
                "FinancialRecord",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "FINANCIAL_PERFORMANCE_OF": [
            [
                "FinancialRecord",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "DISTRIBUTION_STRATEGY_FOR": [
            [
                "DistributionPlan",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "MARKETED": [
            [
                "MarketingCampaign",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "LEGAL_FRAMEWORK_FOR": [
            [
                "LegalDocument",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "OPERATIONS_FOR": [
            [
                "ProductionLogistics",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "INSURED": [
            [
                "InsurancePolicy",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "PRESERVES": [
            [
                "GeneratedByClaudeAI",
                "ArchiveRecord"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "LABOR_FRAMEWORK_FOR": [
            [
                "LaborAgreement",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "MERCHANDISE_RIGHTS_FOR": [
            [
                "GeneratedByClaudeAI",
                "LicensingProgram"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "BRAND_INTEGRATION_FOR": [
            [
                "CommercialDeal",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "POST_PRODUCED": [
            [
                "PostProductionFacility",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "VOICED_IN": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "CO_PRODUCED": [
            [
                "Studio",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "ANIMATED": [
            [
                "AnimationStudio",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "CO_DIRECTED": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "COMPOSED_MUSIC_FOR": [
            [
                "Person",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "LABORATORY_SERVICES_FOR": [
            [
                "FilmLaboratory",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ],
        "FINANCIAL_SERVICES_FOR": [
            [
                "FinancialService",
                "GeneratedByClaudeAI"
            ],
            [
                "Movie",
                "GeneratedByClaudeAI"
            ]
        ]
    }
}


class Nodes:
    """
    Interface for working with nodes in the Neo4j graph.
    Each method corresponds to a node label in the graph.
    """

    def movie(uuid=None, **props):
        """
        Find nodes with label Movie matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check title (expected str)
        if "title" in props and props["title"] is not None:
            if not isinstance(props["title"], str):
                try:
                    # Attempt to convert
                    props["title"] = str(props["title"])
                except:
                    raise TypeError(f"Property title must be of type str, got {type(props['title']).__name__}")
    
        # Type check released (expected int)
        if "released" in props and props["released"] is not None:
            if not isinstance(props["released"], int):
                try:
                    # Attempt to convert
                    props["released"] = int(props["released"])
                except:
                    raise TypeError(f"Property released must be of type int, got {type(props['released']).__name__}")
    
        # Type check tagline (expected str)
        if "tagline" in props and props["tagline"] is not None:
            if not isinstance(props["tagline"], str):
                try:
                    # Attempt to convert
                    props["tagline"] = str(props["tagline"])
                except:
                    raise TypeError(f"Property tagline must be of type str, got {type(props['tagline']).__name__}")
    
        # Type check dreamLevels (expected int)
        if "dreamLevels" in props and props["dreamLevels"] is not None:
            if not isinstance(props["dreamLevels"], int):
                try:
                    # Attempt to convert
                    props["dreamLevels"] = int(props["dreamLevels"])
                except:
                    raise TypeError(f"Property dreamLevels must be of type int, got {type(props['dreamLevels']).__name__}")
    
        # Type check boxOfficeNA (expected int)
        if "boxOfficeNA" in props and props["boxOfficeNA"] is not None:
            if not isinstance(props["boxOfficeNA"], int):
                try:
                    # Attempt to convert
                    props["boxOfficeNA"] = int(props["boxOfficeNA"])
                except:
                    raise TypeError(f"Property boxOfficeNA must be of type int, got {type(props['boxOfficeNA']).__name__}")
    
        # Type check boxOfficeEurope (expected int)
        if "boxOfficeEurope" in props and props["boxOfficeEurope"] is not None:
            if not isinstance(props["boxOfficeEurope"], int):
                try:
                    # Attempt to convert
                    props["boxOfficeEurope"] = int(props["boxOfficeEurope"])
                except:
                    raise TypeError(f"Property boxOfficeEurope must be of type int, got {type(props['boxOfficeEurope']).__name__}")
    
        # Type check boxOfficeAsia (expected int)
        if "boxOfficeAsia" in props and props["boxOfficeAsia"] is not None:
            if not isinstance(props["boxOfficeAsia"], int):
                try:
                    # Attempt to convert
                    props["boxOfficeAsia"] = int(props["boxOfficeAsia"])
                except:
                    raise TypeError(f"Property boxOfficeAsia must be of type int, got {type(props['boxOfficeAsia']).__name__}")
    
        # Type check boxOfficeOther (expected int)
        if "boxOfficeOther" in props and props["boxOfficeOther"] is not None:
            if not isinstance(props["boxOfficeOther"], int):
                try:
                    # Attempt to convert
                    props["boxOfficeOther"] = int(props["boxOfficeOther"])
                except:
                    raise TypeError(f"Property boxOfficeOther must be of type int, got {type(props['boxOfficeOther']).__name__}")
    
        # Type check filmingLocationLong (expected object)
        if "filmingLocationLong" in props and props["filmingLocationLong"] is not None:
            if not isinstance(props["filmingLocationLong"], object):
                try:
                    # Attempt to convert
                    props["filmingLocationLong"] = object(props["filmingLocationLong"])
                except:
                    raise TypeError(f"Property filmingLocationLong must be of type object, got {type(props['filmingLocationLong']).__name__}")
    
        # Type check filmingLocationLat (expected object)
        if "filmingLocationLat" in props and props["filmingLocationLat"] is not None:
            if not isinstance(props["filmingLocationLat"], object):
                try:
                    # Attempt to convert
                    props["filmingLocationLat"] = object(props["filmingLocationLat"])
                except:
                    raise TypeError(f"Property filmingLocationLat must be of type object, got {type(props['filmingLocationLat']).__name__}")
    
        # Type check budget (expected int)
        if "budget" in props and props["budget"] is not None:
            if not isinstance(props["budget"], int):
                try:
                    # Attempt to convert
                    props["budget"] = int(props["budget"])
                except:
                    raise TypeError(f"Property budget must be of type int, got {type(props['budget']).__name__}")
    
        # Type check certifications (expected object)
        if "certifications" in props and props["certifications"] is not None:
            if not isinstance(props["certifications"], object):
                try:
                    # Attempt to convert
                    props["certifications"] = object(props["certifications"])
                except:
                    raise TypeError(f"Property certifications must be of type object, got {type(props['certifications']).__name__}")
    
        # Type check genres (expected object)
        if "genres" in props and props["genres"] is not None:
            if not isinstance(props["genres"], object):
                try:
                    # Attempt to convert
                    props["genres"] = object(props["genres"])
                except:
                    raise TypeError(f"Property genres must be of type object, got {type(props['genres']).__name__}")
    
        # Type check ratings (expected object)
        if "ratings" in props and props["ratings"] is not None:
            if not isinstance(props["ratings"], object):
                try:
                    # Attempt to convert
                    props["ratings"] = object(props["ratings"])
                except:
                    raise TypeError(f"Property ratings must be of type object, got {type(props['ratings']).__name__}")
    
        # Type check digitalRelease (expected object)
        if "digitalRelease" in props and props["digitalRelease"] is not None:
            if not isinstance(props["digitalRelease"], object):
                try:
                    # Attempt to convert
                    props["digitalRelease"] = object(props["digitalRelease"])
                except:
                    raise TypeError(f"Property digitalRelease must be of type object, got {type(props['digitalRelease']).__name__}")
    
        # Type check rating_avg (expected float)
        if "rating_avg" in props and props["rating_avg"] is not None:
            if not isinstance(props["rating_avg"], float):
                try:
                    # Attempt to convert
                    props["rating_avg"] = float(props["rating_avg"])
                except:
                    raise TypeError(f"Property rating_avg must be of type float, got {type(props['rating_avg']).__name__}")
    
        # Type check runtime_minutes (expected int)
        if "runtime_minutes" in props and props["runtime_minutes"] is not None:
            if not isinstance(props["runtime_minutes"], int):
                try:
                    # Attempt to convert
                    props["runtime_minutes"] = int(props["runtime_minutes"])
                except:
                    raise TypeError(f"Property runtime_minutes must be of type int, got {type(props['runtime_minutes']).__name__}")
    
        # Type check revenue (expected int)
        if "revenue" in props and props["revenue"] is not None:
            if not isinstance(props["revenue"], int):
                try:
                    # Attempt to convert
                    props["revenue"] = int(props["revenue"])
                except:
                    raise TypeError(f"Property revenue must be of type int, got {type(props['revenue']).__name__}")
    
        # Type check releaseDate (expected object)
        if "releaseDate" in props and props["releaseDate"] is not None:
            if not isinstance(props["releaseDate"], object):
                try:
                    # Attempt to convert
                    props["releaseDate"] = object(props["releaseDate"])
                except:
                    raise TypeError(f"Property releaseDate must be of type object, got {type(props['releaseDate']).__name__}")
    
        # Type check isOscarWinner (expected bool)
        if "isOscarWinner" in props and props["isOscarWinner"] is not None:
            if not isinstance(props["isOscarWinner"], bool):
                try:
                    # Attempt to convert
                    props["isOscarWinner"] = bool(props["isOscarWinner"])
                except:
                    raise TypeError(f"Property isOscarWinner must be of type bool, got {type(props['isOscarWinner']).__name__}")
    
        # Type check animationStudioLong (expected object)
        if "animationStudioLong" in props and props["animationStudioLong"] is not None:
            if not isinstance(props["animationStudioLong"], object):
                try:
                    # Attempt to convert
                    props["animationStudioLong"] = object(props["animationStudioLong"])
                except:
                    raise TypeError(f"Property animationStudioLong must be of type object, got {type(props['animationStudioLong']).__name__}")
    
        # Type check animationStudioLat (expected object)
        if "animationStudioLat" in props and props["animationStudioLat"] is not None:
            if not isinstance(props["animationStudioLat"], object):
                try:
                    # Attempt to convert
                    props["animationStudioLat"] = object(props["animationStudioLat"])
                except:
                    raise TypeError(f"Property animationStudioLat must be of type object, got {type(props['animationStudioLat']).__name__}")
    
        # Type check preservationRegistry (expected str)
        if "preservationRegistry" in props and props["preservationRegistry"] is not None:
            if not isinstance(props["preservationRegistry"], str):
                try:
                    # Attempt to convert
                    props["preservationRegistry"] = str(props["preservationRegistry"])
                except:
                    raise TypeError(f"Property preservationRegistry must be of type str, got {type(props['preservationRegistry']).__name__}")
    
        # Type check digitalRestoration (expected object)
        if "digitalRestoration" in props and props["digitalRestoration"] is not None:
            if not isinstance(props["digitalRestoration"], object):
                try:
                    # Attempt to convert
                    props["digitalRestoration"] = object(props["digitalRestoration"])
                except:
                    raise TypeError(f"Property digitalRestoration must be of type object, got {type(props['digitalRestoration']).__name__}")
    
        # Type check isPreservationRegistry (expected bool)
        if "isPreservationRegistry" in props and props["isPreservationRegistry"] is not None:
            if not isinstance(props["isPreservationRegistry"], bool):
                try:
                    # Attempt to convert
                    props["isPreservationRegistry"] = bool(props["isPreservationRegistry"])
                except:
                    raise TypeError(f"Property isPreservationRegistry must be of type bool, got {type(props['isPreservationRegistry']).__name__}")
    
        # Type check preservationDate (expected object)
        if "preservationDate" in props and props["preservationDate"] is not None:
            if not isinstance(props["preservationDate"], object):
                try:
                    # Attempt to convert
                    props["preservationDate"] = object(props["preservationDate"])
                except:
                    raise TypeError(f"Property preservationDate must be of type object, got {type(props['preservationDate']).__name__}")
    
        # Type check initialReviews (expected object)
        if "initialReviews" in props and props["initialReviews"] is not None:
            if not isinstance(props["initialReviews"], object):
                try:
                    # Attempt to convert
                    props["initialReviews"] = object(props["initialReviews"])
                except:
                    raise TypeError(f"Property initialReviews must be of type object, got {type(props['initialReviews']).__name__}")
    
        # Type check technicalInnovations (expected object)
        if "technicalInnovations" in props and props["technicalInnovations"] is not None:
            if not isinstance(props["technicalInnovations"], object):
                try:
                    # Attempt to convert
                    props["technicalInnovations"] = object(props["technicalInnovations"])
                except:
                    raise TypeError(f"Property technicalInnovations must be of type object, got {type(props['technicalInnovations']).__name__}")
    
        # Type check festivalsWon (expected object)
        if "festivalsWon" in props and props["festivalsWon"] is not None:
            if not isinstance(props["festivalsWon"], object):
                try:
                    # Attempt to convert
                    props["festivalsWon"] = object(props["festivalsWon"])
                except:
                    raise TypeError(f"Property festivalsWon must be of type object, got {type(props['festivalsWon']).__name__}")
    
        # Type check originalLanguage (expected str)
        if "originalLanguage" in props and props["originalLanguage"] is not None:
            if not isinstance(props["originalLanguage"], str):
                try:
                    # Attempt to convert
                    props["originalLanguage"] = str(props["originalLanguage"])
                except:
                    raise TypeError(f"Property originalLanguage must be of type str, got {type(props['originalLanguage']).__name__}")
    
        # Type check boxOfficeInternational (expected int)
        if "boxOfficeInternational" in props and props["boxOfficeInternational"] is not None:
            if not isinstance(props["boxOfficeInternational"], int):
                try:
                    # Attempt to convert
                    props["boxOfficeInternational"] = int(props["boxOfficeInternational"])
                except:
                    raise TypeError(f"Property boxOfficeInternational must be of type int, got {type(props['boxOfficeInternational']).__name__}")
    
        # Type check subtitleLanguages (expected object)
        if "subtitleLanguages" in props and props["subtitleLanguages"] is not None:
            if not isinstance(props["subtitleLanguages"], object):
                try:
                    # Attempt to convert
                    props["subtitleLanguages"] = object(props["subtitleLanguages"])
                except:
                    raise TypeError(f"Property subtitleLanguages must be of type object, got {type(props['subtitleLanguages']).__name__}")
    
        # Type check isInternational (expected bool)
        if "isInternational" in props and props["isInternational"] is not None:
            if not isinstance(props["isInternational"], bool):
                try:
                    # Attempt to convert
                    props["isInternational"] = bool(props["isInternational"])
                except:
                    raise TypeError(f"Property isInternational must be of type bool, got {type(props['isInternational']).__name__}")
    
        # Type check temperatureUnit (expected str)
        if "temperatureUnit" in props and props["temperatureUnit"] is not None:
            if not isinstance(props["temperatureUnit"], str):
                try:
                    # Attempt to convert
                    props["temperatureUnit"] = str(props["temperatureUnit"])
                except:
                    raise TypeError(f"Property temperatureUnit must be of type str, got {type(props['temperatureUnit']).__name__}")
    
        # Type check extremeTemperatures (expected object)
        if "extremeTemperatures" in props and props["extremeTemperatures"] is not None:
            if not isinstance(props["extremeTemperatures"], object):
                try:
                    # Attempt to convert
                    props["extremeTemperatures"] = object(props["extremeTemperatures"])
                except:
                    raise TypeError(f"Property extremeTemperatures must be of type object, got {type(props['extremeTemperatures']).__name__}")
    
        # Type check filmingDuration (expected object)
        if "filmingDuration" in props and props["filmingDuration"] is not None:
            if not isinstance(props["filmingDuration"], object):
                try:
                    # Attempt to convert
                    props["filmingDuration"] = object(props["filmingDuration"])
                except:
                    raise TypeError(f"Property filmingDuration must be of type object, got {type(props['filmingDuration']).__name__}")
    
        # Type check filmingConditions (expected str)
        if "filmingConditions" in props and props["filmingConditions"] is not None:
            if not isinstance(props["filmingConditions"], str):
                try:
                    # Attempt to convert
                    props["filmingConditions"] = str(props["filmingConditions"])
                except:
                    raise TypeError(f"Property filmingConditions must be of type str, got {type(props['filmingConditions']).__name__}")
    
        # Type check narrators (expected object)
        if "narrators" in props and props["narrators"] is not None:
            if not isinstance(props["narrators"], object):
                try:
                    # Attempt to convert
                    props["narrators"] = object(props["narrators"])
                except:
                    raise TypeError(f"Property narrators must be of type object, got {type(props['narrators']).__name__}")
    
        # Type check isDocumentary (expected bool)
        if "isDocumentary" in props and props["isDocumentary"] is not None:
            if not isinstance(props["isDocumentary"], bool):
                try:
                    # Attempt to convert
                    props["isDocumentary"] = bool(props["isDocumentary"])
                except:
                    raise TypeError(f"Property isDocumentary must be of type bool, got {type(props['isDocumentary']).__name__}")
    
        # Type check musicalNumbers (expected int)
        if "musicalNumbers" in props and props["musicalNumbers"] is not None:
            if not isinstance(props["musicalNumbers"], int):
                try:
                    # Attempt to convert
                    props["musicalNumbers"] = int(props["musicalNumbers"])
                except:
                    raise TypeError(f"Property musicalNumbers must be of type int, got {type(props['musicalNumbers']).__name__}")
    
        # Type check digitalRemastering (expected int)
        if "digitalRemastering" in props and props["digitalRemastering"] is not None:
            if not isinstance(props["digitalRemastering"], int):
                try:
                    # Attempt to convert
                    props["digitalRemastering"] = int(props["digitalRemastering"])
                except:
                    raise TypeError(f"Property digitalRemastering must be of type int, got {type(props['digitalRemastering']).__name__}")
    
        # Type check iconicScenes (expected object)
        if "iconicScenes" in props and props["iconicScenes"] is not None:
            if not isinstance(props["iconicScenes"], object):
                try:
                    # Attempt to convert
                    props["iconicScenes"] = object(props["iconicScenes"])
                except:
                    raise TypeError(f"Property iconicScenes must be of type object, got {type(props['iconicScenes']).__name__}")
    
        # Type check renderingHours (expected int)
        if "renderingHours" in props and props["renderingHours"] is not None:
            if not isinstance(props["renderingHours"], int):
                try:
                    # Attempt to convert
                    props["renderingHours"] = int(props["renderingHours"])
                except:
                    raise TypeError(f"Property renderingHours must be of type int, got {type(props['renderingHours']).__name__}")
    
        # Type check is3D (expected bool)
        if "is3D" in props and props["is3D"] is not None:
            if not isinstance(props["is3D"], bool):
                try:
                    # Attempt to convert
                    props["is3D"] = bool(props["is3D"])
                except:
                    raise TypeError(f"Property is3D must be of type bool, got {type(props['is3D']).__name__}")
    
        # Type check motionCapturePercentage (expected int)
        if "motionCapturePercentage" in props and props["motionCapturePercentage"] is not None:
            if not isinstance(props["motionCapturePercentage"], int):
                try:
                    # Attempt to convert
                    props["motionCapturePercentage"] = int(props["motionCapturePercentage"])
                except:
                    raise TypeError(f"Property motionCapturePercentage must be of type int, got {type(props['motionCapturePercentage']).__name__}")
    
        # Type check merchandisingSales (expected int)
        if "merchandisingSales" in props and props["merchandisingSales"] is not None:
            if not isinstance(props["merchandisingSales"], int):
                try:
                    # Attempt to convert
                    props["merchandisingSales"] = int(props["merchandisingSales"])
                except:
                    raise TypeError(f"Property merchandisingSales must be of type int, got {type(props['merchandisingSales']).__name__}")
    
        # Type check culturalImpact (expected str)
        if "culturalImpact" in props and props["culturalImpact"] is not None:
            if not isinstance(props["culturalImpact"], str):
                try:
                    # Attempt to convert
                    props["culturalImpact"] = str(props["culturalImpact"])
                except:
                    raise TypeError(f"Property culturalImpact must be of type str, got {type(props['culturalImpact']).__name__}")
    
        # Type check culturalMilestones (expected object)
        if "culturalMilestones" in props and props["culturalMilestones"] is not None:
            if not isinstance(props["culturalMilestones"], object):
                try:
                    # Attempt to convert
                    props["culturalMilestones"] = object(props["culturalMilestones"])
                except:
                    raise TypeError(f"Property culturalMilestones must be of type object, got {type(props['culturalMilestones']).__name__}")
    
        # Type check isAnimated (expected bool)
        if "isAnimated" in props and props["isAnimated"] is not None:
            if not isinstance(props["isAnimated"], bool):
                try:
                    # Attempt to convert
                    props["isAnimated"] = bool(props["isAnimated"])
                except:
                    raise TypeError(f"Property isAnimated must be of type bool, got {type(props['isAnimated']).__name__}")
    
        # Type check animationStyles (expected object)
        if "animationStyles" in props and props["animationStyles"] is not None:
            if not isinstance(props["animationStyles"], object):
                try:
                    # Attempt to convert
                    props["animationStyles"] = object(props["animationStyles"])
                except:
                    raise TypeError(f"Property animationStyles must be of type object, got {type(props['animationStyles']).__name__}")
    
        # Type check renderedFrames (expected int)
        if "renderedFrames" in props and props["renderedFrames"] is not None:
            if not isinstance(props["renderedFrames"], int):
                try:
                    # Attempt to convert
                    props["renderedFrames"] = int(props["renderedFrames"])
                except:
                    raise TypeError(f"Property renderedFrames must be of type int, got {type(props['renderedFrames']).__name__}")
    
        # Type check isIndie (expected bool)
        if "isIndie" in props and props["isIndie"] is not None:
            if not isinstance(props["isIndie"], bool):
                try:
                    # Attempt to convert
                    props["isIndie"] = bool(props["isIndie"])
                except:
                    raise TypeError(f"Property isIndie must be of type bool, got {type(props['isIndie']).__name__}")
    
        # Type check festivalWins (expected int)
        if "festivalWins" in props and props["festivalWins"] is not None:
            if not isinstance(props["festivalWins"], int):
                try:
                    # Attempt to convert
                    props["festivalWins"] = int(props["festivalWins"])
                except:
                    raise TypeError(f"Property festivalWins must be of type int, got {type(props['festivalWins']).__name__}")
    
        # Type check filmingDays (expected int)
        if "filmingDays" in props and props["filmingDays"] is not None:
            if not isinstance(props["filmingDays"], int):
                try:
                    # Attempt to convert
                    props["filmingDays"] = int(props["filmingDays"])
                except:
                    raise TypeError(f"Property filmingDays must be of type int, got {type(props['filmingDays']).__name__}")
    
        # Type check specialEffectsAwards (expected int)
        if "specialEffectsAwards" in props and props["specialEffectsAwards"] is not None:
            if not isinstance(props["specialEffectsAwards"], int):
                try:
                    # Attempt to convert
                    props["specialEffectsAwards"] = int(props["specialEffectsAwards"])
                except:
                    raise TypeError(f"Property specialEffectsAwards must be of type int, got {type(props['specialEffectsAwards']).__name__}")
    
        # Type check rereleaseDates (expected list)
        if "rereleaseDates" in props and props["rereleaseDates"] is not None:
            if not isinstance(props["rereleaseDates"], list):
                try:
                    # Attempt to convert
                    props["rereleaseDates"] = list(props["rereleaseDates"])
                except:
                    raise TypeError(f"Property rereleaseDates must be of type list, got {type(props['rereleaseDates']).__name__}")
    
        # Type check iMAXSequences (expected int)
        if "iMAXSequences" in props and props["iMAXSequences"] is not None:
            if not isinstance(props["iMAXSequences"], int):
                try:
                    # Attempt to convert
                    props["iMAXSequences"] = int(props["iMAXSequences"])
                except:
                    raise TypeError(f"Property iMAXSequences must be of type int, got {type(props['iMAXSequences']).__name__}")
    
        # Type check posthumousAwards (expected int)
        if "posthumousAwards" in props and props["posthumousAwards"] is not None:
            if not isinstance(props["posthumousAwards"], int):
                try:
                    # Attempt to convert
                    props["posthumousAwards"] = int(props["posthumousAwards"])
                except:
                    raise TypeError(f"Property posthumousAwards must be of type int, got {type(props['posthumousAwards']).__name__}")
    
        # Type check nonLinearStructure (expected bool)
        if "nonLinearStructure" in props and props["nonLinearStructure"] is not None:
            if not isinstance(props["nonLinearStructure"], bool):
                try:
                    # Attempt to convert
                    props["nonLinearStructure"] = bool(props["nonLinearStructure"])
                except:
                    raise TypeError(f"Property nonLinearStructure must be of type bool, got {type(props['nonLinearStructure']).__name__}")
    
        # Type check martialArtsStyles (expected object)
        if "martialArtsStyles" in props and props["martialArtsStyles"] is not None:
            if not isinstance(props["martialArtsStyles"], object):
                try:
                    # Attempt to convert
                    props["martialArtsStyles"] = object(props["martialArtsStyles"])
                except:
                    raise TypeError(f"Property martialArtsStyles must be of type object, got {type(props['martialArtsStyles']).__name__}")
    
        # Type check practicalEffectsPercentage (expected int)
        if "practicalEffectsPercentage" in props and props["practicalEffectsPercentage"] is not None:
            if not isinstance(props["practicalEffectsPercentage"], int):
                try:
                    # Attempt to convert
                    props["practicalEffectsPercentage"] = int(props["practicalEffectsPercentage"])
                except:
                    raise TypeError(f"Property practicalEffectsPercentage must be of type int, got {type(props['practicalEffectsPercentage']).__name__}")
    
        # Type check sequelNumber (expected int)
        if "sequelNumber" in props and props["sequelNumber"] is not None:
            if not isinstance(props["sequelNumber"], int):
                try:
                    # Attempt to convert
                    props["sequelNumber"] = int(props["sequelNumber"])
                except:
                    raise TypeError(f"Property sequelNumber must be of type int, got {type(props['sequelNumber']).__name__}")
    
        # Type check volumeNumber (expected int)
        if "volumeNumber" in props and props["volumeNumber"] is not None:
            if not isinstance(props["volumeNumber"], int):
                try:
                    # Attempt to convert
                    props["volumeNumber"] = int(props["volumeNumber"])
                except:
                    raise TypeError(f"Property volumeNumber must be of type int, got {type(props['volumeNumber']).__name__}")
    
        # Type check homageFilms (expected object)
        if "homageFilms" in props and props["homageFilms"] is not None:
            if not isinstance(props["homageFilms"], object):
                try:
                    # Attempt to convert
                    props["homageFilms"] = object(props["homageFilms"])
                except:
                    raise TypeError(f"Property homageFilms must be of type object, got {type(props['homageFilms']).__name__}")
    
        # Type check visualEffectsBreakthrough (expected bool)
        if "visualEffectsBreakthrough" in props and props["visualEffectsBreakthrough"] is not None:
            if not isinstance(props["visualEffectsBreakthrough"], bool):
                try:
                    # Attempt to convert
                    props["visualEffectsBreakthrough"] = bool(props["visualEffectsBreakthrough"])
                except:
                    raise TypeError(f"Property visualEffectsBreakthrough must be of type bool, got {type(props['visualEffectsBreakthrough']).__name__}")
    
        # Type check adaptationFidelity (expected str)
        if "adaptationFidelity" in props and props["adaptationFidelity"] is not None:
            if not isinstance(props["adaptationFidelity"], str):
                try:
                    # Attempt to convert
                    props["adaptationFidelity"] = str(props["adaptationFidelity"])
                except:
                    raise TypeError(f"Property adaptationFidelity must be of type str, got {type(props['adaptationFidelity']).__name__}")
    
        # Type check periodAccuracy (expected str)
        if "periodAccuracy" in props and props["periodAccuracy"] is not None:
            if not isinstance(props["periodAccuracy"], str):
                try:
                    # Attempt to convert
                    props["periodAccuracy"] = str(props["periodAccuracy"])
                except:
                    raise TypeError(f"Property periodAccuracy must be of type str, got {type(props['periodAccuracy']).__name__}")
    
        # Type check isAdaptation (expected bool)
        if "isAdaptation" in props and props["isAdaptation"] is not None:
            if not isinstance(props["isAdaptation"], bool):
                try:
                    # Attempt to convert
                    props["isAdaptation"] = bool(props["isAdaptation"])
                except:
                    raise TypeError(f"Property isAdaptation must be of type bool, got {type(props['isAdaptation']).__name__}")
    
        # Type check sourceAuthor (expected str)
        if "sourceAuthor" in props and props["sourceAuthor"] is not None:
            if not isinstance(props["sourceAuthor"], str):
                try:
                    # Attempt to convert
                    props["sourceAuthor"] = str(props["sourceAuthor"])
                except:
                    raise TypeError(f"Property sourceAuthor must be of type str, got {type(props['sourceAuthor']).__name__}")
    
        # Type check historicalAccuracy (expected str)
        if "historicalAccuracy" in props and props["historicalAccuracy"] is not None:
            if not isinstance(props["historicalAccuracy"], str):
                try:
                    # Attempt to convert
                    props["historicalAccuracy"] = str(props["historicalAccuracy"])
                except:
                    raise TypeError(f"Property historicalAccuracy must be of type str, got {type(props['historicalAccuracy']).__name__}")
    
        # Type check iMAXPercentage (expected int)
        if "iMAXPercentage" in props and props["iMAXPercentage"] is not None:
            if not isinstance(props["iMAXPercentage"], int):
                try:
                    # Attempt to convert
                    props["iMAXPercentage"] = int(props["iMAXPercentage"])
                except:
                    raise TypeError(f"Property iMAXPercentage must be of type int, got {type(props['iMAXPercentage']).__name__}")
    
        # Type check iMAXFilming (expected bool)
        if "iMAXFilming" in props and props["iMAXFilming"] is not None:
            if not isinstance(props["iMAXFilming"], bool):
                try:
                    # Attempt to convert
                    props["iMAXFilming"] = bool(props["iMAXFilming"])
                except:
                    raise TypeError(f"Property iMAXFilming must be of type bool, got {type(props['iMAXFilming']).__name__}")
    
        # Type check cgiBreakthroughs (expected object)
        if "cgiBreakthroughs" in props and props["cgiBreakthroughs"] is not None:
            if not isinstance(props["cgiBreakthroughs"], object):
                try:
                    # Attempt to convert
                    props["cgiBreakthroughs"] = object(props["cgiBreakthroughs"])
                except:
                    raise TypeError(f"Property cgiBreakthroughs must be of type object, got {type(props['cgiBreakthroughs']).__name__}")
    
        # Type check specialEffectsBreakthrough (expected bool)
        if "specialEffectsBreakthrough" in props and props["specialEffectsBreakthrough"] is not None:
            if not isinstance(props["specialEffectsBreakthrough"], bool):
                try:
                    # Attempt to convert
                    props["specialEffectsBreakthrough"] = bool(props["specialEffectsBreakthrough"])
                except:
                    raise TypeError(f"Property specialEffectsBreakthrough must be of type bool, got {type(props['specialEffectsBreakthrough']).__name__}")
    
        # Type check westernRemakes (expected str)
        if "westernRemakes" in props and props["westernRemakes"] is not None:
            if not isinstance(props["westernRemakes"], str):
                try:
                    # Attempt to convert
                    props["westernRemakes"] = str(props["westernRemakes"])
                except:
                    raise TypeError(f"Property westernRemakes must be of type str, got {type(props['westernRemakes']).__name__}")
    
        # Type check filmPreservation (expected str)
        if "filmPreservation" in props and props["filmPreservation"] is not None:
            if not isinstance(props["filmPreservation"], str):
                try:
                    # Attempt to convert
                    props["filmPreservation"] = str(props["filmPreservation"])
                except:
                    raise TypeError(f"Property filmPreservation must be of type str, got {type(props['filmPreservation']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Movie", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def person(uuid=None, **props):
        """
        Find nodes with label Person matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check born (expected int)
        if "born" in props and props["born"] is not None:
            if not isinstance(props["born"], int):
                try:
                    # Attempt to convert
                    props["born"] = int(props["born"])
                except:
                    raise TypeError(f"Property born must be of type int, got {type(props['born']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check residenceLat (expected float)
        if "residenceLat" in props and props["residenceLat"] is not None:
            if not isinstance(props["residenceLat"], float):
                try:
                    # Attempt to convert
                    props["residenceLat"] = float(props["residenceLat"])
                except:
                    raise TypeError(f"Property residenceLat must be of type float, got {type(props['residenceLat']).__name__}")
    
        # Type check activeYears (expected object)
        if "activeYears" in props and props["activeYears"] is not None:
            if not isinstance(props["activeYears"], object):
                try:
                    # Attempt to convert
                    props["activeYears"] = object(props["activeYears"])
                except:
                    raise TypeError(f"Property activeYears must be of type object, got {type(props['activeYears']).__name__}")
    
        # Type check typicalFilmLengthHrs (expected float)
        if "typicalFilmLengthHrs" in props and props["typicalFilmLengthHrs"] is not None:
            if not isinstance(props["typicalFilmLengthHrs"], float):
                try:
                    # Attempt to convert
                    props["typicalFilmLengthHrs"] = float(props["typicalFilmLengthHrs"])
                except:
                    raise TypeError(f"Property typicalFilmLengthHrs must be of type float, got {type(props['typicalFilmLengthHrs']).__name__}")
    
        # Type check oscarNominations (expected int)
        if "oscarNominations" in props and props["oscarNominations"] is not None:
            if not isinstance(props["oscarNominations"], int):
                try:
                    # Attempt to convert
                    props["oscarNominations"] = int(props["oscarNominations"])
                except:
                    raise TypeError(f"Property oscarNominations must be of type int, got {type(props['oscarNominations']).__name__}")
    
        # Type check nationality (expected str)
        if "nationality" in props and props["nationality"] is not None:
            if not isinstance(props["nationality"], str):
                try:
                    # Attempt to convert
                    props["nationality"] = str(props["nationality"])
                except:
                    raise TypeError(f"Property nationality must be of type str, got {type(props['nationality']).__name__}")
    
        # Type check isActive (expected bool)
        if "isActive" in props and props["isActive"] is not None:
            if not isinstance(props["isActive"], bool):
                try:
                    # Attempt to convert
                    props["isActive"] = bool(props["isActive"])
                except:
                    raise TypeError(f"Property isActive must be of type bool, got {type(props['isActive']).__name__}")
    
        # Type check lastDirected (expected object)
        if "lastDirected" in props and props["lastDirected"] is not None:
            if not isinstance(props["lastDirected"], object):
                try:
                    # Attempt to convert
                    props["lastDirected"] = object(props["lastDirected"])
                except:
                    raise TypeError(f"Property lastDirected must be of type object, got {type(props['lastDirected']).__name__}")
    
        # Type check birthdate (expected object)
        if "birthdate" in props and props["birthdate"] is not None:
            if not isinstance(props["birthdate"], object):
                try:
                    # Attempt to convert
                    props["birthdate"] = object(props["birthdate"])
                except:
                    raise TypeError(f"Property birthdate must be of type object, got {type(props['birthdate']).__name__}")
    
        # Type check residenceLong (expected float)
        if "residenceLong" in props and props["residenceLong"] is not None:
            if not isinstance(props["residenceLong"], float):
                try:
                    # Attempt to convert
                    props["residenceLong"] = float(props["residenceLong"])
                except:
                    raise TypeError(f"Property residenceLong must be of type float, got {type(props['residenceLong']).__name__}")
    
        # Type check preferredAspectRatios (expected object)
        if "preferredAspectRatios" in props and props["preferredAspectRatios"] is not None:
            if not isinstance(props["preferredAspectRatios"], object):
                try:
                    # Attempt to convert
                    props["preferredAspectRatios"] = object(props["preferredAspectRatios"])
                except:
                    raise TypeError(f"Property preferredAspectRatios must be of type object, got {type(props['preferredAspectRatios']).__name__}")
    
        # Type check collaborators (expected object)
        if "collaborators" in props and props["collaborators"] is not None:
            if not isinstance(props["collaborators"], object):
                try:
                    # Attempt to convert
                    props["collaborators"] = object(props["collaborators"])
                except:
                    raise TypeError(f"Property collaborators must be of type object, got {type(props['collaborators']).__name__}")
    
        # Type check filmCountCrime (expected int)
        if "filmCountCrime" in props and props["filmCountCrime"] is not None:
            if not isinstance(props["filmCountCrime"], int):
                try:
                    # Attempt to convert
                    props["filmCountCrime"] = int(props["filmCountCrime"])
                except:
                    raise TypeError(f"Property filmCountCrime must be of type int, got {type(props['filmCountCrime']).__name__}")
    
        # Type check filmCountRomance (expected int)
        if "filmCountRomance" in props and props["filmCountRomance"] is not None:
            if not isinstance(props["filmCountRomance"], int):
                try:
                    # Attempt to convert
                    props["filmCountRomance"] = int(props["filmCountRomance"])
                except:
                    raise TypeError(f"Property filmCountRomance must be of type int, got {type(props['filmCountRomance']).__name__}")
    
        # Type check filmCountWestern (expected int)
        if "filmCountWestern" in props and props["filmCountWestern"] is not None:
            if not isinstance(props["filmCountWestern"], int):
                try:
                    # Attempt to convert
                    props["filmCountWestern"] = int(props["filmCountWestern"])
                except:
                    raise TypeError(f"Property filmCountWestern must be of type int, got {type(props['filmCountWestern']).__name__}")
    
        # Type check residenceLongs (expected object)
        if "residenceLongs" in props and props["residenceLongs"] is not None:
            if not isinstance(props["residenceLongs"], object):
                try:
                    # Attempt to convert
                    props["residenceLongs"] = object(props["residenceLongs"])
                except:
                    raise TypeError(f"Property residenceLongs must be of type object, got {type(props['residenceLongs']).__name__}")
    
        # Type check filmCountThriller (expected int)
        if "filmCountThriller" in props and props["filmCountThriller"] is not None:
            if not isinstance(props["filmCountThriller"], int):
                try:
                    # Attempt to convert
                    props["filmCountThriller"] = int(props["filmCountThriller"])
                except:
                    raise TypeError(f"Property filmCountThriller must be of type int, got {type(props['filmCountThriller']).__name__}")
    
        # Type check residenceLats (expected object)
        if "residenceLats" in props and props["residenceLats"] is not None:
            if not isinstance(props["residenceLats"], object):
                try:
                    # Attempt to convert
                    props["residenceLats"] = object(props["residenceLats"])
                except:
                    raise TypeError(f"Property residenceLats must be of type object, got {type(props['residenceLats']).__name__}")
    
        # Type check filmCountDrama (expected int)
        if "filmCountDrama" in props and props["filmCountDrama"] is not None:
            if not isinstance(props["filmCountDrama"], int):
                try:
                    # Attempt to convert
                    props["filmCountDrama"] = int(props["filmCountDrama"])
                except:
                    raise TypeError(f"Property filmCountDrama must be of type int, got {type(props['filmCountDrama']).__name__}")
    
        # Type check oscarWins (expected int)
        if "oscarWins" in props and props["oscarWins"] is not None:
            if not isinstance(props["oscarWins"], int):
                try:
                    # Attempt to convert
                    props["oscarWins"] = int(props["oscarWins"])
                except:
                    raise TypeError(f"Property oscarWins must be of type int, got {type(props['oscarWins']).__name__}")
    
        # Type check netWorth (expected int)
        if "netWorth" in props and props["netWorth"] is not None:
            if not isinstance(props["netWorth"], int):
                try:
                    # Attempt to convert
                    props["netWorth"] = int(props["netWorth"])
                except:
                    raise TypeError(f"Property netWorth must be of type int, got {type(props['netWorth']).__name__}")
    
        # Type check typicalShootScheduleMonths (expected int)
        if "typicalShootScheduleMonths" in props and props["typicalShootScheduleMonths"] is not None:
            if not isinstance(props["typicalShootScheduleMonths"], int):
                try:
                    # Attempt to convert
                    props["typicalShootScheduleMonths"] = int(props["typicalShootScheduleMonths"])
                except:
                    raise TypeError(f"Property typicalShootScheduleMonths must be of type int, got {type(props['typicalShootScheduleMonths']).__name__}")
    
        # Type check languages (expected object)
        if "languages" in props and props["languages"] is not None:
            if not isinstance(props["languages"], object):
                try:
                    # Attempt to convert
                    props["languages"] = object(props["languages"])
                except:
                    raise TypeError(f"Property languages must be of type object, got {type(props['languages']).__name__}")
    
        # Type check actingRangeScore (expected float)
        if "actingRangeScore" in props and props["actingRangeScore"] is not None:
            if not isinstance(props["actingRangeScore"], float):
                try:
                    # Attempt to convert
                    props["actingRangeScore"] = float(props["actingRangeScore"])
                except:
                    raise TypeError(f"Property actingRangeScore must be of type float, got {type(props['actingRangeScore']).__name__}")
    
        # Type check heightInMeters (expected float)
        if "heightInMeters" in props and props["heightInMeters"] is not None:
            if not isinstance(props["heightInMeters"], float):
                try:
                    # Attempt to convert
                    props["heightInMeters"] = float(props["heightInMeters"])
                except:
                    raise TypeError(f"Property heightInMeters must be of type float, got {type(props['heightInMeters']).__name__}")
    
        # Type check firstOscarWin (expected object)
        if "firstOscarWin" in props and props["firstOscarWin"] is not None:
            if not isinstance(props["firstOscarWin"], object):
                try:
                    # Attempt to convert
                    props["firstOscarWin"] = object(props["firstOscarWin"])
                except:
                    raise TypeError(f"Property firstOscarWin must be of type object, got {type(props['firstOscarWin']).__name__}")
    
        # Type check filmography_roles (expected object)
        if "filmography_roles" in props and props["filmography_roles"] is not None:
            if not isinstance(props["filmography_roles"], object):
                try:
                    # Attempt to convert
                    props["filmography_roles"] = object(props["filmography_roles"])
                except:
                    raise TypeError(f"Property filmography_roles must be of type object, got {type(props['filmography_roles']).__name__}")
    
        # Type check filmography_years (expected object)
        if "filmography_years" in props and props["filmography_years"] is not None:
            if not isinstance(props["filmography_years"], object):
                try:
                    # Attempt to convert
                    props["filmography_years"] = object(props["filmography_years"])
                except:
                    raise TypeError(f"Property filmography_years must be of type object, got {type(props['filmography_years']).__name__}")
    
        # Type check filmography_titles (expected object)
        if "filmography_titles" in props and props["filmography_titles"] is not None:
            if not isinstance(props["filmography_titles"], object):
                try:
                    # Attempt to convert
                    props["filmography_titles"] = object(props["filmography_titles"])
                except:
                    raise TypeError(f"Property filmography_titles must be of type object, got {type(props['filmography_titles']).__name__}")
    
        # Type check typicalDay (expected object)
        if "typicalDay" in props and props["typicalDay"] is not None:
            if not isinstance(props["typicalDay"], object):
                try:
                    # Attempt to convert
                    props["typicalDay"] = object(props["typicalDay"])
                except:
                    raise TypeError(f"Property typicalDay must be of type object, got {type(props['typicalDay']).__name__}")
    
        # Type check oscarCeremony (expected object)
        if "oscarCeremony" in props and props["oscarCeremony"] is not None:
            if not isinstance(props["oscarCeremony"], object):
                try:
                    # Attempt to convert
                    props["oscarCeremony"] = object(props["oscarCeremony"])
                except:
                    raise TypeError(f"Property oscarCeremony must be of type object, got {type(props['oscarCeremony']).__name__}")
    
        # Type check firstFilm (expected object)
        if "firstFilm" in props and props["firstFilm"] is not None:
            if not isinstance(props["firstFilm"], object):
                try:
                    # Attempt to convert
                    props["firstFilm"] = object(props["firstFilm"])
                except:
                    raise TypeError(f"Property firstFilm must be of type object, got {type(props['firstFilm']).__name__}")
    
        # Type check acceptedFilmStart (expected object)
        if "acceptedFilmStart" in props and props["acceptedFilmStart"] is not None:
            if not isinstance(props["acceptedFilmStart"], object):
                try:
                    # Attempt to convert
                    props["acceptedFilmStart"] = object(props["acceptedFilmStart"])
                except:
                    raise TypeError(f"Property acceptedFilmStart must be of type object, got {type(props['acceptedFilmStart']).__name__}")
    
        # Type check height (expected int)
        if "height" in props and props["height"] is not None:
            if not isinstance(props["height"], int):
                try:
                    # Attempt to convert
                    props["height"] = int(props["height"])
                except:
                    raise TypeError(f"Property height must be of type int, got {type(props['height']).__name__}")
    
        # Type check activityDays (expected object)
        if "activityDays" in props and props["activityDays"] is not None:
            if not isinstance(props["activityDays"], object):
                try:
                    # Attempt to convert
                    props["activityDays"] = object(props["activityDays"])
                except:
                    raise TypeError(f"Property activityDays must be of type object, got {type(props['activityDays']).__name__}")
    
        # Type check activityTypes (expected object)
        if "activityTypes" in props and props["activityTypes"] is not None:
            if not isinstance(props["activityTypes"], object):
                try:
                    # Attempt to convert
                    props["activityTypes"] = object(props["activityTypes"])
                except:
                    raise TypeError(f"Property activityTypes must be of type object, got {type(props['activityTypes']).__name__}")
    
        # Type check activityDurations (expected object)
        if "activityDurations" in props and props["activityDurations"] is not None:
            if not isinstance(props["activityDurations"], object):
                try:
                    # Attempt to convert
                    props["activityDurations"] = object(props["activityDurations"])
                except:
                    raise TypeError(f"Property activityDurations must be of type object, got {type(props['activityDurations']).__name__}")
    
        # Type check isCurrentlyFilming (expected bool)
        if "isCurrentlyFilming" in props and props["isCurrentlyFilming"] is not None:
            if not isinstance(props["isCurrentlyFilming"], bool):
                try:
                    # Attempt to convert
                    props["isCurrentlyFilming"] = bool(props["isCurrentlyFilming"])
                except:
                    raise TypeError(f"Property isCurrentlyFilming must be of type bool, got {type(props['isCurrentlyFilming']).__name__}")
    
        # Type check weight (expected int)
        if "weight" in props and props["weight"] is not None:
            if not isinstance(props["weight"], int):
                try:
                    # Attempt to convert
                    props["weight"] = int(props["weight"])
                except:
                    raise TypeError(f"Property weight must be of type int, got {type(props['weight']).__name__}")
    
        # Type check methodActingScore (expected float)
        if "methodActingScore" in props and props["methodActingScore"] is not None:
            if not isinstance(props["methodActingScore"], float):
                try:
                    # Attempt to convert
                    props["methodActingScore"] = float(props["methodActingScore"])
                except:
                    raise TypeError(f"Property methodActingScore must be of type float, got {type(props['methodActingScore']).__name__}")
    
        # Type check marriageDate (expected object)
        if "marriageDate" in props and props["marriageDate"] is not None:
            if not isinstance(props["marriageDate"], object):
                try:
                    # Attempt to convert
                    props["marriageDate"] = object(props["marriageDate"])
                except:
                    raise TypeError(f"Property marriageDate must be of type object, got {type(props['marriageDate']).__name__}")
    
        # Type check oscarWinDate (expected object)
        if "oscarWinDate" in props and props["oscarWinDate"] is not None:
            if not isinstance(props["oscarWinDate"], object):
                try:
                    # Attempt to convert
                    props["oscarWinDate"] = object(props["oscarWinDate"])
                except:
                    raise TypeError(f"Property oscarWinDate must be of type object, got {type(props['oscarWinDate']).__name__}")
    
        # Type check filmCountComedy (expected int)
        if "filmCountComedy" in props and props["filmCountComedy"] is not None:
            if not isinstance(props["filmCountComedy"], int):
                try:
                    # Attempt to convert
                    props["filmCountComedy"] = int(props["filmCountComedy"])
                except:
                    raise TypeError(f"Property filmCountComedy must be of type int, got {type(props['filmCountComedy']).__name__}")
    
        # Type check filmCountSciFi (expected int)
        if "filmCountSciFi" in props and props["filmCountSciFi"] is not None:
            if not isinstance(props["filmCountSciFi"], int):
                try:
                    # Attempt to convert
                    props["filmCountSciFi"] = int(props["filmCountSciFi"])
                except:
                    raise TypeError(f"Property filmCountSciFi must be of type int, got {type(props['filmCountSciFi']).__name__}")
    
        # Type check typicalRolePreparationMonths (expected float)
        if "typicalRolePreparationMonths" in props and props["typicalRolePreparationMonths"] is not None:
            if not isinstance(props["typicalRolePreparationMonths"], float):
                try:
                    # Attempt to convert
                    props["typicalRolePreparationMonths"] = float(props["typicalRolePreparationMonths"])
                except:
                    raise TypeError(f"Property typicalRolePreparationMonths must be of type float, got {type(props['typicalRolePreparationMonths']).__name__}")
    
        # Type check spouseName (expected str)
        if "spouseName" in props and props["spouseName"] is not None:
            if not isinstance(props["spouseName"], str):
                try:
                    # Attempt to convert
                    props["spouseName"] = str(props["spouseName"])
                except:
                    raise TypeError(f"Property spouseName must be of type str, got {type(props['spouseName']).__name__}")
    
        # Type check directorDebut (expected object)
        if "directorDebut" in props and props["directorDebut"] is not None:
            if not isinstance(props["directorDebut"], object):
                try:
                    # Attempt to convert
                    props["directorDebut"] = object(props["directorDebut"])
                except:
                    raise TypeError(f"Property directorDebut must be of type object, got {type(props['directorDebut']).__name__}")
    
        # Type check knighted (expected object)
        if "knighted" in props and props["knighted"] is not None:
            if not isinstance(props["knighted"], object):
                try:
                    # Attempt to convert
                    props["knighted"] = object(props["knighted"])
                except:
                    raise TypeError(f"Property knighted must be of type object, got {type(props['knighted']).__name__}")
    
        # Type check classicalTraining (expected bool)
        if "classicalTraining" in props and props["classicalTraining"] is not None:
            if not isinstance(props["classicalTraining"], bool):
                try:
                    # Attempt to convert
                    props["classicalTraining"] = bool(props["classicalTraining"])
                except:
                    raise TypeError(f"Property classicalTraining must be of type bool, got {type(props['classicalTraining']).__name__}")
    
        # Type check documentaryCount (expected int)
        if "documentaryCount" in props and props["documentaryCount"] is not None:
            if not isinstance(props["documentaryCount"], int):
                try:
                    # Attempt to convert
                    props["documentaryCount"] = int(props["documentaryCount"])
                except:
                    raise TypeError(f"Property documentaryCount must be of type int, got {type(props['documentaryCount']).__name__}")
    
        # Type check careerLength (expected object)
        if "careerLength" in props and props["careerLength"] is not None:
            if not isinstance(props["careerLength"], object):
                try:
                    # Attempt to convert
                    props["careerLength"] = object(props["careerLength"])
                except:
                    raise TypeError(f"Property careerLength must be of type object, got {type(props['careerLength']).__name__}")
    
        # Type check lastFilm (expected object)
        if "lastFilm" in props and props["lastFilm"] is not None:
            if not isinstance(props["lastFilm"], object):
                try:
                    # Attempt to convert
                    props["lastFilm"] = object(props["lastFilm"])
                except:
                    raise TypeError(f"Property lastFilm must be of type object, got {type(props['lastFilm']).__name__}")
    
        # Type check genres (expected object)
        if "genres" in props and props["genres"] is not None:
            if not isinstance(props["genres"], object):
                try:
                    # Attempt to convert
                    props["genres"] = object(props["genres"])
                except:
                    raise TypeError(f"Property genres must be of type object, got {type(props['genres']).__name__}")
    
        # Type check deathdate (expected object)
        if "deathdate" in props and props["deathdate"] is not None:
            if not isinstance(props["deathdate"], object):
                try:
                    # Attempt to convert
                    props["deathdate"] = object(props["deathdate"])
                except:
                    raise TypeError(f"Property deathdate must be of type object, got {type(props['deathdate']).__name__}")
    
        # Type check musicianSince (expected object)
        if "musicianSince" in props and props["musicianSince"] is not None:
            if not isinstance(props["musicianSince"], object):
                try:
                    # Attempt to convert
                    props["musicianSince"] = object(props["musicianSince"])
                except:
                    raise TypeError(f"Property musicianSince must be of type object, got {type(props['musicianSince']).__name__}")
    
        # Type check musicalInstruments (expected object)
        if "musicalInstruments" in props and props["musicalInstruments"] is not None:
            if not isinstance(props["musicalInstruments"], object):
                try:
                    # Attempt to convert
                    props["musicalInstruments"] = object(props["musicalInstruments"])
                except:
                    raise TypeError(f"Property musicalInstruments must be of type object, got {type(props['musicalInstruments']).__name__}")
    
        # Type check musicCareerStart (expected object)
        if "musicCareerStart" in props and props["musicCareerStart"] is not None:
            if not isinstance(props["musicCareerStart"], object):
                try:
                    # Attempt to convert
                    props["musicCareerStart"] = object(props["musicCareerStart"])
                except:
                    raise TypeError(f"Property musicCareerStart must be of type object, got {type(props['musicCareerStart']).__name__}")
    
        # Type check voiceActingScore (expected float)
        if "voiceActingScore" in props and props["voiceActingScore"] is not None:
            if not isinstance(props["voiceActingScore"], float):
                try:
                    # Attempt to convert
                    props["voiceActingScore"] = float(props["voiceActingScore"])
                except:
                    raise TypeError(f"Property voiceActingScore must be of type float, got {type(props['voiceActingScore']).__name__}")
    
        # Type check musicGenres (expected object)
        if "musicGenres" in props and props["musicGenres"] is not None:
            if not isinstance(props["musicGenres"], object):
                try:
                    # Attempt to convert
                    props["musicGenres"] = object(props["musicGenres"])
                except:
                    raise TypeError(f"Property musicGenres must be of type object, got {type(props['musicGenres']).__name__}")
    
        # Type check specialization (expected str)
        if "specialization" in props and props["specialization"] is not None:
            if not isinstance(props["specialization"], str):
                try:
                    # Attempt to convert
                    props["specialization"] = str(props["specialization"])
                except:
                    raise TypeError(f"Property specialization must be of type str, got {type(props['specialization']).__name__}")
    
        # Type check yearsInIndustry (expected int)
        if "yearsInIndustry" in props and props["yearsInIndustry"] is not None:
            if not isinstance(props["yearsInIndustry"], int):
                try:
                    # Attempt to convert
                    props["yearsInIndustry"] = int(props["yearsInIndustry"])
                except:
                    raise TypeError(f"Property yearsInIndustry must be of type int, got {type(props['yearsInIndustry']).__name__}")
    
        # Type check animationBackground (expected bool)
        if "animationBackground" in props and props["animationBackground"] is not None:
            if not isinstance(props["animationBackground"], bool):
                try:
                    # Attempt to convert
                    props["animationBackground"] = bool(props["animationBackground"])
                except:
                    raise TypeError(f"Property animationBackground must be of type bool, got {type(props['animationBackground']).__name__}")
    
        # Type check designStyle (expected str)
        if "designStyle" in props and props["designStyle"] is not None:
            if not isinstance(props["designStyle"], str):
                try:
                    # Attempt to convert
                    props["designStyle"] = str(props["designStyle"])
                except:
                    raise TypeError(f"Property designStyle must be of type str, got {type(props['designStyle']).__name__}")
    
        # Type check cameraPreference (expected str)
        if "cameraPreference" in props and props["cameraPreference"] is not None:
            if not isinstance(props["cameraPreference"], str):
                try:
                    # Attempt to convert
                    props["cameraPreference"] = str(props["cameraPreference"])
                except:
                    raise TypeError(f"Property cameraPreference must be of type str, got {type(props['cameraPreference']).__name__}")
    
        # Type check visualStyle (expected str)
        if "visualStyle" in props and props["visualStyle"] is not None:
            if not isinstance(props["visualStyle"], str):
                try:
                    # Attempt to convert
                    props["visualStyle"] = str(props["visualStyle"])
                except:
                    raise TypeError(f"Property visualStyle must be of type str, got {type(props['visualStyle']).__name__}")
    
        # Type check musicStyle (expected str)
        if "musicStyle" in props and props["musicStyle"] is not None:
            if not isinstance(props["musicStyle"], str):
                try:
                    # Attempt to convert
                    props["musicStyle"] = str(props["musicStyle"])
                except:
                    raise TypeError(f"Property musicStyle must be of type str, got {type(props['musicStyle']).__name__}")
    
        # Type check awardWins (expected int)
        if "awardWins" in props and props["awardWins"] is not None:
            if not isinstance(props["awardWins"], int):
                try:
                    # Attempt to convert
                    props["awardWins"] = int(props["awardWins"])
                except:
                    raise TypeError(f"Property awardWins must be of type int, got {type(props['awardWins']).__name__}")
    
        # Type check awardNominations (expected int)
        if "awardNominations" in props and props["awardNominations"] is not None:
            if not isinstance(props["awardNominations"], int):
                try:
                    # Attempt to convert
                    props["awardNominations"] = int(props["awardNominations"])
                except:
                    raise TypeError(f"Property awardNominations must be of type int, got {type(props['awardNominations']).__name__}")
    
        # Type check instrumentsPlayed (expected int)
        if "instrumentsPlayed" in props and props["instrumentsPlayed"] is not None:
            if not isinstance(props["instrumentsPlayed"], int):
                try:
                    # Attempt to convert
                    props["instrumentsPlayed"] = int(props["instrumentsPlayed"])
                except:
                    raise TypeError(f"Property instrumentsPlayed must be of type int, got {type(props['instrumentsPlayed']).__name__}")
    
        # Type check studioLocation (expected str)
        if "studioLocation" in props and props["studioLocation"] is not None:
            if not isinstance(props["studioLocation"], str):
                try:
                    # Attempt to convert
                    props["studioLocation"] = str(props["studioLocation"])
                except:
                    raise TypeError(f"Property studioLocation must be of type str, got {type(props['studioLocation']).__name__}")
    
        # Type check significance (expected str)
        if "significance" in props and props["significance"] is not None:
            if not isinstance(props["significance"], str):
                try:
                    # Attempt to convert
                    props["significance"] = str(props["significance"])
                except:
                    raise TypeError(f"Property significance must be of type str, got {type(props['significance']).__name__}")
    
        # Type check died (expected int)
        if "died" in props and props["died"] is not None:
            if not isinstance(props["died"], int):
                try:
                    # Attempt to convert
                    props["died"] = int(props["died"])
                except:
                    raise TypeError(f"Property died must be of type int, got {type(props['died']).__name__}")
    
        # Type check skillSets (expected object)
        if "skillSets" in props and props["skillSets"] is not None:
            if not isinstance(props["skillSets"], object):
                try:
                    # Attempt to convert
                    props["skillSets"] = object(props["skillSets"])
                except:
                    raise TypeError(f"Property skillSets must be of type object, got {type(props['skillSets']).__name__}")
    
        # Type check filmingStyle (expected str)
        if "filmingStyle" in props and props["filmingStyle"] is not None:
            if not isinstance(props["filmingStyle"], str):
                try:
                    # Attempt to convert
                    props["filmingStyle"] = str(props["filmingStyle"])
                except:
                    raise TypeError(f"Property filmingStyle must be of type str, got {type(props['filmingStyle']).__name__}")
    
        # Type check internationalRecognition (expected object)
        if "internationalRecognition" in props and props["internationalRecognition"] is not None:
            if not isinstance(props["internationalRecognition"], object):
                try:
                    # Attempt to convert
                    props["internationalRecognition"] = object(props["internationalRecognition"])
                except:
                    raise TypeError(f"Property internationalRecognition must be of type object, got {type(props['internationalRecognition']).__name__}")
    
        # Type check fieldworkLocations (expected object)
        if "fieldworkLocations" in props and props["fieldworkLocations"] is not None:
            if not isinstance(props["fieldworkLocations"], object):
                try:
                    # Attempt to convert
                    props["fieldworkLocations"] = object(props["fieldworkLocations"])
                except:
                    raise TypeError(f"Property fieldworkLocations must be of type object, got {type(props['fieldworkLocations']).__name__}")
    
        # Type check academicDegrees (expected object)
        if "academicDegrees" in props and props["academicDegrees"] is not None:
            if not isinstance(props["academicDegrees"], object):
                try:
                    # Attempt to convert
                    props["academicDegrees"] = object(props["academicDegrees"])
                except:
                    raise TypeError(f"Property academicDegrees must be of type object, got {type(props['academicDegrees']).__name__}")
    
        # Type check background (expected str)
        if "background" in props and props["background"] is not None:
            if not isinstance(props["background"], str):
                try:
                    # Attempt to convert
                    props["background"] = str(props["background"])
                except:
                    raise TypeError(f"Property background must be of type str, got {type(props['background']).__name__}")
    
        # Type check collaborationsWithBong (expected int)
        if "collaborationsWithBong" in props and props["collaborationsWithBong"] is not None:
            if not isinstance(props["collaborationsWithBong"], int):
                try:
                    # Attempt to convert
                    props["collaborationsWithBong"] = int(props["collaborationsWithBong"])
                except:
                    raise TypeError(f"Property collaborationsWithBong must be of type int, got {type(props['collaborationsWithBong']).__name__}")
    
        # Type check technicalPreferences (expected object)
        if "technicalPreferences" in props and props["technicalPreferences"] is not None:
            if not isinstance(props["technicalPreferences"], object):
                try:
                    # Attempt to convert
                    props["technicalPreferences"] = object(props["technicalPreferences"])
                except:
                    raise TypeError(f"Property technicalPreferences must be of type object, got {type(props['technicalPreferences']).__name__}")
    
        # Type check innovations (expected object)
        if "innovations" in props and props["innovations"] is not None:
            if not isinstance(props["innovations"], object):
                try:
                    # Attempt to convert
                    props["innovations"] = object(props["innovations"])
                except:
                    raise TypeError(f"Property innovations must be of type object, got {type(props['innovations']).__name__}")
    
        # Type check technicalInnovations (expected object)
        if "technicalInnovations" in props and props["technicalInnovations"] is not None:
            if not isinstance(props["technicalInnovations"], object):
                try:
                    # Attempt to convert
                    props["technicalInnovations"] = object(props["technicalInnovations"])
                except:
                    raise TypeError(f"Property technicalInnovations must be of type object, got {type(props['technicalInnovations']).__name__}")
    
        # Type check voiceType (expected str)
        if "voiceType" in props and props["voiceType"] is not None:
            if not isinstance(props["voiceType"], str):
                try:
                    # Attempt to convert
                    props["voiceType"] = str(props["voiceType"])
                except:
                    raise TypeError(f"Property voiceType must be of type str, got {type(props['voiceType']).__name__}")
    
        # Type check narratorRanking (expected int)
        if "narratorRanking" in props and props["narratorRanking"] is not None:
            if not isinstance(props["narratorRanking"], int):
                try:
                    # Attempt to convert
                    props["narratorRanking"] = int(props["narratorRanking"])
                except:
                    raise TypeError(f"Property narratorRanking must be of type int, got {type(props['narratorRanking']).__name__}")
    
        # Type check voiceRecognition (expected float)
        if "voiceRecognition" in props and props["voiceRecognition"] is not None:
            if not isinstance(props["voiceRecognition"], float):
                try:
                    # Attempt to convert
                    props["voiceRecognition"] = float(props["voiceRecognition"])
                except:
                    raise TypeError(f"Property voiceRecognition must be of type float, got {type(props['voiceRecognition']).__name__}")
    
        # Type check martialArtsTraining (expected bool)
        if "martialArtsTraining" in props and props["martialArtsTraining"] is not None:
            if not isinstance(props["martialArtsTraining"], bool):
                try:
                    # Attempt to convert
                    props["martialArtsTraining"] = bool(props["martialArtsTraining"])
                except:
                    raise TypeError(f"Property martialArtsTraining must be of type bool, got {type(props['martialArtsTraining']).__name__}")
    
        # Type check collaborations (expected int)
        if "collaborations" in props and props["collaborations"] is not None:
            if not isinstance(props["collaborations"], int):
                try:
                    # Attempt to convert
                    props["collaborations"] = int(props["collaborations"])
                except:
                    raise TypeError(f"Property collaborations must be of type int, got {type(props['collaborations']).__name__}")
    
        # Type check voiceRange (expected str)
        if "voiceRange" in props and props["voiceRange"] is not None:
            if not isinstance(props["voiceRange"], str):
                try:
                    # Attempt to convert
                    props["voiceRange"] = str(props["voiceRange"])
                except:
                    raise TypeError(f"Property voiceRange must be of type str, got {type(props['voiceRange']).__name__}")
    
        # Type check musicalSkills (expected object)
        if "musicalSkills" in props and props["musicalSkills"] is not None:
            if not isinstance(props["musicalSkills"], object):
                try:
                    # Attempt to convert
                    props["musicalSkills"] = object(props["musicalSkills"])
                except:
                    raise TypeError(f"Property musicalSkills must be of type object, got {type(props['musicalSkills']).__name__}")
    
        # Type check cameramanship (expected str)
        if "cameramanship" in props and props["cameramanship"] is not None:
            if not isinstance(props["cameramanship"], str):
                try:
                    # Attempt to convert
                    props["cameramanship"] = str(props["cameramanship"])
                except:
                    raise TypeError(f"Property cameramanship must be of type str, got {type(props['cameramanship']).__name__}")
    
        # Type check significantContribution (expected str)
        if "significantContribution" in props and props["significantContribution"] is not None:
            if not isinstance(props["significantContribution"], str):
                try:
                    # Attempt to convert
                    props["significantContribution"] = str(props["significantContribution"])
                except:
                    raise TypeError(f"Property significantContribution must be of type str, got {type(props['significantContribution']).__name__}")
    
        # Type check typecastEffect (expected str)
        if "typecastEffect" in props and props["typecastEffect"] is not None:
            if not isinstance(props["typecastEffect"], str):
                try:
                    # Attempt to convert
                    props["typecastEffect"] = str(props["typecastEffect"])
                except:
                    raise TypeError(f"Property typecastEffect must be of type str, got {type(props['typecastEffect']).__name__}")
    
        # Type check directorRanking (expected str)
        if "directorRanking" in props and props["directorRanking"] is not None:
            if not isinstance(props["directorRanking"], str):
                try:
                    # Attempt to convert
                    props["directorRanking"] = str(props["directorRanking"])
                except:
                    raise TypeError(f"Property directorRanking must be of type str, got {type(props['directorRanking']).__name__}")
    
        # Type check deepSeaExperience (expected bool)
        if "deepSeaExperience" in props and props["deepSeaExperience"] is not None:
            if not isinstance(props["deepSeaExperience"], bool):
                try:
                    # Attempt to convert
                    props["deepSeaExperience"] = bool(props["deepSeaExperience"])
                except:
                    raise TypeError(f"Property deepSeaExperience must be of type bool, got {type(props['deepSeaExperience']).__name__}")
    
        # Type check motionCaptureExperience (expected bool)
        if "motionCaptureExperience" in props and props["motionCaptureExperience"] is not None:
            if not isinstance(props["motionCaptureExperience"], bool):
                try:
                    # Attempt to convert
                    props["motionCaptureExperience"] = bool(props["motionCaptureExperience"])
                except:
                    raise TypeError(f"Property motionCaptureExperience must be of type bool, got {type(props['motionCaptureExperience']).__name__}")
    
        # Type check culturalImpact (expected str)
        if "culturalImpact" in props and props["culturalImpact"] is not None:
            if not isinstance(props["culturalImpact"], str):
                try:
                    # Attempt to convert
                    props["culturalImpact"] = str(props["culturalImpact"])
                except:
                    raise TypeError(f"Property culturalImpact must be of type str, got {type(props['culturalImpact']).__name__}")
    
        # Type check genreSpecialty (expected object)
        if "genreSpecialty" in props and props["genreSpecialty"] is not None:
            if not isinstance(props["genreSpecialty"], object):
                try:
                    # Attempt to convert
                    props["genreSpecialty"] = object(props["genreSpecialty"])
                except:
                    raise TypeError(f"Property genreSpecialty must be of type object, got {type(props['genreSpecialty']).__name__}")
    
        # Type check directorStyle (expected str)
        if "directorStyle" in props and props["directorStyle"] is not None:
            if not isinstance(props["directorStyle"], str):
                try:
                    # Attempt to convert
                    props["directorStyle"] = str(props["directorStyle"])
                except:
                    raise TypeError(f"Property directorStyle must be of type str, got {type(props['directorStyle']).__name__}")
    
        # Type check voiceActingExperience (expected bool)
        if "voiceActingExperience" in props and props["voiceActingExperience"] is not None:
            if not isinstance(props["voiceActingExperience"], bool):
                try:
                    # Attempt to convert
                    props["voiceActingExperience"] = bool(props["voiceActingExperience"])
                except:
                    raise TypeError(f"Property voiceActingExperience must be of type bool, got {type(props['voiceActingExperience']).__name__}")
    
        # Type check visualAesthetics (expected str)
        if "visualAesthetics" in props and props["visualAesthetics"] is not None:
            if not isinstance(props["visualAesthetics"], str):
                try:
                    # Attempt to convert
                    props["visualAesthetics"] = str(props["visualAesthetics"])
                except:
                    raise TypeError(f"Property visualAesthetics must be of type str, got {type(props['visualAesthetics']).__name__}")
    
        # Type check musicalBackground (expected bool)
        if "musicalBackground" in props and props["musicalBackground"] is not None:
            if not isinstance(props["musicalBackground"], bool):
                try:
                    # Attempt to convert
                    props["musicalBackground"] = bool(props["musicalBackground"])
                except:
                    raise TypeError(f"Property musicalBackground must be of type bool, got {type(props['musicalBackground']).__name__}")
    
        # Type check wineBusinessOwner (expected bool)
        if "wineBusinessOwner" in props and props["wineBusinessOwner"] is not None:
            if not isinstance(props["wineBusinessOwner"], bool):
                try:
                    # Attempt to convert
                    props["wineBusinessOwner"] = bool(props["wineBusinessOwner"])
                except:
                    raise TypeError(f"Property wineBusinessOwner must be of type bool, got {type(props['wineBusinessOwner']).__name__}")
    
        # Type check characterImmersion (expected str)
        if "characterImmersion" in props and props["characterImmersion"] is not None:
            if not isinstance(props["characterImmersion"], str):
                try:
                    # Attempt to convert
                    props["characterImmersion"] = str(props["characterImmersion"])
                except:
                    raise TypeError(f"Property characterImmersion must be of type str, got {type(props['characterImmersion']).__name__}")
    
        # Type check posthumousAwards (expected int)
        if "posthumousAwards" in props and props["posthumousAwards"] is not None:
            if not isinstance(props["posthumousAwards"], int):
                try:
                    # Attempt to convert
                    props["posthumousAwards"] = int(props["posthumousAwards"])
                except:
                    raise TypeError(f"Property posthumousAwards must be of type int, got {type(props['posthumousAwards']).__name__}")
    
        # Type check musicianExperience (expected bool)
        if "musicianExperience" in props and props["musicianExperience"] is not None:
            if not isinstance(props["musicianExperience"], bool):
                try:
                    # Attempt to convert
                    props["musicianExperience"] = bool(props["musicianExperience"])
                except:
                    raise TypeError(f"Property musicianExperience must be of type bool, got {type(props['musicianExperience']).__name__}")
    
        # Type check genreVersatility (expected float)
        if "genreVersatility" in props and props["genreVersatility"] is not None:
            if not isinstance(props["genreVersatility"], float):
                try:
                    # Attempt to convert
                    props["genreVersatility"] = float(props["genreVersatility"])
                except:
                    raise TypeError(f"Property genreVersatility must be of type float, got {type(props['genreVersatility']).__name__}")
    
        # Type check writerDirectorDuality (expected bool)
        if "writerDirectorDuality" in props and props["writerDirectorDuality"] is not None:
            if not isinstance(props["writerDirectorDuality"], bool):
                try:
                    # Attempt to convert
                    props["writerDirectorDuality"] = bool(props["writerDirectorDuality"])
                except:
                    raise TypeError(f"Property writerDirectorDuality must be of type bool, got {type(props['writerDirectorDuality']).__name__}")
    
        # Type check lighting_style (expected str)
        if "lighting_style" in props and props["lighting_style"] is not None:
            if not isinstance(props["lighting_style"], str):
                try:
                    # Attempt to convert
                    props["lighting_style"] = str(props["lighting_style"])
                except:
                    raise TypeError(f"Property lighting_style must be of type str, got {type(props['lighting_style']).__name__}")
    
        # Type check camera_preference (expected str)
        if "camera_preference" in props and props["camera_preference"] is not None:
            if not isinstance(props["camera_preference"], str):
                try:
                    # Attempt to convert
                    props["camera_preference"] = str(props["camera_preference"])
                except:
                    raise TypeError(f"Property camera_preference must be of type str, got {type(props['camera_preference']).__name__}")
    
        # Type check nickname (expected str)
        if "nickname" in props and props["nickname"] is not None:
            if not isinstance(props["nickname"], str):
                try:
                    # Attempt to convert
                    props["nickname"] = str(props["nickname"])
                except:
                    raise TypeError(f"Property nickname must be of type str, got {type(props['nickname']).__name__}")
    
        # Type check oscarHonoraryAward (expected bool)
        if "oscarHonoraryAward" in props and props["oscarHonoraryAward"] is not None:
            if not isinstance(props["oscarHonoraryAward"], bool):
                try:
                    # Attempt to convert
                    props["oscarHonoraryAward"] = bool(props["oscarHonoraryAward"])
                except:
                    raise TypeError(f"Property oscarHonoraryAward must be of type bool, got {type(props['oscarHonoraryAward']).__name__}")
    
        # Type check writerSkill (expected float)
        if "writerSkill" in props and props["writerSkill"] is not None:
            if not isinstance(props["writerSkill"], float):
                try:
                    # Attempt to convert
                    props["writerSkill"] = float(props["writerSkill"])
                except:
                    raise TypeError(f"Property writerSkill must be of type float, got {type(props['writerSkill']).__name__}")
    
        # Type check adaptationCredits (expected object)
        if "adaptationCredits" in props and props["adaptationCredits"] is not None:
            if not isinstance(props["adaptationCredits"], object):
                try:
                    # Attempt to convert
                    props["adaptationCredits"] = object(props["adaptationCredits"])
                except:
                    raise TypeError(f"Property adaptationCredits must be of type object, got {type(props['adaptationCredits']).__name__}")
    
        # Type check politicalCareer (expected bool)
        if "politicalCareer" in props and props["politicalCareer"] is not None:
            if not isinstance(props["politicalCareer"], bool):
                try:
                    # Attempt to convert
                    props["politicalCareer"] = bool(props["politicalCareer"])
                except:
                    raise TypeError(f"Property politicalCareer must be of type bool, got {type(props['politicalCareer']).__name__}")
    
        # Type check governorYears (expected str)
        if "governorYears" in props and props["governorYears"] is not None:
            if not isinstance(props["governorYears"], str):
                try:
                    # Attempt to convert
                    props["governorYears"] = str(props["governorYears"])
                except:
                    raise TypeError(f"Property governorYears must be of type str, got {type(props['governorYears']).__name__}")
    
        # Type check westernInfluence (expected str)
        if "westernInfluence" in props and props["westernInfluence"] is not None:
            if not isinstance(props["westernInfluence"], str):
                try:
                    # Attempt to convert
                    props["westernInfluence"] = str(props["westernInfluence"])
                except:
                    raise TypeError(f"Property westernInfluence must be of type str, got {type(props['westernInfluence']).__name__}")
    
        # Type check globalInfluence (expected str)
        if "globalInfluence" in props and props["globalInfluence"] is not None:
            if not isinstance(props["globalInfluence"], str):
                try:
                    # Attempt to convert
                    props["globalInfluence"] = str(props["globalInfluence"])
                except:
                    raise TypeError(f"Property globalInfluence must be of type str, got {type(props['globalInfluence']).__name__}")
    
        # Type check paintingBackground (expected bool)
        if "paintingBackground" in props and props["paintingBackground"] is not None:
            if not isinstance(props["paintingBackground"], bool):
                try:
                    # Attempt to convert
                    props["paintingBackground"] = bool(props["paintingBackground"])
                except:
                    raise TypeError(f"Property paintingBackground must be of type bool, got {type(props['paintingBackground']).__name__}")
    
        # Type check actingStyle (expected str)
        if "actingStyle" in props and props["actingStyle"] is not None:
            if not isinstance(props["actingStyle"], str):
                try:
                    # Attempt to convert
                    props["actingStyle"] = str(props["actingStyle"])
                except:
                    raise TypeError(f"Property actingStyle must be of type str, got {type(props['actingStyle']).__name__}")
    
        # Type check collaborationsWithKurosawa (expected int)
        if "collaborationsWithKurosawa" in props and props["collaborationsWithKurosawa"] is not None:
            if not isinstance(props["collaborationsWithKurosawa"], int):
                try:
                    # Attempt to convert
                    props["collaborationsWithKurosawa"] = int(props["collaborationsWithKurosawa"])
                except:
                    raise TypeError(f"Property collaborationsWithKurosawa must be of type int, got {type(props['collaborationsWithKurosawa']).__name__}")
    
        # Type check actingInfluence (expected str)
        if "actingInfluence" in props and props["actingInfluence"] is not None:
            if not isinstance(props["actingInfluence"], str):
                try:
                    # Attempt to convert
                    props["actingInfluence"] = str(props["actingInfluence"])
                except:
                    raise TypeError(f"Property actingInfluence must be of type str, got {type(props['actingInfluence']).__name__}")
    
        # Type check methodActingPioneer (expected bool)
        if "methodActingPioneer" in props and props["methodActingPioneer"] is not None:
            if not isinstance(props["methodActingPioneer"], bool):
                try:
                    # Attempt to convert
                    props["methodActingPioneer"] = bool(props["methodActingPioneer"])
                except:
                    raise TypeError(f"Property methodActingPioneer must be of type bool, got {type(props['methodActingPioneer']).__name__}")
    
        # Type check athleticBackground (expected bool)
        if "athleticBackground" in props and props["athleticBackground"] is not None:
            if not isinstance(props["athleticBackground"], bool):
                try:
                    # Attempt to convert
                    props["athleticBackground"] = bool(props["athleticBackground"])
                except:
                    raise TypeError(f"Property athleticBackground must be of type bool, got {type(props['athleticBackground']).__name__}")
    
        # Type check sportsPassions (expected object)
        if "sportsPassions" in props and props["sportsPassions"] is not None:
            if not isinstance(props["sportsPassions"], object):
                try:
                    # Attempt to convert
                    props["sportsPassions"] = object(props["sportsPassions"])
                except:
                    raise TypeError(f"Property sportsPassions must be of type object, got {type(props['sportsPassions']).__name__}")
    
        # Type check directorCredits (expected int)
        if "directorCredits" in props and props["directorCredits"] is not None:
            if not isinstance(props["directorCredits"], int):
                try:
                    # Attempt to convert
                    props["directorCredits"] = int(props["directorCredits"])
                except:
                    raise TypeError(f"Property directorCredits must be of type int, got {type(props['directorCredits']).__name__}")
    
        # Type check militaryService (expected str)
        if "militaryService" in props and props["militaryService"] is not None:
            if not isinstance(props["militaryService"], str):
                try:
                    # Attempt to convert
                    props["militaryService"] = str(props["militaryService"])
                except:
                    raise TypeError(f"Property militaryService must be of type str, got {type(props['militaryService']).__name__}")
    
        # Type check photographyExhibits (expected int)
        if "photographyExhibits" in props and props["photographyExhibits"] is not None:
            if not isinstance(props["photographyExhibits"], int):
                try:
                    # Attempt to convert
                    props["photographyExhibits"] = int(props["photographyExhibits"])
                except:
                    raise TypeError(f"Property photographyExhibits must be of type int, got {type(props['photographyExhibits']).__name__}")
    
        # Type check bookAuthor (expected bool)
        if "bookAuthor" in props and props["bookAuthor"] is not None:
            if not isinstance(props["bookAuthor"], bool):
                try:
                    # Attempt to convert
                    props["bookAuthor"] = bool(props["bookAuthor"])
                except:
                    raise TypeError(f"Property bookAuthor must be of type bool, got {type(props['bookAuthor']).__name__}")
    
        # Type check book_years (expected object)
        if "book_years" in props and props["book_years"] is not None:
            if not isinstance(props["book_years"], object):
                try:
                    # Attempt to convert
                    props["book_years"] = object(props["book_years"])
                except:
                    raise TypeError(f"Property book_years must be of type object, got {type(props['book_years']).__name__}")
    
        # Type check screenplay_credits (expected object)
        if "screenplay_credits" in props and props["screenplay_credits"] is not None:
            if not isinstance(props["screenplay_credits"], object):
                try:
                    # Attempt to convert
                    props["screenplay_credits"] = object(props["screenplay_credits"])
                except:
                    raise TypeError(f"Property screenplay_credits must be of type object, got {type(props['screenplay_credits']).__name__}")
    
        # Type check mafia_knowledge (expected str)
        if "mafia_knowledge" in props and props["mafia_knowledge"] is not None:
            if not isinstance(props["mafia_knowledge"], str):
                try:
                    # Attempt to convert
                    props["mafia_knowledge"] = str(props["mafia_knowledge"])
                except:
                    raise TypeError(f"Property mafia_knowledge must be of type str, got {type(props['mafia_knowledge']).__name__}")
    
        # Type check firstNovel (expected object)
        if "firstNovel" in props and props["firstNovel"] is not None:
            if not isinstance(props["firstNovel"], object):
                try:
                    # Attempt to convert
                    props["firstNovel"] = object(props["firstNovel"])
                except:
                    raise TypeError(f"Property firstNovel must be of type object, got {type(props['firstNovel']).__name__}")
    
        # Type check book_titles (expected object)
        if "book_titles" in props and props["book_titles"] is not None:
            if not isinstance(props["book_titles"], object):
                try:
                    # Attempt to convert
                    props["book_titles"] = object(props["book_titles"])
                except:
                    raise TypeError(f"Property book_titles must be of type object, got {type(props['book_titles']).__name__}")
    
        # Type check lastNovel (expected object)
        if "lastNovel" in props and props["lastNovel"] is not None:
            if not isinstance(props["lastNovel"], object):
                try:
                    # Attempt to convert
                    props["lastNovel"] = object(props["lastNovel"])
                except:
                    raise TypeError(f"Property lastNovel must be of type object, got {type(props['lastNovel']).__name__}")
    
        # Type check novelistFirst (expected bool)
        if "novelistFirst" in props and props["novelistFirst"] is not None:
            if not isinstance(props["novelistFirst"], bool):
                try:
                    # Attempt to convert
                    props["novelistFirst"] = bool(props["novelistFirst"])
                except:
                    raise TypeError(f"Property novelistFirst must be of type bool, got {type(props['novelistFirst']).__name__}")
    
        # Type check composition_style (expected str)
        if "composition_style" in props and props["composition_style"] is not None:
            if not isinstance(props["composition_style"], str):
                try:
                    # Attempt to convert
                    props["composition_style"] = str(props["composition_style"])
                except:
                    raise TypeError(f"Property composition_style must be of type str, got {type(props['composition_style']).__name__}")
    
        # Type check musical_education (expected str)
        if "musical_education" in props and props["musical_education"] is not None:
            if not isinstance(props["musical_education"], str):
                try:
                    # Attempt to convert
                    props["musical_education"] = str(props["musical_education"])
                except:
                    raise TypeError(f"Property musical_education must be of type str, got {type(props['musical_education']).__name__}")
    
        # Type check compositionsCount (expected int)
        if "compositionsCount" in props and props["compositionsCount"] is not None:
            if not isinstance(props["compositionsCount"], int):
                try:
                    # Attempt to convert
                    props["compositionsCount"] = int(props["compositionsCount"])
                except:
                    raise TypeError(f"Property compositionsCount must be of type int, got {type(props['compositionsCount']).__name__}")
    
        # Type check collaboration_directors (expected object)
        if "collaboration_directors" in props and props["collaboration_directors"] is not None:
            if not isinstance(props["collaboration_directors"], object):
                try:
                    # Attempt to convert
                    props["collaboration_directors"] = object(props["collaboration_directors"])
                except:
                    raise TypeError(f"Property collaboration_directors must be of type object, got {type(props['collaboration_directors']).__name__}")
    
        # Type check collaboration_years (expected object)
        if "collaboration_years" in props and props["collaboration_years"] is not None:
            if not isinstance(props["collaboration_years"], object):
                try:
                    # Attempt to convert
                    props["collaboration_years"] = object(props["collaboration_years"])
                except:
                    raise TypeError(f"Property collaboration_years must be of type object, got {type(props['collaboration_years']).__name__}")
    
        # Type check research_methodology (expected str)
        if "research_methodology" in props and props["research_methodology"] is not None:
            if not isinstance(props["research_methodology"], str):
                try:
                    # Attempt to convert
                    props["research_methodology"] = str(props["research_methodology"])
                except:
                    raise TypeError(f"Property research_methodology must be of type str, got {type(props['research_methodology']).__name__}")
    
        # Type check designPhilosophy (expected str)
        if "designPhilosophy" in props and props["designPhilosophy"] is not None:
            if not isinstance(props["designPhilosophy"], str):
                try:
                    # Attempt to convert
                    props["designPhilosophy"] = str(props["designPhilosophy"])
                except:
                    raise TypeError(f"Property designPhilosophy must be of type str, got {type(props['designPhilosophy']).__name__}")
    
        # Type check design_specialties (expected object)
        if "design_specialties" in props and props["design_specialties"] is not None:
            if not isinstance(props["design_specialties"], object):
                try:
                    # Attempt to convert
                    props["design_specialties"] = object(props["design_specialties"])
                except:
                    raise TypeError(f"Property design_specialties must be of type object, got {type(props['design_specialties']).__name__}")
    
        # Type check family_origin (expected str)
        if "family_origin" in props and props["family_origin"] is not None:
            if not isinstance(props["family_origin"], str):
                try:
                    # Attempt to convert
                    props["family_origin"] = str(props["family_origin"])
                except:
                    raise TypeError(f"Property family_origin must be of type str, got {type(props['family_origin']).__name__}")
    
        # Type check public_titles (expected object)
        if "public_titles" in props and props["public_titles"] is not None:
            if not isinstance(props["public_titles"], object):
                try:
                    # Attempt to convert
                    props["public_titles"] = object(props["public_titles"])
                except:
                    raise TypeError(f"Property public_titles must be of type object, got {type(props['public_titles']).__name__}")
    
        # Type check activities (expected object)
        if "activities" in props and props["activities"] is not None:
            if not isinstance(props["activities"], object):
                try:
                    # Attempt to convert
                    props["activities"] = object(props["activities"])
                except:
                    raise TypeError(f"Property activities must be of type object, got {type(props['activities']).__name__}")
    
        # Type check livedInSicily (expected bool)
        if "livedInSicily" in props and props["livedInSicily"] is not None:
            if not isinstance(props["livedInSicily"], bool):
                try:
                    # Attempt to convert
                    props["livedInSicily"] = bool(props["livedInSicily"])
                except:
                    raise TypeError(f"Property livedInSicily must be of type bool, got {type(props['livedInSicily']).__name__}")
    
        # Type check lastPublicAppearance (expected object)
        if "lastPublicAppearance" in props and props["lastPublicAppearance"] is not None:
            if not isinstance(props["lastPublicAppearance"], object):
                try:
                    # Attempt to convert
                    props["lastPublicAppearance"] = object(props["lastPublicAppearance"])
                except:
                    raise TypeError(f"Property lastPublicAppearance must be of type object, got {type(props['lastPublicAppearance']).__name__}")
    
        # Type check firstPublicAppearance (expected object)
        if "firstPublicAppearance" in props and props["firstPublicAppearance"] is not None:
            if not isinstance(props["firstPublicAppearance"], object):
                try:
                    # Attempt to convert
                    props["firstPublicAppearance"] = object(props["firstPublicAppearance"])
                except:
                    raise TypeError(f"Property firstPublicAppearance must be of type object, got {type(props['firstPublicAppearance']).__name__}")
    
        # Type check memoirAuthor (expected bool)
        if "memoirAuthor" in props and props["memoirAuthor"] is not None:
            if not isinstance(props["memoirAuthor"], bool):
                try:
                    # Attempt to convert
                    props["memoirAuthor"] = bool(props["memoirAuthor"])
                except:
                    raise TypeError(f"Property memoirAuthor must be of type bool, got {type(props['memoirAuthor']).__name__}")
    
        # Type check writing_style (expected str)
        if "writing_style" in props and props["writing_style"] is not None:
            if not isinstance(props["writing_style"], str):
                try:
                    # Attempt to convert
                    props["writing_style"] = str(props["writing_style"])
                except:
                    raise TypeError(f"Property writing_style must be of type str, got {type(props['writing_style']).__name__}")
    
        # Type check lastReview (expected object)
        if "lastReview" in props and props["lastReview"] is not None:
            if not isinstance(props["lastReview"], object):
                try:
                    # Attempt to convert
                    props["lastReview"] = object(props["lastReview"])
                except:
                    raise TypeError(f"Property lastReview must be of type object, got {type(props['lastReview']).__name__}")
    
        # Type check critical_philosophy (expected str)
        if "critical_philosophy" in props and props["critical_philosophy"] is not None:
            if not isinstance(props["critical_philosophy"], str):
                try:
                    # Attempt to convert
                    props["critical_philosophy"] = str(props["critical_philosophy"])
                except:
                    raise TypeError(f"Property critical_philosophy must be of type str, got {type(props['critical_philosophy']).__name__}")
    
        # Type check criticalApproach (expected str)
        if "criticalApproach" in props and props["criticalApproach"] is not None:
            if not isinstance(props["criticalApproach"], str):
                try:
                    # Attempt to convert
                    props["criticalApproach"] = str(props["criticalApproach"])
                except:
                    raise TypeError(f"Property criticalApproach must be of type str, got {type(props['criticalApproach']).__name__}")
    
        # Type check books (expected object)
        if "books" in props and props["books"] is not None:
            if not isinstance(props["books"], object):
                try:
                    # Attempt to convert
                    props["books"] = object(props["books"])
                except:
                    raise TypeError(f"Property books must be of type object, got {type(props['books']).__name__}")
    
        # Type check firstReview (expected object)
        if "firstReview" in props and props["firstReview"] is not None:
            if not isinstance(props["firstReview"], object):
                try:
                    # Attempt to convert
                    props["firstReview"] = object(props["firstReview"])
                except:
                    raise TypeError(f"Property firstReview must be of type object, got {type(props['firstReview']).__name__}")
    
        # Type check oscarInfluence (expected str)
        if "oscarInfluence" in props and props["oscarInfluence"] is not None:
            if not isinstance(props["oscarInfluence"], str):
                try:
                    # Attempt to convert
                    props["oscarInfluence"] = str(props["oscarInfluence"])
                except:
                    raise TypeError(f"Property oscarInfluence must be of type str, got {type(props['oscarInfluence']).__name__}")
    
        # Type check reviewCount (expected int)
        if "reviewCount" in props and props["reviewCount"] is not None:
            if not isinstance(props["reviewCount"], int):
                try:
                    # Attempt to convert
                    props["reviewCount"] = int(props["reviewCount"])
                except:
                    raise TypeError(f"Property reviewCount must be of type int, got {type(props['reviewCount']).__name__}")
    
        # Type check publications (expected object)
        if "publications" in props and props["publications"] is not None:
            if not isinstance(props["publications"], object):
                try:
                    # Attempt to convert
                    props["publications"] = object(props["publications"])
                except:
                    raise TypeError(f"Property publications must be of type object, got {type(props['publications']).__name__}")
    
        # Type check working_style (expected str)
        if "working_style" in props and props["working_style"] is not None:
            if not isinstance(props["working_style"], str):
                try:
                    # Attempt to convert
                    props["working_style"] = str(props["working_style"])
                except:
                    raise TypeError(f"Property working_style must be of type str, got {type(props['working_style']).__name__}")
    
        # Type check technical_expertise (expected str)
        if "technical_expertise" in props and props["technical_expertise"] is not None:
            if not isinstance(props["technical_expertise"], str):
                try:
                    # Attempt to convert
                    props["technical_expertise"] = str(props["technical_expertise"])
                except:
                    raise TypeError(f"Property technical_expertise must be of type str, got {type(props['technical_expertise']).__name__}")
    
        # Type check editingStyle (expected str)
        if "editingStyle" in props and props["editingStyle"] is not None:
            if not isinstance(props["editingStyle"], str):
                try:
                    # Attempt to convert
                    props["editingStyle"] = str(props["editingStyle"])
                except:
                    raise TypeError(f"Property editingStyle must be of type str, got {type(props['editingStyle']).__name__}")
    
        # Type check dialect_expertise (expected object)
        if "dialect_expertise" in props and props["dialect_expertise"] is not None:
            if not isinstance(props["dialect_expertise"], object):
                try:
                    # Attempt to convert
                    props["dialect_expertise"] = object(props["dialect_expertise"])
                except:
                    raise TypeError(f"Property dialect_expertise must be of type object, got {type(props['dialect_expertise']).__name__}")
    
        # Type check teaching_methodology (expected str)
        if "teaching_methodology" in props and props["teaching_methodology"] is not None:
            if not isinstance(props["teaching_methodology"], str):
                try:
                    # Attempt to convert
                    props["teaching_methodology"] = str(props["teaching_methodology"])
                except:
                    raise TypeError(f"Property teaching_methodology must be of type str, got {type(props['teaching_methodology']).__name__}")
    
        # Type check film_appearances (expected object)
        if "film_appearances" in props and props["film_appearances"] is not None:
            if not isinstance(props["film_appearances"], object):
                try:
                    # Attempt to convert
                    props["film_appearances"] = object(props["film_appearances"])
                except:
                    raise TypeError(f"Property film_appearances must be of type object, got {type(props['film_appearances']).__name__}")
    
        # Type check appearance_years (expected object)
        if "appearance_years" in props and props["appearance_years"] is not None:
            if not isinstance(props["appearance_years"], object):
                try:
                    # Attempt to convert
                    props["appearance_years"] = object(props["appearance_years"])
                except:
                    raise TypeError(f"Property appearance_years must be of type object, got {type(props['appearance_years']).__name__}")
    
        # Type check sicilianNative (expected bool)
        if "sicilianNative" in props and props["sicilianNative"] is not None:
            if not isinstance(props["sicilianNative"], bool):
                try:
                    # Attempt to convert
                    props["sicilianNative"] = bool(props["sicilianNative"])
                except:
                    raise TypeError(f"Property sicilianNative must be of type bool, got {type(props['sicilianNative']).__name__}")
    
        # Type check dialectsKnown (expected int)
        if "dialectsKnown" in props and props["dialectsKnown"] is not None:
            if not isinstance(props["dialectsKnown"], int):
                try:
                    # Attempt to convert
                    props["dialectsKnown"] = int(props["dialectsKnown"])
                except:
                    raise TypeError(f"Property dialectsKnown must be of type int, got {type(props['dialectsKnown']).__name__}")
    
        # Type check actingCredits (expected int)
        if "actingCredits" in props and props["actingCredits"] is not None:
            if not isinstance(props["actingCredits"], int):
                try:
                    # Attempt to convert
                    props["actingCredits"] = int(props["actingCredits"])
                except:
                    raise TypeError(f"Property actingCredits must be of type int, got {type(props['actingCredits']).__name__}")
    
        # Type check negotiation_style (expected str)
        if "negotiation_style" in props and props["negotiation_style"] is not None:
            if not isinstance(props["negotiation_style"], str):
                try:
                    # Attempt to convert
                    props["negotiation_style"] = str(props["negotiation_style"])
                except:
                    raise TypeError(f"Property negotiation_style must be of type str, got {type(props['negotiation_style']).__name__}")
    
        # Type check production_titles (expected object)
        if "production_titles" in props and props["production_titles"] is not None:
            if not isinstance(props["production_titles"], object):
                try:
                    # Attempt to convert
                    props["production_titles"] = object(props["production_titles"])
                except:
                    raise TypeError(f"Property production_titles must be of type object, got {type(props['production_titles']).__name__}")
    
        # Type check production_years (expected object)
        if "production_years" in props and props["production_years"] is not None:
            if not isinstance(props["production_years"], object):
                try:
                    # Attempt to convert
                    props["production_years"] = object(props["production_years"])
                except:
                    raise TypeError(f"Property production_years must be of type object, got {type(props['production_years']).__name__}")
    
        # Type check education (expected str)
        if "education" in props and props["education"] is not None:
            if not isinstance(props["education"], str):
                try:
                    # Attempt to convert
                    props["education"] = str(props["education"])
                except:
                    raise TypeError(f"Property education must be of type str, got {type(props['education']).__name__}")
    
        # Type check businessBackground (expected str)
        if "businessBackground" in props and props["businessBackground"] is not None:
            if not isinstance(props["businessBackground"], str):
                try:
                    # Attempt to convert
                    props["businessBackground"] = str(props["businessBackground"])
                except:
                    raise TypeError(f"Property businessBackground must be of type str, got {type(props['businessBackground']).__name__}")
    
        # Type check firstProduction (expected object)
        if "firstProduction" in props and props["firstProduction"] is not None:
            if not isinstance(props["firstProduction"], object):
                try:
                    # Attempt to convert
                    props["firstProduction"] = object(props["firstProduction"])
                except:
                    raise TypeError(f"Property firstProduction must be of type object, got {type(props['firstProduction']).__name__}")
    
        # Type check business_background (expected str)
        if "business_background" in props and props["business_background"] is not None:
            if not isinstance(props["business_background"], str):
                try:
                    # Attempt to convert
                    props["business_background"] = str(props["business_background"])
                except:
                    raise TypeError(f"Property business_background must be of type str, got {type(props['business_background']).__name__}")
    
        # Type check lastProduction (expected object)
        if "lastProduction" in props and props["lastProduction"] is not None:
            if not isinstance(props["lastProduction"], object):
                try:
                    # Attempt to convert
                    props["lastProduction"] = object(props["lastProduction"])
                except:
                    raise TypeError(f"Property lastProduction must be of type object, got {type(props['lastProduction']).__name__}")
    
        # Type check key_productions (expected object)
        if "key_productions" in props and props["key_productions"] is not None:
            if not isinstance(props["key_productions"], object):
                try:
                    # Attempt to convert
                    props["key_productions"] = object(props["key_productions"])
                except:
                    raise TypeError(f"Property key_productions must be of type object, got {type(props['key_productions']).__name__}")
    
        # Type check studioExecutive (expected bool)
        if "studioExecutive" in props and props["studioExecutive"] is not None:
            if not isinstance(props["studioExecutive"], bool):
                try:
                    # Attempt to convert
                    props["studioExecutive"] = bool(props["studioExecutive"])
                except:
                    raise TypeError(f"Property studioExecutive must be of type bool, got {type(props['studioExecutive']).__name__}")
    
        # Type check studio_role (expected str)
        if "studio_role" in props and props["studio_role"] is not None:
            if not isinstance(props["studio_role"], str):
                try:
                    # Attempt to convert
                    props["studio_role"] = str(props["studio_role"])
                except:
                    raise TypeError(f"Property studio_role must be of type str, got {type(props['studio_role']).__name__}")
    
        # Type check acquisition_strategy (expected str)
        if "acquisition_strategy" in props and props["acquisition_strategy"] is not None:
            if not isinstance(props["acquisition_strategy"], str):
                try:
                    # Attempt to convert
                    props["acquisition_strategy"] = str(props["acquisition_strategy"])
                except:
                    raise TypeError(f"Property acquisition_strategy must be of type str, got {type(props['acquisition_strategy']).__name__}")
    
        # Type check business_entities (expected object)
        if "business_entities" in props and props["business_entities"] is not None:
            if not isinstance(props["business_entities"], object):
                try:
                    # Attempt to convert
                    props["business_entities"] = object(props["business_entities"])
                except:
                    raise TypeError(f"Property business_entities must be of type object, got {type(props['business_entities']).__name__}")
    
        # Type check leadership_years (expected object)
        if "leadership_years" in props and props["leadership_years"] is not None:
            if not isinstance(props["leadership_years"], object):
                try:
                    # Attempt to convert
                    props["leadership_years"] = object(props["leadership_years"])
                except:
                    raise TypeError(f"Property leadership_years must be of type object, got {type(props['leadership_years']).__name__}")
    
        # Type check business_titles (expected object)
        if "business_titles" in props and props["business_titles"] is not None:
            if not isinstance(props["business_titles"], object):
                try:
                    # Attempt to convert
                    props["business_titles"] = object(props["business_titles"])
                except:
                    raise TypeError(f"Property business_titles must be of type object, got {type(props['business_titles']).__name__}")
    
        # Type check corporateRole (expected str)
        if "corporateRole" in props and props["corporateRole"] is not None:
            if not isinstance(props["corporateRole"], str):
                try:
                    # Attempt to convert
                    props["corporateRole"] = str(props["corporateRole"])
                except:
                    raise TypeError(f"Property corporateRole must be of type str, got {type(props['corporateRole']).__name__}")
    
        # Type check firstPosition (expected object)
        if "firstPosition" in props and props["firstPosition"] is not None:
            if not isinstance(props["firstPosition"], object):
                try:
                    # Attempt to convert
                    props["firstPosition"] = object(props["firstPosition"])
                except:
                    raise TypeError(f"Property firstPosition must be of type object, got {type(props['firstPosition']).__name__}")
    
        # Type check tradePublicationLeadership (expected bool)
        if "tradePublicationLeadership" in props and props["tradePublicationLeadership"] is not None:
            if not isinstance(props["tradePublicationLeadership"], bool):
                try:
                    # Attempt to convert
                    props["tradePublicationLeadership"] = bool(props["tradePublicationLeadership"])
                except:
                    raise TypeError(f"Property tradePublicationLeadership must be of type bool, got {type(props['tradePublicationLeadership']).__name__}")
    
        # Type check executiveRole (expected str)
        if "executiveRole" in props and props["executiveRole"] is not None:
            if not isinstance(props["executiveRole"], str):
                try:
                    # Attempt to convert
                    props["executiveRole"] = str(props["executiveRole"])
                except:
                    raise TypeError(f"Property executiveRole must be of type str, got {type(props['executiveRole']).__name__}")
    
        # Type check journalismBackground (expected bool)
        if "journalismBackground" in props and props["journalismBackground"] is not None:
            if not isinstance(props["journalismBackground"], bool):
                try:
                    # Attempt to convert
                    props["journalismBackground"] = bool(props["journalismBackground"])
                except:
                    raise TypeError(f"Property journalismBackground must be of type bool, got {type(props['journalismBackground']).__name__}")
    
        # Type check development_years (expected object)
        if "development_years" in props and props["development_years"] is not None:
            if not isinstance(props["development_years"], object):
                try:
                    # Attempt to convert
                    props["development_years"] = object(props["development_years"])
                except:
                    raise TypeError(f"Property development_years must be of type object, got {type(props['development_years']).__name__}")
    
        # Type check career_positions (expected object)
        if "career_positions" in props and props["career_positions"] is not None:
            if not isinstance(props["career_positions"], object):
                try:
                    # Attempt to convert
                    props["career_positions"] = object(props["career_positions"])
                except:
                    raise TypeError(f"Property career_positions must be of type object, got {type(props['career_positions']).__name__}")
    
        # Type check position_years (expected object)
        if "position_years" in props and props["position_years"] is not None:
            if not isinstance(props["position_years"], object):
                try:
                    # Attempt to convert
                    props["position_years"] = object(props["position_years"])
                except:
                    raise TypeError(f"Property position_years must be of type object, got {type(props['position_years']).__name__}")
    
        # Type check key_developments (expected object)
        if "key_developments" in props and props["key_developments"] is not None:
            if not isinstance(props["key_developments"], object):
                try:
                    # Attempt to convert
                    props["key_developments"] = object(props["key_developments"])
                except:
                    raise TypeError(f"Property key_developments must be of type object, got {type(props['key_developments']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Person", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def category(uuid=None, **props):
        """
        Find nodes with label Category matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.node(label="Category", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def product(uuid=None, **props):
        """
        Find nodes with label Product matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.node(label="Product", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def supplier(uuid=None, **props):
        """
        Find nodes with label Supplier matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.node(label="Supplier", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def customer(uuid=None, **props):
        """
        Find nodes with label Customer matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.node(label="Customer", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def order(uuid=None, **props):
        """
        Find nodes with label Order matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.node(label="Order", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def ceremony(uuid=None, **props):
        """
        Find nodes with label Ceremony matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check established (expected object)
        if "established" in props and props["established"] is not None:
            if not isinstance(props["established"], object):
                try:
                    # Attempt to convert
                    props["established"] = object(props["established"])
                except:
                    raise TypeError(f"Property established must be of type object, got {type(props['established']).__name__}")
    
        # Type check locationLat (expected float)
        if "locationLat" in props and props["locationLat"] is not None:
            if not isinstance(props["locationLat"], float):
                try:
                    # Attempt to convert
                    props["locationLat"] = float(props["locationLat"])
                except:
                    raise TypeError(f"Property locationLat must be of type float, got {type(props['locationLat']).__name__}")
    
        # Type check viewership2022 (expected int)
        if "viewership2022" in props and props["viewership2022"] is not None:
            if not isinstance(props["viewership2022"], int):
                try:
                    # Attempt to convert
                    props["viewership2022"] = int(props["viewership2022"])
                except:
                    raise TypeError(f"Property viewership2022 must be of type int, got {type(props['viewership2022']).__name__}")
    
        # Type check viewership2023 (expected int)
        if "viewership2023" in props and props["viewership2023"] is not None:
            if not isinstance(props["viewership2023"], int):
                try:
                    # Attempt to convert
                    props["viewership2023"] = int(props["viewership2023"])
                except:
                    raise TypeError(f"Property viewership2023 must be of type int, got {type(props['viewership2023']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check typicalDurationHrs (expected float)
        if "typicalDurationHrs" in props and props["typicalDurationHrs"] is not None:
            if not isinstance(props["typicalDurationHrs"], float):
                try:
                    # Attempt to convert
                    props["typicalDurationHrs"] = float(props["typicalDurationHrs"])
                except:
                    raise TypeError(f"Property typicalDurationHrs must be of type float, got {type(props['typicalDurationHrs']).__name__}")
    
        # Type check viewership2020 (expected int)
        if "viewership2020" in props and props["viewership2020"] is not None:
            if not isinstance(props["viewership2020"], int):
                try:
                    # Attempt to convert
                    props["viewership2020"] = int(props["viewership2020"])
                except:
                    raise TypeError(f"Property viewership2020 must be of type int, got {type(props['viewership2020']).__name__}")
    
        # Type check viewership2021 (expected int)
        if "viewership2021" in props and props["viewership2021"] is not None:
            if not isinstance(props["viewership2021"], int):
                try:
                    # Attempt to convert
                    props["viewership2021"] = int(props["viewership2021"])
                except:
                    raise TypeError(f"Property viewership2021 must be of type int, got {type(props['viewership2021']).__name__}")
    
        # Type check nickname (expected str)
        if "nickname" in props and props["nickname"] is not None:
            if not isinstance(props["nickname"], str):
                try:
                    # Attempt to convert
                    props["nickname"] = str(props["nickname"])
                except:
                    raise TypeError(f"Property nickname must be of type str, got {type(props['nickname']).__name__}")
    
        # Type check locationHeight (expected int)
        if "locationHeight" in props and props["locationHeight"] is not None:
            if not isinstance(props["locationHeight"], int):
                try:
                    # Attempt to convert
                    props["locationHeight"] = int(props["locationHeight"])
                except:
                    raise TypeError(f"Property locationHeight must be of type int, got {type(props['locationHeight']).__name__}")
    
        # Type check categories (expected object)
        if "categories" in props and props["categories"] is not None:
            if not isinstance(props["categories"], object):
                try:
                    # Attempt to convert
                    props["categories"] = object(props["categories"])
                except:
                    raise TypeError(f"Property categories must be of type object, got {type(props['categories']).__name__}")
    
        # Type check isPrestigious (expected bool)
        if "isPrestigious" in props and props["isPrestigious"] is not None:
            if not isinstance(props["isPrestigious"], bool):
                try:
                    # Attempt to convert
                    props["isPrestigious"] = bool(props["isPrestigious"])
                except:
                    raise TypeError(f"Property isPrestigious must be of type bool, got {type(props['isPrestigious']).__name__}")
    
        # Type check nextCeremony (expected object)
        if "nextCeremony" in props and props["nextCeremony"] is not None:
            if not isinstance(props["nextCeremony"], object):
                try:
                    # Attempt to convert
                    props["nextCeremony"] = object(props["nextCeremony"])
                except:
                    raise TypeError(f"Property nextCeremony must be of type object, got {type(props['nextCeremony']).__name__}")
    
        # Type check locationLong (expected float)
        if "locationLong" in props and props["locationLong"] is not None:
            if not isinstance(props["locationLong"], float):
                try:
                    # Attempt to convert
                    props["locationLong"] = float(props["locationLong"])
                except:
                    raise TypeError(f"Property locationLong must be of type float, got {type(props['locationLong']).__name__}")
    
        # Type check ceremonyTime (expected object)
        if "ceremonyTime" in props and props["ceremonyTime"] is not None:
            if not isinstance(props["ceremonyTime"], object):
                try:
                    # Attempt to convert
                    props["ceremonyTime"] = object(props["ceremonyTime"])
                except:
                    raise TypeError(f"Property ceremonyTime must be of type object, got {type(props['ceremonyTime']).__name__}")
    
        # Type check attendance2022 (expected int)
        if "attendance2022" in props and props["attendance2022"] is not None:
            if not isinstance(props["attendance2022"], int):
                try:
                    # Attempt to convert
                    props["attendance2022"] = int(props["attendance2022"])
                except:
                    raise TypeError(f"Property attendance2022 must be of type int, got {type(props['attendance2022']).__name__}")
    
        # Type check attendance2023 (expected int)
        if "attendance2023" in props and props["attendance2023"] is not None:
            if not isinstance(props["attendance2023"], int):
                try:
                    # Attempt to convert
                    props["attendance2023"] = int(props["attendance2023"])
                except:
                    raise TypeError(f"Property attendance2023 must be of type int, got {type(props['attendance2023']).__name__}")
    
        # Type check typicalDurationDays (expected int)
        if "typicalDurationDays" in props and props["typicalDurationDays"] is not None:
            if not isinstance(props["typicalDurationDays"], int):
                try:
                    # Attempt to convert
                    props["typicalDurationDays"] = int(props["typicalDurationDays"])
                except:
                    raise TypeError(f"Property typicalDurationDays must be of type int, got {type(props['typicalDurationDays']).__name__}")
    
        # Type check attendance2019 (expected int)
        if "attendance2019" in props and props["attendance2019"] is not None:
            if not isinstance(props["attendance2019"], int):
                try:
                    # Attempt to convert
                    props["attendance2019"] = int(props["attendance2019"])
                except:
                    raise TypeError(f"Property attendance2019 must be of type int, got {type(props['attendance2019']).__name__}")
    
        # Type check attendance2021 (expected int)
        if "attendance2021" in props and props["attendance2021"] is not None:
            if not isinstance(props["attendance2021"], int):
                try:
                    # Attempt to convert
                    props["attendance2021"] = int(props["attendance2021"])
                except:
                    raise TypeError(f"Property attendance2021 must be of type int, got {type(props['attendance2021']).__name__}")
    
        # Type check attendance2020 (expected int)
        if "attendance2020" in props and props["attendance2020"] is not None:
            if not isinstance(props["attendance2020"], int):
                try:
                    # Attempt to convert
                    props["attendance2020"] = int(props["attendance2020"])
                except:
                    raise TypeError(f"Property attendance2020 must be of type int, got {type(props['attendance2020']).__name__}")
    
        # Type check historicalWinners (expected object)
        if "historicalWinners" in props and props["historicalWinners"] is not None:
            if not isinstance(props["historicalWinners"], object):
                try:
                    # Attempt to convert
                    props["historicalWinners"] = object(props["historicalWinners"])
                except:
                    raise TypeError(f"Property historicalWinners must be of type object, got {type(props['historicalWinners']).__name__}")
    
        # Type check historicalYears (expected object)
        if "historicalYears" in props and props["historicalYears"] is not None:
            if not isinstance(props["historicalYears"], object):
                try:
                    # Attempt to convert
                    props["historicalYears"] = object(props["historicalYears"])
                except:
                    raise TypeError(f"Property historicalYears must be of type object, got {type(props['historicalYears']).__name__}")
    
        # Type check historicalSignificance (expected str)
        if "historicalSignificance" in props and props["historicalSignificance"] is not None:
            if not isinstance(props["historicalSignificance"], str):
                try:
                    # Attempt to convert
                    props["historicalSignificance"] = str(props["historicalSignificance"])
                except:
                    raise TypeError(f"Property historicalSignificance must be of type str, got {type(props['historicalSignificance']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Ceremony", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def studio(uuid=None, **props):
        """
        Find nodes with label Studio matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check studioLotsLong (expected object)
        if "studioLotsLong" in props and props["studioLotsLong"] is not None:
            if not isinstance(props["studioLotsLong"], object):
                try:
                    # Attempt to convert
                    props["studioLotsLong"] = object(props["studioLotsLong"])
                except:
                    raise TypeError(f"Property studioLotsLong must be of type object, got {type(props['studioLotsLong']).__name__}")
    
        # Type check studioLotsLat (expected object)
        if "studioLotsLat" in props and props["studioLotsLat"] is not None:
            if not isinstance(props["studioLotsLat"], object):
                try:
                    # Attempt to convert
                    props["studioLotsLat"] = object(props["studioLotsLat"])
                except:
                    raise TypeError(f"Property studioLotsLat must be of type object, got {type(props['studioLotsLat']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check distributionMarkets (expected object)
        if "distributionMarkets" in props and props["distributionMarkets"] is not None:
            if not isinstance(props["distributionMarkets"], object):
                try:
                    # Attempt to convert
                    props["distributionMarkets"] = object(props["distributionMarkets"])
                except:
                    raise TypeError(f"Property distributionMarkets must be of type object, got {type(props['distributionMarkets']).__name__}")
    
        # Type check founded (expected object)
        if "founded" in props and props["founded"] is not None:
            if not isinstance(props["founded"], object):
                try:
                    # Attempt to convert
                    props["founded"] = object(props["founded"])
                except:
                    raise TypeError(f"Property founded must be of type object, got {type(props['founded']).__name__}")
    
        # Type check yearlyRevenue2020 (expected int)
        if "yearlyRevenue2020" in props and props["yearlyRevenue2020"] is not None:
            if not isinstance(props["yearlyRevenue2020"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue2020"] = int(props["yearlyRevenue2020"])
                except:
                    raise TypeError(f"Property yearlyRevenue2020 must be of type int, got {type(props['yearlyRevenue2020']).__name__}")
    
        # Type check subsidiaries (expected object)
        if "subsidiaries" in props and props["subsidiaries"] is not None:
            if not isinstance(props["subsidiaries"], object):
                try:
                    # Attempt to convert
                    props["subsidiaries"] = object(props["subsidiaries"])
                except:
                    raise TypeError(f"Property subsidiaries must be of type object, got {type(props['subsidiaries']).__name__}")
    
        # Type check digitalStreamingDate (expected object)
        if "digitalStreamingDate" in props and props["digitalStreamingDate"] is not None:
            if not isinstance(props["digitalStreamingDate"], object):
                try:
                    # Attempt to convert
                    props["digitalStreamingDate"] = object(props["digitalStreamingDate"])
                except:
                    raise TypeError(f"Property digitalStreamingDate must be of type object, got {type(props['digitalStreamingDate']).__name__}")
    
        # Type check yearlyRevenue2021 (expected int)
        if "yearlyRevenue2021" in props and props["yearlyRevenue2021"] is not None:
            if not isinstance(props["yearlyRevenue2021"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue2021"] = int(props["yearlyRevenue2021"])
                except:
                    raise TypeError(f"Property yearlyRevenue2021 must be of type int, got {type(props['yearlyRevenue2021']).__name__}")
    
        # Type check headquartersLat (expected float)
        if "headquartersLat" in props and props["headquartersLat"] is not None:
            if not isinstance(props["headquartersLat"], float):
                try:
                    # Attempt to convert
                    props["headquartersLat"] = float(props["headquartersLat"])
                except:
                    raise TypeError(f"Property headquartersLat must be of type float, got {type(props['headquartersLat']).__name__}")
    
        # Type check marketShare (expected float)
        if "marketShare" in props and props["marketShare"] is not None:
            if not isinstance(props["marketShare"], float):
                try:
                    # Attempt to convert
                    props["marketShare"] = float(props["marketShare"])
                except:
                    raise TypeError(f"Property marketShare must be of type float, got {type(props['marketShare']).__name__}")
    
        # Type check yearlyRevenue2022 (expected int)
        if "yearlyRevenue2022" in props and props["yearlyRevenue2022"] is not None:
            if not isinstance(props["yearlyRevenue2022"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue2022"] = int(props["yearlyRevenue2022"])
                except:
                    raise TypeError(f"Property yearlyRevenue2022 must be of type int, got {type(props['yearlyRevenue2022']).__name__}")
    
        # Type check headquartersLong (expected float)
        if "headquartersLong" in props and props["headquartersLong"] is not None:
            if not isinstance(props["headquartersLong"], float):
                try:
                    # Attempt to convert
                    props["headquartersLong"] = float(props["headquartersLong"])
                except:
                    raise TypeError(f"Property headquartersLong must be of type float, got {type(props['headquartersLong']).__name__}")
    
        # Type check isPublic (expected bool)
        if "isPublic" in props and props["isPublic"] is not None:
            if not isinstance(props["isPublic"], bool):
                try:
                    # Attempt to convert
                    props["isPublic"] = bool(props["isPublic"])
                except:
                    raise TypeError(f"Property isPublic must be of type bool, got {type(props['isPublic']).__name__}")
    
        # Type check isActive (expected bool)
        if "isActive" in props and props["isActive"] is not None:
            if not isinstance(props["isActive"], bool):
                try:
                    # Attempt to convert
                    props["isActive"] = bool(props["isActive"])
                except:
                    raise TypeError(f"Property isActive must be of type bool, got {type(props['isActive']).__name__}")
    
        # Type check notableYears (expected object)
        if "notableYears" in props and props["notableYears"] is not None:
            if not isinstance(props["notableYears"], object):
                try:
                    # Attempt to convert
                    props["notableYears"] = object(props["notableYears"])
                except:
                    raise TypeError(f"Property notableYears must be of type object, got {type(props['notableYears']).__name__}")
    
        # Type check peakMarketShare (expected float)
        if "peakMarketShare" in props and props["peakMarketShare"] is not None:
            if not isinstance(props["peakMarketShare"], float):
                try:
                    # Attempt to convert
                    props["peakMarketShare"] = float(props["peakMarketShare"])
                except:
                    raise TypeError(f"Property peakMarketShare must be of type float, got {type(props['peakMarketShare']).__name__}")
    
        # Type check notableFilms (expected object)
        if "notableFilms" in props and props["notableFilms"] is not None:
            if not isinstance(props["notableFilms"], object):
                try:
                    # Attempt to convert
                    props["notableFilms"] = object(props["notableFilms"])
                except:
                    raise TypeError(f"Property notableFilms must be of type object, got {type(props['notableFilms']).__name__}")
    
        # Type check acquisitionDate (expected object)
        if "acquisitionDate" in props and props["acquisitionDate"] is not None:
            if not isinstance(props["acquisitionDate"], object):
                try:
                    # Attempt to convert
                    props["acquisitionDate"] = object(props["acquisitionDate"])
                except:
                    raise TypeError(f"Property acquisitionDate must be of type object, got {type(props['acquisitionDate']).__name__}")
    
        # Type check yearlyRevenue1992 (expected int)
        if "yearlyRevenue1992" in props and props["yearlyRevenue1992"] is not None:
            if not isinstance(props["yearlyRevenue1992"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1992"] = int(props["yearlyRevenue1992"])
                except:
                    raise TypeError(f"Property yearlyRevenue1992 must be of type int, got {type(props['yearlyRevenue1992']).__name__}")
    
        # Type check yearlyRevenue1991 (expected int)
        if "yearlyRevenue1991" in props and props["yearlyRevenue1991"] is not None:
            if not isinstance(props["yearlyRevenue1991"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1991"] = int(props["yearlyRevenue1991"])
                except:
                    raise TypeError(f"Property yearlyRevenue1991 must be of type int, got {type(props['yearlyRevenue1991']).__name__}")
    
        # Type check relaunch (expected object)
        if "relaunch" in props and props["relaunch"] is not None:
            if not isinstance(props["relaunch"], object):
                try:
                    # Attempt to convert
                    props["relaunch"] = object(props["relaunch"])
                except:
                    raise TypeError(f"Property relaunch must be of type object, got {type(props['relaunch']).__name__}")
    
        # Type check bankruptcyDate (expected object)
        if "bankruptcyDate" in props and props["bankruptcyDate"] is not None:
            if not isinstance(props["bankruptcyDate"], object):
                try:
                    # Attempt to convert
                    props["bankruptcyDate"] = object(props["bankruptcyDate"])
                except:
                    raise TypeError(f"Property bankruptcyDate must be of type object, got {type(props['bankruptcyDate']).__name__}")
    
        # Type check internationalOffices (expected object)
        if "internationalOffices" in props and props["internationalOffices"] is not None:
            if not isinstance(props["internationalOffices"], object):
                try:
                    # Attempt to convert
                    props["internationalOffices"] = object(props["internationalOffices"])
                except:
                    raise TypeError(f"Property internationalOffices must be of type object, got {type(props['internationalOffices']).__name__}")
    
        # Type check internationalPresence (expected int)
        if "internationalPresence" in props and props["internationalPresence"] is not None:
            if not isinstance(props["internationalPresence"], int):
                try:
                    # Attempt to convert
                    props["internationalPresence"] = int(props["internationalPresence"])
                except:
                    raise TypeError(f"Property internationalPresence must be of type int, got {type(props['internationalPresence']).__name__}")
    
        # Type check yearlyRevenue2019 (expected int)
        if "yearlyRevenue2019" in props and props["yearlyRevenue2019"] is not None:
            if not isinstance(props["yearlyRevenue2019"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue2019"] = int(props["yearlyRevenue2019"])
                except:
                    raise TypeError(f"Property yearlyRevenue2019 must be of type int, got {type(props['yearlyRevenue2019']).__name__}")
    
        # Type check parentCompany (expected str)
        if "parentCompany" in props and props["parentCompany"] is not None:
            if not isinstance(props["parentCompany"], str):
                try:
                    # Attempt to convert
                    props["parentCompany"] = str(props["parentCompany"])
                except:
                    raise TypeError(f"Property parentCompany must be of type str, got {type(props['parentCompany']).__name__}")
    
        # Type check conservationContributions (expected int)
        if "conservationContributions" in props and props["conservationContributions"] is not None:
            if not isinstance(props["conservationContributions"], int):
                try:
                    # Attempt to convert
                    props["conservationContributions"] = int(props["conservationContributions"])
                except:
                    raise TypeError(f"Property conservationContributions must be of type int, got {type(props['conservationContributions']).__name__}")
    
        # Type check conservationPartners (expected object)
        if "conservationPartners" in props and props["conservationPartners"] is not None:
            if not isinstance(props["conservationPartners"], object):
                try:
                    # Attempt to convert
                    props["conservationPartners"] = object(props["conservationPartners"])
                except:
                    raise TypeError(f"Property conservationPartners must be of type object, got {type(props['conservationPartners']).__name__}")
    
        # Type check documentaryFocus (expected object)
        if "documentaryFocus" in props and props["documentaryFocus"] is not None:
            if not isinstance(props["documentaryFocus"], object):
                try:
                    # Attempt to convert
                    props["documentaryFocus"] = object(props["documentaryFocus"])
                except:
                    raise TypeError(f"Property documentaryFocus must be of type object, got {type(props['documentaryFocus']).__name__}")
    
        # Type check releasedTitles (expected object)
        if "releasedTitles" in props and props["releasedTitles"] is not None:
            if not isinstance(props["releasedTitles"], object):
                try:
                    # Attempt to convert
                    props["releasedTitles"] = object(props["releasedTitles"])
                except:
                    raise TypeError(f"Property releasedTitles must be of type object, got {type(props['releasedTitles']).__name__}")
    
        # Type check releasedYears (expected object)
        if "releasedYears" in props and props["releasedYears"] is not None:
            if not isinstance(props["releasedYears"], object):
                try:
                    # Attempt to convert
                    props["releasedYears"] = object(props["releasedYears"])
                except:
                    raise TypeError(f"Property releasedYears must be of type object, got {type(props['releasedYears']).__name__}")
    
        # Type check archivalFootageHours (expected int)
        if "archivalFootageHours" in props and props["archivalFootageHours"] is not None:
            if not isinstance(props["archivalFootageHours"], int):
                try:
                    # Attempt to convert
                    props["archivalFootageHours"] = int(props["archivalFootageHours"])
                except:
                    raise TypeError(f"Property archivalFootageHours must be of type int, got {type(props['archivalFootageHours']).__name__}")
    
        # Type check dissolved (expected object)
        if "dissolved" in props and props["dissolved"] is not None:
            if not isinstance(props["dissolved"], object):
                try:
                    # Attempt to convert
                    props["dissolved"] = object(props["dissolved"])
                except:
                    raise TypeError(f"Property dissolved must be of type object, got {type(props['dissolved']).__name__}")
    
        # Type check historicalSignificance (expected str)
        if "historicalSignificance" in props and props["historicalSignificance"] is not None:
            if not isinstance(props["historicalSignificance"], str):
                try:
                    # Attempt to convert
                    props["historicalSignificance"] = str(props["historicalSignificance"])
                except:
                    raise TypeError(f"Property historicalSignificance must be of type str, got {type(props['historicalSignificance']).__name__}")
    
        # Type check keyFigures (expected object)
        if "keyFigures" in props and props["keyFigures"] is not None:
            if not isinstance(props["keyFigures"], object):
                try:
                    # Attempt to convert
                    props["keyFigures"] = object(props["keyFigures"])
                except:
                    raise TypeError(f"Property keyFigures must be of type object, got {type(props['keyFigures']).__name__}")
    
        # Type check digitalArchiveCreation (expected object)
        if "digitalArchiveCreation" in props and props["digitalArchiveCreation"] is not None:
            if not isinstance(props["digitalArchiveCreation"], object):
                try:
                    # Attempt to convert
                    props["digitalArchiveCreation"] = object(props["digitalArchiveCreation"])
                except:
                    raise TypeError(f"Property digitalArchiveCreation must be of type object, got {type(props['digitalArchiveCreation']).__name__}")
    
        # Type check studioLotsHistorical (expected object)
        if "studioLotsHistorical" in props and props["studioLotsHistorical"] is not None:
            if not isinstance(props["studioLotsHistorical"], object):
                try:
                    # Attempt to convert
                    props["studioLotsHistorical"] = object(props["studioLotsHistorical"])
                except:
                    raise TypeError(f"Property studioLotsHistorical must be of type object, got {type(props['studioLotsHistorical']).__name__}")
    
        # Type check peakYear (expected int)
        if "peakYear" in props and props["peakYear"] is not None:
            if not isinstance(props["peakYear"], int):
                try:
                    # Attempt to convert
                    props["peakYear"] = int(props["peakYear"])
                except:
                    raise TypeError(f"Property peakYear must be of type int, got {type(props['peakYear']).__name__}")
    
        # Type check reestablished (expected object)
        if "reestablished" in props and props["reestablished"] is not None:
            if not isinstance(props["reestablished"], object):
                try:
                    # Attempt to convert
                    props["reestablished"] = object(props["reestablished"])
                except:
                    raise TypeError(f"Property reestablished must be of type object, got {type(props['reestablished']).__name__}")
    
        # Type check peakYearlyRevenue (expected int)
        if "peakYearlyRevenue" in props and props["peakYearlyRevenue"] is not None:
            if not isinstance(props["peakYearlyRevenue"], int):
                try:
                    # Attempt to convert
                    props["peakYearlyRevenue"] = int(props["peakYearlyRevenue"])
                except:
                    raise TypeError(f"Property peakYearlyRevenue must be of type int, got {type(props['peakYearlyRevenue']).__name__}")
    
        # Type check acquisitionAmount (expected int)
        if "acquisitionAmount" in props and props["acquisitionAmount"] is not None:
            if not isinstance(props["acquisitionAmount"], int):
                try:
                    # Attempt to convert
                    props["acquisitionAmount"] = int(props["acquisitionAmount"])
                except:
                    raise TypeError(f"Property acquisitionAmount must be of type int, got {type(props['acquisitionAmount']).__name__}")
    
        # Type check acquiredBy (expected str)
        if "acquiredBy" in props and props["acquiredBy"] is not None:
            if not isinstance(props["acquiredBy"], str):
                try:
                    # Attempt to convert
                    props["acquiredBy"] = str(props["acquiredBy"])
                except:
                    raise TypeError(f"Property acquiredBy must be of type str, got {type(props['acquiredBy']).__name__}")
    
        # Type check acquired (expected object)
        if "acquired" in props and props["acquired"] is not None:
            if not isinstance(props["acquired"], object):
                try:
                    # Attempt to convert
                    props["acquired"] = object(props["acquired"])
                except:
                    raise TypeError(f"Property acquired must be of type object, got {type(props['acquired']).__name__}")
    
        # Type check yearlyRevenue2018 (expected int)
        if "yearlyRevenue2018" in props and props["yearlyRevenue2018"] is not None:
            if not isinstance(props["yearlyRevenue2018"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue2018"] = int(props["yearlyRevenue2018"])
                except:
                    raise TypeError(f"Property yearlyRevenue2018 must be of type int, got {type(props['yearlyRevenue2018']).__name__}")
    
        # Type check studioAge (expected int)
        if "studioAge" in props and props["studioAge"] is not None:
            if not isinstance(props["studioAge"], int):
                try:
                    # Attempt to convert
                    props["studioAge"] = int(props["studioAge"])
                except:
                    raise TypeError(f"Property studioAge must be of type int, got {type(props['studioAge']).__name__}")
    
        # Type check mountainLogo (expected bool)
        if "mountainLogo" in props and props["mountainLogo"] is not None:
            if not isinstance(props["mountainLogo"], bool):
                try:
                    # Attempt to convert
                    props["mountainLogo"] = bool(props["mountainLogo"])
                except:
                    raise TypeError(f"Property mountainLogo must be of type bool, got {type(props['mountainLogo']).__name__}")
    
        # Type check indieFilmFocus (expected bool)
        if "indieFilmFocus" in props and props["indieFilmFocus"] is not None:
            if not isinstance(props["indieFilmFocus"], bool):
                try:
                    # Attempt to convert
                    props["indieFilmFocus"] = bool(props["indieFilmFocus"])
                except:
                    raise TypeError(f"Property indieFilmFocus must be of type bool, got {type(props['indieFilmFocus']).__name__}")
    
        # Type check awardWinningFilms (expected int)
        if "awardWinningFilms" in props and props["awardWinningFilms"] is not None:
            if not isinstance(props["awardWinningFilms"], int):
                try:
                    # Attempt to convert
                    props["awardWinningFilms"] = int(props["awardWinningFilms"])
                except:
                    raise TypeError(f"Property awardWinningFilms must be of type int, got {type(props['awardWinningFilms']).__name__}")
    
        # Type check independentFocus (expected bool)
        if "independentFocus" in props and props["independentFocus"] is not None:
            if not isinstance(props["independentFocus"], bool):
                try:
                    # Attempt to convert
                    props["independentFocus"] = bool(props["independentFocus"])
                except:
                    raise TypeError(f"Property independentFocus must be of type bool, got {type(props['independentFocus']).__name__}")
    
        # Type check yearlyRevenue1996 (expected int)
        if "yearlyRevenue1996" in props and props["yearlyRevenue1996"] is not None:
            if not isinstance(props["yearlyRevenue1996"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1996"] = int(props["yearlyRevenue1996"])
                except:
                    raise TypeError(f"Property yearlyRevenue1996 must be of type int, got {type(props['yearlyRevenue1996']).__name__}")
    
        # Type check yearlyRevenue1995 (expected int)
        if "yearlyRevenue1995" in props and props["yearlyRevenue1995"] is not None:
            if not isinstance(props["yearlyRevenue1995"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1995"] = int(props["yearlyRevenue1995"])
                except:
                    raise TypeError(f"Property yearlyRevenue1995 must be of type int, got {type(props['yearlyRevenue1995']).__name__}")
    
        # Type check yearlyRevenue1994 (expected int)
        if "yearlyRevenue1994" in props and props["yearlyRevenue1994"] is not None:
            if not isinstance(props["yearlyRevenue1994"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1994"] = int(props["yearlyRevenue1994"])
                except:
                    raise TypeError(f"Property yearlyRevenue1994 must be of type int, got {type(props['yearlyRevenue1994']).__name__}")
    
        # Type check foundedBy (expected object)
        if "foundedBy" in props and props["foundedBy"] is not None:
            if not isinstance(props["foundedBy"], object):
                try:
                    # Attempt to convert
                    props["foundedBy"] = object(props["foundedBy"])
                except:
                    raise TypeError(f"Property foundedBy must be of type object, got {type(props['foundedBy']).__name__}")
    
        # Type check divested (expected object)
        if "divested" in props and props["divested"] is not None:
            if not isinstance(props["divested"], object):
                try:
                    # Attempt to convert
                    props["divested"] = object(props["divested"])
                except:
                    raise TypeError(f"Property divested must be of type object, got {type(props['divested']).__name__}")
    
        # Type check employeeCount (expected int)
        if "employeeCount" in props and props["employeeCount"] is not None:
            if not isinstance(props["employeeCount"], int):
                try:
                    # Attempt to convert
                    props["employeeCount"] = int(props["employeeCount"])
                except:
                    raise TypeError(f"Property employeeCount must be of type int, got {type(props['employeeCount']).__name__}")
    
        # Type check mountain_logo (expected bool)
        if "mountain_logo" in props and props["mountain_logo"] is not None:
            if not isinstance(props["mountain_logo"], bool):
                try:
                    # Attempt to convert
                    props["mountain_logo"] = bool(props["mountain_logo"])
                except:
                    raise TypeError(f"Property mountain_logo must be of type bool, got {type(props['mountain_logo']).__name__}")
    
        # Type check production_heads (expected object)
        if "production_heads" in props and props["production_heads"] is not None:
            if not isinstance(props["production_heads"], object):
                try:
                    # Attempt to convert
                    props["production_heads"] = object(props["production_heads"])
                except:
                    raise TypeError(f"Property production_heads must be of type object, got {type(props['production_heads']).__name__}")
    
        # Type check distribution_markets (expected object)
        if "distribution_markets" in props and props["distribution_markets"] is not None:
            if not isinstance(props["distribution_markets"], object):
                try:
                    # Attempt to convert
                    props["distribution_markets"] = object(props["distribution_markets"])
                except:
                    raise TypeError(f"Property distribution_markets must be of type object, got {type(props['distribution_markets']).__name__}")
    
        # Type check totalSoundstages (expected int)
        if "totalSoundstages" in props and props["totalSoundstages"] is not None:
            if not isinstance(props["totalSoundstages"], int):
                try:
                    # Attempt to convert
                    props["totalSoundstages"] = int(props["totalSoundstages"])
                except:
                    raise TypeError(f"Property totalSoundstages must be of type int, got {type(props['totalSoundstages']).__name__}")
    
        # Type check yearlyRevenue1973 (expected int)
        if "yearlyRevenue1973" in props and props["yearlyRevenue1973"] is not None:
            if not isinstance(props["yearlyRevenue1973"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1973"] = int(props["yearlyRevenue1973"])
                except:
                    raise TypeError(f"Property yearlyRevenue1973 must be of type int, got {type(props['yearlyRevenue1973']).__name__}")
    
        # Type check yearlyRevenue1972 (expected int)
        if "yearlyRevenue1972" in props and props["yearlyRevenue1972"] is not None:
            if not isinstance(props["yearlyRevenue1972"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1972"] = int(props["yearlyRevenue1972"])
                except:
                    raise TypeError(f"Property yearlyRevenue1972 must be of type int, got {type(props['yearlyRevenue1972']).__name__}")
    
        # Type check yearlyRevenue1971 (expected int)
        if "yearlyRevenue1971" in props and props["yearlyRevenue1971"] is not None:
            if not isinstance(props["yearlyRevenue1971"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1971"] = int(props["yearlyRevenue1971"])
                except:
                    raise TypeError(f"Property yearlyRevenue1971 must be of type int, got {type(props['yearlyRevenue1971']).__name__}")
    
        # Type check filmReleases1972 (expected int)
        if "filmReleases1972" in props and props["filmReleases1972"] is not None:
            if not isinstance(props["filmReleases1972"], int):
                try:
                    # Attempt to convert
                    props["filmReleases1972"] = int(props["filmReleases1972"])
                except:
                    raise TypeError(f"Property filmReleases1972 must be of type int, got {type(props['filmReleases1972']).__name__}")
    
        # Type check reorganized (expected object)
        if "reorganized" in props and props["reorganized"] is not None:
            if not isinstance(props["reorganized"], object):
                try:
                    # Attempt to convert
                    props["reorganized"] = object(props["reorganized"])
                except:
                    raise TypeError(f"Property reorganized must be of type object, got {type(props['reorganized']).__name__}")
    
        # Type check chairmen_history (expected object)
        if "chairmen_history" in props and props["chairmen_history"] is not None:
            if not isinstance(props["chairmen_history"], object):
                try:
                    # Attempt to convert
                    props["chairmen_history"] = object(props["chairmen_history"])
                except:
                    raise TypeError(f"Property chairmen_history must be of type object, got {type(props['chairmen_history']).__name__}")
    
        # Type check totalStudioLots (expected int)
        if "totalStudioLots" in props and props["totalStudioLots"] is not None:
            if not isinstance(props["totalStudioLots"], int):
                try:
                    # Attempt to convert
                    props["totalStudioLots"] = int(props["totalStudioLots"])
                except:
                    raise TypeError(f"Property totalStudioLots must be of type int, got {type(props['totalStudioLots']).__name__}")
    
        # Type check founded_for (expected str)
        if "founded_for" in props and props["founded_for"] is not None:
            if not isinstance(props["founded_for"], str):
                try:
                    # Attempt to convert
                    props["founded_for"] = str(props["founded_for"])
                except:
                    raise TypeError(f"Property founded_for must be of type str, got {type(props['founded_for']).__name__}")
    
        # Type check annualBudget (expected int)
        if "annualBudget" in props and props["annualBudget"] is not None:
            if not isinstance(props["annualBudget"], int):
                try:
                    # Attempt to convert
                    props["annualBudget"] = int(props["annualBudget"])
                except:
                    raise TypeError(f"Property annualBudget must be of type int, got {type(props['annualBudget']).__name__}")
    
        # Type check production_years (expected object)
        if "production_years" in props and props["production_years"] is not None:
            if not isinstance(props["production_years"], object):
                try:
                    # Attempt to convert
                    props["production_years"] = object(props["production_years"])
                except:
                    raise TypeError(f"Property production_years must be of type object, got {type(props['production_years']).__name__}")
    
        # Type check namedFor (expected str)
        if "namedFor" in props and props["namedFor"] is not None:
            if not isinstance(props["namedFor"], str):
                try:
                    # Attempt to convert
                    props["namedFor"] = str(props["namedFor"])
                except:
                    raise TypeError(f"Property namedFor must be of type str, got {type(props['namedFor']).__name__}")
    
        # Type check officeSpace (expected int)
        if "officeSpace" in props and props["officeSpace"] is not None:
            if not isinstance(props["officeSpace"], int):
                try:
                    # Attempt to convert
                    props["officeSpace"] = int(props["officeSpace"])
                except:
                    raise TypeError(f"Property officeSpace must be of type int, got {type(props['officeSpace']).__name__}")
    
        # Type check companyType (expected str)
        if "companyType" in props and props["companyType"] is not None:
            if not isinstance(props["companyType"], str):
                try:
                    # Attempt to convert
                    props["companyType"] = str(props["companyType"])
                except:
                    raise TypeError(f"Property companyType must be of type str, got {type(props['companyType']).__name__}")
    
        # Type check headquarters (expected str)
        if "headquarters" in props and props["headquarters"] is not None:
            if not isinstance(props["headquarters"], str):
                try:
                    # Attempt to convert
                    props["headquarters"] = str(props["headquarters"])
                except:
                    raise TypeError(f"Property headquarters must be of type str, got {type(props['headquarters']).__name__}")
    
        # Type check officeSpaceUnit (expected str)
        if "officeSpaceUnit" in props and props["officeSpaceUnit"] is not None:
            if not isinstance(props["officeSpaceUnit"], str):
                try:
                    # Attempt to convert
                    props["officeSpaceUnit"] = str(props["officeSpaceUnit"])
                except:
                    raise TypeError(f"Property officeSpaceUnit must be of type str, got {type(props['officeSpaceUnit']).__name__}")
    
        # Type check company_structure (expected str)
        if "company_structure" in props and props["company_structure"] is not None:
            if not isinstance(props["company_structure"], str):
                try:
                    # Attempt to convert
                    props["company_structure"] = str(props["company_structure"])
                except:
                    raise TypeError(f"Property company_structure must be of type str, got {type(props['company_structure']).__name__}")
    
        # Type check studio_partnerships (expected object)
        if "studio_partnerships" in props and props["studio_partnerships"] is not None:
            if not isinstance(props["studio_partnerships"], object):
                try:
                    # Attempt to convert
                    props["studio_partnerships"] = object(props["studio_partnerships"])
                except:
                    raise TypeError(f"Property studio_partnerships must be of type object, got {type(props['studio_partnerships']).__name__}")
    
        # Type check production_titles (expected object)
        if "production_titles" in props and props["production_titles"] is not None:
            if not isinstance(props["production_titles"], object):
                try:
                    # Attempt to convert
                    props["production_titles"] = object(props["production_titles"])
                except:
                    raise TypeError(f"Property production_titles must be of type object, got {type(props['production_titles']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Studio", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def production(uuid=None, **props):
        """
        Find nodes with label Production matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check scheduleTimes (expected object)
        if "scheduleTimes" in props and props["scheduleTimes"] is not None:
            if not isinstance(props["scheduleTimes"], object):
                try:
                    # Attempt to convert
                    props["scheduleTimes"] = object(props["scheduleTimes"])
                except:
                    raise TypeError(f"Property scheduleTimes must be of type object, got {type(props['scheduleTimes']).__name__}")
    
        # Type check scheduleDurations (expected object)
        if "scheduleDurations" in props and props["scheduleDurations"] is not None:
            if not isinstance(props["scheduleDurations"], object):
                try:
                    # Attempt to convert
                    props["scheduleDurations"] = object(props["scheduleDurations"])
                except:
                    raise TypeError(f"Property scheduleDurations must be of type object, got {type(props['scheduleDurations']).__name__}")
    
        # Type check weatherPoor (expected int)
        if "weatherPoor" in props and props["weatherPoor"] is not None:
            if not isinstance(props["weatherPoor"], int):
                try:
                    # Attempt to convert
                    props["weatherPoor"] = int(props["weatherPoor"])
                except:
                    raise TypeError(f"Property weatherPoor must be of type int, got {type(props['weatherPoor']).__name__}")
    
        # Type check startDate (expected object)
        if "startDate" in props and props["startDate"] is not None:
            if not isinstance(props["startDate"], object):
                try:
                    # Attempt to convert
                    props["startDate"] = object(props["startDate"])
                except:
                    raise TypeError(f"Property startDate must be of type object, got {type(props['startDate']).__name__}")
    
        # Type check isCompleted (expected bool)
        if "isCompleted" in props and props["isCompleted"] is not None:
            if not isinstance(props["isCompleted"], bool):
                try:
                    # Attempt to convert
                    props["isCompleted"] = bool(props["isCompleted"])
                except:
                    raise TypeError(f"Property isCompleted must be of type bool, got {type(props['isCompleted']).__name__}")
    
        # Type check scheduleActivities (expected object)
        if "scheduleActivities" in props and props["scheduleActivities"] is not None:
            if not isinstance(props["scheduleActivities"], object):
                try:
                    # Attempt to convert
                    props["scheduleActivities"] = object(props["scheduleActivities"])
                except:
                    raise TypeError(f"Property scheduleActivities must be of type object, got {type(props['scheduleActivities']).__name__}")
    
        # Type check budgetEquipment (expected int)
        if "budgetEquipment" in props and props["budgetEquipment"] is not None:
            if not isinstance(props["budgetEquipment"], int):
                try:
                    # Attempt to convert
                    props["budgetEquipment"] = int(props["budgetEquipment"])
                except:
                    raise TypeError(f"Property budgetEquipment must be of type int, got {type(props['budgetEquipment']).__name__}")
    
        # Type check weatherGood (expected int)
        if "weatherGood" in props and props["weatherGood"] is not None:
            if not isinstance(props["weatherGood"], int):
                try:
                    # Attempt to convert
                    props["weatherGood"] = int(props["weatherGood"])
                except:
                    raise TypeError(f"Property weatherGood must be of type int, got {type(props['weatherGood']).__name__}")
    
        # Type check startTime (expected object)
        if "startTime" in props and props["startTime"] is not None:
            if not isinstance(props["startTime"], object):
                try:
                    # Attempt to convert
                    props["startTime"] = object(props["startTime"])
                except:
                    raise TypeError(f"Property startTime must be of type object, got {type(props['startTime']).__name__}")
    
        # Type check budgetPersonnel (expected int)
        if "budgetPersonnel" in props and props["budgetPersonnel"] is not None:
            if not isinstance(props["budgetPersonnel"], int):
                try:
                    # Attempt to convert
                    props["budgetPersonnel"] = int(props["budgetPersonnel"])
                except:
                    raise TypeError(f"Property budgetPersonnel must be of type int, got {type(props['budgetPersonnel']).__name__}")
    
        # Type check durationDays (expected int)
        if "durationDays" in props and props["durationDays"] is not None:
            if not isinstance(props["durationDays"], int):
                try:
                    # Attempt to convert
                    props["durationDays"] = int(props["durationDays"])
                except:
                    raise TypeError(f"Property durationDays must be of type int, got {type(props['durationDays']).__name__}")
    
        # Type check budgetVFX (expected int)
        if "budgetVFX" in props and props["budgetVFX"] is not None:
            if not isinstance(props["budgetVFX"], int):
                try:
                    # Attempt to convert
                    props["budgetVFX"] = int(props["budgetVFX"])
                except:
                    raise TypeError(f"Property budgetVFX must be of type int, got {type(props['budgetVFX']).__name__}")
    
        # Type check weatherAcceptable (expected int)
        if "weatherAcceptable" in props and props["weatherAcceptable"] is not None:
            if not isinstance(props["weatherAcceptable"], int):
                try:
                    # Attempt to convert
                    props["weatherAcceptable"] = int(props["weatherAcceptable"])
                except:
                    raise TypeError(f"Property weatherAcceptable must be of type int, got {type(props['weatherAcceptable']).__name__}")
    
        # Type check durationMonths (expected int)
        if "durationMonths" in props and props["durationMonths"] is not None:
            if not isinstance(props["durationMonths"], int):
                try:
                    # Attempt to convert
                    props["durationMonths"] = int(props["durationMonths"])
                except:
                    raise TypeError(f"Property durationMonths must be of type int, got {type(props['durationMonths']).__name__}")
    
        # Type check budgetOther (expected int)
        if "budgetOther" in props and props["budgetOther"] is not None:
            if not isinstance(props["budgetOther"], int):
                try:
                    # Attempt to convert
                    props["budgetOther"] = int(props["budgetOther"])
                except:
                    raise TypeError(f"Property budgetOther must be of type int, got {type(props['budgetOther']).__name__}")
    
        # Type check endDate (expected object)
        if "endDate" in props and props["endDate"] is not None:
            if not isinstance(props["endDate"], object):
                try:
                    # Attempt to convert
                    props["endDate"] = object(props["endDate"])
                except:
                    raise TypeError(f"Property endDate must be of type object, got {type(props['endDate']).__name__}")
    
        # Type check budgetLocations (expected int)
        if "budgetLocations" in props and props["budgetLocations"] is not None:
            if not isinstance(props["budgetLocations"], int):
                try:
                    # Attempt to convert
                    props["budgetLocations"] = int(props["budgetLocations"])
                except:
                    raise TypeError(f"Property budgetLocations must be of type int, got {type(props['budgetLocations']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check productionPhases (expected object)
        if "productionPhases" in props and props["productionPhases"] is not None:
            if not isinstance(props["productionPhases"], object):
                try:
                    # Attempt to convert
                    props["productionPhases"] = object(props["productionPhases"])
                except:
                    raise TypeError(f"Property productionPhases must be of type object, got {type(props['productionPhases']).__name__}")
    
        # Type check phaseStartDates (expected object)
        if "phaseStartDates" in props and props["phaseStartDates"] is not None:
            if not isinstance(props["phaseStartDates"], object):
                try:
                    # Attempt to convert
                    props["phaseStartDates"] = object(props["phaseStartDates"])
                except:
                    raise TypeError(f"Property phaseStartDates must be of type object, got {type(props['phaseStartDates']).__name__}")
    
        # Type check phaseDurationsMonths (expected object)
        if "phaseDurationsMonths" in props and props["phaseDurationsMonths"] is not None:
            if not isinstance(props["phaseDurationsMonths"], object):
                try:
                    # Attempt to convert
                    props["phaseDurationsMonths"] = object(props["phaseDurationsMonths"])
                except:
                    raise TypeError(f"Property phaseDurationsMonths must be of type object, got {type(props['phaseDurationsMonths']).__name__}")
    
        # Type check renderingHours (expected int)
        if "renderingHours" in props and props["renderingHours"] is not None:
            if not isinstance(props["renderingHours"], int):
                try:
                    # Attempt to convert
                    props["renderingHours"] = int(props["renderingHours"])
                except:
                    raise TypeError(f"Property renderingHours must be of type int, got {type(props['renderingHours']).__name__}")
    
        # Type check budgetVoiceActing (expected int)
        if "budgetVoiceActing" in props and props["budgetVoiceActing"] is not None:
            if not isinstance(props["budgetVoiceActing"], int):
                try:
                    # Attempt to convert
                    props["budgetVoiceActing"] = int(props["budgetVoiceActing"])
                except:
                    raise TypeError(f"Property budgetVoiceActing must be of type int, got {type(props['budgetVoiceActing']).__name__}")
    
        # Type check budgetTechnology (expected int)
        if "budgetTechnology" in props and props["budgetTechnology"] is not None:
            if not isinstance(props["budgetTechnology"], int):
                try:
                    # Attempt to convert
                    props["budgetTechnology"] = int(props["budgetTechnology"])
                except:
                    raise TypeError(f"Property budgetTechnology must be of type int, got {type(props['budgetTechnology']).__name__}")
    
        # Type check budgetRendering (expected int)
        if "budgetRendering" in props and props["budgetRendering"] is not None:
            if not isinstance(props["budgetRendering"], int):
                try:
                    # Attempt to convert
                    props["budgetRendering"] = int(props["budgetRendering"])
                except:
                    raise TypeError(f"Property budgetRendering must be of type int, got {type(props['budgetRendering']).__name__}")
    
        # Type check renderFarmServers (expected int)
        if "renderFarmServers" in props and props["renderFarmServers"] is not None:
            if not isinstance(props["renderFarmServers"], int):
                try:
                    # Attempt to convert
                    props["renderFarmServers"] = int(props["renderFarmServers"])
                except:
                    raise TypeError(f"Property renderFarmServers must be of type int, got {type(props['renderFarmServers']).__name__}")
    
        # Type check animatorsCount (expected int)
        if "animatorsCount" in props and props["animatorsCount"] is not None:
            if not isinstance(props["animatorsCount"], int):
                try:
                    # Attempt to convert
                    props["animatorsCount"] = int(props["animatorsCount"])
                except:
                    raise TypeError(f"Property animatorsCount must be of type int, got {type(props['animatorsCount']).__name__}")
    
        # Type check technicalInnovations (expected object)
        if "technicalInnovations" in props and props["technicalInnovations"] is not None:
            if not isinstance(props["technicalInnovations"], object):
                try:
                    # Attempt to convert
                    props["technicalInnovations"] = object(props["technicalInnovations"])
                except:
                    raise TypeError(f"Property technicalInnovations must be of type object, got {type(props['technicalInnovations']).__name__}")
    
        # Type check innovationImpact (expected object)
        if "innovationImpact" in props and props["innovationImpact"] is not None:
            if not isinstance(props["innovationImpact"], object):
                try:
                    # Attempt to convert
                    props["innovationImpact"] = object(props["innovationImpact"])
                except:
                    raise TypeError(f"Property innovationImpact must be of type object, got {type(props['innovationImpact']).__name__}")
    
        # Type check budgetSets (expected int)
        if "budgetSets" in props and props["budgetSets"] is not None:
            if not isinstance(props["budgetSets"], int):
                try:
                    # Attempt to convert
                    props["budgetSets"] = int(props["budgetSets"])
                except:
                    raise TypeError(f"Property budgetSets must be of type int, got {type(props['budgetSets']).__name__}")
    
        # Type check customSets (expected object)
        if "customSets" in props and props["customSets"] is not None:
            if not isinstance(props["customSets"], object):
                try:
                    # Attempt to convert
                    props["customSets"] = object(props["customSets"])
                except:
                    raise TypeError(f"Property customSets must be of type object, got {type(props['customSets']).__name__}")
    
        # Type check setConstructionDays (expected object)
        if "setConstructionDays" in props and props["setConstructionDays"] is not None:
            if not isinstance(props["setConstructionDays"], object):
                try:
                    # Attempt to convert
                    props["setConstructionDays"] = object(props["setConstructionDays"])
                except:
                    raise TypeError(f"Property setConstructionDays must be of type object, got {type(props['setConstructionDays']).__name__}")
    
        # Type check equipmentSuccessRate (expected object)
        if "equipmentSuccessRate" in props and props["equipmentSuccessRate"] is not None:
            if not isinstance(props["equipmentSuccessRate"], object):
                try:
                    # Attempt to convert
                    props["equipmentSuccessRate"] = object(props["equipmentSuccessRate"])
                except:
                    raise TypeError(f"Property equipmentSuccessRate must be of type object, got {type(props['equipmentSuccessRate']).__name__}")
    
        # Type check environmentalChallenges (expected object)
        if "environmentalChallenges" in props and props["environmentalChallenges"] is not None:
            if not isinstance(props["environmentalChallenges"], object):
                try:
                    # Attempt to convert
                    props["environmentalChallenges"] = object(props["environmentalChallenges"])
                except:
                    raise TypeError(f"Property environmentalChallenges must be of type object, got {type(props['environmentalChallenges']).__name__}")
    
        # Type check challengeSeverity (expected object)
        if "challengeSeverity" in props and props["challengeSeverity"] is not None:
            if not isinstance(props["challengeSeverity"], object):
                try:
                    # Attempt to convert
                    props["challengeSeverity"] = object(props["challengeSeverity"])
                except:
                    raise TypeError(f"Property challengeSeverity must be of type object, got {type(props['challengeSeverity']).__name__}")
    
        # Type check specialEquipment (expected object)
        if "specialEquipment" in props and props["specialEquipment"] is not None:
            if not isinstance(props["specialEquipment"], object):
                try:
                    # Attempt to convert
                    props["specialEquipment"] = object(props["specialEquipment"])
                except:
                    raise TypeError(f"Property specialEquipment must be of type object, got {type(props['specialEquipment']).__name__}")
    
        # Type check crewRotations (expected int)
        if "crewRotations" in props and props["crewRotations"] is not None:
            if not isinstance(props["crewRotations"], int):
                try:
                    # Attempt to convert
                    props["crewRotations"] = int(props["crewRotations"])
                except:
                    raise TypeError(f"Property crewRotations must be of type int, got {type(props['crewRotations']).__name__}")
    
        # Type check budgetSurvival (expected int)
        if "budgetSurvival" in props and props["budgetSurvival"] is not None:
            if not isinstance(props["budgetSurvival"], int):
                try:
                    # Attempt to convert
                    props["budgetSurvival"] = int(props["budgetSurvival"])
                except:
                    raise TypeError(f"Property budgetSurvival must be of type int, got {type(props['budgetSurvival']).__name__}")
    
        # Type check extremeConditionDays (expected int)
        if "extremeConditionDays" in props and props["extremeConditionDays"] is not None:
            if not isinstance(props["extremeConditionDays"], int):
                try:
                    # Attempt to convert
                    props["extremeConditionDays"] = int(props["extremeConditionDays"])
                except:
                    raise TypeError(f"Property extremeConditionDays must be of type int, got {type(props['extremeConditionDays']).__name__}")
    
        # Type check budgetTransport (expected int)
        if "budgetTransport" in props and props["budgetTransport"] is not None:
            if not isinstance(props["budgetTransport"], int):
                try:
                    # Attempt to convert
                    props["budgetTransport"] = int(props["budgetTransport"])
                except:
                    raise TypeError(f"Property budgetTransport must be of type int, got {type(props['budgetTransport']).__name__}")
    
        # Type check budgetMusic (expected int)
        if "budgetMusic" in props and props["budgetMusic"] is not None:
            if not isinstance(props["budgetMusic"], int):
                try:
                    # Attempt to convert
                    props["budgetMusic"] = int(props["budgetMusic"])
                except:
                    raise TypeError(f"Property budgetMusic must be of type int, got {type(props['budgetMusic']).__name__}")
    
        # Type check locationCountries (expected object)
        if "locationCountries" in props and props["locationCountries"] is not None:
            if not isinstance(props["locationCountries"], object):
                try:
                    # Attempt to convert
                    props["locationCountries"] = object(props["locationCountries"])
                except:
                    raise TypeError(f"Property locationCountries must be of type object, got {type(props['locationCountries']).__name__}")
    
        # Type check studioRestrictions (expected object)
        if "studioRestrictions" in props and props["studioRestrictions"] is not None:
            if not isinstance(props["studioRestrictions"], object):
                try:
                    # Attempt to convert
                    props["studioRestrictions"] = object(props["studioRestrictions"])
                except:
                    raise TypeError(f"Property studioRestrictions must be of type object, got {type(props['studioRestrictions']).__name__}")
    
        # Type check technicalSuccesses (expected int)
        if "technicalSuccesses" in props and props["technicalSuccesses"] is not None:
            if not isinstance(props["technicalSuccesses"], int):
                try:
                    # Attempt to convert
                    props["technicalSuccesses"] = int(props["technicalSuccesses"])
                except:
                    raise TypeError(f"Property technicalSuccesses must be of type int, got {type(props['technicalSuccesses']).__name__}")
    
        # Type check motionCaptureStages (expected int)
        if "motionCaptureStages" in props and props["motionCaptureStages"] is not None:
            if not isinstance(props["motionCaptureStages"], int):
                try:
                    # Attempt to convert
                    props["motionCaptureStages"] = int(props["motionCaptureStages"])
                except:
                    raise TypeError(f"Property motionCaptureStages must be of type int, got {type(props['motionCaptureStages']).__name__}")
    
        # Type check budgetMotionCapture (expected int)
        if "budgetMotionCapture" in props and props["budgetMotionCapture"] is not None:
            if not isinstance(props["budgetMotionCapture"], int):
                try:
                    # Attempt to convert
                    props["budgetMotionCapture"] = int(props["budgetMotionCapture"])
                except:
                    raise TypeError(f"Property budgetMotionCapture must be of type int, got {type(props['budgetMotionCapture']).__name__}")
    
        # Type check technicalChallenges (expected int)
        if "technicalChallenges" in props and props["technicalChallenges"] is not None:
            if not isinstance(props["technicalChallenges"], int):
                try:
                    # Attempt to convert
                    props["technicalChallenges"] = int(props["technicalChallenges"])
                except:
                    raise TypeError(f"Property technicalChallenges must be of type int, got {type(props['technicalChallenges']).__name__}")
    
        # Type check filmingCountries (expected object)
        if "filmingCountries" in props and props["filmingCountries"] is not None:
            if not isinstance(props["filmingCountries"], object):
                try:
                    # Attempt to convert
                    props["filmingCountries"] = object(props["filmingCountries"])
                except:
                    raise TypeError(f"Property filmingCountries must be of type object, got {type(props['filmingCountries']).__name__}")
    
        # Type check guerrillaFilming (expected bool)
        if "guerrillaFilming" in props and props["guerrillaFilming"] is not None:
            if not isinstance(props["guerrillaFilming"], bool):
                try:
                    # Attempt to convert
                    props["guerrillaFilming"] = bool(props["guerrillaFilming"])
                except:
                    raise TypeError(f"Property guerrillaFilming must be of type bool, got {type(props['guerrillaFilming']).__name__}")
    
        # Type check replicas (expected object)
        if "replicas" in props and props["replicas"] is not None:
            if not isinstance(props["replicas"], object):
                try:
                    # Attempt to convert
                    props["replicas"] = object(props["replicas"])
                except:
                    raise TypeError(f"Property replicas must be of type object, got {type(props['replicas']).__name__}")
    
        # Type check setLocation (expected str)
        if "setLocation" in props and props["setLocation"] is not None:
            if not isinstance(props["setLocation"], str):
                try:
                    # Attempt to convert
                    props["setLocation"] = str(props["setLocation"])
                except:
                    raise TypeError(f"Property setLocation must be of type str, got {type(props['setLocation']).__name__}")
    
        # Type check castingDisputes (expected str)
        if "castingDisputes" in props and props["castingDisputes"] is not None:
            if not isinstance(props["castingDisputes"], str):
                try:
                    # Attempt to convert
                    props["castingDisputes"] = str(props["castingDisputes"])
                except:
                    raise TypeError(f"Property castingDisputes must be of type str, got {type(props['castingDisputes']).__name__}")
    
        # Type check studioInterference (expected str)
        if "studioInterference" in props and props["studioInterference"] is not None:
            if not isinstance(props["studioInterference"], str):
                try:
                    # Attempt to convert
                    props["studioInterference"] = str(props["studioInterference"])
                except:
                    raise TypeError(f"Property studioInterference must be of type str, got {type(props['studioInterference']).__name__}")
    
        # Type check citiesFilmed (expected object)
        if "citiesFilmed" in props and props["citiesFilmed"] is not None:
            if not isinstance(props["citiesFilmed"], object):
                try:
                    # Attempt to convert
                    props["citiesFilmed"] = object(props["citiesFilmed"])
                except:
                    raise TypeError(f"Property citiesFilmed must be of type object, got {type(props['citiesFilmed']).__name__}")
    
        # Type check iMAXCameras (expected int)
        if "iMAXCameras" in props and props["iMAXCameras"] is not None:
            if not isinstance(props["iMAXCameras"], int):
                try:
                    # Attempt to convert
                    props["iMAXCameras"] = int(props["iMAXCameras"])
                except:
                    raise TypeError(f"Property iMAXCameras must be of type int, got {type(props['iMAXCameras']).__name__}")
    
        # Type check independentFilming (expected bool)
        if "independentFilming" in props and props["independentFilming"] is not None:
            if not isinstance(props["independentFilming"], bool):
                try:
                    # Attempt to convert
                    props["independentFilming"] = bool(props["independentFilming"])
                except:
                    raise TypeError(f"Property independentFilming must be of type bool, got {type(props['independentFilming']).__name__}")
    
        # Type check filmingDays (expected int)
        if "filmingDays" in props and props["filmingDays"] is not None:
            if not isinstance(props["filmingDays"], int):
                try:
                    # Attempt to convert
                    props["filmingDays"] = int(props["filmingDays"])
                except:
                    raise TypeError(f"Property filmingDays must be of type int, got {type(props['filmingDays']).__name__}")
    
        # Type check challengingLocations (expected object)
        if "challengingLocations" in props and props["challengingLocations"] is not None:
            if not isinstance(props["challengingLocations"], object):
                try:
                    # Attempt to convert
                    props["challengingLocations"] = object(props["challengingLocations"])
                except:
                    raise TypeError(f"Property challengingLocations must be of type object, got {type(props['challengingLocations']).__name__}")
    
        # Type check wireworkDays (expected int)
        if "wireworkDays" in props and props["wireworkDays"] is not None:
            if not isinstance(props["wireworkDays"], int):
                try:
                    # Attempt to convert
                    props["wireworkDays"] = int(props["wireworkDays"])
                except:
                    raise TypeError(f"Property wireworkDays must be of type int, got {type(props['wireworkDays']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Production", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def review(uuid=None, **props):
        """
        Find nodes with label Review matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check readerLocationsLong (expected object)
        if "readerLocationsLong" in props and props["readerLocationsLong"] is not None:
            if not isinstance(props["readerLocationsLong"], object):
                try:
                    # Attempt to convert
                    props["readerLocationsLong"] = object(props["readerLocationsLong"])
                except:
                    raise TypeError(f"Property readerLocationsLong must be of type object, got {type(props['readerLocationsLong']).__name__}")
    
        # Type check readerLocationsLat (expected object)
        if "readerLocationsLat" in props and props["readerLocationsLat"] is not None:
            if not isinstance(props["readerLocationsLat"], object):
                try:
                    # Attempt to convert
                    props["readerLocationsLat"] = object(props["readerLocationsLat"])
                except:
                    raise TypeError(f"Property readerLocationsLat must be of type object, got {type(props['readerLocationsLat']).__name__}")
    
        # Type check title (expected str)
        if "title" in props and props["title"] is not None:
            if not isinstance(props["title"], str):
                try:
                    # Attempt to convert
                    props["title"] = str(props["title"])
                except:
                    raise TypeError(f"Property title must be of type str, got {type(props['title']).__name__}")
    
        # Type check aspectDirection (expected float)
        if "aspectDirection" in props and props["aspectDirection"] is not None:
            if not isinstance(props["aspectDirection"], float):
                try:
                    # Attempt to convert
                    props["aspectDirection"] = float(props["aspectDirection"])
                except:
                    raise TypeError(f"Property aspectDirection must be of type float, got {type(props['aspectDirection']).__name__}")
    
        # Type check commentTimestamps (expected list)
        if "commentTimestamps" in props and props["commentTimestamps"] is not None:
            if not isinstance(props["commentTimestamps"], list):
                try:
                    # Attempt to convert
                    props["commentTimestamps"] = list(props["commentTimestamps"])
                except:
                    raise TypeError(f"Property commentTimestamps must be of type list, got {type(props['commentTimestamps']).__name__}")
    
        # Type check keywords (expected object)
        if "keywords" in props and props["keywords"] is not None:
            if not isinstance(props["keywords"], object):
                try:
                    # Attempt to convert
                    props["keywords"] = object(props["keywords"])
                except:
                    raise TypeError(f"Property keywords must be of type object, got {type(props['keywords']).__name__}")
    
        # Type check stars (expected float)
        if "stars" in props and props["stars"] is not None:
            if not isinstance(props["stars"], float):
                try:
                    # Attempt to convert
                    props["stars"] = float(props["stars"])
                except:
                    raise TypeError(f"Property stars must be of type float, got {type(props['stars']).__name__}")
    
        # Type check time (expected object)
        if "time" in props and props["time"] is not None:
            if not isinstance(props["time"], object):
                try:
                    # Attempt to convert
                    props["time"] = object(props["time"])
                except:
                    raise TypeError(f"Property time must be of type object, got {type(props['time']).__name__}")
    
        # Type check aspectMusic (expected float)
        if "aspectMusic" in props and props["aspectMusic"] is not None:
            if not isinstance(props["aspectMusic"], float):
                try:
                    # Attempt to convert
                    props["aspectMusic"] = float(props["aspectMusic"])
                except:
                    raise TypeError(f"Property aspectMusic must be of type float, got {type(props['aspectMusic']).__name__}")
    
        # Type check aspectPlot (expected float)
        if "aspectPlot" in props and props["aspectPlot"] is not None:
            if not isinstance(props["aspectPlot"], float):
                try:
                    # Attempt to convert
                    props["aspectPlot"] = float(props["aspectPlot"])
                except:
                    raise TypeError(f"Property aspectPlot must be of type float, got {type(props['aspectPlot']).__name__}")
    
        # Type check aspectVisuals (expected float)
        if "aspectVisuals" in props and props["aspectVisuals"] is not None:
            if not isinstance(props["aspectVisuals"], float):
                try:
                    # Attempt to convert
                    props["aspectVisuals"] = float(props["aspectVisuals"])
                except:
                    raise TypeError(f"Property aspectVisuals must be of type float, got {type(props['aspectVisuals']).__name__}")
    
        # Type check isVerified (expected bool)
        if "isVerified" in props and props["isVerified"] is not None:
            if not isinstance(props["isVerified"], bool):
                try:
                    # Attempt to convert
                    props["isVerified"] = bool(props["isVerified"])
                except:
                    raise TypeError(f"Property isVerified must be of type bool, got {type(props['isVerified']).__name__}")
    
        # Type check reviewText (expected str)
        if "reviewText" in props and props["reviewText"] is not None:
            if not isinstance(props["reviewText"], str):
                try:
                    # Attempt to convert
                    props["reviewText"] = str(props["reviewText"])
                except:
                    raise TypeError(f"Property reviewText must be of type str, got {type(props['reviewText']).__name__}")
    
        # Type check date (expected object)
        if "date" in props and props["date"] is not None:
            if not isinstance(props["date"], object):
                try:
                    # Attempt to convert
                    props["date"] = object(props["date"])
                except:
                    raise TypeError(f"Property date must be of type object, got {type(props['date']).__name__}")
    
        # Type check aspectActing (expected float)
        if "aspectActing" in props and props["aspectActing"] is not None:
            if not isinstance(props["aspectActing"], float):
                try:
                    # Attempt to convert
                    props["aspectActing"] = float(props["aspectActing"])
                except:
                    raise TypeError(f"Property aspectActing must be of type float, got {type(props['aspectActing']).__name__}")
    
        # Type check upvotes (expected int)
        if "upvotes" in props and props["upvotes"] is not None:
            if not isinstance(props["upvotes"], int):
                try:
                    # Attempt to convert
                    props["upvotes"] = int(props["upvotes"])
                except:
                    raise TypeError(f"Property upvotes must be of type int, got {type(props['upvotes']).__name__}")
    
        # Type check aspectVoiceActing (expected float)
        if "aspectVoiceActing" in props and props["aspectVoiceActing"] is not None:
            if not isinstance(props["aspectVoiceActing"], float):
                try:
                    # Attempt to convert
                    props["aspectVoiceActing"] = float(props["aspectVoiceActing"])
                except:
                    raise TypeError(f"Property aspectVoiceActing must be of type float, got {type(props['aspectVoiceActing']).__name__}")
    
        # Type check aspectAnimation (expected float)
        if "aspectAnimation" in props and props["aspectAnimation"] is not None:
            if not isinstance(props["aspectAnimation"], float):
                try:
                    # Attempt to convert
                    props["aspectAnimation"] = float(props["aspectAnimation"])
                except:
                    raise TypeError(f"Property aspectAnimation must be of type float, got {type(props['aspectAnimation']).__name__}")
    
        # Type check academicCitations (expected int)
        if "academicCitations" in props and props["academicCitations"] is not None:
            if not isinstance(props["academicCitations"], int):
                try:
                    # Attempt to convert
                    props["academicCitations"] = int(props["academicCitations"])
                except:
                    raise TypeError(f"Property academicCitations must be of type int, got {type(props['academicCitations']).__name__}")
    
        # Type check modernReassessmentDates (expected list)
        if "modernReassessmentDates" in props and props["modernReassessmentDates"] is not None:
            if not isinstance(props["modernReassessmentDates"], list):
                try:
                    # Attempt to convert
                    props["modernReassessmentDates"] = list(props["modernReassessmentDates"])
                except:
                    raise TypeError(f"Property modernReassessmentDates must be of type list, got {type(props['modernReassessmentDates']).__name__}")
    
        # Type check sightAndSoundRankings (expected object)
        if "sightAndSoundRankings" in props and props["sightAndSoundRankings"] is not None:
            if not isinstance(props["sightAndSoundRankings"], object):
                try:
                    # Attempt to convert
                    props["sightAndSoundRankings"] = object(props["sightAndSoundRankings"])
                except:
                    raise TypeError(f"Property sightAndSoundRankings must be of type object, got {type(props['sightAndSoundRankings']).__name__}")
    
        # Type check rankingYears (expected object)
        if "rankingYears" in props and props["rankingYears"] is not None:
            if not isinstance(props["rankingYears"], object):
                try:
                    # Attempt to convert
                    props["rankingYears"] = object(props["rankingYears"])
                except:
                    raise TypeError(f"Property rankingYears must be of type object, got {type(props['rankingYears']).__name__}")
    
        # Type check historicalReassessmentDate (expected object)
        if "historicalReassessmentDate" in props and props["historicalReassessmentDate"] is not None:
            if not isinstance(props["historicalReassessmentDate"], object):
                try:
                    # Attempt to convert
                    props["historicalReassessmentDate"] = object(props["historicalReassessmentDate"])
                except:
                    raise TypeError(f"Property historicalReassessmentDate must be of type object, got {type(props['historicalReassessmentDate']).__name__}")
    
        # Type check aspectWriting (expected float)
        if "aspectWriting" in props and props["aspectWriting"] is not None:
            if not isinstance(props["aspectWriting"], float):
                try:
                    # Attempt to convert
                    props["aspectWriting"] = float(props["aspectWriting"])
                except:
                    raise TypeError(f"Property aspectWriting must be of type float, got {type(props['aspectWriting']).__name__}")
    
        # Type check aspectInnovation (expected float)
        if "aspectInnovation" in props and props["aspectInnovation"] is not None:
            if not isinstance(props["aspectInnovation"], float):
                try:
                    # Attempt to convert
                    props["aspectInnovation"] = float(props["aspectInnovation"])
                except:
                    raise TypeError(f"Property aspectInnovation must be of type float, got {type(props['aspectInnovation']).__name__}")
    
        # Type check historicalRelevance (expected str)
        if "historicalRelevance" in props and props["historicalRelevance"] is not None:
            if not isinstance(props["historicalRelevance"], str):
                try:
                    # Attempt to convert
                    props["historicalRelevance"] = str(props["historicalRelevance"])
                except:
                    raise TypeError(f"Property historicalRelevance must be of type str, got {type(props['historicalRelevance']).__name__}")
    
        # Type check aspectSocialCommentary (expected float)
        if "aspectSocialCommentary" in props and props["aspectSocialCommentary"] is not None:
            if not isinstance(props["aspectSocialCommentary"], float):
                try:
                    # Attempt to convert
                    props["aspectSocialCommentary"] = float(props["aspectSocialCommentary"])
                except:
                    raise TypeError(f"Property aspectSocialCommentary must be of type float, got {type(props['aspectSocialCommentary']).__name__}")
    
        # Type check translationLanguages (expected object)
        if "translationLanguages" in props and props["translationLanguages"] is not None:
            if not isinstance(props["translationLanguages"], object):
                try:
                    # Attempt to convert
                    props["translationLanguages"] = object(props["translationLanguages"])
                except:
                    raise TypeError(f"Property translationLanguages must be of type object, got {type(props['translationLanguages']).__name__}")
    
        # Type check familyRecommendationScore (expected float)
        if "familyRecommendationScore" in props and props["familyRecommendationScore"] is not None:
            if not isinstance(props["familyRecommendationScore"], float):
                try:
                    # Attempt to convert
                    props["familyRecommendationScore"] = float(props["familyRecommendationScore"])
                except:
                    raise TypeError(f"Property familyRecommendationScore must be of type float, got {type(props['familyRecommendationScore']).__name__}")
    
        # Type check aspectCinematography (expected float)
        if "aspectCinematography" in props and props["aspectCinematography"] is not None:
            if not isinstance(props["aspectCinematography"], float):
                try:
                    # Attempt to convert
                    props["aspectCinematography"] = float(props["aspectCinematography"])
                except:
                    raise TypeError(f"Property aspectCinematography must be of type float, got {type(props['aspectCinematography']).__name__}")
    
        # Type check aspectEducationalValue (expected float)
        if "aspectEducationalValue" in props and props["aspectEducationalValue"] is not None:
            if not isinstance(props["aspectEducationalValue"], float):
                try:
                    # Attempt to convert
                    props["aspectEducationalValue"] = float(props["aspectEducationalValue"])
                except:
                    raise TypeError(f"Property aspectEducationalValue must be of type float, got {type(props['aspectEducationalValue']).__name__}")
    
        # Type check aspectNarration (expected float)
        if "aspectNarration" in props and props["aspectNarration"] is not None:
            if not isinstance(props["aspectNarration"], float):
                try:
                    # Attempt to convert
                    props["aspectNarration"] = float(props["aspectNarration"])
                except:
                    raise TypeError(f"Property aspectNarration must be of type float, got {type(props['aspectNarration']).__name__}")
    
        # Type check aspectEmotionalImpact (expected float)
        if "aspectEmotionalImpact" in props and props["aspectEmotionalImpact"] is not None:
            if not isinstance(props["aspectEmotionalImpact"], float):
                try:
                    # Attempt to convert
                    props["aspectEmotionalImpact"] = float(props["aspectEmotionalImpact"])
                except:
                    raise TypeError(f"Property aspectEmotionalImpact must be of type float, got {type(props['aspectEmotionalImpact']).__name__}")
    
        # Type check assessmentYears (expected object)
        if "assessmentYears" in props and props["assessmentYears"] is not None:
            if not isinstance(props["assessmentYears"], object):
                try:
                    # Attempt to convert
                    props["assessmentYears"] = object(props["assessmentYears"])
                except:
                    raise TypeError(f"Property assessmentYears must be of type object, got {type(props['assessmentYears']).__name__}")
    
        # Type check historicalSignificanceRatings (expected object)
        if "historicalSignificanceRatings" in props and props["historicalSignificanceRatings"] is not None:
            if not isinstance(props["historicalSignificanceRatings"], object):
                try:
                    # Attempt to convert
                    props["historicalSignificanceRatings"] = object(props["historicalSignificanceRatings"])
                except:
                    raise TypeError(f"Property historicalSignificanceRatings must be of type object, got {type(props['historicalSignificanceRatings']).__name__}")
    
        # Type check culturalImpactAssessments (expected list)
        if "culturalImpactAssessments" in props and props["culturalImpactAssessments"] is not None:
            if not isinstance(props["culturalImpactAssessments"], list):
                try:
                    # Attempt to convert
                    props["culturalImpactAssessments"] = list(props["culturalImpactAssessments"])
                except:
                    raise TypeError(f"Property culturalImpactAssessments must be of type list, got {type(props['culturalImpactAssessments']).__name__}")
    
        # Type check culturalImpact (expected str)
        if "culturalImpact" in props and props["culturalImpact"] is not None:
            if not isinstance(props["culturalImpact"], str):
                try:
                    # Attempt to convert
                    props["culturalImpact"] = str(props["culturalImpact"])
                except:
                    raise TypeError(f"Property culturalImpact must be of type str, got {type(props['culturalImpact']).__name__}")
    
        # Type check influenceRatings (expected object)
        if "influenceRatings" in props and props["influenceRatings"] is not None:
            if not isinstance(props["influenceRatings"], object):
                try:
                    # Attempt to convert
                    props["influenceRatings"] = object(props["influenceRatings"])
                except:
                    raise TypeError(f"Property influenceRatings must be of type object, got {type(props['influenceRatings']).__name__}")
    
        # Type check filmSchoolReferences (expected int)
        if "filmSchoolReferences" in props and props["filmSchoolReferences"] is not None:
            if not isinstance(props["filmSchoolReferences"], int):
                try:
                    # Attempt to convert
                    props["filmSchoolReferences"] = int(props["filmSchoolReferences"])
                except:
                    raise TypeError(f"Property filmSchoolReferences must be of type int, got {type(props['filmSchoolReferences']).__name__}")
    
        # Type check aspectTension (expected float)
        if "aspectTension" in props and props["aspectTension"] is not None:
            if not isinstance(props["aspectTension"], float):
                try:
                    # Attempt to convert
                    props["aspectTension"] = float(props["aspectTension"])
                except:
                    raise TypeError(f"Property aspectTension must be of type float, got {type(props['aspectTension']).__name__}")
    
        # Type check historicalReassessments (expected list)
        if "historicalReassessments" in props and props["historicalReassessments"] is not None:
            if not isinstance(props["historicalReassessments"], list):
                try:
                    # Attempt to convert
                    props["historicalReassessments"] = list(props["historicalReassessments"])
                except:
                    raise TypeError(f"Property historicalReassessments must be of type list, got {type(props['historicalReassessments']).__name__}")
    
        # Type check aspectWorldBuilding (expected float)
        if "aspectWorldBuilding" in props and props["aspectWorldBuilding"] is not None:
            if not isinstance(props["aspectWorldBuilding"], float):
                try:
                    # Attempt to convert
                    props["aspectWorldBuilding"] = float(props["aspectWorldBuilding"])
                except:
                    raise TypeError(f"Property aspectWorldBuilding must be of type float, got {type(props['aspectWorldBuilding']).__name__}")
    
        # Type check aspectCulturalImpact (expected float)
        if "aspectCulturalImpact" in props and props["aspectCulturalImpact"] is not None:
            if not isinstance(props["aspectCulturalImpact"], float):
                try:
                    # Attempt to convert
                    props["aspectCulturalImpact"] = float(props["aspectCulturalImpact"])
                except:
                    raise TypeError(f"Property aspectCulturalImpact must be of type float, got {type(props['aspectCulturalImpact']).__name__}")
    
        # Type check aspectAtmosphere (expected float)
        if "aspectAtmosphere" in props and props["aspectAtmosphere"] is not None:
            if not isinstance(props["aspectAtmosphere"], float):
                try:
                    # Attempt to convert
                    props["aspectAtmosphere"] = float(props["aspectAtmosphere"])
                except:
                    raise TypeError(f"Property aspectAtmosphere must be of type float, got {type(props['aspectAtmosphere']).__name__}")
    
        # Type check aspectSubtlety (expected float)
        if "aspectSubtlety" in props and props["aspectSubtlety"] is not None:
            if not isinstance(props["aspectSubtlety"], float):
                try:
                    # Attempt to convert
                    props["aspectSubtlety"] = float(props["aspectSubtlety"])
                except:
                    raise TypeError(f"Property aspectSubtlety must be of type float, got {type(props['aspectSubtlety']).__name__}")
    
        # Type check aspectMusicScore (expected float)
        if "aspectMusicScore" in props and props["aspectMusicScore"] is not None:
            if not isinstance(props["aspectMusicScore"], float):
                try:
                    # Attempt to convert
                    props["aspectMusicScore"] = float(props["aspectMusicScore"])
                except:
                    raise TypeError(f"Property aspectMusicScore must be of type float, got {type(props['aspectMusicScore']).__name__}")
    
        # Type check aspectScore (expected float)
        if "aspectScore" in props and props["aspectScore"] is not None:
            if not isinstance(props["aspectScore"], float):
                try:
                    # Attempt to convert
                    props["aspectScore"] = float(props["aspectScore"])
                except:
                    raise TypeError(f"Property aspectScore must be of type float, got {type(props['aspectScore']).__name__}")
    
        # Type check aspectDialogue (expected float)
        if "aspectDialogue" in props and props["aspectDialogue"] is not None:
            if not isinstance(props["aspectDialogue"], float):
                try:
                    # Attempt to convert
                    props["aspectDialogue"] = float(props["aspectDialogue"])
                except:
                    raise TypeError(f"Property aspectDialogue must be of type float, got {type(props['aspectDialogue']).__name__}")
    
        # Type check aspectStructure (expected float)
        if "aspectStructure" in props and props["aspectStructure"] is not None:
            if not isinstance(props["aspectStructure"], float):
                try:
                    # Attempt to convert
                    props["aspectStructure"] = float(props["aspectStructure"])
                except:
                    raise TypeError(f"Property aspectStructure must be of type float, got {type(props['aspectStructure']).__name__}")
    
        # Type check aspectEmotionalDepth (expected float)
        if "aspectEmotionalDepth" in props and props["aspectEmotionalDepth"] is not None:
            if not isinstance(props["aspectEmotionalDepth"], float):
                try:
                    # Attempt to convert
                    props["aspectEmotionalDepth"] = float(props["aspectEmotionalDepth"])
                except:
                    raise TypeError(f"Property aspectEmotionalDepth must be of type float, got {type(props['aspectEmotionalDepth']).__name__}")
    
        # Type check aspectMartialArts (expected float)
        if "aspectMartialArts" in props and props["aspectMartialArts"] is not None:
            if not isinstance(props["aspectMartialArts"], float):
                try:
                    # Attempt to convert
                    props["aspectMartialArts"] = float(props["aspectMartialArts"])
                except:
                    raise TypeError(f"Property aspectMartialArts must be of type float, got {type(props['aspectMartialArts']).__name__}")
    
        # Type check wordCount (expected int)
        if "wordCount" in props and props["wordCount"] is not None:
            if not isinstance(props["wordCount"], int):
                try:
                    # Attempt to convert
                    props["wordCount"] = int(props["wordCount"])
                except:
                    raise TypeError(f"Property wordCount must be of type int, got {type(props['wordCount']).__name__}")
    
        # Type check criticalInfluence (expected str)
        if "criticalInfluence" in props and props["criticalInfluence"] is not None:
            if not isinstance(props["criticalInfluence"], str):
                try:
                    # Attempt to convert
                    props["criticalInfluence"] = str(props["criticalInfluence"])
                except:
                    raise TypeError(f"Property criticalInfluence must be of type str, got {type(props['criticalInfluence']).__name__}")
    
        # Type check author (expected str)
        if "author" in props and props["author"] is not None:
            if not isinstance(props["author"], str):
                try:
                    # Attempt to convert
                    props["author"] = str(props["author"])
                except:
                    raise TypeError(f"Property author must be of type str, got {type(props['author']).__name__}")
    
        # Type check publication (expected str)
        if "publication" in props and props["publication"] is not None:
            if not isinstance(props["publication"], str):
                try:
                    # Attempt to convert
                    props["publication"] = str(props["publication"])
                except:
                    raise TypeError(f"Property publication must be of type str, got {type(props['publication']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Review", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def generatedbyclaudeai(uuid=None, **props):
        """
        Find nodes with label GeneratedByClaudeAI matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check dreamLevels (expected int)
        if "dreamLevels" in props and props["dreamLevels"] is not None:
            if not isinstance(props["dreamLevels"], int):
                try:
                    # Attempt to convert
                    props["dreamLevels"] = int(props["dreamLevels"])
                except:
                    raise TypeError(f"Property dreamLevels must be of type int, got {type(props['dreamLevels']).__name__}")
    
        # Type check boxOfficeNA (expected int)
        if "boxOfficeNA" in props and props["boxOfficeNA"] is not None:
            if not isinstance(props["boxOfficeNA"], int):
                try:
                    # Attempt to convert
                    props["boxOfficeNA"] = int(props["boxOfficeNA"])
                except:
                    raise TypeError(f"Property boxOfficeNA must be of type int, got {type(props['boxOfficeNA']).__name__}")
    
        # Type check boxOfficeEurope (expected int)
        if "boxOfficeEurope" in props and props["boxOfficeEurope"] is not None:
            if not isinstance(props["boxOfficeEurope"], int):
                try:
                    # Attempt to convert
                    props["boxOfficeEurope"] = int(props["boxOfficeEurope"])
                except:
                    raise TypeError(f"Property boxOfficeEurope must be of type int, got {type(props['boxOfficeEurope']).__name__}")
    
        # Type check boxOfficeAsia (expected int)
        if "boxOfficeAsia" in props and props["boxOfficeAsia"] is not None:
            if not isinstance(props["boxOfficeAsia"], int):
                try:
                    # Attempt to convert
                    props["boxOfficeAsia"] = int(props["boxOfficeAsia"])
                except:
                    raise TypeError(f"Property boxOfficeAsia must be of type int, got {type(props['boxOfficeAsia']).__name__}")
    
        # Type check boxOfficeOther (expected int)
        if "boxOfficeOther" in props and props["boxOfficeOther"] is not None:
            if not isinstance(props["boxOfficeOther"], int):
                try:
                    # Attempt to convert
                    props["boxOfficeOther"] = int(props["boxOfficeOther"])
                except:
                    raise TypeError(f"Property boxOfficeOther must be of type int, got {type(props['boxOfficeOther']).__name__}")
    
        # Type check filmingLocationLong (expected object)
        if "filmingLocationLong" in props and props["filmingLocationLong"] is not None:
            if not isinstance(props["filmingLocationLong"], object):
                try:
                    # Attempt to convert
                    props["filmingLocationLong"] = object(props["filmingLocationLong"])
                except:
                    raise TypeError(f"Property filmingLocationLong must be of type object, got {type(props['filmingLocationLong']).__name__}")
    
        # Type check filmingLocationLat (expected object)
        if "filmingLocationLat" in props and props["filmingLocationLat"] is not None:
            if not isinstance(props["filmingLocationLat"], object):
                try:
                    # Attempt to convert
                    props["filmingLocationLat"] = object(props["filmingLocationLat"])
                except:
                    raise TypeError(f"Property filmingLocationLat must be of type object, got {type(props['filmingLocationLat']).__name__}")
    
        # Type check budget (expected int)
        if "budget" in props and props["budget"] is not None:
            if not isinstance(props["budget"], int):
                try:
                    # Attempt to convert
                    props["budget"] = int(props["budget"])
                except:
                    raise TypeError(f"Property budget must be of type int, got {type(props['budget']).__name__}")
    
        # Type check certifications (expected object)
        if "certifications" in props and props["certifications"] is not None:
            if not isinstance(props["certifications"], object):
                try:
                    # Attempt to convert
                    props["certifications"] = object(props["certifications"])
                except:
                    raise TypeError(f"Property certifications must be of type object, got {type(props['certifications']).__name__}")
    
        # Type check genres (expected object)
        if "genres" in props and props["genres"] is not None:
            if not isinstance(props["genres"], object):
                try:
                    # Attempt to convert
                    props["genres"] = object(props["genres"])
                except:
                    raise TypeError(f"Property genres must be of type object, got {type(props['genres']).__name__}")
    
        # Type check ratings (expected object)
        if "ratings" in props and props["ratings"] is not None:
            if not isinstance(props["ratings"], object):
                try:
                    # Attempt to convert
                    props["ratings"] = object(props["ratings"])
                except:
                    raise TypeError(f"Property ratings must be of type object, got {type(props['ratings']).__name__}")
    
        # Type check tagline (expected str)
        if "tagline" in props and props["tagline"] is not None:
            if not isinstance(props["tagline"], str):
                try:
                    # Attempt to convert
                    props["tagline"] = str(props["tagline"])
                except:
                    raise TypeError(f"Property tagline must be of type str, got {type(props['tagline']).__name__}")
    
        # Type check digitalRelease (expected object)
        if "digitalRelease" in props and props["digitalRelease"] is not None:
            if not isinstance(props["digitalRelease"], object):
                try:
                    # Attempt to convert
                    props["digitalRelease"] = object(props["digitalRelease"])
                except:
                    raise TypeError(f"Property digitalRelease must be of type object, got {type(props['digitalRelease']).__name__}")
    
        # Type check released (expected object)
        if "released" in props and props["released"] is not None:
            if not isinstance(props["released"], object):
                try:
                    # Attempt to convert
                    props["released"] = object(props["released"])
                except:
                    raise TypeError(f"Property released must be of type object, got {type(props['released']).__name__}")
    
        # Type check rating_avg (expected float)
        if "rating_avg" in props and props["rating_avg"] is not None:
            if not isinstance(props["rating_avg"], float):
                try:
                    # Attempt to convert
                    props["rating_avg"] = float(props["rating_avg"])
                except:
                    raise TypeError(f"Property rating_avg must be of type float, got {type(props['rating_avg']).__name__}")
    
        # Type check title (expected str)
        if "title" in props and props["title"] is not None:
            if not isinstance(props["title"], str):
                try:
                    # Attempt to convert
                    props["title"] = str(props["title"])
                except:
                    raise TypeError(f"Property title must be of type str, got {type(props['title']).__name__}")
    
        # Type check runtime_minutes (expected int)
        if "runtime_minutes" in props and props["runtime_minutes"] is not None:
            if not isinstance(props["runtime_minutes"], int):
                try:
                    # Attempt to convert
                    props["runtime_minutes"] = int(props["runtime_minutes"])
                except:
                    raise TypeError(f"Property runtime_minutes must be of type int, got {type(props['runtime_minutes']).__name__}")
    
        # Type check revenue (expected int)
        if "revenue" in props and props["revenue"] is not None:
            if not isinstance(props["revenue"], int):
                try:
                    # Attempt to convert
                    props["revenue"] = int(props["revenue"])
                except:
                    raise TypeError(f"Property revenue must be of type int, got {type(props['revenue']).__name__}")
    
        # Type check releaseDate (expected object)
        if "releaseDate" in props and props["releaseDate"] is not None:
            if not isinstance(props["releaseDate"], object):
                try:
                    # Attempt to convert
                    props["releaseDate"] = object(props["releaseDate"])
                except:
                    raise TypeError(f"Property releaseDate must be of type object, got {type(props['releaseDate']).__name__}")
    
        # Type check isOscarWinner (expected bool)
        if "isOscarWinner" in props and props["isOscarWinner"] is not None:
            if not isinstance(props["isOscarWinner"], bool):
                try:
                    # Attempt to convert
                    props["isOscarWinner"] = bool(props["isOscarWinner"])
                except:
                    raise TypeError(f"Property isOscarWinner must be of type bool, got {type(props['isOscarWinner']).__name__}")
    
        # Type check residenceLat (expected float)
        if "residenceLat" in props and props["residenceLat"] is not None:
            if not isinstance(props["residenceLat"], float):
                try:
                    # Attempt to convert
                    props["residenceLat"] = float(props["residenceLat"])
                except:
                    raise TypeError(f"Property residenceLat must be of type float, got {type(props['residenceLat']).__name__}")
    
        # Type check activeYears (expected object)
        if "activeYears" in props and props["activeYears"] is not None:
            if not isinstance(props["activeYears"], object):
                try:
                    # Attempt to convert
                    props["activeYears"] = object(props["activeYears"])
                except:
                    raise TypeError(f"Property activeYears must be of type object, got {type(props['activeYears']).__name__}")
    
        # Type check typicalFilmLengthHrs (expected float)
        if "typicalFilmLengthHrs" in props and props["typicalFilmLengthHrs"] is not None:
            if not isinstance(props["typicalFilmLengthHrs"], float):
                try:
                    # Attempt to convert
                    props["typicalFilmLengthHrs"] = float(props["typicalFilmLengthHrs"])
                except:
                    raise TypeError(f"Property typicalFilmLengthHrs must be of type float, got {type(props['typicalFilmLengthHrs']).__name__}")
    
        # Type check oscarNominations (expected int)
        if "oscarNominations" in props and props["oscarNominations"] is not None:
            if not isinstance(props["oscarNominations"], int):
                try:
                    # Attempt to convert
                    props["oscarNominations"] = int(props["oscarNominations"])
                except:
                    raise TypeError(f"Property oscarNominations must be of type int, got {type(props['oscarNominations']).__name__}")
    
        # Type check nationality (expected str)
        if "nationality" in props and props["nationality"] is not None:
            if not isinstance(props["nationality"], str):
                try:
                    # Attempt to convert
                    props["nationality"] = str(props["nationality"])
                except:
                    raise TypeError(f"Property nationality must be of type str, got {type(props['nationality']).__name__}")
    
        # Type check isActive (expected bool)
        if "isActive" in props and props["isActive"] is not None:
            if not isinstance(props["isActive"], bool):
                try:
                    # Attempt to convert
                    props["isActive"] = bool(props["isActive"])
                except:
                    raise TypeError(f"Property isActive must be of type bool, got {type(props['isActive']).__name__}")
    
        # Type check lastDirected (expected object)
        if "lastDirected" in props and props["lastDirected"] is not None:
            if not isinstance(props["lastDirected"], object):
                try:
                    # Attempt to convert
                    props["lastDirected"] = object(props["lastDirected"])
                except:
                    raise TypeError(f"Property lastDirected must be of type object, got {type(props['lastDirected']).__name__}")
    
        # Type check birthdate (expected object)
        if "birthdate" in props and props["birthdate"] is not None:
            if not isinstance(props["birthdate"], object):
                try:
                    # Attempt to convert
                    props["birthdate"] = object(props["birthdate"])
                except:
                    raise TypeError(f"Property birthdate must be of type object, got {type(props['birthdate']).__name__}")
    
        # Type check born (expected int)
        if "born" in props and props["born"] is not None:
            if not isinstance(props["born"], int):
                try:
                    # Attempt to convert
                    props["born"] = int(props["born"])
                except:
                    raise TypeError(f"Property born must be of type int, got {type(props['born']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check residenceLong (expected float)
        if "residenceLong" in props and props["residenceLong"] is not None:
            if not isinstance(props["residenceLong"], float):
                try:
                    # Attempt to convert
                    props["residenceLong"] = float(props["residenceLong"])
                except:
                    raise TypeError(f"Property residenceLong must be of type float, got {type(props['residenceLong']).__name__}")
    
        # Type check preferredAspectRatios (expected object)
        if "preferredAspectRatios" in props and props["preferredAspectRatios"] is not None:
            if not isinstance(props["preferredAspectRatios"], object):
                try:
                    # Attempt to convert
                    props["preferredAspectRatios"] = object(props["preferredAspectRatios"])
                except:
                    raise TypeError(f"Property preferredAspectRatios must be of type object, got {type(props['preferredAspectRatios']).__name__}")
    
        # Type check collaborators (expected object)
        if "collaborators" in props and props["collaborators"] is not None:
            if not isinstance(props["collaborators"], object):
                try:
                    # Attempt to convert
                    props["collaborators"] = object(props["collaborators"])
                except:
                    raise TypeError(f"Property collaborators must be of type object, got {type(props['collaborators']).__name__}")
    
        # Type check filmCountCrime (expected int)
        if "filmCountCrime" in props and props["filmCountCrime"] is not None:
            if not isinstance(props["filmCountCrime"], int):
                try:
                    # Attempt to convert
                    props["filmCountCrime"] = int(props["filmCountCrime"])
                except:
                    raise TypeError(f"Property filmCountCrime must be of type int, got {type(props['filmCountCrime']).__name__}")
    
        # Type check filmCountRomance (expected int)
        if "filmCountRomance" in props and props["filmCountRomance"] is not None:
            if not isinstance(props["filmCountRomance"], int):
                try:
                    # Attempt to convert
                    props["filmCountRomance"] = int(props["filmCountRomance"])
                except:
                    raise TypeError(f"Property filmCountRomance must be of type int, got {type(props['filmCountRomance']).__name__}")
    
        # Type check filmCountWestern (expected int)
        if "filmCountWestern" in props and props["filmCountWestern"] is not None:
            if not isinstance(props["filmCountWestern"], int):
                try:
                    # Attempt to convert
                    props["filmCountWestern"] = int(props["filmCountWestern"])
                except:
                    raise TypeError(f"Property filmCountWestern must be of type int, got {type(props['filmCountWestern']).__name__}")
    
        # Type check residenceLongs (expected object)
        if "residenceLongs" in props and props["residenceLongs"] is not None:
            if not isinstance(props["residenceLongs"], object):
                try:
                    # Attempt to convert
                    props["residenceLongs"] = object(props["residenceLongs"])
                except:
                    raise TypeError(f"Property residenceLongs must be of type object, got {type(props['residenceLongs']).__name__}")
    
        # Type check filmCountThriller (expected int)
        if "filmCountThriller" in props and props["filmCountThriller"] is not None:
            if not isinstance(props["filmCountThriller"], int):
                try:
                    # Attempt to convert
                    props["filmCountThriller"] = int(props["filmCountThriller"])
                except:
                    raise TypeError(f"Property filmCountThriller must be of type int, got {type(props['filmCountThriller']).__name__}")
    
        # Type check residenceLats (expected object)
        if "residenceLats" in props and props["residenceLats"] is not None:
            if not isinstance(props["residenceLats"], object):
                try:
                    # Attempt to convert
                    props["residenceLats"] = object(props["residenceLats"])
                except:
                    raise TypeError(f"Property residenceLats must be of type object, got {type(props['residenceLats']).__name__}")
    
        # Type check filmCountDrama (expected int)
        if "filmCountDrama" in props and props["filmCountDrama"] is not None:
            if not isinstance(props["filmCountDrama"], int):
                try:
                    # Attempt to convert
                    props["filmCountDrama"] = int(props["filmCountDrama"])
                except:
                    raise TypeError(f"Property filmCountDrama must be of type int, got {type(props['filmCountDrama']).__name__}")
    
        # Type check oscarWins (expected int)
        if "oscarWins" in props and props["oscarWins"] is not None:
            if not isinstance(props["oscarWins"], int):
                try:
                    # Attempt to convert
                    props["oscarWins"] = int(props["oscarWins"])
                except:
                    raise TypeError(f"Property oscarWins must be of type int, got {type(props['oscarWins']).__name__}")
    
        # Type check netWorth (expected int)
        if "netWorth" in props and props["netWorth"] is not None:
            if not isinstance(props["netWorth"], int):
                try:
                    # Attempt to convert
                    props["netWorth"] = int(props["netWorth"])
                except:
                    raise TypeError(f"Property netWorth must be of type int, got {type(props['netWorth']).__name__}")
    
        # Type check typicalShootScheduleMonths (expected int)
        if "typicalShootScheduleMonths" in props and props["typicalShootScheduleMonths"] is not None:
            if not isinstance(props["typicalShootScheduleMonths"], int):
                try:
                    # Attempt to convert
                    props["typicalShootScheduleMonths"] = int(props["typicalShootScheduleMonths"])
                except:
                    raise TypeError(f"Property typicalShootScheduleMonths must be of type int, got {type(props['typicalShootScheduleMonths']).__name__}")
    
        # Type check languages (expected object)
        if "languages" in props and props["languages"] is not None:
            if not isinstance(props["languages"], object):
                try:
                    # Attempt to convert
                    props["languages"] = object(props["languages"])
                except:
                    raise TypeError(f"Property languages must be of type object, got {type(props['languages']).__name__}")
    
        # Type check actingRangeScore (expected float)
        if "actingRangeScore" in props and props["actingRangeScore"] is not None:
            if not isinstance(props["actingRangeScore"], float):
                try:
                    # Attempt to convert
                    props["actingRangeScore"] = float(props["actingRangeScore"])
                except:
                    raise TypeError(f"Property actingRangeScore must be of type float, got {type(props['actingRangeScore']).__name__}")
    
        # Type check heightInMeters (expected float)
        if "heightInMeters" in props and props["heightInMeters"] is not None:
            if not isinstance(props["heightInMeters"], float):
                try:
                    # Attempt to convert
                    props["heightInMeters"] = float(props["heightInMeters"])
                except:
                    raise TypeError(f"Property heightInMeters must be of type float, got {type(props['heightInMeters']).__name__}")
    
        # Type check firstOscarWin (expected object)
        if "firstOscarWin" in props and props["firstOscarWin"] is not None:
            if not isinstance(props["firstOscarWin"], object):
                try:
                    # Attempt to convert
                    props["firstOscarWin"] = object(props["firstOscarWin"])
                except:
                    raise TypeError(f"Property firstOscarWin must be of type object, got {type(props['firstOscarWin']).__name__}")
    
        # Type check filmography_roles (expected object)
        if "filmography_roles" in props and props["filmography_roles"] is not None:
            if not isinstance(props["filmography_roles"], object):
                try:
                    # Attempt to convert
                    props["filmography_roles"] = object(props["filmography_roles"])
                except:
                    raise TypeError(f"Property filmography_roles must be of type object, got {type(props['filmography_roles']).__name__}")
    
        # Type check filmography_years (expected object)
        if "filmography_years" in props and props["filmography_years"] is not None:
            if not isinstance(props["filmography_years"], object):
                try:
                    # Attempt to convert
                    props["filmography_years"] = object(props["filmography_years"])
                except:
                    raise TypeError(f"Property filmography_years must be of type object, got {type(props['filmography_years']).__name__}")
    
        # Type check filmography_titles (expected object)
        if "filmography_titles" in props and props["filmography_titles"] is not None:
            if not isinstance(props["filmography_titles"], object):
                try:
                    # Attempt to convert
                    props["filmography_titles"] = object(props["filmography_titles"])
                except:
                    raise TypeError(f"Property filmography_titles must be of type object, got {type(props['filmography_titles']).__name__}")
    
        # Type check typicalDay (expected object)
        if "typicalDay" in props and props["typicalDay"] is not None:
            if not isinstance(props["typicalDay"], object):
                try:
                    # Attempt to convert
                    props["typicalDay"] = object(props["typicalDay"])
                except:
                    raise TypeError(f"Property typicalDay must be of type object, got {type(props['typicalDay']).__name__}")
    
        # Type check oscarCeremony (expected object)
        if "oscarCeremony" in props and props["oscarCeremony"] is not None:
            if not isinstance(props["oscarCeremony"], object):
                try:
                    # Attempt to convert
                    props["oscarCeremony"] = object(props["oscarCeremony"])
                except:
                    raise TypeError(f"Property oscarCeremony must be of type object, got {type(props['oscarCeremony']).__name__}")
    
        # Type check firstFilm (expected object)
        if "firstFilm" in props and props["firstFilm"] is not None:
            if not isinstance(props["firstFilm"], object):
                try:
                    # Attempt to convert
                    props["firstFilm"] = object(props["firstFilm"])
                except:
                    raise TypeError(f"Property firstFilm must be of type object, got {type(props['firstFilm']).__name__}")
    
        # Type check acceptedFilmStart (expected object)
        if "acceptedFilmStart" in props and props["acceptedFilmStart"] is not None:
            if not isinstance(props["acceptedFilmStart"], object):
                try:
                    # Attempt to convert
                    props["acceptedFilmStart"] = object(props["acceptedFilmStart"])
                except:
                    raise TypeError(f"Property acceptedFilmStart must be of type object, got {type(props['acceptedFilmStart']).__name__}")
    
        # Type check height (expected int)
        if "height" in props and props["height"] is not None:
            if not isinstance(props["height"], int):
                try:
                    # Attempt to convert
                    props["height"] = int(props["height"])
                except:
                    raise TypeError(f"Property height must be of type int, got {type(props['height']).__name__}")
    
        # Type check activityDays (expected object)
        if "activityDays" in props and props["activityDays"] is not None:
            if not isinstance(props["activityDays"], object):
                try:
                    # Attempt to convert
                    props["activityDays"] = object(props["activityDays"])
                except:
                    raise TypeError(f"Property activityDays must be of type object, got {type(props['activityDays']).__name__}")
    
        # Type check activityTypes (expected object)
        if "activityTypes" in props and props["activityTypes"] is not None:
            if not isinstance(props["activityTypes"], object):
                try:
                    # Attempt to convert
                    props["activityTypes"] = object(props["activityTypes"])
                except:
                    raise TypeError(f"Property activityTypes must be of type object, got {type(props['activityTypes']).__name__}")
    
        # Type check activityDurations (expected object)
        if "activityDurations" in props and props["activityDurations"] is not None:
            if not isinstance(props["activityDurations"], object):
                try:
                    # Attempt to convert
                    props["activityDurations"] = object(props["activityDurations"])
                except:
                    raise TypeError(f"Property activityDurations must be of type object, got {type(props['activityDurations']).__name__}")
    
        # Type check isCurrentlyFilming (expected bool)
        if "isCurrentlyFilming" in props and props["isCurrentlyFilming"] is not None:
            if not isinstance(props["isCurrentlyFilming"], bool):
                try:
                    # Attempt to convert
                    props["isCurrentlyFilming"] = bool(props["isCurrentlyFilming"])
                except:
                    raise TypeError(f"Property isCurrentlyFilming must be of type bool, got {type(props['isCurrentlyFilming']).__name__}")
    
        # Type check weight (expected float)
        if "weight" in props and props["weight"] is not None:
            if not isinstance(props["weight"], float):
                try:
                    # Attempt to convert
                    props["weight"] = float(props["weight"])
                except:
                    raise TypeError(f"Property weight must be of type float, got {type(props['weight']).__name__}")
    
        # Type check established (expected object)
        if "established" in props and props["established"] is not None:
            if not isinstance(props["established"], object):
                try:
                    # Attempt to convert
                    props["established"] = object(props["established"])
                except:
                    raise TypeError(f"Property established must be of type object, got {type(props['established']).__name__}")
    
        # Type check locationLat (expected float)
        if "locationLat" in props and props["locationLat"] is not None:
            if not isinstance(props["locationLat"], float):
                try:
                    # Attempt to convert
                    props["locationLat"] = float(props["locationLat"])
                except:
                    raise TypeError(f"Property locationLat must be of type float, got {type(props['locationLat']).__name__}")
    
        # Type check viewership2022 (expected int)
        if "viewership2022" in props and props["viewership2022"] is not None:
            if not isinstance(props["viewership2022"], int):
                try:
                    # Attempt to convert
                    props["viewership2022"] = int(props["viewership2022"])
                except:
                    raise TypeError(f"Property viewership2022 must be of type int, got {type(props['viewership2022']).__name__}")
    
        # Type check viewership2023 (expected int)
        if "viewership2023" in props and props["viewership2023"] is not None:
            if not isinstance(props["viewership2023"], int):
                try:
                    # Attempt to convert
                    props["viewership2023"] = int(props["viewership2023"])
                except:
                    raise TypeError(f"Property viewership2023 must be of type int, got {type(props['viewership2023']).__name__}")
    
        # Type check typicalDurationHrs (expected float)
        if "typicalDurationHrs" in props and props["typicalDurationHrs"] is not None:
            if not isinstance(props["typicalDurationHrs"], float):
                try:
                    # Attempt to convert
                    props["typicalDurationHrs"] = float(props["typicalDurationHrs"])
                except:
                    raise TypeError(f"Property typicalDurationHrs must be of type float, got {type(props['typicalDurationHrs']).__name__}")
    
        # Type check viewership2020 (expected int)
        if "viewership2020" in props and props["viewership2020"] is not None:
            if not isinstance(props["viewership2020"], int):
                try:
                    # Attempt to convert
                    props["viewership2020"] = int(props["viewership2020"])
                except:
                    raise TypeError(f"Property viewership2020 must be of type int, got {type(props['viewership2020']).__name__}")
    
        # Type check viewership2021 (expected int)
        if "viewership2021" in props and props["viewership2021"] is not None:
            if not isinstance(props["viewership2021"], int):
                try:
                    # Attempt to convert
                    props["viewership2021"] = int(props["viewership2021"])
                except:
                    raise TypeError(f"Property viewership2021 must be of type int, got {type(props['viewership2021']).__name__}")
    
        # Type check nickname (expected str)
        if "nickname" in props and props["nickname"] is not None:
            if not isinstance(props["nickname"], str):
                try:
                    # Attempt to convert
                    props["nickname"] = str(props["nickname"])
                except:
                    raise TypeError(f"Property nickname must be of type str, got {type(props['nickname']).__name__}")
    
        # Type check locationHeight (expected int)
        if "locationHeight" in props and props["locationHeight"] is not None:
            if not isinstance(props["locationHeight"], int):
                try:
                    # Attempt to convert
                    props["locationHeight"] = int(props["locationHeight"])
                except:
                    raise TypeError(f"Property locationHeight must be of type int, got {type(props['locationHeight']).__name__}")
    
        # Type check categories (expected object)
        if "categories" in props and props["categories"] is not None:
            if not isinstance(props["categories"], object):
                try:
                    # Attempt to convert
                    props["categories"] = object(props["categories"])
                except:
                    raise TypeError(f"Property categories must be of type object, got {type(props['categories']).__name__}")
    
        # Type check isPrestigious (expected bool)
        if "isPrestigious" in props and props["isPrestigious"] is not None:
            if not isinstance(props["isPrestigious"], bool):
                try:
                    # Attempt to convert
                    props["isPrestigious"] = bool(props["isPrestigious"])
                except:
                    raise TypeError(f"Property isPrestigious must be of type bool, got {type(props['isPrestigious']).__name__}")
    
        # Type check nextCeremony (expected object)
        if "nextCeremony" in props and props["nextCeremony"] is not None:
            if not isinstance(props["nextCeremony"], object):
                try:
                    # Attempt to convert
                    props["nextCeremony"] = object(props["nextCeremony"])
                except:
                    raise TypeError(f"Property nextCeremony must be of type object, got {type(props['nextCeremony']).__name__}")
    
        # Type check locationLong (expected float)
        if "locationLong" in props and props["locationLong"] is not None:
            if not isinstance(props["locationLong"], float):
                try:
                    # Attempt to convert
                    props["locationLong"] = float(props["locationLong"])
                except:
                    raise TypeError(f"Property locationLong must be of type float, got {type(props['locationLong']).__name__}")
    
        # Type check ceremonyTime (expected object)
        if "ceremonyTime" in props and props["ceremonyTime"] is not None:
            if not isinstance(props["ceremonyTime"], object):
                try:
                    # Attempt to convert
                    props["ceremonyTime"] = object(props["ceremonyTime"])
                except:
                    raise TypeError(f"Property ceremonyTime must be of type object, got {type(props['ceremonyTime']).__name__}")
    
        # Type check studioLotsLong (expected object)
        if "studioLotsLong" in props and props["studioLotsLong"] is not None:
            if not isinstance(props["studioLotsLong"], object):
                try:
                    # Attempt to convert
                    props["studioLotsLong"] = object(props["studioLotsLong"])
                except:
                    raise TypeError(f"Property studioLotsLong must be of type object, got {type(props['studioLotsLong']).__name__}")
    
        # Type check studioLotsLat (expected object)
        if "studioLotsLat" in props and props["studioLotsLat"] is not None:
            if not isinstance(props["studioLotsLat"], object):
                try:
                    # Attempt to convert
                    props["studioLotsLat"] = object(props["studioLotsLat"])
                except:
                    raise TypeError(f"Property studioLotsLat must be of type object, got {type(props['studioLotsLat']).__name__}")
    
        # Type check distributionMarkets (expected object)
        if "distributionMarkets" in props and props["distributionMarkets"] is not None:
            if not isinstance(props["distributionMarkets"], object):
                try:
                    # Attempt to convert
                    props["distributionMarkets"] = object(props["distributionMarkets"])
                except:
                    raise TypeError(f"Property distributionMarkets must be of type object, got {type(props['distributionMarkets']).__name__}")
    
        # Type check founded (expected object)
        if "founded" in props and props["founded"] is not None:
            if not isinstance(props["founded"], object):
                try:
                    # Attempt to convert
                    props["founded"] = object(props["founded"])
                except:
                    raise TypeError(f"Property founded must be of type object, got {type(props['founded']).__name__}")
    
        # Type check yearlyRevenue2020 (expected int)
        if "yearlyRevenue2020" in props and props["yearlyRevenue2020"] is not None:
            if not isinstance(props["yearlyRevenue2020"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue2020"] = int(props["yearlyRevenue2020"])
                except:
                    raise TypeError(f"Property yearlyRevenue2020 must be of type int, got {type(props['yearlyRevenue2020']).__name__}")
    
        # Type check subsidiaries (expected object)
        if "subsidiaries" in props and props["subsidiaries"] is not None:
            if not isinstance(props["subsidiaries"], object):
                try:
                    # Attempt to convert
                    props["subsidiaries"] = object(props["subsidiaries"])
                except:
                    raise TypeError(f"Property subsidiaries must be of type object, got {type(props['subsidiaries']).__name__}")
    
        # Type check digitalStreamingDate (expected object)
        if "digitalStreamingDate" in props and props["digitalStreamingDate"] is not None:
            if not isinstance(props["digitalStreamingDate"], object):
                try:
                    # Attempt to convert
                    props["digitalStreamingDate"] = object(props["digitalStreamingDate"])
                except:
                    raise TypeError(f"Property digitalStreamingDate must be of type object, got {type(props['digitalStreamingDate']).__name__}")
    
        # Type check yearlyRevenue2021 (expected int)
        if "yearlyRevenue2021" in props and props["yearlyRevenue2021"] is not None:
            if not isinstance(props["yearlyRevenue2021"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue2021"] = int(props["yearlyRevenue2021"])
                except:
                    raise TypeError(f"Property yearlyRevenue2021 must be of type int, got {type(props['yearlyRevenue2021']).__name__}")
    
        # Type check headquartersLat (expected float)
        if "headquartersLat" in props and props["headquartersLat"] is not None:
            if not isinstance(props["headquartersLat"], float):
                try:
                    # Attempt to convert
                    props["headquartersLat"] = float(props["headquartersLat"])
                except:
                    raise TypeError(f"Property headquartersLat must be of type float, got {type(props['headquartersLat']).__name__}")
    
        # Type check marketShare (expected float)
        if "marketShare" in props and props["marketShare"] is not None:
            if not isinstance(props["marketShare"], float):
                try:
                    # Attempt to convert
                    props["marketShare"] = float(props["marketShare"])
                except:
                    raise TypeError(f"Property marketShare must be of type float, got {type(props['marketShare']).__name__}")
    
        # Type check yearlyRevenue2022 (expected int)
        if "yearlyRevenue2022" in props and props["yearlyRevenue2022"] is not None:
            if not isinstance(props["yearlyRevenue2022"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue2022"] = int(props["yearlyRevenue2022"])
                except:
                    raise TypeError(f"Property yearlyRevenue2022 must be of type int, got {type(props['yearlyRevenue2022']).__name__}")
    
        # Type check headquartersLong (expected float)
        if "headquartersLong" in props and props["headquartersLong"] is not None:
            if not isinstance(props["headquartersLong"], float):
                try:
                    # Attempt to convert
                    props["headquartersLong"] = float(props["headquartersLong"])
                except:
                    raise TypeError(f"Property headquartersLong must be of type float, got {type(props['headquartersLong']).__name__}")
    
        # Type check isPublic (expected bool)
        if "isPublic" in props and props["isPublic"] is not None:
            if not isinstance(props["isPublic"], bool):
                try:
                    # Attempt to convert
                    props["isPublic"] = bool(props["isPublic"])
                except:
                    raise TypeError(f"Property isPublic must be of type bool, got {type(props['isPublic']).__name__}")
    
        # Type check scheduleTimes (expected object)
        if "scheduleTimes" in props and props["scheduleTimes"] is not None:
            if not isinstance(props["scheduleTimes"], object):
                try:
                    # Attempt to convert
                    props["scheduleTimes"] = object(props["scheduleTimes"])
                except:
                    raise TypeError(f"Property scheduleTimes must be of type object, got {type(props['scheduleTimes']).__name__}")
    
        # Type check scheduleDurations (expected object)
        if "scheduleDurations" in props and props["scheduleDurations"] is not None:
            if not isinstance(props["scheduleDurations"], object):
                try:
                    # Attempt to convert
                    props["scheduleDurations"] = object(props["scheduleDurations"])
                except:
                    raise TypeError(f"Property scheduleDurations must be of type object, got {type(props['scheduleDurations']).__name__}")
    
        # Type check weatherPoor (expected int)
        if "weatherPoor" in props and props["weatherPoor"] is not None:
            if not isinstance(props["weatherPoor"], int):
                try:
                    # Attempt to convert
                    props["weatherPoor"] = int(props["weatherPoor"])
                except:
                    raise TypeError(f"Property weatherPoor must be of type int, got {type(props['weatherPoor']).__name__}")
    
        # Type check startDate (expected object)
        if "startDate" in props and props["startDate"] is not None:
            if not isinstance(props["startDate"], object):
                try:
                    # Attempt to convert
                    props["startDate"] = object(props["startDate"])
                except:
                    raise TypeError(f"Property startDate must be of type object, got {type(props['startDate']).__name__}")
    
        # Type check isCompleted (expected bool)
        if "isCompleted" in props and props["isCompleted"] is not None:
            if not isinstance(props["isCompleted"], bool):
                try:
                    # Attempt to convert
                    props["isCompleted"] = bool(props["isCompleted"])
                except:
                    raise TypeError(f"Property isCompleted must be of type bool, got {type(props['isCompleted']).__name__}")
    
        # Type check scheduleActivities (expected object)
        if "scheduleActivities" in props and props["scheduleActivities"] is not None:
            if not isinstance(props["scheduleActivities"], object):
                try:
                    # Attempt to convert
                    props["scheduleActivities"] = object(props["scheduleActivities"])
                except:
                    raise TypeError(f"Property scheduleActivities must be of type object, got {type(props['scheduleActivities']).__name__}")
    
        # Type check budgetEquipment (expected int)
        if "budgetEquipment" in props and props["budgetEquipment"] is not None:
            if not isinstance(props["budgetEquipment"], int):
                try:
                    # Attempt to convert
                    props["budgetEquipment"] = int(props["budgetEquipment"])
                except:
                    raise TypeError(f"Property budgetEquipment must be of type int, got {type(props['budgetEquipment']).__name__}")
    
        # Type check weatherGood (expected int)
        if "weatherGood" in props and props["weatherGood"] is not None:
            if not isinstance(props["weatherGood"], int):
                try:
                    # Attempt to convert
                    props["weatherGood"] = int(props["weatherGood"])
                except:
                    raise TypeError(f"Property weatherGood must be of type int, got {type(props['weatherGood']).__name__}")
    
        # Type check startTime (expected object)
        if "startTime" in props and props["startTime"] is not None:
            if not isinstance(props["startTime"], object):
                try:
                    # Attempt to convert
                    props["startTime"] = object(props["startTime"])
                except:
                    raise TypeError(f"Property startTime must be of type object, got {type(props['startTime']).__name__}")
    
        # Type check budgetPersonnel (expected int)
        if "budgetPersonnel" in props and props["budgetPersonnel"] is not None:
            if not isinstance(props["budgetPersonnel"], int):
                try:
                    # Attempt to convert
                    props["budgetPersonnel"] = int(props["budgetPersonnel"])
                except:
                    raise TypeError(f"Property budgetPersonnel must be of type int, got {type(props['budgetPersonnel']).__name__}")
    
        # Type check durationDays (expected int)
        if "durationDays" in props and props["durationDays"] is not None:
            if not isinstance(props["durationDays"], int):
                try:
                    # Attempt to convert
                    props["durationDays"] = int(props["durationDays"])
                except:
                    raise TypeError(f"Property durationDays must be of type int, got {type(props['durationDays']).__name__}")
    
        # Type check budgetVFX (expected int)
        if "budgetVFX" in props and props["budgetVFX"] is not None:
            if not isinstance(props["budgetVFX"], int):
                try:
                    # Attempt to convert
                    props["budgetVFX"] = int(props["budgetVFX"])
                except:
                    raise TypeError(f"Property budgetVFX must be of type int, got {type(props['budgetVFX']).__name__}")
    
        # Type check weatherAcceptable (expected int)
        if "weatherAcceptable" in props and props["weatherAcceptable"] is not None:
            if not isinstance(props["weatherAcceptable"], int):
                try:
                    # Attempt to convert
                    props["weatherAcceptable"] = int(props["weatherAcceptable"])
                except:
                    raise TypeError(f"Property weatherAcceptable must be of type int, got {type(props['weatherAcceptable']).__name__}")
    
        # Type check durationMonths (expected int)
        if "durationMonths" in props and props["durationMonths"] is not None:
            if not isinstance(props["durationMonths"], int):
                try:
                    # Attempt to convert
                    props["durationMonths"] = int(props["durationMonths"])
                except:
                    raise TypeError(f"Property durationMonths must be of type int, got {type(props['durationMonths']).__name__}")
    
        # Type check budgetOther (expected int)
        if "budgetOther" in props and props["budgetOther"] is not None:
            if not isinstance(props["budgetOther"], int):
                try:
                    # Attempt to convert
                    props["budgetOther"] = int(props["budgetOther"])
                except:
                    raise TypeError(f"Property budgetOther must be of type int, got {type(props['budgetOther']).__name__}")
    
        # Type check endDate (expected object)
        if "endDate" in props and props["endDate"] is not None:
            if not isinstance(props["endDate"], object):
                try:
                    # Attempt to convert
                    props["endDate"] = object(props["endDate"])
                except:
                    raise TypeError(f"Property endDate must be of type object, got {type(props['endDate']).__name__}")
    
        # Type check budgetLocations (expected int)
        if "budgetLocations" in props and props["budgetLocations"] is not None:
            if not isinstance(props["budgetLocations"], int):
                try:
                    # Attempt to convert
                    props["budgetLocations"] = int(props["budgetLocations"])
                except:
                    raise TypeError(f"Property budgetLocations must be of type int, got {type(props['budgetLocations']).__name__}")
    
        # Type check readerLocationsLong (expected object)
        if "readerLocationsLong" in props and props["readerLocationsLong"] is not None:
            if not isinstance(props["readerLocationsLong"], object):
                try:
                    # Attempt to convert
                    props["readerLocationsLong"] = object(props["readerLocationsLong"])
                except:
                    raise TypeError(f"Property readerLocationsLong must be of type object, got {type(props['readerLocationsLong']).__name__}")
    
        # Type check readerLocationsLat (expected object)
        if "readerLocationsLat" in props and props["readerLocationsLat"] is not None:
            if not isinstance(props["readerLocationsLat"], object):
                try:
                    # Attempt to convert
                    props["readerLocationsLat"] = object(props["readerLocationsLat"])
                except:
                    raise TypeError(f"Property readerLocationsLat must be of type object, got {type(props['readerLocationsLat']).__name__}")
    
        # Type check aspectDirection (expected float)
        if "aspectDirection" in props and props["aspectDirection"] is not None:
            if not isinstance(props["aspectDirection"], float):
                try:
                    # Attempt to convert
                    props["aspectDirection"] = float(props["aspectDirection"])
                except:
                    raise TypeError(f"Property aspectDirection must be of type float, got {type(props['aspectDirection']).__name__}")
    
        # Type check commentTimestamps (expected list)
        if "commentTimestamps" in props and props["commentTimestamps"] is not None:
            if not isinstance(props["commentTimestamps"], list):
                try:
                    # Attempt to convert
                    props["commentTimestamps"] = list(props["commentTimestamps"])
                except:
                    raise TypeError(f"Property commentTimestamps must be of type list, got {type(props['commentTimestamps']).__name__}")
    
        # Type check keywords (expected object)
        if "keywords" in props and props["keywords"] is not None:
            if not isinstance(props["keywords"], object):
                try:
                    # Attempt to convert
                    props["keywords"] = object(props["keywords"])
                except:
                    raise TypeError(f"Property keywords must be of type object, got {type(props['keywords']).__name__}")
    
        # Type check stars (expected float)
        if "stars" in props and props["stars"] is not None:
            if not isinstance(props["stars"], float):
                try:
                    # Attempt to convert
                    props["stars"] = float(props["stars"])
                except:
                    raise TypeError(f"Property stars must be of type float, got {type(props['stars']).__name__}")
    
        # Type check time (expected object)
        if "time" in props and props["time"] is not None:
            if not isinstance(props["time"], object):
                try:
                    # Attempt to convert
                    props["time"] = object(props["time"])
                except:
                    raise TypeError(f"Property time must be of type object, got {type(props['time']).__name__}")
    
        # Type check aspectMusic (expected float)
        if "aspectMusic" in props and props["aspectMusic"] is not None:
            if not isinstance(props["aspectMusic"], float):
                try:
                    # Attempt to convert
                    props["aspectMusic"] = float(props["aspectMusic"])
                except:
                    raise TypeError(f"Property aspectMusic must be of type float, got {type(props['aspectMusic']).__name__}")
    
        # Type check aspectPlot (expected float)
        if "aspectPlot" in props and props["aspectPlot"] is not None:
            if not isinstance(props["aspectPlot"], float):
                try:
                    # Attempt to convert
                    props["aspectPlot"] = float(props["aspectPlot"])
                except:
                    raise TypeError(f"Property aspectPlot must be of type float, got {type(props['aspectPlot']).__name__}")
    
        # Type check aspectVisuals (expected float)
        if "aspectVisuals" in props and props["aspectVisuals"] is not None:
            if not isinstance(props["aspectVisuals"], float):
                try:
                    # Attempt to convert
                    props["aspectVisuals"] = float(props["aspectVisuals"])
                except:
                    raise TypeError(f"Property aspectVisuals must be of type float, got {type(props['aspectVisuals']).__name__}")
    
        # Type check isVerified (expected bool)
        if "isVerified" in props and props["isVerified"] is not None:
            if not isinstance(props["isVerified"], bool):
                try:
                    # Attempt to convert
                    props["isVerified"] = bool(props["isVerified"])
                except:
                    raise TypeError(f"Property isVerified must be of type bool, got {type(props['isVerified']).__name__}")
    
        # Type check reviewText (expected str)
        if "reviewText" in props and props["reviewText"] is not None:
            if not isinstance(props["reviewText"], str):
                try:
                    # Attempt to convert
                    props["reviewText"] = str(props["reviewText"])
                except:
                    raise TypeError(f"Property reviewText must be of type str, got {type(props['reviewText']).__name__}")
    
        # Type check date (expected object)
        if "date" in props and props["date"] is not None:
            if not isinstance(props["date"], object):
                try:
                    # Attempt to convert
                    props["date"] = object(props["date"])
                except:
                    raise TypeError(f"Property date must be of type object, got {type(props['date']).__name__}")
    
        # Type check aspectActing (expected float)
        if "aspectActing" in props and props["aspectActing"] is not None:
            if not isinstance(props["aspectActing"], float):
                try:
                    # Attempt to convert
                    props["aspectActing"] = float(props["aspectActing"])
                except:
                    raise TypeError(f"Property aspectActing must be of type float, got {type(props['aspectActing']).__name__}")
    
        # Type check upvotes (expected int)
        if "upvotes" in props and props["upvotes"] is not None:
            if not isinstance(props["upvotes"], int):
                try:
                    # Attempt to convert
                    props["upvotes"] = int(props["upvotes"])
                except:
                    raise TypeError(f"Property upvotes must be of type int, got {type(props['upvotes']).__name__}")
    
        # Type check methodActingScore (expected float)
        if "methodActingScore" in props and props["methodActingScore"] is not None:
            if not isinstance(props["methodActingScore"], float):
                try:
                    # Attempt to convert
                    props["methodActingScore"] = float(props["methodActingScore"])
                except:
                    raise TypeError(f"Property methodActingScore must be of type float, got {type(props['methodActingScore']).__name__}")
    
        # Type check marriageDate (expected object)
        if "marriageDate" in props and props["marriageDate"] is not None:
            if not isinstance(props["marriageDate"], object):
                try:
                    # Attempt to convert
                    props["marriageDate"] = object(props["marriageDate"])
                except:
                    raise TypeError(f"Property marriageDate must be of type object, got {type(props['marriageDate']).__name__}")
    
        # Type check oscarWinDate (expected object)
        if "oscarWinDate" in props and props["oscarWinDate"] is not None:
            if not isinstance(props["oscarWinDate"], object):
                try:
                    # Attempt to convert
                    props["oscarWinDate"] = object(props["oscarWinDate"])
                except:
                    raise TypeError(f"Property oscarWinDate must be of type object, got {type(props['oscarWinDate']).__name__}")
    
        # Type check filmCountComedy (expected int)
        if "filmCountComedy" in props and props["filmCountComedy"] is not None:
            if not isinstance(props["filmCountComedy"], int):
                try:
                    # Attempt to convert
                    props["filmCountComedy"] = int(props["filmCountComedy"])
                except:
                    raise TypeError(f"Property filmCountComedy must be of type int, got {type(props['filmCountComedy']).__name__}")
    
        # Type check filmCountSciFi (expected int)
        if "filmCountSciFi" in props and props["filmCountSciFi"] is not None:
            if not isinstance(props["filmCountSciFi"], int):
                try:
                    # Attempt to convert
                    props["filmCountSciFi"] = int(props["filmCountSciFi"])
                except:
                    raise TypeError(f"Property filmCountSciFi must be of type int, got {type(props['filmCountSciFi']).__name__}")
    
        # Type check typicalRolePreparationMonths (expected float)
        if "typicalRolePreparationMonths" in props and props["typicalRolePreparationMonths"] is not None:
            if not isinstance(props["typicalRolePreparationMonths"], float):
                try:
                    # Attempt to convert
                    props["typicalRolePreparationMonths"] = float(props["typicalRolePreparationMonths"])
                except:
                    raise TypeError(f"Property typicalRolePreparationMonths must be of type float, got {type(props['typicalRolePreparationMonths']).__name__}")
    
        # Type check spouseName (expected str)
        if "spouseName" in props and props["spouseName"] is not None:
            if not isinstance(props["spouseName"], str):
                try:
                    # Attempt to convert
                    props["spouseName"] = str(props["spouseName"])
                except:
                    raise TypeError(f"Property spouseName must be of type str, got {type(props['spouseName']).__name__}")
    
        # Type check attendance2022 (expected int)
        if "attendance2022" in props and props["attendance2022"] is not None:
            if not isinstance(props["attendance2022"], int):
                try:
                    # Attempt to convert
                    props["attendance2022"] = int(props["attendance2022"])
                except:
                    raise TypeError(f"Property attendance2022 must be of type int, got {type(props['attendance2022']).__name__}")
    
        # Type check attendance2023 (expected int)
        if "attendance2023" in props and props["attendance2023"] is not None:
            if not isinstance(props["attendance2023"], int):
                try:
                    # Attempt to convert
                    props["attendance2023"] = int(props["attendance2023"])
                except:
                    raise TypeError(f"Property attendance2023 must be of type int, got {type(props['attendance2023']).__name__}")
    
        # Type check typicalDurationDays (expected int)
        if "typicalDurationDays" in props and props["typicalDurationDays"] is not None:
            if not isinstance(props["typicalDurationDays"], int):
                try:
                    # Attempt to convert
                    props["typicalDurationDays"] = int(props["typicalDurationDays"])
                except:
                    raise TypeError(f"Property typicalDurationDays must be of type int, got {type(props['typicalDurationDays']).__name__}")
    
        # Type check attendance2019 (expected int)
        if "attendance2019" in props and props["attendance2019"] is not None:
            if not isinstance(props["attendance2019"], int):
                try:
                    # Attempt to convert
                    props["attendance2019"] = int(props["attendance2019"])
                except:
                    raise TypeError(f"Property attendance2019 must be of type int, got {type(props['attendance2019']).__name__}")
    
        # Type check attendance2021 (expected int)
        if "attendance2021" in props and props["attendance2021"] is not None:
            if not isinstance(props["attendance2021"], int):
                try:
                    # Attempt to convert
                    props["attendance2021"] = int(props["attendance2021"])
                except:
                    raise TypeError(f"Property attendance2021 must be of type int, got {type(props['attendance2021']).__name__}")
    
        # Type check manufactureLocationLong (expected float)
        if "manufactureLocationLong" in props and props["manufactureLocationLong"] is not None:
            if not isinstance(props["manufactureLocationLong"], float):
                try:
                    # Attempt to convert
                    props["manufactureLocationLong"] = float(props["manufactureLocationLong"])
                except:
                    raise TypeError(f"Property manufactureLocationLong must be of type float, got {type(props['manufactureLocationLong']).__name__}")
    
        # Type check vehicleType (expected str)
        if "vehicleType" in props and props["vehicleType"] is not None:
            if not isinstance(props["vehicleType"], str):
                try:
                    # Attempt to convert
                    props["vehicleType"] = str(props["vehicleType"])
                except:
                    raise TypeError(f"Property vehicleType must be of type str, got {type(props['vehicleType']).__name__}")
    
        # Type check manufactureLocation (expected str)
        if "manufactureLocation" in props and props["manufactureLocation"] is not None:
            if not isinstance(props["manufactureLocation"], str):
                try:
                    # Attempt to convert
                    props["manufactureLocation"] = str(props["manufactureLocation"])
                except:
                    raise TypeError(f"Property manufactureLocation must be of type str, got {type(props['manufactureLocation']).__name__}")
    
        # Type check productPlacementCost (expected int)
        if "productPlacementCost" in props and props["productPlacementCost"] is not None:
            if not isinstance(props["productPlacementCost"], int):
                try:
                    # Attempt to convert
                    props["productPlacementCost"] = int(props["productPlacementCost"])
                except:
                    raise TypeError(f"Property productPlacementCost must be of type int, got {type(props['productPlacementCost']).__name__}")
    
        # Type check featuredInMovies (expected object)
        if "featuredInMovies" in props and props["featuredInMovies"] is not None:
            if not isinstance(props["featuredInMovies"], object):
                try:
                    # Attempt to convert
                    props["featuredInMovies"] = object(props["featuredInMovies"])
                except:
                    raise TypeError(f"Property featuredInMovies must be of type object, got {type(props['featuredInMovies']).__name__}")
    
        # Type check manufactureLocationLat (expected float)
        if "manufactureLocationLat" in props and props["manufactureLocationLat"] is not None:
            if not isinstance(props["manufactureLocationLat"], float):
                try:
                    # Attempt to convert
                    props["manufactureLocationLat"] = float(props["manufactureLocationLat"])
                except:
                    raise TypeError(f"Property manufactureLocationLat must be of type float, got {type(props['manufactureLocationLat']).__name__}")
    
        # Type check maxSpeed (expected int)
        if "maxSpeed" in props and props["maxSpeed"] is not None:
            if not isinstance(props["maxSpeed"], int):
                try:
                    # Attempt to convert
                    props["maxSpeed"] = int(props["maxSpeed"])
                except:
                    raise TypeError(f"Property maxSpeed must be of type int, got {type(props['maxSpeed']).__name__}")
    
        # Type check featuredInYears (expected object)
        if "featuredInYears" in props and props["featuredInYears"] is not None:
            if not isinstance(props["featuredInYears"], object):
                try:
                    # Attempt to convert
                    props["featuredInYears"] = object(props["featuredInYears"])
                except:
                    raise TypeError(f"Property featuredInYears must be of type object, got {type(props['featuredInYears']).__name__}")
    
        # Type check featured (expected bool)
        if "featured" in props and props["featured"] is not None:
            if not isinstance(props["featured"], bool):
                try:
                    # Attempt to convert
                    props["featured"] = bool(props["featured"])
                except:
                    raise TypeError(f"Property featured must be of type bool, got {type(props['featured']).__name__}")
    
        # Type check introduced (expected object)
        if "introduced" in props and props["introduced"] is not None:
            if not isinstance(props["introduced"], object):
                try:
                    # Attempt to convert
                    props["introduced"] = object(props["introduced"])
                except:
                    raise TypeError(f"Property introduced must be of type object, got {type(props['introduced']).__name__}")
    
        # Type check maxSpeedUnit (expected str)
        if "maxSpeedUnit" in props and props["maxSpeedUnit"] is not None:
            if not isinstance(props["maxSpeedUnit"], str):
                try:
                    # Attempt to convert
                    props["maxSpeedUnit"] = str(props["maxSpeedUnit"])
                except:
                    raise TypeError(f"Property maxSpeedUnit must be of type str, got {type(props['maxSpeedUnit']).__name__}")
    
        # Type check copiesMade (expected int)
        if "copiesMade" in props and props["copiesMade"] is not None:
            if not isinstance(props["copiesMade"], int):
                try:
                    # Attempt to convert
                    props["copiesMade"] = int(props["copiesMade"])
                except:
                    raise TypeError(f"Property copiesMade must be of type int, got {type(props['copiesMade']).__name__}")
    
        # Type check isIconic (expected bool)
        if "isIconic" in props and props["isIconic"] is not None:
            if not isinstance(props["isIconic"], bool):
                try:
                    # Attempt to convert
                    props["isIconic"] = bool(props["isIconic"])
                except:
                    raise TypeError(f"Property isIconic must be of type bool, got {type(props['isIconic']).__name__}")
    
        # Type check weightUnit (expected str)
        if "weightUnit" in props and props["weightUnit"] is not None:
            if not isinstance(props["weightUnit"], str):
                try:
                    # Attempt to convert
                    props["weightUnit"] = str(props["weightUnit"])
                except:
                    raise TypeError(f"Property weightUnit must be of type str, got {type(props['weightUnit']).__name__}")
    
        # Type check screenTime (expected object)
        if "screenTime" in props and props["screenTime"] is not None:
            if not isinstance(props["screenTime"], object):
                try:
                    # Attempt to convert
                    props["screenTime"] = object(props["screenTime"])
                except:
                    raise TypeError(f"Property screenTime must be of type object, got {type(props['screenTime']).__name__}")
    
        # Type check movie (expected str)
        if "movie" in props and props["movie"] is not None:
            if not isinstance(props["movie"], str):
                try:
                    # Attempt to convert
                    props["movie"] = str(props["movie"])
                except:
                    raise TypeError(f"Property movie must be of type str, got {type(props['movie']).__name__}")
    
        # Type check material (expected str)
        if "material" in props and props["material"] is not None:
            if not isinstance(props["material"], str):
                try:
                    # Attempt to convert
                    props["material"] = str(props["material"])
                except:
                    raise TypeError(f"Property material must be of type str, got {type(props['material']).__name__}")
    
        # Type check auctionValue (expected int)
        if "auctionValue" in props and props["auctionValue"] is not None:
            if not isinstance(props["auctionValue"], int):
                try:
                    # Attempt to convert
                    props["auctionValue"] = int(props["auctionValue"])
                except:
                    raise TypeError(f"Property auctionValue must be of type int, got {type(props['auctionValue']).__name__}")
    
        # Type check createdDate (expected object)
        if "createdDate" in props and props["createdDate"] is not None:
            if not isinstance(props["createdDate"], object):
                try:
                    # Attempt to convert
                    props["createdDate"] = object(props["createdDate"])
                except:
                    raise TypeError(f"Property createdDate must be of type object, got {type(props['createdDate']).__name__}")
    
        # Type check duration (expected object)
        if "duration" in props and props["duration"] is not None:
            if not isinstance(props["duration"], object):
                try:
                    # Attempt to convert
                    props["duration"] = object(props["duration"])
                except:
                    raise TypeError(f"Property duration must be of type object, got {type(props['duration']).__name__}")
    
        # Type check salesUnits (expected int)
        if "salesUnits" in props and props["salesUnits"] is not None:
            if not isinstance(props["salesUnits"], int):
                try:
                    # Attempt to convert
                    props["salesUnits"] = int(props["salesUnits"])
                except:
                    raise TypeError(f"Property salesUnits must be of type int, got {type(props['salesUnits']).__name__}")
    
        # Type check peakChartPosition (expected int)
        if "peakChartPosition" in props and props["peakChartPosition"] is not None:
            if not isinstance(props["peakChartPosition"], int):
                try:
                    # Attempt to convert
                    props["peakChartPosition"] = int(props["peakChartPosition"])
                except:
                    raise TypeError(f"Property peakChartPosition must be of type int, got {type(props['peakChartPosition']).__name__}")
    
        # Type check recordingStudio (expected str)
        if "recordingStudio" in props and props["recordingStudio"] is not None:
            if not isinstance(props["recordingStudio"], str):
                try:
                    # Attempt to convert
                    props["recordingStudio"] = str(props["recordingStudio"])
                except:
                    raise TypeError(f"Property recordingStudio must be of type str, got {type(props['recordingStudio']).__name__}")
    
        # Type check composer (expected str)
        if "composer" in props and props["composer"] is not None:
            if not isinstance(props["composer"], str):
                try:
                    # Attempt to convert
                    props["composer"] = str(props["composer"])
                except:
                    raise TypeError(f"Property composer must be of type str, got {type(props['composer']).__name__}")
    
        # Type check recordingStudioLong (expected float)
        if "recordingStudioLong" in props and props["recordingStudioLong"] is not None:
            if not isinstance(props["recordingStudioLong"], float):
                try:
                    # Attempt to convert
                    props["recordingStudioLong"] = float(props["recordingStudioLong"])
                except:
                    raise TypeError(f"Property recordingStudioLong must be of type float, got {type(props['recordingStudioLong']).__name__}")
    
        # Type check recordingStudioLat (expected float)
        if "recordingStudioLat" in props and props["recordingStudioLat"] is not None:
            if not isinstance(props["recordingStudioLat"], float):
                try:
                    # Attempt to convert
                    props["recordingStudioLat"] = float(props["recordingStudioLat"])
                except:
                    raise TypeError(f"Property recordingStudioLat must be of type float, got {type(props['recordingStudioLat']).__name__}")
    
        # Type check trackCount (expected int)
        if "trackCount" in props and props["trackCount"] is not None:
            if not isinstance(props["trackCount"], int):
                try:
                    # Attempt to convert
                    props["trackCount"] = int(props["trackCount"])
                except:
                    raise TypeError(f"Property trackCount must be of type int, got {type(props['trackCount']).__name__}")
    
        # Type check streamingCount (expected int)
        if "streamingCount" in props and props["streamingCount"] is not None:
            if not isinstance(props["streamingCount"], int):
                try:
                    # Attempt to convert
                    props["streamingCount"] = int(props["streamingCount"])
                except:
                    raise TypeError(f"Property streamingCount must be of type int, got {type(props['streamingCount']).__name__}")
    
        # Type check longitude (expected float)
        if "longitude" in props and props["longitude"] is not None:
            if not isinstance(props["longitude"], float):
                try:
                    # Attempt to convert
                    props["longitude"] = float(props["longitude"])
                except:
                    raise TypeError(f"Property longitude must be of type float, got {type(props['longitude']).__name__}")
    
        # Type check latitude (expected float)
        if "latitude" in props and props["latitude"] is not None:
            if not isinstance(props["latitude"], float):
                try:
                    # Attempt to convert
                    props["latitude"] = float(props["latitude"])
                except:
                    raise TypeError(f"Property latitude must be of type float, got {type(props['latitude']).__name__}")
    
        # Type check climate (expected str)
        if "climate" in props and props["climate"] is not None:
            if not isinstance(props["climate"], str):
                try:
                    # Attempt to convert
                    props["climate"] = str(props["climate"])
                except:
                    raise TypeError(f"Property climate must be of type str, got {type(props['climate']).__name__}")
    
        # Type check permitCurrency (expected str)
        if "permitCurrency" in props and props["permitCurrency"] is not None:
            if not isinstance(props["permitCurrency"], str):
                try:
                    # Attempt to convert
                    props["permitCurrency"] = str(props["permitCurrency"])
                except:
                    raise TypeError(f"Property permitCurrency must be of type str, got {type(props['permitCurrency']).__name__}")
    
        # Type check firstUsed (expected object)
        if "firstUsed" in props and props["firstUsed"] is not None:
            if not isinstance(props["firstUsed"], object):
                try:
                    # Attempt to convert
                    props["firstUsed"] = object(props["firstUsed"])
                except:
                    raise TypeError(f"Property firstUsed must be of type object, got {type(props['firstUsed']).__name__}")
    
        # Type check permitCost (expected int)
        if "permitCost" in props and props["permitCost"] is not None:
            if not isinstance(props["permitCost"], int):
                try:
                    # Attempt to convert
                    props["permitCost"] = int(props["permitCost"])
                except:
                    raise TypeError(f"Property permitCost must be of type int, got {type(props['permitCost']).__name__}")
    
        # Type check elevationUnit (expected str)
        if "elevationUnit" in props and props["elevationUnit"] is not None:
            if not isinstance(props["elevationUnit"], str):
                try:
                    # Attempt to convert
                    props["elevationUnit"] = str(props["elevationUnit"])
                except:
                    raise TypeError(f"Property elevationUnit must be of type str, got {type(props['elevationUnit']).__name__}")
    
        # Type check region (expected str)
        if "region" in props and props["region"] is not None:
            if not isinstance(props["region"], str):
                try:
                    # Attempt to convert
                    props["region"] = str(props["region"])
                except:
                    raise TypeError(f"Property region must be of type str, got {type(props['region']).__name__}")
    
        # Type check country (expected str)
        if "country" in props and props["country"] is not None:
            if not isinstance(props["country"], str):
                try:
                    # Attempt to convert
                    props["country"] = str(props["country"])
                except:
                    raise TypeError(f"Property country must be of type str, got {type(props['country']).__name__}")
    
        # Type check lastUsed (expected object)
        if "lastUsed" in props and props["lastUsed"] is not None:
            if not isinstance(props["lastUsed"], object):
                try:
                    # Attempt to convert
                    props["lastUsed"] = object(props["lastUsed"])
                except:
                    raise TypeError(f"Property lastUsed must be of type object, got {type(props['lastUsed']).__name__}")
    
        # Type check elevation (expected int)
        if "elevation" in props and props["elevation"] is not None:
            if not isinstance(props["elevation"], int):
                try:
                    # Attempt to convert
                    props["elevation"] = int(props["elevation"])
                except:
                    raise TypeError(f"Property elevation must be of type int, got {type(props['elevation']).__name__}")
    
        # Type check animationStudioLong (expected object)
        if "animationStudioLong" in props and props["animationStudioLong"] is not None:
            if not isinstance(props["animationStudioLong"], object):
                try:
                    # Attempt to convert
                    props["animationStudioLong"] = object(props["animationStudioLong"])
                except:
                    raise TypeError(f"Property animationStudioLong must be of type object, got {type(props['animationStudioLong']).__name__}")
    
        # Type check animationStudioLat (expected object)
        if "animationStudioLat" in props and props["animationStudioLat"] is not None:
            if not isinstance(props["animationStudioLat"], object):
                try:
                    # Attempt to convert
                    props["animationStudioLat"] = object(props["animationStudioLat"])
                except:
                    raise TypeError(f"Property animationStudioLat must be of type object, got {type(props['animationStudioLat']).__name__}")
    
        # Type check directorDebut (expected object)
        if "directorDebut" in props and props["directorDebut"] is not None:
            if not isinstance(props["directorDebut"], object):
                try:
                    # Attempt to convert
                    props["directorDebut"] = object(props["directorDebut"])
                except:
                    raise TypeError(f"Property directorDebut must be of type object, got {type(props['directorDebut']).__name__}")
    
        # Type check knighted (expected object)
        if "knighted" in props and props["knighted"] is not None:
            if not isinstance(props["knighted"], object):
                try:
                    # Attempt to convert
                    props["knighted"] = object(props["knighted"])
                except:
                    raise TypeError(f"Property knighted must be of type object, got {type(props['knighted']).__name__}")
    
        # Type check classicalTraining (expected bool)
        if "classicalTraining" in props and props["classicalTraining"] is not None:
            if not isinstance(props["classicalTraining"], bool):
                try:
                    # Attempt to convert
                    props["classicalTraining"] = bool(props["classicalTraining"])
                except:
                    raise TypeError(f"Property classicalTraining must be of type bool, got {type(props['classicalTraining']).__name__}")
    
        # Type check documentaryCount (expected int)
        if "documentaryCount" in props and props["documentaryCount"] is not None:
            if not isinstance(props["documentaryCount"], int):
                try:
                    # Attempt to convert
                    props["documentaryCount"] = int(props["documentaryCount"])
                except:
                    raise TypeError(f"Property documentaryCount must be of type int, got {type(props['documentaryCount']).__name__}")
    
        # Type check careerLength (expected object)
        if "careerLength" in props and props["careerLength"] is not None:
            if not isinstance(props["careerLength"], object):
                try:
                    # Attempt to convert
                    props["careerLength"] = object(props["careerLength"])
                except:
                    raise TypeError(f"Property careerLength must be of type object, got {type(props['careerLength']).__name__}")
    
        # Type check lastFilm (expected object)
        if "lastFilm" in props and props["lastFilm"] is not None:
            if not isinstance(props["lastFilm"], object):
                try:
                    # Attempt to convert
                    props["lastFilm"] = object(props["lastFilm"])
                except:
                    raise TypeError(f"Property lastFilm must be of type object, got {type(props['lastFilm']).__name__}")
    
        # Type check deathdate (expected object)
        if "deathdate" in props and props["deathdate"] is not None:
            if not isinstance(props["deathdate"], object):
                try:
                    # Attempt to convert
                    props["deathdate"] = object(props["deathdate"])
                except:
                    raise TypeError(f"Property deathdate must be of type object, got {type(props['deathdate']).__name__}")
    
        # Type check musicianSince (expected object)
        if "musicianSince" in props and props["musicianSince"] is not None:
            if not isinstance(props["musicianSince"], object):
                try:
                    # Attempt to convert
                    props["musicianSince"] = object(props["musicianSince"])
                except:
                    raise TypeError(f"Property musicianSince must be of type object, got {type(props['musicianSince']).__name__}")
    
        # Type check musicalInstruments (expected object)
        if "musicalInstruments" in props and props["musicalInstruments"] is not None:
            if not isinstance(props["musicalInstruments"], object):
                try:
                    # Attempt to convert
                    props["musicalInstruments"] = object(props["musicalInstruments"])
                except:
                    raise TypeError(f"Property musicalInstruments must be of type object, got {type(props['musicalInstruments']).__name__}")
    
        # Type check musicCareerStart (expected object)
        if "musicCareerStart" in props and props["musicCareerStart"] is not None:
            if not isinstance(props["musicCareerStart"], object):
                try:
                    # Attempt to convert
                    props["musicCareerStart"] = object(props["musicCareerStart"])
                except:
                    raise TypeError(f"Property musicCareerStart must be of type object, got {type(props['musicCareerStart']).__name__}")
    
        # Type check voiceActingScore (expected float)
        if "voiceActingScore" in props and props["voiceActingScore"] is not None:
            if not isinstance(props["voiceActingScore"], float):
                try:
                    # Attempt to convert
                    props["voiceActingScore"] = float(props["voiceActingScore"])
                except:
                    raise TypeError(f"Property voiceActingScore must be of type float, got {type(props['voiceActingScore']).__name__}")
    
        # Type check musicGenres (expected object)
        if "musicGenres" in props and props["musicGenres"] is not None:
            if not isinstance(props["musicGenres"], object):
                try:
                    # Attempt to convert
                    props["musicGenres"] = object(props["musicGenres"])
                except:
                    raise TypeError(f"Property musicGenres must be of type object, got {type(props['musicGenres']).__name__}")
    
        # Type check notableYears (expected object)
        if "notableYears" in props and props["notableYears"] is not None:
            if not isinstance(props["notableYears"], object):
                try:
                    # Attempt to convert
                    props["notableYears"] = object(props["notableYears"])
                except:
                    raise TypeError(f"Property notableYears must be of type object, got {type(props['notableYears']).__name__}")
    
        # Type check peakMarketShare (expected float)
        if "peakMarketShare" in props and props["peakMarketShare"] is not None:
            if not isinstance(props["peakMarketShare"], float):
                try:
                    # Attempt to convert
                    props["peakMarketShare"] = float(props["peakMarketShare"])
                except:
                    raise TypeError(f"Property peakMarketShare must be of type float, got {type(props['peakMarketShare']).__name__}")
    
        # Type check notableFilms (expected object)
        if "notableFilms" in props and props["notableFilms"] is not None:
            if not isinstance(props["notableFilms"], object):
                try:
                    # Attempt to convert
                    props["notableFilms"] = object(props["notableFilms"])
                except:
                    raise TypeError(f"Property notableFilms must be of type object, got {type(props['notableFilms']).__name__}")
    
        # Type check acquisitionDate (expected object)
        if "acquisitionDate" in props and props["acquisitionDate"] is not None:
            if not isinstance(props["acquisitionDate"], object):
                try:
                    # Attempt to convert
                    props["acquisitionDate"] = object(props["acquisitionDate"])
                except:
                    raise TypeError(f"Property acquisitionDate must be of type object, got {type(props['acquisitionDate']).__name__}")
    
        # Type check yearlyRevenue1992 (expected int)
        if "yearlyRevenue1992" in props and props["yearlyRevenue1992"] is not None:
            if not isinstance(props["yearlyRevenue1992"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1992"] = int(props["yearlyRevenue1992"])
                except:
                    raise TypeError(f"Property yearlyRevenue1992 must be of type int, got {type(props['yearlyRevenue1992']).__name__}")
    
        # Type check yearlyRevenue1991 (expected int)
        if "yearlyRevenue1991" in props and props["yearlyRevenue1991"] is not None:
            if not isinstance(props["yearlyRevenue1991"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1991"] = int(props["yearlyRevenue1991"])
                except:
                    raise TypeError(f"Property yearlyRevenue1991 must be of type int, got {type(props['yearlyRevenue1991']).__name__}")
    
        # Type check relaunch (expected object)
        if "relaunch" in props and props["relaunch"] is not None:
            if not isinstance(props["relaunch"], object):
                try:
                    # Attempt to convert
                    props["relaunch"] = object(props["relaunch"])
                except:
                    raise TypeError(f"Property relaunch must be of type object, got {type(props['relaunch']).__name__}")
    
        # Type check bankruptcyDate (expected object)
        if "bankruptcyDate" in props and props["bankruptcyDate"] is not None:
            if not isinstance(props["bankruptcyDate"], object):
                try:
                    # Attempt to convert
                    props["bankruptcyDate"] = object(props["bankruptcyDate"])
                except:
                    raise TypeError(f"Property bankruptcyDate must be of type object, got {type(props['bankruptcyDate']).__name__}")
    
        # Type check productionPhases (expected object)
        if "productionPhases" in props and props["productionPhases"] is not None:
            if not isinstance(props["productionPhases"], object):
                try:
                    # Attempt to convert
                    props["productionPhases"] = object(props["productionPhases"])
                except:
                    raise TypeError(f"Property productionPhases must be of type object, got {type(props['productionPhases']).__name__}")
    
        # Type check phaseStartDates (expected object)
        if "phaseStartDates" in props and props["phaseStartDates"] is not None:
            if not isinstance(props["phaseStartDates"], object):
                try:
                    # Attempt to convert
                    props["phaseStartDates"] = object(props["phaseStartDates"])
                except:
                    raise TypeError(f"Property phaseStartDates must be of type object, got {type(props['phaseStartDates']).__name__}")
    
        # Type check phaseDurationsMonths (expected object)
        if "phaseDurationsMonths" in props and props["phaseDurationsMonths"] is not None:
            if not isinstance(props["phaseDurationsMonths"], object):
                try:
                    # Attempt to convert
                    props["phaseDurationsMonths"] = object(props["phaseDurationsMonths"])
                except:
                    raise TypeError(f"Property phaseDurationsMonths must be of type object, got {type(props['phaseDurationsMonths']).__name__}")
    
        # Type check renderingHours (expected int)
        if "renderingHours" in props and props["renderingHours"] is not None:
            if not isinstance(props["renderingHours"], int):
                try:
                    # Attempt to convert
                    props["renderingHours"] = int(props["renderingHours"])
                except:
                    raise TypeError(f"Property renderingHours must be of type int, got {type(props['renderingHours']).__name__}")
    
        # Type check budgetVoiceActing (expected int)
        if "budgetVoiceActing" in props and props["budgetVoiceActing"] is not None:
            if not isinstance(props["budgetVoiceActing"], int):
                try:
                    # Attempt to convert
                    props["budgetVoiceActing"] = int(props["budgetVoiceActing"])
                except:
                    raise TypeError(f"Property budgetVoiceActing must be of type int, got {type(props['budgetVoiceActing']).__name__}")
    
        # Type check budgetTechnology (expected int)
        if "budgetTechnology" in props and props["budgetTechnology"] is not None:
            if not isinstance(props["budgetTechnology"], int):
                try:
                    # Attempt to convert
                    props["budgetTechnology"] = int(props["budgetTechnology"])
                except:
                    raise TypeError(f"Property budgetTechnology must be of type int, got {type(props['budgetTechnology']).__name__}")
    
        # Type check budgetRendering (expected int)
        if "budgetRendering" in props and props["budgetRendering"] is not None:
            if not isinstance(props["budgetRendering"], int):
                try:
                    # Attempt to convert
                    props["budgetRendering"] = int(props["budgetRendering"])
                except:
                    raise TypeError(f"Property budgetRendering must be of type int, got {type(props['budgetRendering']).__name__}")
    
        # Type check renderFarmServers (expected int)
        if "renderFarmServers" in props and props["renderFarmServers"] is not None:
            if not isinstance(props["renderFarmServers"], int):
                try:
                    # Attempt to convert
                    props["renderFarmServers"] = int(props["renderFarmServers"])
                except:
                    raise TypeError(f"Property renderFarmServers must be of type int, got {type(props['renderFarmServers']).__name__}")
    
        # Type check animatorsCount (expected int)
        if "animatorsCount" in props and props["animatorsCount"] is not None:
            if not isinstance(props["animatorsCount"], int):
                try:
                    # Attempt to convert
                    props["animatorsCount"] = int(props["animatorsCount"])
                except:
                    raise TypeError(f"Property animatorsCount must be of type int, got {type(props['animatorsCount']).__name__}")
    
        # Type check aspectVoiceActing (expected float)
        if "aspectVoiceActing" in props and props["aspectVoiceActing"] is not None:
            if not isinstance(props["aspectVoiceActing"], float):
                try:
                    # Attempt to convert
                    props["aspectVoiceActing"] = float(props["aspectVoiceActing"])
                except:
                    raise TypeError(f"Property aspectVoiceActing must be of type float, got {type(props['aspectVoiceActing']).__name__}")
    
        # Type check aspectAnimation (expected float)
        if "aspectAnimation" in props and props["aspectAnimation"] is not None:
            if not isinstance(props["aspectAnimation"], float):
                try:
                    # Attempt to convert
                    props["aspectAnimation"] = float(props["aspectAnimation"])
                except:
                    raise TypeError(f"Property aspectAnimation must be of type float, got {type(props['aspectAnimation']).__name__}")
    
        # Type check attendance2020 (expected int)
        if "attendance2020" in props and props["attendance2020"] is not None:
            if not isinstance(props["attendance2020"], int):
                try:
                    # Attempt to convert
                    props["attendance2020"] = int(props["attendance2020"])
                except:
                    raise TypeError(f"Property attendance2020 must be of type int, got {type(props['attendance2020']).__name__}")
    
        # Type check yearlyProductions (expected float)
        if "yearlyProductions" in props and props["yearlyProductions"] is not None:
            if not isinstance(props["yearlyProductions"], float):
                try:
                    # Attempt to convert
                    props["yearlyProductions"] = float(props["yearlyProductions"])
                except:
                    raise TypeError(f"Property yearlyProductions must be of type float, got {type(props['yearlyProductions']).__name__}")
    
        # Type check specialization (expected str)
        if "specialization" in props and props["specialization"] is not None:
            if not isinstance(props["specialization"], str):
                try:
                    # Attempt to convert
                    props["specialization"] = str(props["specialization"])
                except:
                    raise TypeError(f"Property specialization must be of type str, got {type(props['specialization']).__name__}")
    
        # Type check awardWins (expected int)
        if "awardWins" in props and props["awardWins"] is not None:
            if not isinstance(props["awardWins"], int):
                try:
                    # Attempt to convert
                    props["awardWins"] = int(props["awardWins"])
                except:
                    raise TypeError(f"Property awardWins must be of type int, got {type(props['awardWins']).__name__}")
    
        # Type check employeeCount (expected int)
        if "employeeCount" in props and props["employeeCount"] is not None:
            if not isinstance(props["employeeCount"], int):
                try:
                    # Attempt to convert
                    props["employeeCount"] = int(props["employeeCount"])
                except:
                    raise TypeError(f"Property employeeCount must be of type int, got {type(props['employeeCount']).__name__}")
    
        # Type check animationStyle (expected str)
        if "animationStyle" in props and props["animationStyle"] is not None:
            if not isinstance(props["animationStyle"], str):
                try:
                    # Attempt to convert
                    props["animationStyle"] = str(props["animationStyle"])
                except:
                    raise TypeError(f"Property animationStyle must be of type str, got {type(props['animationStyle']).__name__}")
    
        # Type check technologyBudget (expected int)
        if "technologyBudget" in props and props["technologyBudget"] is not None:
            if not isinstance(props["technologyBudget"], int):
                try:
                    # Attempt to convert
                    props["technologyBudget"] = int(props["technologyBudget"])
                except:
                    raise TypeError(f"Property technologyBudget must be of type int, got {type(props['technologyBudget']).__name__}")
    
        # Type check yearsInIndustry (expected int)
        if "yearsInIndustry" in props and props["yearsInIndustry"] is not None:
            if not isinstance(props["yearsInIndustry"], int):
                try:
                    # Attempt to convert
                    props["yearsInIndustry"] = int(props["yearsInIndustry"])
                except:
                    raise TypeError(f"Property yearsInIndustry must be of type int, got {type(props['yearsInIndustry']).__name__}")
    
        # Type check animationBackground (expected bool)
        if "animationBackground" in props and props["animationBackground"] is not None:
            if not isinstance(props["animationBackground"], bool):
                try:
                    # Attempt to convert
                    props["animationBackground"] = bool(props["animationBackground"])
                except:
                    raise TypeError(f"Property animationBackground must be of type bool, got {type(props['animationBackground']).__name__}")
    
        # Type check designStyle (expected str)
        if "designStyle" in props and props["designStyle"] is not None:
            if not isinstance(props["designStyle"], str):
                try:
                    # Attempt to convert
                    props["designStyle"] = str(props["designStyle"])
                except:
                    raise TypeError(f"Property designStyle must be of type str, got {type(props['designStyle']).__name__}")
    
        # Type check cameraPreference (expected str)
        if "cameraPreference" in props and props["cameraPreference"] is not None:
            if not isinstance(props["cameraPreference"], str):
                try:
                    # Attempt to convert
                    props["cameraPreference"] = str(props["cameraPreference"])
                except:
                    raise TypeError(f"Property cameraPreference must be of type str, got {type(props['cameraPreference']).__name__}")
    
        # Type check visualStyle (expected str)
        if "visualStyle" in props and props["visualStyle"] is not None:
            if not isinstance(props["visualStyle"], str):
                try:
                    # Attempt to convert
                    props["visualStyle"] = str(props["visualStyle"])
                except:
                    raise TypeError(f"Property visualStyle must be of type str, got {type(props['visualStyle']).__name__}")
    
        # Type check fanfictionCount (expected int)
        if "fanfictionCount" in props and props["fanfictionCount"] is not None:
            if not isinstance(props["fanfictionCount"], int):
                try:
                    # Attempt to convert
                    props["fanfictionCount"] = int(props["fanfictionCount"])
                except:
                    raise TypeError(f"Property fanfictionCount must be of type int, got {type(props['fanfictionCount']).__name__}")
    
        # Type check expansion2049 (expected object)
        if "expansion2049" in props and props["expansion2049"] is not None:
            if not isinstance(props["expansion2049"], object):
                try:
                    # Attempt to convert
                    props["expansion2049"] = object(props["expansion2049"])
                except:
                    raise TypeError(f"Property expansion2049 must be of type object, got {type(props['expansion2049']).__name__}")
    
        # Type check largestEventAttendance (expected int)
        if "largestEventAttendance" in props and props["largestEventAttendance"] is not None:
            if not isinstance(props["largestEventAttendance"], int):
                try:
                    # Attempt to convert
                    props["largestEventAttendance"] = int(props["largestEventAttendance"])
                except:
                    raise TypeError(f"Property largestEventAttendance must be of type int, got {type(props['largestEventAttendance']).__name__}")
    
        # Type check academicPapers (expected int)
        if "academicPapers" in props and props["academicPapers"] is not None:
            if not isinstance(props["academicPapers"], int):
                try:
                    # Attempt to convert
                    props["academicPapers"] = int(props["academicPapers"])
                except:
                    raise TypeError(f"Property academicPapers must be of type int, got {type(props['academicPapers']).__name__}")
    
        # Type check contentCreators (expected int)
        if "contentCreators" in props and props["contentCreators"] is not None:
            if not isinstance(props["contentCreators"], int):
                try:
                    # Attempt to convert
                    props["contentCreators"] = int(props["contentCreators"])
                except:
                    raise TypeError(f"Property contentCreators must be of type int, got {type(props['contentCreators']).__name__}")
    
        # Type check memberCount (expected int)
        if "memberCount" in props and props["memberCount"] is not None:
            if not isinstance(props["memberCount"], int):
                try:
                    # Attempt to convert
                    props["memberCount"] = int(props["memberCount"])
                except:
                    raise TypeError(f"Property memberCount must be of type int, got {type(props['memberCount']).__name__}")
    
        # Type check annualConventions (expected int)
        if "annualConventions" in props and props["annualConventions"] is not None:
            if not isinstance(props["annualConventions"], int):
                try:
                    # Attempt to convert
                    props["annualConventions"] = int(props["annualConventions"])
                except:
                    raise TypeError(f"Property annualConventions must be of type int, got {type(props['annualConventions']).__name__}")
    
        # Type check fanArtCount (expected int)
        if "fanArtCount" in props and props["fanArtCount"] is not None:
            if not isinstance(props["fanArtCount"], int):
                try:
                    # Attempt to convert
                    props["fanArtCount"] = int(props["fanArtCount"])
                except:
                    raise TypeError(f"Property fanArtCount must be of type int, got {type(props['fanArtCount']).__name__}")
    
        # Type check onlinePlatforms (expected int)
        if "onlinePlatforms" in props and props["onlinePlatforms"] is not None:
            if not isinstance(props["onlinePlatforms"], int):
                try:
                    # Attempt to convert
                    props["onlinePlatforms"] = int(props["onlinePlatforms"])
                except:
                    raise TypeError(f"Property onlinePlatforms must be of type int, got {type(props['onlinePlatforms']).__name__}")
    
        # Type check industryAwards (expected int)
        if "industryAwards" in props and props["industryAwards"] is not None:
            if not isinstance(props["industryAwards"], int):
                try:
                    # Attempt to convert
                    props["industryAwards"] = int(props["industryAwards"])
                except:
                    raise TypeError(f"Property industryAwards must be of type int, got {type(props['industryAwards']).__name__}")
    
        # Type check adoptionRate (expected float)
        if "adoptionRate" in props and props["adoptionRate"] is not None:
            if not isinstance(props["adoptionRate"], float):
                try:
                    # Attempt to convert
                    props["adoptionRate"] = float(props["adoptionRate"])
                except:
                    raise TypeError(f"Property adoptionRate must be of type float, got {type(props['adoptionRate']).__name__}")
    
        # Type check secondaryApplications (expected int)
        if "secondaryApplications" in props and props["secondaryApplications"] is not None:
            if not isinstance(props["secondaryApplications"], int):
                try:
                    # Attempt to convert
                    props["secondaryApplications"] = int(props["secondaryApplications"])
                except:
                    raise TypeError(f"Property secondaryApplications must be of type int, got {type(props['secondaryApplications']).__name__}")
    
        # Type check mainApplication (expected str)
        if "mainApplication" in props and props["mainApplication"] is not None:
            if not isinstance(props["mainApplication"], str):
                try:
                    # Attempt to convert
                    props["mainApplication"] = str(props["mainApplication"])
                except:
                    raise TypeError(f"Property mainApplication must be of type str, got {type(props['mainApplication']).__name__}")
    
        # Type check technicalPapersPublished (expected int)
        if "technicalPapersPublished" in props and props["technicalPapersPublished"] is not None:
            if not isinstance(props["technicalPapersPublished"], int):
                try:
                    # Attempt to convert
                    props["technicalPapersPublished"] = int(props["technicalPapersPublished"])
                except:
                    raise TypeError(f"Property technicalPapersPublished must be of type int, got {type(props['technicalPapersPublished']).__name__}")
    
        # Type check teamSize (expected int)
        if "teamSize" in props and props["teamSize"] is not None:
            if not isinstance(props["teamSize"], int):
                try:
                    # Attempt to convert
                    props["teamSize"] = int(props["teamSize"])
                except:
                    raise TypeError(f"Property teamSize must be of type int, got {type(props['teamSize']).__name__}")
    
        # Type check developmentCost (expected int)
        if "developmentCost" in props and props["developmentCost"] is not None:
            if not isinstance(props["developmentCost"], int):
                try:
                    # Attempt to convert
                    props["developmentCost"] = int(props["developmentCost"])
                except:
                    raise TypeError(f"Property developmentCost must be of type int, got {type(props['developmentCost']).__name__}")
    
        # Type check patented (expected object)
        if "patented" in props and props["patented"] is not None:
            if not isinstance(props["patented"], object):
                try:
                    # Attempt to convert
                    props["patented"] = object(props["patented"])
                except:
                    raise TypeError(f"Property patented must be of type object, got {type(props['patented']).__name__}")
    
        # Type check developedDate (expected object)
        if "developedDate" in props and props["developedDate"] is not None:
            if not isinstance(props["developedDate"], object):
                try:
                    # Attempt to convert
                    props["developedDate"] = object(props["developedDate"])
                except:
                    raise TypeError(f"Property developedDate must be of type object, got {type(props['developedDate']).__name__}")
    
        # Type check musicStyle (expected str)
        if "musicStyle" in props and props["musicStyle"] is not None:
            if not isinstance(props["musicStyle"], str):
                try:
                    # Attempt to convert
                    props["musicStyle"] = str(props["musicStyle"])
                except:
                    raise TypeError(f"Property musicStyle must be of type str, got {type(props['musicStyle']).__name__}")
    
        # Type check awardNominations (expected int)
        if "awardNominations" in props and props["awardNominations"] is not None:
            if not isinstance(props["awardNominations"], int):
                try:
                    # Attempt to convert
                    props["awardNominations"] = int(props["awardNominations"])
                except:
                    raise TypeError(f"Property awardNominations must be of type int, got {type(props['awardNominations']).__name__}")
    
        # Type check instrumentsPlayed (expected int)
        if "instrumentsPlayed" in props and props["instrumentsPlayed"] is not None:
            if not isinstance(props["instrumentsPlayed"], int):
                try:
                    # Attempt to convert
                    props["instrumentsPlayed"] = int(props["instrumentsPlayed"])
                except:
                    raise TypeError(f"Property instrumentsPlayed must be of type int, got {type(props['instrumentsPlayed']).__name__}")
    
        # Type check studioLocation (expected str)
        if "studioLocation" in props and props["studioLocation"] is not None:
            if not isinstance(props["studioLocation"], str):
                try:
                    # Attempt to convert
                    props["studioLocation"] = str(props["studioLocation"])
                except:
                    raise TypeError(f"Property studioLocation must be of type str, got {type(props['studioLocation']).__name__}")
    
        # Type check preservationRegistry (expected str)
        if "preservationRegistry" in props and props["preservationRegistry"] is not None:
            if not isinstance(props["preservationRegistry"], str):
                try:
                    # Attempt to convert
                    props["preservationRegistry"] = str(props["preservationRegistry"])
                except:
                    raise TypeError(f"Property preservationRegistry must be of type str, got {type(props['preservationRegistry']).__name__}")
    
        # Type check digitalRestoration (expected object)
        if "digitalRestoration" in props and props["digitalRestoration"] is not None:
            if not isinstance(props["digitalRestoration"], object):
                try:
                    # Attempt to convert
                    props["digitalRestoration"] = object(props["digitalRestoration"])
                except:
                    raise TypeError(f"Property digitalRestoration must be of type object, got {type(props['digitalRestoration']).__name__}")
    
        # Type check isPreservationRegistry (expected bool)
        if "isPreservationRegistry" in props and props["isPreservationRegistry"] is not None:
            if not isinstance(props["isPreservationRegistry"], bool):
                try:
                    # Attempt to convert
                    props["isPreservationRegistry"] = bool(props["isPreservationRegistry"])
                except:
                    raise TypeError(f"Property isPreservationRegistry must be of type bool, got {type(props['isPreservationRegistry']).__name__}")
    
        # Type check preservationDate (expected object)
        if "preservationDate" in props and props["preservationDate"] is not None:
            if not isinstance(props["preservationDate"], object):
                try:
                    # Attempt to convert
                    props["preservationDate"] = object(props["preservationDate"])
                except:
                    raise TypeError(f"Property preservationDate must be of type object, got {type(props['preservationDate']).__name__}")
    
        # Type check initialReviews (expected object)
        if "initialReviews" in props and props["initialReviews"] is not None:
            if not isinstance(props["initialReviews"], object):
                try:
                    # Attempt to convert
                    props["initialReviews"] = object(props["initialReviews"])
                except:
                    raise TypeError(f"Property initialReviews must be of type object, got {type(props['initialReviews']).__name__}")
    
        # Type check technicalInnovations (expected int)
        if "technicalInnovations" in props and props["technicalInnovations"] is not None:
            if not isinstance(props["technicalInnovations"], int):
                try:
                    # Attempt to convert
                    props["technicalInnovations"] = int(props["technicalInnovations"])
                except:
                    raise TypeError(f"Property technicalInnovations must be of type int, got {type(props['technicalInnovations']).__name__}")
    
        # Type check festivalsWon (expected object)
        if "festivalsWon" in props and props["festivalsWon"] is not None:
            if not isinstance(props["festivalsWon"], object):
                try:
                    # Attempt to convert
                    props["festivalsWon"] = object(props["festivalsWon"])
                except:
                    raise TypeError(f"Property festivalsWon must be of type object, got {type(props['festivalsWon']).__name__}")
    
        # Type check originalLanguage (expected str)
        if "originalLanguage" in props and props["originalLanguage"] is not None:
            if not isinstance(props["originalLanguage"], str):
                try:
                    # Attempt to convert
                    props["originalLanguage"] = str(props["originalLanguage"])
                except:
                    raise TypeError(f"Property originalLanguage must be of type str, got {type(props['originalLanguage']).__name__}")
    
        # Type check boxOfficeInternational (expected int)
        if "boxOfficeInternational" in props and props["boxOfficeInternational"] is not None:
            if not isinstance(props["boxOfficeInternational"], int):
                try:
                    # Attempt to convert
                    props["boxOfficeInternational"] = int(props["boxOfficeInternational"])
                except:
                    raise TypeError(f"Property boxOfficeInternational must be of type int, got {type(props['boxOfficeInternational']).__name__}")
    
        # Type check subtitleLanguages (expected object)
        if "subtitleLanguages" in props and props["subtitleLanguages"] is not None:
            if not isinstance(props["subtitleLanguages"], object):
                try:
                    # Attempt to convert
                    props["subtitleLanguages"] = object(props["subtitleLanguages"])
                except:
                    raise TypeError(f"Property subtitleLanguages must be of type object, got {type(props['subtitleLanguages']).__name__}")
    
        # Type check isInternational (expected bool)
        if "isInternational" in props and props["isInternational"] is not None:
            if not isinstance(props["isInternational"], bool):
                try:
                    # Attempt to convert
                    props["isInternational"] = bool(props["isInternational"])
                except:
                    raise TypeError(f"Property isInternational must be of type bool, got {type(props['isInternational']).__name__}")
    
        # Type check temperatureUnit (expected str)
        if "temperatureUnit" in props and props["temperatureUnit"] is not None:
            if not isinstance(props["temperatureUnit"], str):
                try:
                    # Attempt to convert
                    props["temperatureUnit"] = str(props["temperatureUnit"])
                except:
                    raise TypeError(f"Property temperatureUnit must be of type str, got {type(props['temperatureUnit']).__name__}")
    
        # Type check extremeTemperatures (expected object)
        if "extremeTemperatures" in props and props["extremeTemperatures"] is not None:
            if not isinstance(props["extremeTemperatures"], object):
                try:
                    # Attempt to convert
                    props["extremeTemperatures"] = object(props["extremeTemperatures"])
                except:
                    raise TypeError(f"Property extremeTemperatures must be of type object, got {type(props['extremeTemperatures']).__name__}")
    
        # Type check filmingDuration (expected object)
        if "filmingDuration" in props and props["filmingDuration"] is not None:
            if not isinstance(props["filmingDuration"], object):
                try:
                    # Attempt to convert
                    props["filmingDuration"] = object(props["filmingDuration"])
                except:
                    raise TypeError(f"Property filmingDuration must be of type object, got {type(props['filmingDuration']).__name__}")
    
        # Type check filmingConditions (expected str)
        if "filmingConditions" in props and props["filmingConditions"] is not None:
            if not isinstance(props["filmingConditions"], str):
                try:
                    # Attempt to convert
                    props["filmingConditions"] = str(props["filmingConditions"])
                except:
                    raise TypeError(f"Property filmingConditions must be of type str, got {type(props['filmingConditions']).__name__}")
    
        # Type check narrators (expected object)
        if "narrators" in props and props["narrators"] is not None:
            if not isinstance(props["narrators"], object):
                try:
                    # Attempt to convert
                    props["narrators"] = object(props["narrators"])
                except:
                    raise TypeError(f"Property narrators must be of type object, got {type(props['narrators']).__name__}")
    
        # Type check isDocumentary (expected bool)
        if "isDocumentary" in props and props["isDocumentary"] is not None:
            if not isinstance(props["isDocumentary"], bool):
                try:
                    # Attempt to convert
                    props["isDocumentary"] = bool(props["isDocumentary"])
                except:
                    raise TypeError(f"Property isDocumentary must be of type bool, got {type(props['isDocumentary']).__name__}")
    
        # Type check significance (expected str)
        if "significance" in props and props["significance"] is not None:
            if not isinstance(props["significance"], str):
                try:
                    # Attempt to convert
                    props["significance"] = str(props["significance"])
                except:
                    raise TypeError(f"Property significance must be of type str, got {type(props['significance']).__name__}")
    
        # Type check died (expected int)
        if "died" in props and props["died"] is not None:
            if not isinstance(props["died"], int):
                try:
                    # Attempt to convert
                    props["died"] = int(props["died"])
                except:
                    raise TypeError(f"Property died must be of type int, got {type(props['died']).__name__}")
    
        # Type check skillSets (expected object)
        if "skillSets" in props and props["skillSets"] is not None:
            if not isinstance(props["skillSets"], object):
                try:
                    # Attempt to convert
                    props["skillSets"] = object(props["skillSets"])
                except:
                    raise TypeError(f"Property skillSets must be of type object, got {type(props['skillSets']).__name__}")
    
        # Type check filmingStyle (expected str)
        if "filmingStyle" in props and props["filmingStyle"] is not None:
            if not isinstance(props["filmingStyle"], str):
                try:
                    # Attempt to convert
                    props["filmingStyle"] = str(props["filmingStyle"])
                except:
                    raise TypeError(f"Property filmingStyle must be of type str, got {type(props['filmingStyle']).__name__}")
    
        # Type check internationalRecognition (expected object)
        if "internationalRecognition" in props and props["internationalRecognition"] is not None:
            if not isinstance(props["internationalRecognition"], object):
                try:
                    # Attempt to convert
                    props["internationalRecognition"] = object(props["internationalRecognition"])
                except:
                    raise TypeError(f"Property internationalRecognition must be of type object, got {type(props['internationalRecognition']).__name__}")
    
        # Type check fieldworkLocations (expected object)
        if "fieldworkLocations" in props and props["fieldworkLocations"] is not None:
            if not isinstance(props["fieldworkLocations"], object):
                try:
                    # Attempt to convert
                    props["fieldworkLocations"] = object(props["fieldworkLocations"])
                except:
                    raise TypeError(f"Property fieldworkLocations must be of type object, got {type(props['fieldworkLocations']).__name__}")
    
        # Type check academicDegrees (expected object)
        if "academicDegrees" in props and props["academicDegrees"] is not None:
            if not isinstance(props["academicDegrees"], object):
                try:
                    # Attempt to convert
                    props["academicDegrees"] = object(props["academicDegrees"])
                except:
                    raise TypeError(f"Property academicDegrees must be of type object, got {type(props['academicDegrees']).__name__}")
    
        # Type check background (expected str)
        if "background" in props and props["background"] is not None:
            if not isinstance(props["background"], str):
                try:
                    # Attempt to convert
                    props["background"] = str(props["background"])
                except:
                    raise TypeError(f"Property background must be of type str, got {type(props['background']).__name__}")
    
        # Type check collaborationsWithBong (expected int)
        if "collaborationsWithBong" in props and props["collaborationsWithBong"] is not None:
            if not isinstance(props["collaborationsWithBong"], int):
                try:
                    # Attempt to convert
                    props["collaborationsWithBong"] = int(props["collaborationsWithBong"])
                except:
                    raise TypeError(f"Property collaborationsWithBong must be of type int, got {type(props['collaborationsWithBong']).__name__}")
    
        # Type check technicalPreferences (expected object)
        if "technicalPreferences" in props and props["technicalPreferences"] is not None:
            if not isinstance(props["technicalPreferences"], object):
                try:
                    # Attempt to convert
                    props["technicalPreferences"] = object(props["technicalPreferences"])
                except:
                    raise TypeError(f"Property technicalPreferences must be of type object, got {type(props['technicalPreferences']).__name__}")
    
        # Type check innovations (expected object)
        if "innovations" in props and props["innovations"] is not None:
            if not isinstance(props["innovations"], object):
                try:
                    # Attempt to convert
                    props["innovations"] = object(props["innovations"])
                except:
                    raise TypeError(f"Property innovations must be of type object, got {type(props['innovations']).__name__}")
    
        # Type check internationalOffices (expected object)
        if "internationalOffices" in props and props["internationalOffices"] is not None:
            if not isinstance(props["internationalOffices"], object):
                try:
                    # Attempt to convert
                    props["internationalOffices"] = object(props["internationalOffices"])
                except:
                    raise TypeError(f"Property internationalOffices must be of type object, got {type(props['internationalOffices']).__name__}")
    
        # Type check internationalPresence (expected int)
        if "internationalPresence" in props and props["internationalPresence"] is not None:
            if not isinstance(props["internationalPresence"], int):
                try:
                    # Attempt to convert
                    props["internationalPresence"] = int(props["internationalPresence"])
                except:
                    raise TypeError(f"Property internationalPresence must be of type int, got {type(props['internationalPresence']).__name__}")
    
        # Type check yearlyRevenue2019 (expected int)
        if "yearlyRevenue2019" in props and props["yearlyRevenue2019"] is not None:
            if not isinstance(props["yearlyRevenue2019"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue2019"] = int(props["yearlyRevenue2019"])
                except:
                    raise TypeError(f"Property yearlyRevenue2019 must be of type int, got {type(props['yearlyRevenue2019']).__name__}")
    
        # Type check parentCompany (expected str)
        if "parentCompany" in props and props["parentCompany"] is not None:
            if not isinstance(props["parentCompany"], str):
                try:
                    # Attempt to convert
                    props["parentCompany"] = str(props["parentCompany"])
                except:
                    raise TypeError(f"Property parentCompany must be of type str, got {type(props['parentCompany']).__name__}")
    
        # Type check conservationContributions (expected int)
        if "conservationContributions" in props and props["conservationContributions"] is not None:
            if not isinstance(props["conservationContributions"], int):
                try:
                    # Attempt to convert
                    props["conservationContributions"] = int(props["conservationContributions"])
                except:
                    raise TypeError(f"Property conservationContributions must be of type int, got {type(props['conservationContributions']).__name__}")
    
        # Type check conservationPartners (expected object)
        if "conservationPartners" in props and props["conservationPartners"] is not None:
            if not isinstance(props["conservationPartners"], object):
                try:
                    # Attempt to convert
                    props["conservationPartners"] = object(props["conservationPartners"])
                except:
                    raise TypeError(f"Property conservationPartners must be of type object, got {type(props['conservationPartners']).__name__}")
    
        # Type check documentaryFocus (expected object)
        if "documentaryFocus" in props and props["documentaryFocus"] is not None:
            if not isinstance(props["documentaryFocus"], object):
                try:
                    # Attempt to convert
                    props["documentaryFocus"] = object(props["documentaryFocus"])
                except:
                    raise TypeError(f"Property documentaryFocus must be of type object, got {type(props['documentaryFocus']).__name__}")
    
        # Type check releasedTitles (expected object)
        if "releasedTitles" in props and props["releasedTitles"] is not None:
            if not isinstance(props["releasedTitles"], object):
                try:
                    # Attempt to convert
                    props["releasedTitles"] = object(props["releasedTitles"])
                except:
                    raise TypeError(f"Property releasedTitles must be of type object, got {type(props['releasedTitles']).__name__}")
    
        # Type check releasedYears (expected object)
        if "releasedYears" in props and props["releasedYears"] is not None:
            if not isinstance(props["releasedYears"], object):
                try:
                    # Attempt to convert
                    props["releasedYears"] = object(props["releasedYears"])
                except:
                    raise TypeError(f"Property releasedYears must be of type object, got {type(props['releasedYears']).__name__}")
    
        # Type check archivalFootageHours (expected int)
        if "archivalFootageHours" in props and props["archivalFootageHours"] is not None:
            if not isinstance(props["archivalFootageHours"], int):
                try:
                    # Attempt to convert
                    props["archivalFootageHours"] = int(props["archivalFootageHours"])
                except:
                    raise TypeError(f"Property archivalFootageHours must be of type int, got {type(props['archivalFootageHours']).__name__}")
    
        # Type check dissolved (expected object)
        if "dissolved" in props and props["dissolved"] is not None:
            if not isinstance(props["dissolved"], object):
                try:
                    # Attempt to convert
                    props["dissolved"] = object(props["dissolved"])
                except:
                    raise TypeError(f"Property dissolved must be of type object, got {type(props['dissolved']).__name__}")
    
        # Type check historicalSignificance (expected str)
        if "historicalSignificance" in props and props["historicalSignificance"] is not None:
            if not isinstance(props["historicalSignificance"], str):
                try:
                    # Attempt to convert
                    props["historicalSignificance"] = str(props["historicalSignificance"])
                except:
                    raise TypeError(f"Property historicalSignificance must be of type str, got {type(props['historicalSignificance']).__name__}")
    
        # Type check keyFigures (expected object)
        if "keyFigures" in props and props["keyFigures"] is not None:
            if not isinstance(props["keyFigures"], object):
                try:
                    # Attempt to convert
                    props["keyFigures"] = object(props["keyFigures"])
                except:
                    raise TypeError(f"Property keyFigures must be of type object, got {type(props['keyFigures']).__name__}")
    
        # Type check digitalArchiveCreation (expected object)
        if "digitalArchiveCreation" in props and props["digitalArchiveCreation"] is not None:
            if not isinstance(props["digitalArchiveCreation"], object):
                try:
                    # Attempt to convert
                    props["digitalArchiveCreation"] = object(props["digitalArchiveCreation"])
                except:
                    raise TypeError(f"Property digitalArchiveCreation must be of type object, got {type(props['digitalArchiveCreation']).__name__}")
    
        # Type check studioLotsHistorical (expected object)
        if "studioLotsHistorical" in props and props["studioLotsHistorical"] is not None:
            if not isinstance(props["studioLotsHistorical"], object):
                try:
                    # Attempt to convert
                    props["studioLotsHistorical"] = object(props["studioLotsHistorical"])
                except:
                    raise TypeError(f"Property studioLotsHistorical must be of type object, got {type(props['studioLotsHistorical']).__name__}")
    
        # Type check peakYear (expected int)
        if "peakYear" in props and props["peakYear"] is not None:
            if not isinstance(props["peakYear"], int):
                try:
                    # Attempt to convert
                    props["peakYear"] = int(props["peakYear"])
                except:
                    raise TypeError(f"Property peakYear must be of type int, got {type(props['peakYear']).__name__}")
    
        # Type check reestablished (expected object)
        if "reestablished" in props and props["reestablished"] is not None:
            if not isinstance(props["reestablished"], object):
                try:
                    # Attempt to convert
                    props["reestablished"] = object(props["reestablished"])
                except:
                    raise TypeError(f"Property reestablished must be of type object, got {type(props['reestablished']).__name__}")
    
        # Type check peakYearlyRevenue (expected int)
        if "peakYearlyRevenue" in props and props["peakYearlyRevenue"] is not None:
            if not isinstance(props["peakYearlyRevenue"], int):
                try:
                    # Attempt to convert
                    props["peakYearlyRevenue"] = int(props["peakYearlyRevenue"])
                except:
                    raise TypeError(f"Property peakYearlyRevenue must be of type int, got {type(props['peakYearlyRevenue']).__name__}")
    
        # Type check innovationImpact (expected object)
        if "innovationImpact" in props and props["innovationImpact"] is not None:
            if not isinstance(props["innovationImpact"], object):
                try:
                    # Attempt to convert
                    props["innovationImpact"] = object(props["innovationImpact"])
                except:
                    raise TypeError(f"Property innovationImpact must be of type object, got {type(props['innovationImpact']).__name__}")
    
        # Type check budgetSets (expected int)
        if "budgetSets" in props and props["budgetSets"] is not None:
            if not isinstance(props["budgetSets"], int):
                try:
                    # Attempt to convert
                    props["budgetSets"] = int(props["budgetSets"])
                except:
                    raise TypeError(f"Property budgetSets must be of type int, got {type(props['budgetSets']).__name__}")
    
        # Type check customSets (expected object)
        if "customSets" in props and props["customSets"] is not None:
            if not isinstance(props["customSets"], object):
                try:
                    # Attempt to convert
                    props["customSets"] = object(props["customSets"])
                except:
                    raise TypeError(f"Property customSets must be of type object, got {type(props['customSets']).__name__}")
    
        # Type check setConstructionDays (expected object)
        if "setConstructionDays" in props and props["setConstructionDays"] is not None:
            if not isinstance(props["setConstructionDays"], object):
                try:
                    # Attempt to convert
                    props["setConstructionDays"] = object(props["setConstructionDays"])
                except:
                    raise TypeError(f"Property setConstructionDays must be of type object, got {type(props['setConstructionDays']).__name__}")
    
        # Type check equipmentSuccessRate (expected object)
        if "equipmentSuccessRate" in props and props["equipmentSuccessRate"] is not None:
            if not isinstance(props["equipmentSuccessRate"], object):
                try:
                    # Attempt to convert
                    props["equipmentSuccessRate"] = object(props["equipmentSuccessRate"])
                except:
                    raise TypeError(f"Property equipmentSuccessRate must be of type object, got {type(props['equipmentSuccessRate']).__name__}")
    
        # Type check environmentalChallenges (expected object)
        if "environmentalChallenges" in props and props["environmentalChallenges"] is not None:
            if not isinstance(props["environmentalChallenges"], object):
                try:
                    # Attempt to convert
                    props["environmentalChallenges"] = object(props["environmentalChallenges"])
                except:
                    raise TypeError(f"Property environmentalChallenges must be of type object, got {type(props['environmentalChallenges']).__name__}")
    
        # Type check challengeSeverity (expected object)
        if "challengeSeverity" in props and props["challengeSeverity"] is not None:
            if not isinstance(props["challengeSeverity"], object):
                try:
                    # Attempt to convert
                    props["challengeSeverity"] = object(props["challengeSeverity"])
                except:
                    raise TypeError(f"Property challengeSeverity must be of type object, got {type(props['challengeSeverity']).__name__}")
    
        # Type check specialEquipment (expected object)
        if "specialEquipment" in props and props["specialEquipment"] is not None:
            if not isinstance(props["specialEquipment"], object):
                try:
                    # Attempt to convert
                    props["specialEquipment"] = object(props["specialEquipment"])
                except:
                    raise TypeError(f"Property specialEquipment must be of type object, got {type(props['specialEquipment']).__name__}")
    
        # Type check crewRotations (expected int)
        if "crewRotations" in props and props["crewRotations"] is not None:
            if not isinstance(props["crewRotations"], int):
                try:
                    # Attempt to convert
                    props["crewRotations"] = int(props["crewRotations"])
                except:
                    raise TypeError(f"Property crewRotations must be of type int, got {type(props['crewRotations']).__name__}")
    
        # Type check budgetSurvival (expected int)
        if "budgetSurvival" in props and props["budgetSurvival"] is not None:
            if not isinstance(props["budgetSurvival"], int):
                try:
                    # Attempt to convert
                    props["budgetSurvival"] = int(props["budgetSurvival"])
                except:
                    raise TypeError(f"Property budgetSurvival must be of type int, got {type(props['budgetSurvival']).__name__}")
    
        # Type check extremeConditionDays (expected int)
        if "extremeConditionDays" in props and props["extremeConditionDays"] is not None:
            if not isinstance(props["extremeConditionDays"], int):
                try:
                    # Attempt to convert
                    props["extremeConditionDays"] = int(props["extremeConditionDays"])
                except:
                    raise TypeError(f"Property extremeConditionDays must be of type int, got {type(props['extremeConditionDays']).__name__}")
    
        # Type check budgetTransport (expected int)
        if "budgetTransport" in props and props["budgetTransport"] is not None:
            if not isinstance(props["budgetTransport"], int):
                try:
                    # Attempt to convert
                    props["budgetTransport"] = int(props["budgetTransport"])
                except:
                    raise TypeError(f"Property budgetTransport must be of type int, got {type(props['budgetTransport']).__name__}")
    
        # Type check academicCitations (expected int)
        if "academicCitations" in props and props["academicCitations"] is not None:
            if not isinstance(props["academicCitations"], int):
                try:
                    # Attempt to convert
                    props["academicCitations"] = int(props["academicCitations"])
                except:
                    raise TypeError(f"Property academicCitations must be of type int, got {type(props['academicCitations']).__name__}")
    
        # Type check modernReassessmentDates (expected list)
        if "modernReassessmentDates" in props and props["modernReassessmentDates"] is not None:
            if not isinstance(props["modernReassessmentDates"], list):
                try:
                    # Attempt to convert
                    props["modernReassessmentDates"] = list(props["modernReassessmentDates"])
                except:
                    raise TypeError(f"Property modernReassessmentDates must be of type list, got {type(props['modernReassessmentDates']).__name__}")
    
        # Type check sightAndSoundRankings (expected object)
        if "sightAndSoundRankings" in props and props["sightAndSoundRankings"] is not None:
            if not isinstance(props["sightAndSoundRankings"], object):
                try:
                    # Attempt to convert
                    props["sightAndSoundRankings"] = object(props["sightAndSoundRankings"])
                except:
                    raise TypeError(f"Property sightAndSoundRankings must be of type object, got {type(props['sightAndSoundRankings']).__name__}")
    
        # Type check rankingYears (expected object)
        if "rankingYears" in props and props["rankingYears"] is not None:
            if not isinstance(props["rankingYears"], object):
                try:
                    # Attempt to convert
                    props["rankingYears"] = object(props["rankingYears"])
                except:
                    raise TypeError(f"Property rankingYears must be of type object, got {type(props['rankingYears']).__name__}")
    
        # Type check historicalReassessmentDate (expected object)
        if "historicalReassessmentDate" in props and props["historicalReassessmentDate"] is not None:
            if not isinstance(props["historicalReassessmentDate"], object):
                try:
                    # Attempt to convert
                    props["historicalReassessmentDate"] = object(props["historicalReassessmentDate"])
                except:
                    raise TypeError(f"Property historicalReassessmentDate must be of type object, got {type(props['historicalReassessmentDate']).__name__}")
    
        # Type check aspectWriting (expected float)
        if "aspectWriting" in props and props["aspectWriting"] is not None:
            if not isinstance(props["aspectWriting"], float):
                try:
                    # Attempt to convert
                    props["aspectWriting"] = float(props["aspectWriting"])
                except:
                    raise TypeError(f"Property aspectWriting must be of type float, got {type(props['aspectWriting']).__name__}")
    
        # Type check aspectInnovation (expected float)
        if "aspectInnovation" in props and props["aspectInnovation"] is not None:
            if not isinstance(props["aspectInnovation"], float):
                try:
                    # Attempt to convert
                    props["aspectInnovation"] = float(props["aspectInnovation"])
                except:
                    raise TypeError(f"Property aspectInnovation must be of type float, got {type(props['aspectInnovation']).__name__}")
    
        # Type check historicalRelevance (expected str)
        if "historicalRelevance" in props and props["historicalRelevance"] is not None:
            if not isinstance(props["historicalRelevance"], str):
                try:
                    # Attempt to convert
                    props["historicalRelevance"] = str(props["historicalRelevance"])
                except:
                    raise TypeError(f"Property historicalRelevance must be of type str, got {type(props['historicalRelevance']).__name__}")
    
        # Type check aspectSocialCommentary (expected float)
        if "aspectSocialCommentary" in props and props["aspectSocialCommentary"] is not None:
            if not isinstance(props["aspectSocialCommentary"], float):
                try:
                    # Attempt to convert
                    props["aspectSocialCommentary"] = float(props["aspectSocialCommentary"])
                except:
                    raise TypeError(f"Property aspectSocialCommentary must be of type float, got {type(props['aspectSocialCommentary']).__name__}")
    
        # Type check translationLanguages (expected object)
        if "translationLanguages" in props and props["translationLanguages"] is not None:
            if not isinstance(props["translationLanguages"], object):
                try:
                    # Attempt to convert
                    props["translationLanguages"] = object(props["translationLanguages"])
                except:
                    raise TypeError(f"Property translationLanguages must be of type object, got {type(props['translationLanguages']).__name__}")
    
        # Type check familyRecommendationScore (expected float)
        if "familyRecommendationScore" in props and props["familyRecommendationScore"] is not None:
            if not isinstance(props["familyRecommendationScore"], float):
                try:
                    # Attempt to convert
                    props["familyRecommendationScore"] = float(props["familyRecommendationScore"])
                except:
                    raise TypeError(f"Property familyRecommendationScore must be of type float, got {type(props['familyRecommendationScore']).__name__}")
    
        # Type check aspectCinematography (expected float)
        if "aspectCinematography" in props and props["aspectCinematography"] is not None:
            if not isinstance(props["aspectCinematography"], float):
                try:
                    # Attempt to convert
                    props["aspectCinematography"] = float(props["aspectCinematography"])
                except:
                    raise TypeError(f"Property aspectCinematography must be of type float, got {type(props['aspectCinematography']).__name__}")
    
        # Type check aspectEducationalValue (expected float)
        if "aspectEducationalValue" in props and props["aspectEducationalValue"] is not None:
            if not isinstance(props["aspectEducationalValue"], float):
                try:
                    # Attempt to convert
                    props["aspectEducationalValue"] = float(props["aspectEducationalValue"])
                except:
                    raise TypeError(f"Property aspectEducationalValue must be of type float, got {type(props['aspectEducationalValue']).__name__}")
    
        # Type check aspectNarration (expected float)
        if "aspectNarration" in props and props["aspectNarration"] is not None:
            if not isinstance(props["aspectNarration"], float):
                try:
                    # Attempt to convert
                    props["aspectNarration"] = float(props["aspectNarration"])
                except:
                    raise TypeError(f"Property aspectNarration must be of type float, got {type(props['aspectNarration']).__name__}")
    
        # Type check aspectEmotionalImpact (expected float)
        if "aspectEmotionalImpact" in props and props["aspectEmotionalImpact"] is not None:
            if not isinstance(props["aspectEmotionalImpact"], float):
                try:
                    # Attempt to convert
                    props["aspectEmotionalImpact"] = float(props["aspectEmotionalImpact"])
                except:
                    raise TypeError(f"Property aspectEmotionalImpact must be of type float, got {type(props['aspectEmotionalImpact']).__name__}")
    
        # Type check historicalWinners (expected object)
        if "historicalWinners" in props and props["historicalWinners"] is not None:
            if not isinstance(props["historicalWinners"], object):
                try:
                    # Attempt to convert
                    props["historicalWinners"] = object(props["historicalWinners"])
                except:
                    raise TypeError(f"Property historicalWinners must be of type object, got {type(props['historicalWinners']).__name__}")
    
        # Type check historicalYears (expected object)
        if "historicalYears" in props and props["historicalYears"] is not None:
            if not isinstance(props["historicalYears"], object):
                try:
                    # Attempt to convert
                    props["historicalYears"] = object(props["historicalYears"])
                except:
                    raise TypeError(f"Property historicalYears must be of type object, got {type(props['historicalYears']).__name__}")
    
        # Type check earliestPreservedFilm (expected str)
        if "earliestPreservedFilm" in props and props["earliestPreservedFilm"] is not None:
            if not isinstance(props["earliestPreservedFilm"], str):
                try:
                    # Attempt to convert
                    props["earliestPreservedFilm"] = str(props["earliestPreservedFilm"])
                except:
                    raise TypeError(f"Property earliestPreservedFilm must be of type str, got {type(props['earliestPreservedFilm']).__name__}")
    
        # Type check digitalPreservationBudget (expected int)
        if "digitalPreservationBudget" in props and props["digitalPreservationBudget"] is not None:
            if not isinstance(props["digitalPreservationBudget"], int):
                try:
                    # Attempt to convert
                    props["digitalPreservationBudget"] = int(props["digitalPreservationBudget"])
                except:
                    raise TypeError(f"Property digitalPreservationBudget must be of type int, got {type(props['digitalPreservationBudget']).__name__}")
    
        # Type check earliestPreservationYear (expected int)
        if "earliestPreservationYear" in props and props["earliestPreservationYear"] is not None:
            if not isinstance(props["earliestPreservationYear"], int):
                try:
                    # Attempt to convert
                    props["earliestPreservationYear"] = int(props["earliestPreservationYear"])
                except:
                    raise TypeError(f"Property earliestPreservationYear must be of type int, got {type(props['earliestPreservationYear']).__name__}")
    
        # Type check earliestFilmYear (expected int)
        if "earliestFilmYear" in props and props["earliestFilmYear"] is not None:
            if not isinstance(props["earliestFilmYear"], int):
                try:
                    # Attempt to convert
                    props["earliestFilmYear"] = int(props["earliestFilmYear"])
                except:
                    raise TypeError(f"Property earliestFilmYear must be of type int, got {type(props['earliestFilmYear']).__name__}")
    
        # Type check preservedFilmsCount (expected int)
        if "preservedFilmsCount" in props and props["preservedFilmsCount"] is not None:
            if not isinstance(props["preservedFilmsCount"], int):
                try:
                    # Attempt to convert
                    props["preservedFilmsCount"] = int(props["preservedFilmsCount"])
                except:
                    raise TypeError(f"Property preservedFilmsCount must be of type int, got {type(props['preservedFilmsCount']).__name__}")
    
        # Type check digitalizedFilmsCount (expected int)
        if "digitalizedFilmsCount" in props and props["digitalizedFilmsCount"] is not None:
            if not isinstance(props["digitalizedFilmsCount"], int):
                try:
                    # Attempt to convert
                    props["digitalizedFilmsCount"] = int(props["digitalizedFilmsCount"])
                except:
                    raise TypeError(f"Property digitalizedFilmsCount must be of type int, got {type(props['digitalizedFilmsCount']).__name__}")
    
        # Type check preservationCriteria (expected object)
        if "preservationCriteria" in props and props["preservationCriteria"] is not None:
            if not isinstance(props["preservationCriteria"], object):
                try:
                    # Attempt to convert
                    props["preservationCriteria"] = object(props["preservationCriteria"])
                except:
                    raise TypeError(f"Property preservationCriteria must be of type object, got {type(props['preservationCriteria']).__name__}")
    
        # Type check criteriaWeights (expected object)
        if "criteriaWeights" in props and props["criteriaWeights"] is not None:
            if not isinstance(props["criteriaWeights"], object):
                try:
                    # Attempt to convert
                    props["criteriaWeights"] = object(props["criteriaWeights"])
                except:
                    raise TypeError(f"Property criteriaWeights must be of type object, got {type(props['criteriaWeights']).__name__}")
    
        # Type check nextPreservationAnnouncement (expected object)
        if "nextPreservationAnnouncement" in props and props["nextPreservationAnnouncement"] is not None:
            if not isinstance(props["nextPreservationAnnouncement"], object):
                try:
                    # Attempt to convert
                    props["nextPreservationAnnouncement"] = object(props["nextPreservationAnnouncement"])
                except:
                    raise TypeError(f"Property nextPreservationAnnouncement must be of type object, got {type(props['nextPreservationAnnouncement']).__name__}")
    
        # Type check annualBudget (expected int)
        if "annualBudget" in props and props["annualBudget"] is not None:
            if not isinstance(props["annualBudget"], int):
                try:
                    # Attempt to convert
                    props["annualBudget"] = int(props["annualBudget"])
                except:
                    raise TypeError(f"Property annualBudget must be of type int, got {type(props['annualBudget']).__name__}")
    
        # Type check isGovernmentFunded (expected bool)
        if "isGovernmentFunded" in props and props["isGovernmentFunded"] is not None:
            if not isinstance(props["isGovernmentFunded"], bool):
                try:
                    # Attempt to convert
                    props["isGovernmentFunded"] = bool(props["isGovernmentFunded"])
                except:
                    raise TypeError(f"Property isGovernmentFunded must be of type bool, got {type(props['isGovernmentFunded']).__name__}")
    
        # Type check memberOrganizations (expected int)
        if "memberOrganizations" in props and props["memberOrganizations"] is not None:
            if not isinstance(props["memberOrganizations"], int):
                try:
                    # Attempt to convert
                    props["memberOrganizations"] = int(props["memberOrganizations"])
                except:
                    raise TypeError(f"Property memberOrganizations must be of type int, got {type(props['memberOrganizations']).__name__}")
    
        # Type check voiceType (expected str)
        if "voiceType" in props and props["voiceType"] is not None:
            if not isinstance(props["voiceType"], str):
                try:
                    # Attempt to convert
                    props["voiceType"] = str(props["voiceType"])
                except:
                    raise TypeError(f"Property voiceType must be of type str, got {type(props['voiceType']).__name__}")
    
        # Type check narratorRanking (expected int)
        if "narratorRanking" in props and props["narratorRanking"] is not None:
            if not isinstance(props["narratorRanking"], int):
                try:
                    # Attempt to convert
                    props["narratorRanking"] = int(props["narratorRanking"])
                except:
                    raise TypeError(f"Property narratorRanking must be of type int, got {type(props['narratorRanking']).__name__}")
    
        # Type check voiceRecognition (expected float)
        if "voiceRecognition" in props and props["voiceRecognition"] is not None:
            if not isinstance(props["voiceRecognition"], float):
                try:
                    # Attempt to convert
                    props["voiceRecognition"] = float(props["voiceRecognition"])
                except:
                    raise TypeError(f"Property voiceRecognition must be of type float, got {type(props['voiceRecognition']).__name__}")
    
        # Type check digitalArchiveSize (expected int)
        if "digitalArchiveSize" in props and props["digitalArchiveSize"] is not None:
            if not isinstance(props["digitalArchiveSize"], int):
                try:
                    # Attempt to convert
                    props["digitalArchiveSize"] = int(props["digitalArchiveSize"])
                except:
                    raise TypeError(f"Property digitalArchiveSize must be of type int, got {type(props['digitalArchiveSize']).__name__}")
    
        # Type check courseCount (expected int)
        if "courseCount" in props and props["courseCount"] is not None:
            if not isinstance(props["courseCount"], int):
                try:
                    # Attempt to convert
                    props["courseCount"] = int(props["courseCount"])
                except:
                    raise TypeError(f"Property courseCount must be of type int, got {type(props['courseCount']).__name__}")
    
        # Type check facultyCount (expected int)
        if "facultyCount" in props and props["facultyCount"] is not None:
            if not isinstance(props["facultyCount"], int):
                try:
                    # Attempt to convert
                    props["facultyCount"] = int(props["facultyCount"])
                except:
                    raise TypeError(f"Property facultyCount must be of type int, got {type(props['facultyCount']).__name__}")
    
        # Type check digitalArchiveUnit (expected str)
        if "digitalArchiveUnit" in props and props["digitalArchiveUnit"] is not None:
            if not isinstance(props["digitalArchiveUnit"], str):
                try:
                    # Attempt to convert
                    props["digitalArchiveUnit"] = str(props["digitalArchiveUnit"])
                except:
                    raise TypeError(f"Property digitalArchiveUnit must be of type str, got {type(props['digitalArchiveUnit']).__name__}")
    
        # Type check filmArchiveSize (expected int)
        if "filmArchiveSize" in props and props["filmArchiveSize"] is not None:
            if not isinstance(props["filmArchiveSize"], int):
                try:
                    # Attempt to convert
                    props["filmArchiveSize"] = int(props["filmArchiveSize"])
                except:
                    raise TypeError(f"Property filmArchiveSize must be of type int, got {type(props['filmArchiveSize']).__name__}")
    
        # Type check studentCount (expected int)
        if "studentCount" in props and props["studentCount"] is not None:
            if not isinstance(props["studentCount"], int):
                try:
                    # Attempt to convert
                    props["studentCount"] = int(props["studentCount"])
                except:
                    raise TypeError(f"Property studentCount must be of type int, got {type(props['studentCount']).__name__}")
    
        # Type check featureImpact (expected object)
        if "featureImpact" in props and props["featureImpact"] is not None:
            if not isinstance(props["featureImpact"], object):
                try:
                    # Attempt to convert
                    props["featureImpact"] = object(props["featureImpact"])
                except:
                    raise TypeError(f"Property featureImpact must be of type object, got {type(props['featureImpact']).__name__}")
    
        # Type check manufactured (expected object)
        if "manufactured" in props and props["manufactured"] is not None:
            if not isinstance(props["manufactured"], object):
                try:
                    # Attempt to convert
                    props["manufactured"] = object(props["manufactured"])
                except:
                    raise TypeError(f"Property manufactured must be of type object, got {type(props['manufactured']).__name__}")
    
        # Type check revolutionaryFeatures (expected object)
        if "revolutionaryFeatures" in props and props["revolutionaryFeatures"] is not None:
            if not isinstance(props["revolutionaryFeatures"], object):
                try:
                    # Attempt to convert
                    props["revolutionaryFeatures"] = object(props["revolutionaryFeatures"])
                except:
                    raise TypeError(f"Property revolutionaryFeatures must be of type object, got {type(props['revolutionaryFeatures']).__name__}")
    
        # Type check manufacturerLong (expected float)
        if "manufacturerLong" in props and props["manufacturerLong"] is not None:
            if not isinstance(props["manufacturerLong"], float):
                try:
                    # Attempt to convert
                    props["manufacturerLong"] = float(props["manufacturerLong"])
                except:
                    raise TypeError(f"Property manufacturerLong must be of type float, got {type(props['manufacturerLong']).__name__}")
    
        # Type check purchaseYear (expected int)
        if "purchaseYear" in props and props["purchaseYear"] is not None:
            if not isinstance(props["purchaseYear"], int):
                try:
                    # Attempt to convert
                    props["purchaseYear"] = int(props["purchaseYear"])
                except:
                    raise TypeError(f"Property purchaseYear must be of type int, got {type(props['purchaseYear']).__name__}")
    
        # Type check cost (expected int)
        if "cost" in props and props["cost"] is not None:
            if not isinstance(props["cost"], int):
                try:
                    # Attempt to convert
                    props["cost"] = int(props["cost"])
                except:
                    raise TypeError(f"Property cost must be of type int, got {type(props['cost']).__name__}")
    
        # Type check technicalSpecifications (expected str)
        if "technicalSpecifications" in props and props["technicalSpecifications"] is not None:
            if not isinstance(props["technicalSpecifications"], str):
                try:
                    # Attempt to convert
                    props["technicalSpecifications"] = str(props["technicalSpecifications"])
                except:
                    raise TypeError(f"Property technicalSpecifications must be of type str, got {type(props['technicalSpecifications']).__name__}")
    
        # Type check manufacturerLat (expected float)
        if "manufacturerLat" in props and props["manufacturerLat"] is not None:
            if not isinstance(props["manufacturerLat"], float):
                try:
                    # Attempt to convert
                    props["manufacturerLat"] = float(props["manufacturerLat"])
                except:
                    raise TypeError(f"Property manufacturerLat must be of type float, got {type(props['manufacturerLat']).__name__}")
    
        # Type check designed (expected object)
        if "designed" in props and props["designed"] is not None:
            if not isinstance(props["designed"], object):
                try:
                    # Attempt to convert
                    props["designed"] = object(props["designed"])
                except:
                    raise TypeError(f"Property designed must be of type object, got {type(props['designed']).__name__}")
    
        # Type check constructionHours (expected int)
        if "constructionHours" in props and props["constructionHours"] is not None:
            if not isinstance(props["constructionHours"], int):
                try:
                    # Attempt to convert
                    props["constructionHours"] = int(props["constructionHours"])
                except:
                    raise TypeError(f"Property constructionHours must be of type int, got {type(props['constructionHours']).__name__}")
    
        # Type check designer (expected str)
        if "designer" in props and props["designer"] is not None:
            if not isinstance(props["designer"], str):
                try:
                    # Attempt to convert
                    props["designer"] = str(props["designer"])
                except:
                    raise TypeError(f"Property designer must be of type str, got {type(props['designer']).__name__}")
    
        # Type check colorPalette (expected object)
        if "colorPalette" in props and props["colorPalette"] is not None:
            if not isinstance(props["colorPalette"], object):
                try:
                    # Attempt to convert
                    props["colorPalette"] = object(props["colorPalette"])
                except:
                    raise TypeError(f"Property colorPalette must be of type object, got {type(props['colorPalette']).__name__}")
    
        # Type check paletteMeaning (expected object)
        if "paletteMeaning" in props and props["paletteMeaning"] is not None:
            if not isinstance(props["paletteMeaning"], object):
                try:
                    # Attempt to convert
                    props["paletteMeaning"] = object(props["paletteMeaning"])
                except:
                    raise TypeError(f"Property paletteMeaning must be of type object, got {type(props['paletteMeaning']).__name__}")
    
        # Type check materialTypes (expected int)
        if "materialTypes" in props and props["materialTypes"] is not None:
            if not isinstance(props["materialTypes"], int):
                try:
                    # Attempt to convert
                    props["materialTypes"] = int(props["materialTypes"])
                except:
                    raise TypeError(f"Property materialTypes must be of type int, got {type(props['materialTypes']).__name__}")
    
        # Type check costumeBudget (expected int)
        if "costumeBudget" in props and props["costumeBudget"] is not None:
            if not isinstance(props["costumeBudget"], int):
                try:
                    # Attempt to convert
                    props["costumeBudget"] = int(props["costumeBudget"])
                except:
                    raise TypeError(f"Property costumeBudget must be of type int, got {type(props['costumeBudget']).__name__}")
    
        # Type check symbolismRating (expected float)
        if "symbolismRating" in props and props["symbolismRating"] is not None:
            if not isinstance(props["symbolismRating"], float):
                try:
                    # Attempt to convert
                    props["symbolismRating"] = float(props["symbolismRating"])
                except:
                    raise TypeError(f"Property symbolismRating must be of type float, got {type(props['symbolismRating']).__name__}")
    
        # Type check costumePieces (expected int)
        if "costumePieces" in props and props["costumePieces"] is not None:
            if not isinstance(props["costumePieces"], int):
                try:
                    # Attempt to convert
                    props["costumePieces"] = int(props["costumePieces"])
                except:
                    raise TypeError(f"Property costumePieces must be of type int, got {type(props['costumePieces']).__name__}")
    
        # Type check location (expected str)
        if "location" in props and props["location"] is not None:
            if not isinstance(props["location"], str):
                try:
                    # Attempt to convert
                    props["location"] = str(props["location"])
                except:
                    raise TypeError(f"Property location must be of type str, got {type(props['location']).__name__}")
    
        # Type check daylight (expected str)
        if "daylight" in props and props["daylight"] is not None:
            if not isinstance(props["daylight"], str):
                try:
                    # Attempt to convert
                    props["daylight"] = str(props["daylight"])
                except:
                    raise TypeError(f"Property daylight must be of type str, got {type(props['daylight']).__name__}")
    
        # Type check windSpeedMax (expected int)
        if "windSpeedMax" in props and props["windSpeedMax"] is not None:
            if not isinstance(props["windSpeedMax"], int):
                try:
                    # Attempt to convert
                    props["windSpeedMax"] = int(props["windSpeedMax"])
                except:
                    raise TypeError(f"Property windSpeedMax must be of type int, got {type(props['windSpeedMax']).__name__}")
    
        # Type check windSpeedAverage (expected int)
        if "windSpeedAverage" in props and props["windSpeedAverage"] is not None:
            if not isinstance(props["windSpeedAverage"], int):
                try:
                    # Attempt to convert
                    props["windSpeedAverage"] = int(props["windSpeedAverage"])
                except:
                    raise TypeError(f"Property windSpeedAverage must be of type int, got {type(props['windSpeedAverage']).__name__}")
    
        # Type check precipitationAnnual (expected int)
        if "precipitationAnnual" in props and props["precipitationAnnual"] is not None:
            if not isinstance(props["precipitationAnnual"], int):
                try:
                    # Attempt to convert
                    props["precipitationAnnual"] = int(props["precipitationAnnual"])
                except:
                    raise TypeError(f"Property precipitationAnnual must be of type int, got {type(props['precipitationAnnual']).__name__}")
    
        # Type check averageTemperature (expected int)
        if "averageTemperature" in props and props["averageTemperature"] is not None:
            if not isinstance(props["averageTemperature"], int):
                try:
                    # Attempt to convert
                    props["averageTemperature"] = int(props["averageTemperature"])
                except:
                    raise TypeError(f"Property averageTemperature must be of type int, got {type(props['averageTemperature']).__name__}")
    
        # Type check extremityIndex (expected float)
        if "extremityIndex" in props and props["extremityIndex"] is not None:
            if not isinstance(props["extremityIndex"], float):
                try:
                    # Attempt to convert
                    props["extremityIndex"] = float(props["extremityIndex"])
                except:
                    raise TypeError(f"Property extremityIndex must be of type float, got {type(props['extremityIndex']).__name__}")
    
        # Type check windSpeedUnit (expected str)
        if "windSpeedUnit" in props and props["windSpeedUnit"] is not None:
            if not isinstance(props["windSpeedUnit"], str):
                try:
                    # Attempt to convert
                    props["windSpeedUnit"] = str(props["windSpeedUnit"])
                except:
                    raise TypeError(f"Property windSpeedUnit must be of type str, got {type(props['windSpeedUnit']).__name__}")
    
        # Type check precipitationUnit (expected str)
        if "precipitationUnit" in props and props["precipitationUnit"] is not None:
            if not isinstance(props["precipitationUnit"], str):
                try:
                    # Attempt to convert
                    props["precipitationUnit"] = str(props["precipitationUnit"])
                except:
                    raise TypeError(f"Property precipitationUnit must be of type str, got {type(props['precipitationUnit']).__name__}")
    
        # Type check mostCitedTheories (expected object)
        if "mostCitedTheories" in props and props["mostCitedTheories"] is not None:
            if not isinstance(props["mostCitedTheories"], object):
                try:
                    # Attempt to convert
                    props["mostCitedTheories"] = object(props["mostCitedTheories"])
                except:
                    raise TypeError(f"Property mostCitedTheories must be of type object, got {type(props['mostCitedTheories']).__name__}")
    
        # Type check annualPublications (expected int)
        if "annualPublications" in props and props["annualPublications"] is not None:
            if not isinstance(props["annualPublications"], int):
                try:
                    # Attempt to convert
                    props["annualPublications"] = int(props["annualPublications"])
                except:
                    raise TypeError(f"Property annualPublications must be of type int, got {type(props['annualPublications']).__name__}")
    
        # Type check digitalArchives (expected int)
        if "digitalArchives" in props and props["digitalArchives"] is not None:
            if not isinstance(props["digitalArchives"], int):
                try:
                    # Attempt to convert
                    props["digitalArchives"] = int(props["digitalArchives"])
                except:
                    raise TypeError(f"Property digitalArchives must be of type int, got {type(props['digitalArchives']).__name__}")
    
        # Type check institutionsCount (expected int)
        if "institutionsCount" in props and props["institutionsCount"] is not None:
            if not isinstance(props["institutionsCount"], int):
                try:
                    # Attempt to convert
                    props["institutionsCount"] = int(props["institutionsCount"])
                except:
                    raise TypeError(f"Property institutionsCount must be of type int, got {type(props['institutionsCount']).__name__}")
    
        # Type check peerReviewedJournals (expected int)
        if "peerReviewedJournals" in props and props["peerReviewedJournals"] is not None:
            if not isinstance(props["peerReviewedJournals"], int):
                try:
                    # Attempt to convert
                    props["peerReviewedJournals"] = int(props["peerReviewedJournals"])
                except:
                    raise TypeError(f"Property peerReviewedJournals must be of type int, got {type(props['peerReviewedJournals']).__name__}")
    
        # Type check theoriesDevelopmentYears (expected object)
        if "theoriesDevelopmentYears" in props and props["theoriesDevelopmentYears"] is not None:
            if not isinstance(props["theoriesDevelopmentYears"], object):
                try:
                    # Attempt to convert
                    props["theoriesDevelopmentYears"] = object(props["theoriesDevelopmentYears"])
                except:
                    raise TypeError(f"Property theoriesDevelopmentYears must be of type object, got {type(props['theoriesDevelopmentYears']).__name__}")
    
        # Type check scholarCount (expected int)
        if "scholarCount" in props and props["scholarCount"] is not None:
            if not isinstance(props["scholarCount"], int):
                try:
                    # Attempt to convert
                    props["scholarCount"] = int(props["scholarCount"])
                except:
                    raise TypeError(f"Property scholarCount must be of type int, got {type(props['scholarCount']).__name__}")
    
        # Type check influentialDirectors (expected int)
        if "influentialDirectors" in props and props["influentialDirectors"] is not None:
            if not isinstance(props["influentialDirectors"], int):
                try:
                    # Attempt to convert
                    props["influentialDirectors"] = int(props["influentialDirectors"])
                except:
                    raise TypeError(f"Property influentialDirectors must be of type int, got {type(props['influentialDirectors']).__name__}")
    
        # Type check academicStudies (expected int)
        if "academicStudies" in props and props["academicStudies"] is not None:
            if not isinstance(props["academicStudies"], int):
                try:
                    # Attempt to convert
                    props["academicStudies"] = int(props["academicStudies"])
                except:
                    raise TypeError(f"Property academicStudies must be of type int, got {type(props['academicStudies']).__name__}")
    
        # Type check criticalReception (expected str)
        if "criticalReception" in props and props["criticalReception"] is not None:
            if not isinstance(props["criticalReception"], str):
                try:
                    # Attempt to convert
                    props["criticalReception"] = str(props["criticalReception"])
                except:
                    raise TypeError(f"Property criticalReception must be of type str, got {type(props['criticalReception']).__name__}")
    
        # Type check internationalFestivals (expected int)
        if "internationalFestivals" in props and props["internationalFestivals"] is not None:
            if not isinstance(props["internationalFestivals"], int):
                try:
                    # Attempt to convert
                    props["internationalFestivals"] = int(props["internationalFestivals"])
                except:
                    raise TypeError(f"Property internationalFestivals must be of type int, got {type(props['internationalFestivals']).__name__}")
    
        # Type check periodStart (expected object)
        if "periodStart" in props and props["periodStart"] is not None:
            if not isinstance(props["periodStart"], object):
                try:
                    # Attempt to convert
                    props["periodStart"] = object(props["periodStart"])
                except:
                    raise TypeError(f"Property periodStart must be of type object, got {type(props['periodStart']).__name__}")
    
        # Type check periodPeak (expected object)
        if "periodPeak" in props and props["periodPeak"] is not None:
            if not isinstance(props["periodPeak"], object):
                try:
                    # Attempt to convert
                    props["periodPeak"] = object(props["periodPeak"])
                except:
                    raise TypeError(f"Property periodPeak must be of type object, got {type(props['periodPeak']).__name__}")
    
        # Type check geographicalSpread (expected str)
        if "geographicalSpread" in props and props["geographicalSpread"] is not None:
            if not isinstance(props["geographicalSpread"], str):
                try:
                    # Attempt to convert
                    props["geographicalSpread"] = str(props["geographicalSpread"])
                except:
                    raise TypeError(f"Property geographicalSpread must be of type str, got {type(props['geographicalSpread']).__name__}")
    
        # Type check majorAwards (expected int)
        if "majorAwards" in props and props["majorAwards"] is not None:
            if not isinstance(props["majorAwards"], int):
                try:
                    # Attempt to convert
                    props["majorAwards"] = int(props["majorAwards"])
                except:
                    raise TypeError(f"Property majorAwards must be of type int, got {type(props['majorAwards']).__name__}")
    
        # Type check oscarsWon (expected int)
        if "oscarsWon" in props and props["oscarsWon"] is not None:
            if not isinstance(props["oscarsWon"], int):
                try:
                    # Attempt to convert
                    props["oscarsWon"] = int(props["oscarsWon"])
                except:
                    raise TypeError(f"Property oscarsWon must be of type int, got {type(props['oscarsWon']).__name__}")
    
        # Type check technologyPatents (expected int)
        if "technologyPatents" in props and props["technologyPatents"] is not None:
            if not isinstance(props["technologyPatents"], int):
                try:
                    # Attempt to convert
                    props["technologyPatents"] = int(props["technologyPatents"])
                except:
                    raise TypeError(f"Property technologyPatents must be of type int, got {type(props['technologyPatents']).__name__}")
    
        # Type check annualRevenue (expected int)
        if "annualRevenue" in props and props["annualRevenue"] is not None:
            if not isinstance(props["annualRevenue"], int):
                try:
                    # Attempt to convert
                    props["annualRevenue"] = int(props["annualRevenue"])
                except:
                    raise TypeError(f"Property annualRevenue must be of type int, got {type(props['annualRevenue']).__name__}")
    
        # Type check proprietarySoftware (expected int)
        if "proprietarySoftware" in props and props["proprietarySoftware"] is not None:
            if not isinstance(props["proprietarySoftware"], int):
                try:
                    # Attempt to convert
                    props["proprietarySoftware"] = int(props["proprietarySoftware"])
                except:
                    raise TypeError(f"Property proprietarySoftware must be of type int, got {type(props['proprietarySoftware']).__name__}")
    
        # Type check computingUnit (expected str)
        if "computingUnit" in props and props["computingUnit"] is not None:
            if not isinstance(props["computingUnit"], str):
                try:
                    # Attempt to convert
                    props["computingUnit"] = str(props["computingUnit"])
                except:
                    raise TypeError(f"Property computingUnit must be of type str, got {type(props['computingUnit']).__name__}")
    
        # Type check technicalAwards (expected int)
        if "technicalAwards" in props and props["technicalAwards"] is not None:
            if not isinstance(props["technicalAwards"], int):
                try:
                    # Attempt to convert
                    props["technicalAwards"] = int(props["technicalAwards"])
                except:
                    raise TypeError(f"Property technicalAwards must be of type int, got {type(props['technicalAwards']).__name__}")
    
        # Type check computingPower (expected int)
        if "computingPower" in props and props["computingPower"] is not None:
            if not isinstance(props["computingPower"], int):
                try:
                    # Attempt to convert
                    props["computingPower"] = int(props["computingPower"])
                except:
                    raise TypeError(f"Property computingPower must be of type int, got {type(props['computingPower']).__name__}")
    
        # Type check opened (expected object)
        if "opened" in props and props["opened"] is not None:
            if not isinstance(props["opened"], object):
                try:
                    # Attempt to convert
                    props["opened"] = object(props["opened"])
                except:
                    raise TypeError(f"Property opened must be of type object, got {type(props['opened']).__name__}")
    
        # Type check visitorCapacity (expected int)
        if "visitorCapacity" in props and props["visitorCapacity"] is not None:
            if not isinstance(props["visitorCapacity"], int):
                try:
                    # Attempt to convert
                    props["visitorCapacity"] = int(props["visitorCapacity"])
                except:
                    raise TypeError(f"Property visitorCapacity must be of type int, got {type(props['visitorCapacity']).__name__}")
    
        # Type check historicalArtifacts (expected int)
        if "historicalArtifacts" in props and props["historicalArtifacts"] is not None:
            if not isinstance(props["historicalArtifacts"], int):
                try:
                    # Attempt to convert
                    props["historicalArtifacts"] = int(props["historicalArtifacts"])
                except:
                    raise TypeError(f"Property historicalArtifacts must be of type int, got {type(props['historicalArtifacts']).__name__}")
    
        # Type check interactiveElements (expected int)
        if "interactiveElements" in props and props["interactiveElements"] is not None:
            if not isinstance(props["interactiveElements"], int):
                try:
                    # Attempt to convert
                    props["interactiveElements"] = int(props["interactiveElements"])
                except:
                    raise TypeError(f"Property interactiveElements must be of type int, got {type(props['interactiveElements']).__name__}")
    
        # Type check sizeUnit (expected str)
        if "sizeUnit" in props and props["sizeUnit"] is not None:
            if not isinstance(props["sizeUnit"], str):
                try:
                    # Attempt to convert
                    props["sizeUnit"] = str(props["sizeUnit"])
                except:
                    raise TypeError(f"Property sizeUnit must be of type str, got {type(props['sizeUnit']).__name__}")
    
        # Type check visitorDuration (expected object)
        if "visitorDuration" in props and props["visitorDuration"] is not None:
            if not isinstance(props["visitorDuration"], object):
                try:
                    # Attempt to convert
                    props["visitorDuration"] = object(props["visitorDuration"])
                except:
                    raise TypeError(f"Property visitorDuration must be of type object, got {type(props['visitorDuration']).__name__}")
    
        # Type check exhibitSize (expected int)
        if "exhibitSize" in props and props["exhibitSize"] is not None:
            if not isinstance(props["exhibitSize"], int):
                try:
                    # Attempt to convert
                    props["exhibitSize"] = int(props["exhibitSize"])
                except:
                    raise TypeError(f"Property exhibitSize must be of type int, got {type(props['exhibitSize']).__name__}")
    
        # Type check annualVisitors (expected int)
        if "annualVisitors" in props and props["annualVisitors"] is not None:
            if not isinstance(props["annualVisitors"], int):
                try:
                    # Attempt to convert
                    props["annualVisitors"] = int(props["annualVisitors"])
                except:
                    raise TypeError(f"Property annualVisitors must be of type int, got {type(props['annualVisitors']).__name__}")
    
        # Type check contributionPercentage (expected float)
        if "contributionPercentage" in props and props["contributionPercentage"] is not None:
            if not isinstance(props["contributionPercentage"], float):
                try:
                    # Attempt to convert
                    props["contributionPercentage"] = float(props["contributionPercentage"])
                except:
                    raise TypeError(f"Property contributionPercentage must be of type float, got {type(props['contributionPercentage']).__name__}")
    
        # Type check retailPrice (expected float)
        if "retailPrice" in props and props["retailPrice"] is not None:
            if not isinstance(props["retailPrice"], float):
                try:
                    # Attempt to convert
                    props["retailPrice"] = float(props["retailPrice"])
                except:
                    raise TypeError(f"Property retailPrice must be of type float, got {type(props['retailPrice']).__name__}")
    
        # Type check conservationContribution (expected float)
        if "conservationContribution" in props and props["conservationContribution"] is not None:
            if not isinstance(props["conservationContribution"], float):
                try:
                    # Attempt to convert
                    props["conservationContribution"] = float(props["conservationContribution"])
                except:
                    raise TypeError(f"Property conservationContribution must be of type float, got {type(props['conservationContribution']).__name__}")
    
        # Type check manufacturerLocationLong (expected float)
        if "manufacturerLocationLong" in props and props["manufacturerLocationLong"] is not None:
            if not isinstance(props["manufacturerLocationLong"], float):
                try:
                    # Attempt to convert
                    props["manufacturerLocationLong"] = float(props["manufacturerLocationLong"])
                except:
                    raise TypeError(f"Property manufacturerLocationLong must be of type float, got {type(props['manufacturerLocationLong']).__name__}")
    
        # Type check priceCurrency (expected str)
        if "priceCurrency" in props and props["priceCurrency"] is not None:
            if not isinstance(props["priceCurrency"], str):
                try:
                    # Attempt to convert
                    props["priceCurrency"] = str(props["priceCurrency"])
                except:
                    raise TypeError(f"Property priceCurrency must be of type str, got {type(props['priceCurrency']).__name__}")
    
        # Type check manufacturerLocationLat (expected float)
        if "manufacturerLocationLat" in props and props["manufacturerLocationLat"] is not None:
            if not isinstance(props["manufacturerLocationLat"], float):
                try:
                    # Attempt to convert
                    props["manufacturerLocationLat"] = float(props["manufacturerLocationLat"])
                except:
                    raise TypeError(f"Property manufacturerLocationLat must be of type float, got {type(props['manufacturerLocationLat']).__name__}")
    
        # Type check educationalMaterials (expected bool)
        if "educationalMaterials" in props and props["educationalMaterials"] is not None:
            if not isinstance(props["educationalMaterials"], bool):
                try:
                    # Attempt to convert
                    props["educationalMaterials"] = bool(props["educationalMaterials"])
                except:
                    raise TypeError(f"Property educationalMaterials must be of type bool, got {type(props['educationalMaterials']).__name__}")
    
        # Type check productionRun (expected int)
        if "productionRun" in props and props["productionRun"] is not None:
            if not isinstance(props["productionRun"], int):
                try:
                    # Attempt to convert
                    props["productionRun"] = int(props["productionRun"])
                except:
                    raise TypeError(f"Property productionRun must be of type int, got {type(props['productionRun']).__name__}")
    
        # Type check ageRange (expected str)
        if "ageRange" in props and props["ageRange"] is not None:
            if not isinstance(props["ageRange"], str):
                try:
                    # Attempt to convert
                    props["ageRange"] = str(props["ageRange"])
                except:
                    raise TypeError(f"Property ageRange must be of type str, got {type(props['ageRange']).__name__}")
    
        # Type check manufacturer (expected str)
        if "manufacturer" in props and props["manufacturer"] is not None:
            if not isinstance(props["manufacturer"], str):
                try:
                    # Attempt to convert
                    props["manufacturer"] = str(props["manufacturer"])
                except:
                    raise TypeError(f"Property manufacturer must be of type str, got {type(props['manufacturer']).__name__}")
    
        # Type check developed (expected object)
        if "developed" in props and props["developed"] is not None:
            if not isinstance(props["developed"], object):
                try:
                    # Attempt to convert
                    props["developed"] = object(props["developed"])
                except:
                    raise TypeError(f"Property developed must be of type object, got {type(props['developed']).__name__}")
    
        # Type check scholarlyEndorsements (expected int)
        if "scholarlyEndorsements" in props and props["scholarlyEndorsements"] is not None:
            if not isinstance(props["scholarlyEndorsements"], int):
                try:
                    # Attempt to convert
                    props["scholarlyEndorsements"] = int(props["scholarlyEndorsements"])
                except:
                    raise TypeError(f"Property scholarlyEndorsements must be of type int, got {type(props['scholarlyEndorsements']).__name__}")
    
        # Type check educatorRating (expected float)
        if "educatorRating" in props and props["educatorRating"] is not None:
            if not isinstance(props["educatorRating"], float):
                try:
                    # Attempt to convert
                    props["educatorRating"] = float(props["educatorRating"])
                except:
                    raise TypeError(f"Property educatorRating must be of type float, got {type(props['educatorRating']).__name__}")
    
        # Type check languagesAvailable (expected int)
        if "languagesAvailable" in props and props["languagesAvailable"] is not None:
            if not isinstance(props["languagesAvailable"], int):
                try:
                    # Attempt to convert
                    props["languagesAvailable"] = int(props["languagesAvailable"])
                except:
                    raise TypeError(f"Property languagesAvailable must be of type int, got {type(props['languagesAvailable']).__name__}")
    
        # Type check courseDuration (expected object)
        if "courseDuration" in props and props["courseDuration"] is not None:
            if not isinstance(props["courseDuration"], object):
                try:
                    # Attempt to convert
                    props["courseDuration"] = object(props["courseDuration"])
                except:
                    raise TypeError(f"Property courseDuration must be of type object, got {type(props['courseDuration']).__name__}")
    
        # Type check institutionsAdopting (expected int)
        if "institutionsAdopting" in props and props["institutionsAdopting"] is not None:
            if not isinstance(props["institutionsAdopting"], int):
                try:
                    # Attempt to convert
                    props["institutionsAdopting"] = int(props["institutionsAdopting"])
                except:
                    raise TypeError(f"Property institutionsAdopting must be of type int, got {type(props['institutionsAdopting']).__name__}")
    
        # Type check materialFormats (expected object)
        if "materialFormats" in props and props["materialFormats"] is not None:
            if not isinstance(props["materialFormats"], object):
                try:
                    # Attempt to convert
                    props["materialFormats"] = object(props["materialFormats"])
                except:
                    raise TypeError(f"Property materialFormats must be of type object, got {type(props['materialFormats']).__name__}")
    
        # Type check targetEducationLevels (expected object)
        if "targetEducationLevels" in props and props["targetEducationLevels"] is not None:
            if not isinstance(props["targetEducationLevels"], object):
                try:
                    # Attempt to convert
                    props["targetEducationLevels"] = object(props["targetEducationLevels"])
                except:
                    raise TypeError(f"Property targetEducationLevels must be of type object, got {type(props['targetEducationLevels']).__name__}")
    
        # Type check totalLessonHours (expected int)
        if "totalLessonHours" in props and props["totalLessonHours"] is not None:
            if not isinstance(props["totalLessonHours"], int):
                try:
                    # Attempt to convert
                    props["totalLessonHours"] = int(props["totalLessonHours"])
                except:
                    raise TypeError(f"Property totalLessonHours must be of type int, got {type(props['totalLessonHours']).__name__}")
    
        # Type check storageSizeUnit (expected str)
        if "storageSizeUnit" in props and props["storageSizeUnit"] is not None:
            if not isinstance(props["storageSizeUnit"], str):
                try:
                    # Attempt to convert
                    props["storageSizeUnit"] = str(props["storageSizeUnit"])
                except:
                    raise TypeError(f"Property storageSizeUnit must be of type str, got {type(props['storageSizeUnit']).__name__}")
    
        # Type check finalMasterUnit (expected str)
        if "finalMasterUnit" in props and props["finalMasterUnit"] is not None:
            if not isinstance(props["finalMasterUnit"], str):
                try:
                    # Attempt to convert
                    props["finalMasterUnit"] = str(props["finalMasterUnit"])
                except:
                    raise TypeError(f"Property finalMasterUnit must be of type str, got {type(props['finalMasterUnit']).__name__}")
    
        # Type check resolutionOutput (expected str)
        if "resolutionOutput" in props and props["resolutionOutput"] is not None:
            if not isinstance(props["resolutionOutput"], str):
                try:
                    # Attempt to convert
                    props["resolutionOutput"] = str(props["resolutionOutput"])
                except:
                    raise TypeError(f"Property resolutionOutput must be of type str, got {type(props['resolutionOutput']).__name__}")
    
        # Type check finalMasterSize (expected int)
        if "finalMasterSize" in props and props["finalMasterSize"] is not None:
            if not isinstance(props["finalMasterSize"], int):
                try:
                    # Attempt to convert
                    props["finalMasterSize"] = int(props["finalMasterSize"])
                except:
                    raise TypeError(f"Property finalMasterSize must be of type int, got {type(props['finalMasterSize']).__name__}")
    
        # Type check completed (expected object)
        if "completed" in props and props["completed"] is not None:
            if not isinstance(props["completed"], object):
                try:
                    # Attempt to convert
                    props["completed"] = object(props["completed"])
                except:
                    raise TypeError(f"Property completed must be of type object, got {type(props['completed']).__name__}")
    
        # Type check colorDepth (expected str)
        if "colorDepth" in props and props["colorDepth"] is not None:
            if not isinstance(props["colorDepth"], str):
                try:
                    # Attempt to convert
                    props["colorDepth"] = str(props["colorDepth"])
                except:
                    raise TypeError(f"Property colorDepth must be of type str, got {type(props['colorDepth']).__name__}")
    
        # Type check storageSizeRaw (expected int)
        if "storageSizeRaw" in props and props["storageSizeRaw"] is not None:
            if not isinstance(props["storageSizeRaw"], int):
                try:
                    # Attempt to convert
                    props["storageSizeRaw"] = int(props["storageSizeRaw"])
                except:
                    raise TypeError(f"Property storageSizeRaw must be of type int, got {type(props['storageSizeRaw']).__name__}")
    
        # Type check originalNegativeUsed (expected bool)
        if "originalNegativeUsed" in props and props["originalNegativeUsed"] is not None:
            if not isinstance(props["originalNegativeUsed"], bool):
                try:
                    # Attempt to convert
                    props["originalNegativeUsed"] = bool(props["originalNegativeUsed"])
                except:
                    raise TypeError(f"Property originalNegativeUsed must be of type bool, got {type(props['originalNegativeUsed']).__name__}")
    
        # Type check started (expected object)
        if "started" in props and props["started"] is not None:
            if not isinstance(props["started"], object):
                try:
                    # Attempt to convert
                    props["started"] = object(props["started"])
                except:
                    raise TypeError(f"Property started must be of type object, got {type(props['started']).__name__}")
    
        # Type check martialArtsTraining (expected bool)
        if "martialArtsTraining" in props and props["martialArtsTraining"] is not None:
            if not isinstance(props["martialArtsTraining"], bool):
                try:
                    # Attempt to convert
                    props["martialArtsTraining"] = bool(props["martialArtsTraining"])
                except:
                    raise TypeError(f"Property martialArtsTraining must be of type bool, got {type(props['martialArtsTraining']).__name__}")
    
        # Type check collaborations (expected int)
        if "collaborations" in props and props["collaborations"] is not None:
            if not isinstance(props["collaborations"], int):
                try:
                    # Attempt to convert
                    props["collaborations"] = int(props["collaborations"])
                except:
                    raise TypeError(f"Property collaborations must be of type int, got {type(props['collaborations']).__name__}")
    
        # Type check constructionCost (expected int)
        if "constructionCost" in props and props["constructionCost"] is not None:
            if not isinstance(props["constructionCost"], int):
                try:
                    # Attempt to convert
                    props["constructionCost"] = int(props["constructionCost"])
                except:
                    raise TypeError(f"Property constructionCost must be of type int, got {type(props['constructionCost']).__name__}")
    
        # Type check reactivation (expected object)
        if "reactivation" in props and props["reactivation"] is not None:
            if not isinstance(props["reactivation"], object):
                try:
                    # Attempt to convert
                    props["reactivation"] = object(props["reactivation"])
                except:
                    raise TypeError(f"Property reactivation must be of type object, got {type(props['reactivation']).__name__}")
    
        # Type check musicalNumbers (expected int)
        if "musicalNumbers" in props and props["musicalNumbers"] is not None:
            if not isinstance(props["musicalNumbers"], int):
                try:
                    # Attempt to convert
                    props["musicalNumbers"] = int(props["musicalNumbers"])
                except:
                    raise TypeError(f"Property musicalNumbers must be of type int, got {type(props['musicalNumbers']).__name__}")
    
        # Type check digitalRemastering (expected int)
        if "digitalRemastering" in props and props["digitalRemastering"] is not None:
            if not isinstance(props["digitalRemastering"], int):
                try:
                    # Attempt to convert
                    props["digitalRemastering"] = int(props["digitalRemastering"])
                except:
                    raise TypeError(f"Property digitalRemastering must be of type int, got {type(props['digitalRemastering']).__name__}")
    
        # Type check iconicScenes (expected object)
        if "iconicScenes" in props and props["iconicScenes"] is not None:
            if not isinstance(props["iconicScenes"], object):
                try:
                    # Attempt to convert
                    props["iconicScenes"] = object(props["iconicScenes"])
                except:
                    raise TypeError(f"Property iconicScenes must be of type object, got {type(props['iconicScenes']).__name__}")
    
        # Type check is3D (expected bool)
        if "is3D" in props and props["is3D"] is not None:
            if not isinstance(props["is3D"], bool):
                try:
                    # Attempt to convert
                    props["is3D"] = bool(props["is3D"])
                except:
                    raise TypeError(f"Property is3D must be of type bool, got {type(props['is3D']).__name__}")
    
        # Type check motionCapturePercentage (expected int)
        if "motionCapturePercentage" in props and props["motionCapturePercentage"] is not None:
            if not isinstance(props["motionCapturePercentage"], int):
                try:
                    # Attempt to convert
                    props["motionCapturePercentage"] = int(props["motionCapturePercentage"])
                except:
                    raise TypeError(f"Property motionCapturePercentage must be of type int, got {type(props['motionCapturePercentage']).__name__}")
    
        # Type check merchandisingSales (expected int)
        if "merchandisingSales" in props and props["merchandisingSales"] is not None:
            if not isinstance(props["merchandisingSales"], int):
                try:
                    # Attempt to convert
                    props["merchandisingSales"] = int(props["merchandisingSales"])
                except:
                    raise TypeError(f"Property merchandisingSales must be of type int, got {type(props['merchandisingSales']).__name__}")
    
        # Type check culturalImpact (expected str)
        if "culturalImpact" in props and props["culturalImpact"] is not None:
            if not isinstance(props["culturalImpact"], str):
                try:
                    # Attempt to convert
                    props["culturalImpact"] = str(props["culturalImpact"])
                except:
                    raise TypeError(f"Property culturalImpact must be of type str, got {type(props['culturalImpact']).__name__}")
    
        # Type check culturalMilestones (expected object)
        if "culturalMilestones" in props and props["culturalMilestones"] is not None:
            if not isinstance(props["culturalMilestones"], object):
                try:
                    # Attempt to convert
                    props["culturalMilestones"] = object(props["culturalMilestones"])
                except:
                    raise TypeError(f"Property culturalMilestones must be of type object, got {type(props['culturalMilestones']).__name__}")
    
        # Type check isAnimated (expected bool)
        if "isAnimated" in props and props["isAnimated"] is not None:
            if not isinstance(props["isAnimated"], bool):
                try:
                    # Attempt to convert
                    props["isAnimated"] = bool(props["isAnimated"])
                except:
                    raise TypeError(f"Property isAnimated must be of type bool, got {type(props['isAnimated']).__name__}")
    
        # Type check animationStyles (expected object)
        if "animationStyles" in props and props["animationStyles"] is not None:
            if not isinstance(props["animationStyles"], object):
                try:
                    # Attempt to convert
                    props["animationStyles"] = object(props["animationStyles"])
                except:
                    raise TypeError(f"Property animationStyles must be of type object, got {type(props['animationStyles']).__name__}")
    
        # Type check renderedFrames (expected int)
        if "renderedFrames" in props and props["renderedFrames"] is not None:
            if not isinstance(props["renderedFrames"], int):
                try:
                    # Attempt to convert
                    props["renderedFrames"] = int(props["renderedFrames"])
                except:
                    raise TypeError(f"Property renderedFrames must be of type int, got {type(props['renderedFrames']).__name__}")
    
        # Type check isIndie (expected bool)
        if "isIndie" in props and props["isIndie"] is not None:
            if not isinstance(props["isIndie"], bool):
                try:
                    # Attempt to convert
                    props["isIndie"] = bool(props["isIndie"])
                except:
                    raise TypeError(f"Property isIndie must be of type bool, got {type(props['isIndie']).__name__}")
    
        # Type check festivalWins (expected int)
        if "festivalWins" in props and props["festivalWins"] is not None:
            if not isinstance(props["festivalWins"], int):
                try:
                    # Attempt to convert
                    props["festivalWins"] = int(props["festivalWins"])
                except:
                    raise TypeError(f"Property festivalWins must be of type int, got {type(props['festivalWins']).__name__}")
    
        # Type check filmingDays (expected int)
        if "filmingDays" in props and props["filmingDays"] is not None:
            if not isinstance(props["filmingDays"], int):
                try:
                    # Attempt to convert
                    props["filmingDays"] = int(props["filmingDays"])
                except:
                    raise TypeError(f"Property filmingDays must be of type int, got {type(props['filmingDays']).__name__}")
    
        # Type check voiceRange (expected str)
        if "voiceRange" in props and props["voiceRange"] is not None:
            if not isinstance(props["voiceRange"], str):
                try:
                    # Attempt to convert
                    props["voiceRange"] = str(props["voiceRange"])
                except:
                    raise TypeError(f"Property voiceRange must be of type str, got {type(props['voiceRange']).__name__}")
    
        # Type check musicalSkills (expected object)
        if "musicalSkills" in props and props["musicalSkills"] is not None:
            if not isinstance(props["musicalSkills"], object):
                try:
                    # Attempt to convert
                    props["musicalSkills"] = object(props["musicalSkills"])
                except:
                    raise TypeError(f"Property musicalSkills must be of type object, got {type(props['musicalSkills']).__name__}")
    
        # Type check cameramanship (expected str)
        if "cameramanship" in props and props["cameramanship"] is not None:
            if not isinstance(props["cameramanship"], str):
                try:
                    # Attempt to convert
                    props["cameramanship"] = str(props["cameramanship"])
                except:
                    raise TypeError(f"Property cameramanship must be of type str, got {type(props['cameramanship']).__name__}")
    
        # Type check significantContribution (expected str)
        if "significantContribution" in props and props["significantContribution"] is not None:
            if not isinstance(props["significantContribution"], str):
                try:
                    # Attempt to convert
                    props["significantContribution"] = str(props["significantContribution"])
                except:
                    raise TypeError(f"Property significantContribution must be of type str, got {type(props['significantContribution']).__name__}")
    
        # Type check typecastEffect (expected str)
        if "typecastEffect" in props and props["typecastEffect"] is not None:
            if not isinstance(props["typecastEffect"], str):
                try:
                    # Attempt to convert
                    props["typecastEffect"] = str(props["typecastEffect"])
                except:
                    raise TypeError(f"Property typecastEffect must be of type str, got {type(props['typecastEffect']).__name__}")
    
        # Type check directorRanking (expected str)
        if "directorRanking" in props and props["directorRanking"] is not None:
            if not isinstance(props["directorRanking"], str):
                try:
                    # Attempt to convert
                    props["directorRanking"] = str(props["directorRanking"])
                except:
                    raise TypeError(f"Property directorRanking must be of type str, got {type(props['directorRanking']).__name__}")
    
        # Type check deepSeaExperience (expected bool)
        if "deepSeaExperience" in props and props["deepSeaExperience"] is not None:
            if not isinstance(props["deepSeaExperience"], bool):
                try:
                    # Attempt to convert
                    props["deepSeaExperience"] = bool(props["deepSeaExperience"])
                except:
                    raise TypeError(f"Property deepSeaExperience must be of type bool, got {type(props['deepSeaExperience']).__name__}")
    
        # Type check motionCaptureExperience (expected bool)
        if "motionCaptureExperience" in props and props["motionCaptureExperience"] is not None:
            if not isinstance(props["motionCaptureExperience"], bool):
                try:
                    # Attempt to convert
                    props["motionCaptureExperience"] = bool(props["motionCaptureExperience"])
                except:
                    raise TypeError(f"Property motionCaptureExperience must be of type bool, got {type(props['motionCaptureExperience']).__name__}")
    
        # Type check genreSpecialty (expected object)
        if "genreSpecialty" in props and props["genreSpecialty"] is not None:
            if not isinstance(props["genreSpecialty"], object):
                try:
                    # Attempt to convert
                    props["genreSpecialty"] = object(props["genreSpecialty"])
                except:
                    raise TypeError(f"Property genreSpecialty must be of type object, got {type(props['genreSpecialty']).__name__}")
    
        # Type check directorStyle (expected str)
        if "directorStyle" in props and props["directorStyle"] is not None:
            if not isinstance(props["directorStyle"], str):
                try:
                    # Attempt to convert
                    props["directorStyle"] = str(props["directorStyle"])
                except:
                    raise TypeError(f"Property directorStyle must be of type str, got {type(props['directorStyle']).__name__}")
    
        # Type check voiceActingExperience (expected bool)
        if "voiceActingExperience" in props and props["voiceActingExperience"] is not None:
            if not isinstance(props["voiceActingExperience"], bool):
                try:
                    # Attempt to convert
                    props["voiceActingExperience"] = bool(props["voiceActingExperience"])
                except:
                    raise TypeError(f"Property voiceActingExperience must be of type bool, got {type(props['voiceActingExperience']).__name__}")
    
        # Type check visualAesthetics (expected str)
        if "visualAesthetics" in props and props["visualAesthetics"] is not None:
            if not isinstance(props["visualAesthetics"], str):
                try:
                    # Attempt to convert
                    props["visualAesthetics"] = str(props["visualAesthetics"])
                except:
                    raise TypeError(f"Property visualAesthetics must be of type str, got {type(props['visualAesthetics']).__name__}")
    
        # Type check musicalBackground (expected bool)
        if "musicalBackground" in props and props["musicalBackground"] is not None:
            if not isinstance(props["musicalBackground"], bool):
                try:
                    # Attempt to convert
                    props["musicalBackground"] = bool(props["musicalBackground"])
                except:
                    raise TypeError(f"Property musicalBackground must be of type bool, got {type(props['musicalBackground']).__name__}")
    
        # Type check acquisitionAmount (expected int)
        if "acquisitionAmount" in props and props["acquisitionAmount"] is not None:
            if not isinstance(props["acquisitionAmount"], int):
                try:
                    # Attempt to convert
                    props["acquisitionAmount"] = int(props["acquisitionAmount"])
                except:
                    raise TypeError(f"Property acquisitionAmount must be of type int, got {type(props['acquisitionAmount']).__name__}")
    
        # Type check acquiredBy (expected str)
        if "acquiredBy" in props and props["acquiredBy"] is not None:
            if not isinstance(props["acquiredBy"], str):
                try:
                    # Attempt to convert
                    props["acquiredBy"] = str(props["acquiredBy"])
                except:
                    raise TypeError(f"Property acquiredBy must be of type str, got {type(props['acquiredBy']).__name__}")
    
        # Type check acquired (expected object)
        if "acquired" in props and props["acquired"] is not None:
            if not isinstance(props["acquired"], object):
                try:
                    # Attempt to convert
                    props["acquired"] = object(props["acquired"])
                except:
                    raise TypeError(f"Property acquired must be of type object, got {type(props['acquired']).__name__}")
    
        # Type check yearlyRevenue2018 (expected int)
        if "yearlyRevenue2018" in props and props["yearlyRevenue2018"] is not None:
            if not isinstance(props["yearlyRevenue2018"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue2018"] = int(props["yearlyRevenue2018"])
                except:
                    raise TypeError(f"Property yearlyRevenue2018 must be of type int, got {type(props['yearlyRevenue2018']).__name__}")
    
        # Type check studioAge (expected int)
        if "studioAge" in props and props["studioAge"] is not None:
            if not isinstance(props["studioAge"], int):
                try:
                    # Attempt to convert
                    props["studioAge"] = int(props["studioAge"])
                except:
                    raise TypeError(f"Property studioAge must be of type int, got {type(props['studioAge']).__name__}")
    
        # Type check mountainLogo (expected bool)
        if "mountainLogo" in props and props["mountainLogo"] is not None:
            if not isinstance(props["mountainLogo"], bool):
                try:
                    # Attempt to convert
                    props["mountainLogo"] = bool(props["mountainLogo"])
                except:
                    raise TypeError(f"Property mountainLogo must be of type bool, got {type(props['mountainLogo']).__name__}")
    
        # Type check indieFilmFocus (expected bool)
        if "indieFilmFocus" in props and props["indieFilmFocus"] is not None:
            if not isinstance(props["indieFilmFocus"], bool):
                try:
                    # Attempt to convert
                    props["indieFilmFocus"] = bool(props["indieFilmFocus"])
                except:
                    raise TypeError(f"Property indieFilmFocus must be of type bool, got {type(props['indieFilmFocus']).__name__}")
    
        # Type check awardWinningFilms (expected int)
        if "awardWinningFilms" in props and props["awardWinningFilms"] is not None:
            if not isinstance(props["awardWinningFilms"], int):
                try:
                    # Attempt to convert
                    props["awardWinningFilms"] = int(props["awardWinningFilms"])
                except:
                    raise TypeError(f"Property awardWinningFilms must be of type int, got {type(props['awardWinningFilms']).__name__}")
    
        # Type check budgetMusic (expected int)
        if "budgetMusic" in props and props["budgetMusic"] is not None:
            if not isinstance(props["budgetMusic"], int):
                try:
                    # Attempt to convert
                    props["budgetMusic"] = int(props["budgetMusic"])
                except:
                    raise TypeError(f"Property budgetMusic must be of type int, got {type(props['budgetMusic']).__name__}")
    
        # Type check locationCountries (expected object)
        if "locationCountries" in props and props["locationCountries"] is not None:
            if not isinstance(props["locationCountries"], object):
                try:
                    # Attempt to convert
                    props["locationCountries"] = object(props["locationCountries"])
                except:
                    raise TypeError(f"Property locationCountries must be of type object, got {type(props['locationCountries']).__name__}")
    
        # Type check studioRestrictions (expected object)
        if "studioRestrictions" in props and props["studioRestrictions"] is not None:
            if not isinstance(props["studioRestrictions"], object):
                try:
                    # Attempt to convert
                    props["studioRestrictions"] = object(props["studioRestrictions"])
                except:
                    raise TypeError(f"Property studioRestrictions must be of type object, got {type(props['studioRestrictions']).__name__}")
    
        # Type check technicalSuccesses (expected int)
        if "technicalSuccesses" in props and props["technicalSuccesses"] is not None:
            if not isinstance(props["technicalSuccesses"], int):
                try:
                    # Attempt to convert
                    props["technicalSuccesses"] = int(props["technicalSuccesses"])
                except:
                    raise TypeError(f"Property technicalSuccesses must be of type int, got {type(props['technicalSuccesses']).__name__}")
    
        # Type check motionCaptureStages (expected int)
        if "motionCaptureStages" in props and props["motionCaptureStages"] is not None:
            if not isinstance(props["motionCaptureStages"], int):
                try:
                    # Attempt to convert
                    props["motionCaptureStages"] = int(props["motionCaptureStages"])
                except:
                    raise TypeError(f"Property motionCaptureStages must be of type int, got {type(props['motionCaptureStages']).__name__}")
    
        # Type check budgetMotionCapture (expected int)
        if "budgetMotionCapture" in props and props["budgetMotionCapture"] is not None:
            if not isinstance(props["budgetMotionCapture"], int):
                try:
                    # Attempt to convert
                    props["budgetMotionCapture"] = int(props["budgetMotionCapture"])
                except:
                    raise TypeError(f"Property budgetMotionCapture must be of type int, got {type(props['budgetMotionCapture']).__name__}")
    
        # Type check technicalChallenges (expected int)
        if "technicalChallenges" in props and props["technicalChallenges"] is not None:
            if not isinstance(props["technicalChallenges"], int):
                try:
                    # Attempt to convert
                    props["technicalChallenges"] = int(props["technicalChallenges"])
                except:
                    raise TypeError(f"Property technicalChallenges must be of type int, got {type(props['technicalChallenges']).__name__}")
    
        # Type check filmingCountries (expected object)
        if "filmingCountries" in props and props["filmingCountries"] is not None:
            if not isinstance(props["filmingCountries"], object):
                try:
                    # Attempt to convert
                    props["filmingCountries"] = object(props["filmingCountries"])
                except:
                    raise TypeError(f"Property filmingCountries must be of type object, got {type(props['filmingCountries']).__name__}")
    
        # Type check guerrillaFilming (expected bool)
        if "guerrillaFilming" in props and props["guerrillaFilming"] is not None:
            if not isinstance(props["guerrillaFilming"], bool):
                try:
                    # Attempt to convert
                    props["guerrillaFilming"] = bool(props["guerrillaFilming"])
                except:
                    raise TypeError(f"Property guerrillaFilming must be of type bool, got {type(props['guerrillaFilming']).__name__}")
    
        # Type check assessmentYears (expected object)
        if "assessmentYears" in props and props["assessmentYears"] is not None:
            if not isinstance(props["assessmentYears"], object):
                try:
                    # Attempt to convert
                    props["assessmentYears"] = object(props["assessmentYears"])
                except:
                    raise TypeError(f"Property assessmentYears must be of type object, got {type(props['assessmentYears']).__name__}")
    
        # Type check historicalSignificanceRatings (expected object)
        if "historicalSignificanceRatings" in props and props["historicalSignificanceRatings"] is not None:
            if not isinstance(props["historicalSignificanceRatings"], object):
                try:
                    # Attempt to convert
                    props["historicalSignificanceRatings"] = object(props["historicalSignificanceRatings"])
                except:
                    raise TypeError(f"Property historicalSignificanceRatings must be of type object, got {type(props['historicalSignificanceRatings']).__name__}")
    
        # Type check culturalImpactAssessments (expected list)
        if "culturalImpactAssessments" in props and props["culturalImpactAssessments"] is not None:
            if not isinstance(props["culturalImpactAssessments"], list):
                try:
                    # Attempt to convert
                    props["culturalImpactAssessments"] = list(props["culturalImpactAssessments"])
                except:
                    raise TypeError(f"Property culturalImpactAssessments must be of type list, got {type(props['culturalImpactAssessments']).__name__}")
    
        # Type check influenceRatings (expected object)
        if "influenceRatings" in props and props["influenceRatings"] is not None:
            if not isinstance(props["influenceRatings"], object):
                try:
                    # Attempt to convert
                    props["influenceRatings"] = object(props["influenceRatings"])
                except:
                    raise TypeError(f"Property influenceRatings must be of type object, got {type(props['influenceRatings']).__name__}")
    
        # Type check filmSchoolReferences (expected int)
        if "filmSchoolReferences" in props and props["filmSchoolReferences"] is not None:
            if not isinstance(props["filmSchoolReferences"], int):
                try:
                    # Attempt to convert
                    props["filmSchoolReferences"] = int(props["filmSchoolReferences"])
                except:
                    raise TypeError(f"Property filmSchoolReferences must be of type int, got {type(props['filmSchoolReferences']).__name__}")
    
        # Type check aspectTension (expected float)
        if "aspectTension" in props and props["aspectTension"] is not None:
            if not isinstance(props["aspectTension"], float):
                try:
                    # Attempt to convert
                    props["aspectTension"] = float(props["aspectTension"])
                except:
                    raise TypeError(f"Property aspectTension must be of type float, got {type(props['aspectTension']).__name__}")
    
        # Type check historicalReassessments (expected list)
        if "historicalReassessments" in props and props["historicalReassessments"] is not None:
            if not isinstance(props["historicalReassessments"], list):
                try:
                    # Attempt to convert
                    props["historicalReassessments"] = list(props["historicalReassessments"])
                except:
                    raise TypeError(f"Property historicalReassessments must be of type list, got {type(props['historicalReassessments']).__name__}")
    
        # Type check aspectWorldBuilding (expected float)
        if "aspectWorldBuilding" in props and props["aspectWorldBuilding"] is not None:
            if not isinstance(props["aspectWorldBuilding"], float):
                try:
                    # Attempt to convert
                    props["aspectWorldBuilding"] = float(props["aspectWorldBuilding"])
                except:
                    raise TypeError(f"Property aspectWorldBuilding must be of type float, got {type(props['aspectWorldBuilding']).__name__}")
    
        # Type check aspectCulturalImpact (expected float)
        if "aspectCulturalImpact" in props and props["aspectCulturalImpact"] is not None:
            if not isinstance(props["aspectCulturalImpact"], float):
                try:
                    # Attempt to convert
                    props["aspectCulturalImpact"] = float(props["aspectCulturalImpact"])
                except:
                    raise TypeError(f"Property aspectCulturalImpact must be of type float, got {type(props['aspectCulturalImpact']).__name__}")
    
        # Type check aspectAtmosphere (expected float)
        if "aspectAtmosphere" in props and props["aspectAtmosphere"] is not None:
            if not isinstance(props["aspectAtmosphere"], float):
                try:
                    # Attempt to convert
                    props["aspectAtmosphere"] = float(props["aspectAtmosphere"])
                except:
                    raise TypeError(f"Property aspectAtmosphere must be of type float, got {type(props['aspectAtmosphere']).__name__}")
    
        # Type check aspectSubtlety (expected float)
        if "aspectSubtlety" in props and props["aspectSubtlety"] is not None:
            if not isinstance(props["aspectSubtlety"], float):
                try:
                    # Attempt to convert
                    props["aspectSubtlety"] = float(props["aspectSubtlety"])
                except:
                    raise TypeError(f"Property aspectSubtlety must be of type float, got {type(props['aspectSubtlety']).__name__}")
    
        # Type check lyricist (expected str)
        if "lyricist" in props and props["lyricist"] is not None:
            if not isinstance(props["lyricist"], str):
                try:
                    # Attempt to convert
                    props["lyricist"] = str(props["lyricist"])
                except:
                    raise TypeError(f"Property lyricist must be of type str, got {type(props['lyricist']).__name__}")
    
        # Type check weeksAtNumberOne (expected int)
        if "weeksAtNumberOne" in props and props["weeksAtNumberOne"] is not None:
            if not isinstance(props["weeksAtNumberOne"], int):
                try:
                    # Attempt to convert
                    props["weeksAtNumberOne"] = int(props["weeksAtNumberOne"])
                except:
                    raise TypeError(f"Property weeksAtNumberOne must be of type int, got {type(props['weeksAtNumberOne']).__name__}")
    
        # Type check stringsOnly (expected bool)
        if "stringsOnly" in props and props["stringsOnly"] is not None:
            if not isinstance(props["stringsOnly"], bool):
                try:
                    # Attempt to convert
                    props["stringsOnly"] = bool(props["stringsOnly"])
                except:
                    raise TypeError(f"Property stringsOnly must be of type bool, got {type(props['stringsOnly']).__name__}")
    
        # Type check tourismIncrease (expected int)
        if "tourismIncrease" in props and props["tourismIncrease"] is not None:
            if not isinstance(props["tourismIncrease"], int):
                try:
                    # Attempt to convert
                    props["tourismIncrease"] = int(props["tourismIncrease"])
                except:
                    raise TypeError(f"Property tourismIncrease must be of type int, got {type(props['tourismIncrease']).__name__}")
    
        # Type check studioOwned (expected bool)
        if "studioOwned" in props and props["studioOwned"] is not None:
            if not isinstance(props["studioOwned"], bool):
                try:
                    # Attempt to convert
                    props["studioOwned"] = bool(props["studioOwned"])
                except:
                    raise TypeError(f"Property studioOwned must be of type bool, got {type(props['studioOwned']).__name__}")
    
        # Type check filmCount (expected int)
        if "filmCount" in props and props["filmCount"] is not None:
            if not isinstance(props["filmCount"], int):
                try:
                    # Attempt to convert
                    props["filmCount"] = int(props["filmCount"])
                except:
                    raise TypeError(f"Property filmCount must be of type int, got {type(props['filmCount']).__name__}")
    
        # Type check tourismRevenueCurrency (expected str)
        if "tourismRevenueCurrency" in props and props["tourismRevenueCurrency"] is not None:
            if not isinstance(props["tourismRevenueCurrency"], str):
                try:
                    # Attempt to convert
                    props["tourismRevenueCurrency"] = str(props["tourismRevenueCurrency"])
                except:
                    raise TypeError(f"Property tourismRevenueCurrency must be of type str, got {type(props['tourismRevenueCurrency']).__name__}")
    
        # Type check tourismRevenue (expected int)
        if "tourismRevenue" in props and props["tourismRevenue"] is not None:
            if not isinstance(props["tourismRevenue"], int):
                try:
                    # Attempt to convert
                    props["tourismRevenue"] = int(props["tourismRevenue"])
                except:
                    raise TypeError(f"Property tourismRevenue must be of type int, got {type(props['tourismRevenue']).__name__}")
    
        # Type check revival (expected object)
        if "revival" in props and props["revival"] is not None:
            if not isinstance(props["revival"], object):
                try:
                    # Attempt to convert
                    props["revival"] = object(props["revival"])
                except:
                    raise TypeError(f"Property revival must be of type object, got {type(props['revival']).__name__}")
    
        # Type check annualTours (expected int)
        if "annualTours" in props and props["annualTours"] is not None:
            if not isinstance(props["annualTours"], int):
                try:
                    # Attempt to convert
                    props["annualTours"] = int(props["annualTours"])
                except:
                    raise TypeError(f"Property annualTours must be of type int, got {type(props['annualTours']).__name__}")
    
        # Type check singAlongEvents (expected int)
        if "singAlongEvents" in props and props["singAlongEvents"] is not None:
            if not isinstance(props["singAlongEvents"], int):
                try:
                    # Attempt to convert
                    props["singAlongEvents"] = int(props["singAlongEvents"])
                except:
                    raise TypeError(f"Property singAlongEvents must be of type int, got {type(props['singAlongEvents']).__name__}")
    
        # Type check historicalSites (expected int)
        if "historicalSites" in props and props["historicalSites"] is not None:
            if not isinstance(props["historicalSites"], int):
                try:
                    # Attempt to convert
                    props["historicalSites"] = int(props["historicalSites"])
                except:
                    raise TypeError(f"Property historicalSites must be of type int, got {type(props['historicalSites']).__name__}")
    
        # Type check lengthUnit (expected str)
        if "lengthUnit" in props and props["lengthUnit"] is not None:
            if not isinstance(props["lengthUnit"], str):
                try:
                    # Attempt to convert
                    props["lengthUnit"] = str(props["lengthUnit"])
                except:
                    raise TypeError(f"Property lengthUnit must be of type str, got {type(props['lengthUnit']).__name__}")
    
        # Type check routeLength (expected int)
        if "routeLength" in props and props["routeLength"] is not None:
            if not isinstance(props["routeLength"], int):
                try:
                    # Attempt to convert
                    props["routeLength"] = int(props["routeLength"])
                except:
                    raise TypeError(f"Property routeLength must be of type int, got {type(props['routeLength']).__name__}")
    
        # Type check limitedEdition (expected bool)
        if "limitedEdition" in props and props["limitedEdition"] is not None:
            if not isinstance(props["limitedEdition"], bool):
                try:
                    # Attempt to convert
                    props["limitedEdition"] = bool(props["limitedEdition"])
                except:
                    raise TypeError(f"Property limitedEdition must be of type bool, got {type(props['limitedEdition']).__name__}")
    
        # Type check packagingInnovation (expected str)
        if "packagingInnovation" in props and props["packagingInnovation"] is not None:
            if not isinstance(props["packagingInnovation"], str):
                try:
                    # Attempt to convert
                    props["packagingInnovation"] = str(props["packagingInnovation"])
                except:
                    raise TypeError(f"Property packagingInnovation must be of type str, got {type(props['packagingInnovation']).__name__}")
    
        # Type check specialFeatures (expected int)
        if "specialFeatures" in props and props["specialFeatures"] is not None:
            if not isinstance(props["specialFeatures"], int):
                try:
                    # Attempt to convert
                    props["specialFeatures"] = int(props["specialFeatures"])
                except:
                    raise TypeError(f"Property specialFeatures must be of type int, got {type(props['specialFeatures']).__name__}")
    
        # Type check collectorValue (expected str)
        if "collectorValue" in props and props["collectorValue"] is not None:
            if not isinstance(props["collectorValue"], str):
                try:
                    # Attempt to convert
                    props["collectorValue"] = str(props["collectorValue"])
                except:
                    raise TypeError(f"Property collectorValue must be of type str, got {type(props['collectorValue']).__name__}")
    
        # Type check specialEffectsAwards (expected int)
        if "specialEffectsAwards" in props and props["specialEffectsAwards"] is not None:
            if not isinstance(props["specialEffectsAwards"], int):
                try:
                    # Attempt to convert
                    props["specialEffectsAwards"] = int(props["specialEffectsAwards"])
                except:
                    raise TypeError(f"Property specialEffectsAwards must be of type int, got {type(props['specialEffectsAwards']).__name__}")
    
        # Type check rereleaseDates (expected list)
        if "rereleaseDates" in props and props["rereleaseDates"] is not None:
            if not isinstance(props["rereleaseDates"], list):
                try:
                    # Attempt to convert
                    props["rereleaseDates"] = list(props["rereleaseDates"])
                except:
                    raise TypeError(f"Property rereleaseDates must be of type list, got {type(props['rereleaseDates']).__name__}")
    
        # Type check iMAXSequences (expected int)
        if "iMAXSequences" in props and props["iMAXSequences"] is not None:
            if not isinstance(props["iMAXSequences"], int):
                try:
                    # Attempt to convert
                    props["iMAXSequences"] = int(props["iMAXSequences"])
                except:
                    raise TypeError(f"Property iMAXSequences must be of type int, got {type(props['iMAXSequences']).__name__}")
    
        # Type check posthumousAwards (expected int)
        if "posthumousAwards" in props and props["posthumousAwards"] is not None:
            if not isinstance(props["posthumousAwards"], int):
                try:
                    # Attempt to convert
                    props["posthumousAwards"] = int(props["posthumousAwards"])
                except:
                    raise TypeError(f"Property posthumousAwards must be of type int, got {type(props['posthumousAwards']).__name__}")
    
        # Type check nonLinearStructure (expected bool)
        if "nonLinearStructure" in props and props["nonLinearStructure"] is not None:
            if not isinstance(props["nonLinearStructure"], bool):
                try:
                    # Attempt to convert
                    props["nonLinearStructure"] = bool(props["nonLinearStructure"])
                except:
                    raise TypeError(f"Property nonLinearStructure must be of type bool, got {type(props['nonLinearStructure']).__name__}")
    
        # Type check martialArtsStyles (expected object)
        if "martialArtsStyles" in props and props["martialArtsStyles"] is not None:
            if not isinstance(props["martialArtsStyles"], object):
                try:
                    # Attempt to convert
                    props["martialArtsStyles"] = object(props["martialArtsStyles"])
                except:
                    raise TypeError(f"Property martialArtsStyles must be of type object, got {type(props['martialArtsStyles']).__name__}")
    
        # Type check wineBusinessOwner (expected bool)
        if "wineBusinessOwner" in props and props["wineBusinessOwner"] is not None:
            if not isinstance(props["wineBusinessOwner"], bool):
                try:
                    # Attempt to convert
                    props["wineBusinessOwner"] = bool(props["wineBusinessOwner"])
                except:
                    raise TypeError(f"Property wineBusinessOwner must be of type bool, got {type(props['wineBusinessOwner']).__name__}")
    
        # Type check characterImmersion (expected str)
        if "characterImmersion" in props and props["characterImmersion"] is not None:
            if not isinstance(props["characterImmersion"], str):
                try:
                    # Attempt to convert
                    props["characterImmersion"] = str(props["characterImmersion"])
                except:
                    raise TypeError(f"Property characterImmersion must be of type str, got {type(props['characterImmersion']).__name__}")
    
        # Type check musicianExperience (expected bool)
        if "musicianExperience" in props and props["musicianExperience"] is not None:
            if not isinstance(props["musicianExperience"], bool):
                try:
                    # Attempt to convert
                    props["musicianExperience"] = bool(props["musicianExperience"])
                except:
                    raise TypeError(f"Property musicianExperience must be of type bool, got {type(props['musicianExperience']).__name__}")
    
        # Type check genreVersatility (expected float)
        if "genreVersatility" in props and props["genreVersatility"] is not None:
            if not isinstance(props["genreVersatility"], float):
                try:
                    # Attempt to convert
                    props["genreVersatility"] = float(props["genreVersatility"])
                except:
                    raise TypeError(f"Property genreVersatility must be of type float, got {type(props['genreVersatility']).__name__}")
    
        # Type check writerDirectorDuality (expected bool)
        if "writerDirectorDuality" in props and props["writerDirectorDuality"] is not None:
            if not isinstance(props["writerDirectorDuality"], bool):
                try:
                    # Attempt to convert
                    props["writerDirectorDuality"] = bool(props["writerDirectorDuality"])
                except:
                    raise TypeError(f"Property writerDirectorDuality must be of type bool, got {type(props['writerDirectorDuality']).__name__}")
    
        # Type check independentFocus (expected bool)
        if "independentFocus" in props and props["independentFocus"] is not None:
            if not isinstance(props["independentFocus"], bool):
                try:
                    # Attempt to convert
                    props["independentFocus"] = bool(props["independentFocus"])
                except:
                    raise TypeError(f"Property independentFocus must be of type bool, got {type(props['independentFocus']).__name__}")
    
        # Type check yearlyRevenue1996 (expected int)
        if "yearlyRevenue1996" in props and props["yearlyRevenue1996"] is not None:
            if not isinstance(props["yearlyRevenue1996"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1996"] = int(props["yearlyRevenue1996"])
                except:
                    raise TypeError(f"Property yearlyRevenue1996 must be of type int, got {type(props['yearlyRevenue1996']).__name__}")
    
        # Type check yearlyRevenue1995 (expected int)
        if "yearlyRevenue1995" in props and props["yearlyRevenue1995"] is not None:
            if not isinstance(props["yearlyRevenue1995"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1995"] = int(props["yearlyRevenue1995"])
                except:
                    raise TypeError(f"Property yearlyRevenue1995 must be of type int, got {type(props['yearlyRevenue1995']).__name__}")
    
        # Type check yearlyRevenue1994 (expected int)
        if "yearlyRevenue1994" in props and props["yearlyRevenue1994"] is not None:
            if not isinstance(props["yearlyRevenue1994"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1994"] = int(props["yearlyRevenue1994"])
                except:
                    raise TypeError(f"Property yearlyRevenue1994 must be of type int, got {type(props['yearlyRevenue1994']).__name__}")
    
        # Type check foundedBy (expected object)
        if "foundedBy" in props and props["foundedBy"] is not None:
            if not isinstance(props["foundedBy"], object):
                try:
                    # Attempt to convert
                    props["foundedBy"] = object(props["foundedBy"])
                except:
                    raise TypeError(f"Property foundedBy must be of type object, got {type(props['foundedBy']).__name__}")
    
        # Type check divested (expected object)
        if "divested" in props and props["divested"] is not None:
            if not isinstance(props["divested"], object):
                try:
                    # Attempt to convert
                    props["divested"] = object(props["divested"])
                except:
                    raise TypeError(f"Property divested must be of type object, got {type(props['divested']).__name__}")
    
        # Type check replicas (expected int)
        if "replicas" in props and props["replicas"] is not None:
            if not isinstance(props["replicas"], int):
                try:
                    # Attempt to convert
                    props["replicas"] = int(props["replicas"])
                except:
                    raise TypeError(f"Property replicas must be of type int, got {type(props['replicas']).__name__}")
    
        # Type check setLocation (expected str)
        if "setLocation" in props and props["setLocation"] is not None:
            if not isinstance(props["setLocation"], str):
                try:
                    # Attempt to convert
                    props["setLocation"] = str(props["setLocation"])
                except:
                    raise TypeError(f"Property setLocation must be of type str, got {type(props['setLocation']).__name__}")
    
        # Type check castingDisputes (expected str)
        if "castingDisputes" in props and props["castingDisputes"] is not None:
            if not isinstance(props["castingDisputes"], str):
                try:
                    # Attempt to convert
                    props["castingDisputes"] = str(props["castingDisputes"])
                except:
                    raise TypeError(f"Property castingDisputes must be of type str, got {type(props['castingDisputes']).__name__}")
    
        # Type check studioInterference (expected str)
        if "studioInterference" in props and props["studioInterference"] is not None:
            if not isinstance(props["studioInterference"], str):
                try:
                    # Attempt to convert
                    props["studioInterference"] = str(props["studioInterference"])
                except:
                    raise TypeError(f"Property studioInterference must be of type str, got {type(props['studioInterference']).__name__}")
    
        # Type check citiesFilmed (expected object)
        if "citiesFilmed" in props and props["citiesFilmed"] is not None:
            if not isinstance(props["citiesFilmed"], object):
                try:
                    # Attempt to convert
                    props["citiesFilmed"] = object(props["citiesFilmed"])
                except:
                    raise TypeError(f"Property citiesFilmed must be of type object, got {type(props['citiesFilmed']).__name__}")
    
        # Type check iMAXCameras (expected int)
        if "iMAXCameras" in props and props["iMAXCameras"] is not None:
            if not isinstance(props["iMAXCameras"], int):
                try:
                    # Attempt to convert
                    props["iMAXCameras"] = int(props["iMAXCameras"])
                except:
                    raise TypeError(f"Property iMAXCameras must be of type int, got {type(props['iMAXCameras']).__name__}")
    
        # Type check independentFilming (expected bool)
        if "independentFilming" in props and props["independentFilming"] is not None:
            if not isinstance(props["independentFilming"], bool):
                try:
                    # Attempt to convert
                    props["independentFilming"] = bool(props["independentFilming"])
                except:
                    raise TypeError(f"Property independentFilming must be of type bool, got {type(props['independentFilming']).__name__}")
    
        # Type check challengingLocations (expected object)
        if "challengingLocations" in props and props["challengingLocations"] is not None:
            if not isinstance(props["challengingLocations"], object):
                try:
                    # Attempt to convert
                    props["challengingLocations"] = object(props["challengingLocations"])
                except:
                    raise TypeError(f"Property challengingLocations must be of type object, got {type(props['challengingLocations']).__name__}")
    
        # Type check wireworkDays (expected int)
        if "wireworkDays" in props and props["wireworkDays"] is not None:
            if not isinstance(props["wireworkDays"], int):
                try:
                    # Attempt to convert
                    props["wireworkDays"] = int(props["wireworkDays"])
                except:
                    raise TypeError(f"Property wireworkDays must be of type int, got {type(props['wireworkDays']).__name__}")
    
        # Type check aspectMusicScore (expected float)
        if "aspectMusicScore" in props and props["aspectMusicScore"] is not None:
            if not isinstance(props["aspectMusicScore"], float):
                try:
                    # Attempt to convert
                    props["aspectMusicScore"] = float(props["aspectMusicScore"])
                except:
                    raise TypeError(f"Property aspectMusicScore must be of type float, got {type(props['aspectMusicScore']).__name__}")
    
        # Type check aspectScore (expected float)
        if "aspectScore" in props and props["aspectScore"] is not None:
            if not isinstance(props["aspectScore"], float):
                try:
                    # Attempt to convert
                    props["aspectScore"] = float(props["aspectScore"])
                except:
                    raise TypeError(f"Property aspectScore must be of type float, got {type(props['aspectScore']).__name__}")
    
        # Type check aspectDialogue (expected float)
        if "aspectDialogue" in props and props["aspectDialogue"] is not None:
            if not isinstance(props["aspectDialogue"], float):
                try:
                    # Attempt to convert
                    props["aspectDialogue"] = float(props["aspectDialogue"])
                except:
                    raise TypeError(f"Property aspectDialogue must be of type float, got {type(props['aspectDialogue']).__name__}")
    
        # Type check aspectStructure (expected float)
        if "aspectStructure" in props and props["aspectStructure"] is not None:
            if not isinstance(props["aspectStructure"], float):
                try:
                    # Attempt to convert
                    props["aspectStructure"] = float(props["aspectStructure"])
                except:
                    raise TypeError(f"Property aspectStructure must be of type float, got {type(props['aspectStructure']).__name__}")
    
        # Type check aspectEmotionalDepth (expected float)
        if "aspectEmotionalDepth" in props and props["aspectEmotionalDepth"] is not None:
            if not isinstance(props["aspectEmotionalDepth"], float):
                try:
                    # Attempt to convert
                    props["aspectEmotionalDepth"] = float(props["aspectEmotionalDepth"])
                except:
                    raise TypeError(f"Property aspectEmotionalDepth must be of type float, got {type(props['aspectEmotionalDepth']).__name__}")
    
        # Type check aspectMartialArts (expected float)
        if "aspectMartialArts" in props and props["aspectMartialArts"] is not None:
            if not isinstance(props["aspectMartialArts"], float):
                try:
                    # Attempt to convert
                    props["aspectMartialArts"] = float(props["aspectMartialArts"])
                except:
                    raise TypeError(f"Property aspectMartialArts must be of type float, got {type(props['aspectMartialArts']).__name__}")
    
        # Type check culturalInfluence (expected str)
        if "culturalInfluence" in props and props["culturalInfluence"] is not None:
            if not isinstance(props["culturalInfluence"], str):
                try:
                    # Attempt to convert
                    props["culturalInfluence"] = str(props["culturalInfluence"])
                except:
                    raise TypeError(f"Property culturalInfluence must be of type str, got {type(props['culturalInfluence']).__name__}")
    
        # Type check purpose (expected str)
        if "purpose" in props and props["purpose"] is not None:
            if not isinstance(props["purpose"], str):
                try:
                    # Attempt to convert
                    props["purpose"] = str(props["purpose"])
                except:
                    raise TypeError(f"Property purpose must be of type str, got {type(props['purpose']).__name__}")
    
        # Type check buildingAccess (expected str)
        if "buildingAccess" in props and props["buildingAccess"] is not None:
            if not isinstance(props["buildingAccess"], str):
                try:
                    # Attempt to convert
                    props["buildingAccess"] = str(props["buildingAccess"])
                except:
                    raise TypeError(f"Property buildingAccess must be of type str, got {type(props['buildingAccess']).__name__}")
    
        # Type check lighting_style (expected str)
        if "lighting_style" in props and props["lighting_style"] is not None:
            if not isinstance(props["lighting_style"], str):
                try:
                    # Attempt to convert
                    props["lighting_style"] = str(props["lighting_style"])
                except:
                    raise TypeError(f"Property lighting_style must be of type str, got {type(props['lighting_style']).__name__}")
    
        # Type check camera_preference (expected str)
        if "camera_preference" in props and props["camera_preference"] is not None:
            if not isinstance(props["camera_preference"], str):
                try:
                    # Attempt to convert
                    props["camera_preference"] = str(props["camera_preference"])
                except:
                    raise TypeError(f"Property camera_preference must be of type str, got {type(props['camera_preference']).__name__}")
    
        # Type check oscarHonoraryAward (expected bool)
        if "oscarHonoraryAward" in props and props["oscarHonoraryAward"] is not None:
            if not isinstance(props["oscarHonoraryAward"], bool):
                try:
                    # Attempt to convert
                    props["oscarHonoraryAward"] = bool(props["oscarHonoraryAward"])
                except:
                    raise TypeError(f"Property oscarHonoraryAward must be of type bool, got {type(props['oscarHonoraryAward']).__name__}")
    
        # Type check annualEvents (expected int)
        if "annualEvents" in props and props["annualEvents"] is not None:
            if not isinstance(props["annualEvents"], int):
                try:
                    # Attempt to convert
                    props["annualEvents"] = int(props["annualEvents"])
                except:
                    raise TypeError(f"Property annualEvents must be of type int, got {type(props['annualEvents']).__name__}")
    
        # Type check materialQuality (expected str)
        if "materialQuality" in props and props["materialQuality"] is not None:
            if not isinstance(props["materialQuality"], str):
                try:
                    # Attempt to convert
                    props["materialQuality"] = str(props["materialQuality"])
                except:
                    raise TypeError(f"Property materialQuality must be of type str, got {type(props['materialQuality']).__name__}")
    
        # Type check marketingTagline (expected str)
        if "marketingTagline" in props and props["marketingTagline"] is not None:
            if not isinstance(props["marketingTagline"], str):
                try:
                    # Attempt to convert
                    props["marketingTagline"] = str(props["marketingTagline"])
                except:
                    raise TypeError(f"Property marketingTagline must be of type str, got {type(props['marketingTagline']).__name__}")
    
        # Type check practicalEffectsPercentage (expected int)
        if "practicalEffectsPercentage" in props and props["practicalEffectsPercentage"] is not None:
            if not isinstance(props["practicalEffectsPercentage"], int):
                try:
                    # Attempt to convert
                    props["practicalEffectsPercentage"] = int(props["practicalEffectsPercentage"])
                except:
                    raise TypeError(f"Property practicalEffectsPercentage must be of type int, got {type(props['practicalEffectsPercentage']).__name__}")
    
        # Type check sequelNumber (expected int)
        if "sequelNumber" in props and props["sequelNumber"] is not None:
            if not isinstance(props["sequelNumber"], int):
                try:
                    # Attempt to convert
                    props["sequelNumber"] = int(props["sequelNumber"])
                except:
                    raise TypeError(f"Property sequelNumber must be of type int, got {type(props['sequelNumber']).__name__}")
    
        # Type check volumeNumber (expected int)
        if "volumeNumber" in props and props["volumeNumber"] is not None:
            if not isinstance(props["volumeNumber"], int):
                try:
                    # Attempt to convert
                    props["volumeNumber"] = int(props["volumeNumber"])
                except:
                    raise TypeError(f"Property volumeNumber must be of type int, got {type(props['volumeNumber']).__name__}")
    
        # Type check homageFilms (expected object)
        if "homageFilms" in props and props["homageFilms"] is not None:
            if not isinstance(props["homageFilms"], object):
                try:
                    # Attempt to convert
                    props["homageFilms"] = object(props["homageFilms"])
                except:
                    raise TypeError(f"Property homageFilms must be of type object, got {type(props['homageFilms']).__name__}")
    
        # Type check visualEffectsBreakthrough (expected bool)
        if "visualEffectsBreakthrough" in props and props["visualEffectsBreakthrough"] is not None:
            if not isinstance(props["visualEffectsBreakthrough"], bool):
                try:
                    # Attempt to convert
                    props["visualEffectsBreakthrough"] = bool(props["visualEffectsBreakthrough"])
                except:
                    raise TypeError(f"Property visualEffectsBreakthrough must be of type bool, got {type(props['visualEffectsBreakthrough']).__name__}")
    
        # Type check adaptationFidelity (expected str)
        if "adaptationFidelity" in props and props["adaptationFidelity"] is not None:
            if not isinstance(props["adaptationFidelity"], str):
                try:
                    # Attempt to convert
                    props["adaptationFidelity"] = str(props["adaptationFidelity"])
                except:
                    raise TypeError(f"Property adaptationFidelity must be of type str, got {type(props['adaptationFidelity']).__name__}")
    
        # Type check periodAccuracy (expected str)
        if "periodAccuracy" in props and props["periodAccuracy"] is not None:
            if not isinstance(props["periodAccuracy"], str):
                try:
                    # Attempt to convert
                    props["periodAccuracy"] = str(props["periodAccuracy"])
                except:
                    raise TypeError(f"Property periodAccuracy must be of type str, got {type(props['periodAccuracy']).__name__}")
    
        # Type check isAdaptation (expected bool)
        if "isAdaptation" in props and props["isAdaptation"] is not None:
            if not isinstance(props["isAdaptation"], bool):
                try:
                    # Attempt to convert
                    props["isAdaptation"] = bool(props["isAdaptation"])
                except:
                    raise TypeError(f"Property isAdaptation must be of type bool, got {type(props['isAdaptation']).__name__}")
    
        # Type check sourceAuthor (expected str)
        if "sourceAuthor" in props and props["sourceAuthor"] is not None:
            if not isinstance(props["sourceAuthor"], str):
                try:
                    # Attempt to convert
                    props["sourceAuthor"] = str(props["sourceAuthor"])
                except:
                    raise TypeError(f"Property sourceAuthor must be of type str, got {type(props['sourceAuthor']).__name__}")
    
        # Type check writerSkill (expected float)
        if "writerSkill" in props and props["writerSkill"] is not None:
            if not isinstance(props["writerSkill"], float):
                try:
                    # Attempt to convert
                    props["writerSkill"] = float(props["writerSkill"])
                except:
                    raise TypeError(f"Property writerSkill must be of type float, got {type(props['writerSkill']).__name__}")
    
        # Type check adaptationCredits (expected object)
        if "adaptationCredits" in props and props["adaptationCredits"] is not None:
            if not isinstance(props["adaptationCredits"], object):
                try:
                    # Attempt to convert
                    props["adaptationCredits"] = object(props["adaptationCredits"])
                except:
                    raise TypeError(f"Property adaptationCredits must be of type object, got {type(props['adaptationCredits']).__name__}")
    
        # Type check historicalAccuracy (expected str)
        if "historicalAccuracy" in props and props["historicalAccuracy"] is not None:
            if not isinstance(props["historicalAccuracy"], str):
                try:
                    # Attempt to convert
                    props["historicalAccuracy"] = str(props["historicalAccuracy"])
                except:
                    raise TypeError(f"Property historicalAccuracy must be of type str, got {type(props['historicalAccuracy']).__name__}")
    
        # Type check iMAXPercentage (expected int)
        if "iMAXPercentage" in props and props["iMAXPercentage"] is not None:
            if not isinstance(props["iMAXPercentage"], int):
                try:
                    # Attempt to convert
                    props["iMAXPercentage"] = int(props["iMAXPercentage"])
                except:
                    raise TypeError(f"Property iMAXPercentage must be of type int, got {type(props['iMAXPercentage']).__name__}")
    
        # Type check iMAXFilming (expected bool)
        if "iMAXFilming" in props and props["iMAXFilming"] is not None:
            if not isinstance(props["iMAXFilming"], bool):
                try:
                    # Attempt to convert
                    props["iMAXFilming"] = bool(props["iMAXFilming"])
                except:
                    raise TypeError(f"Property iMAXFilming must be of type bool, got {type(props['iMAXFilming']).__name__}")
    
        # Type check cgiBreakthroughs (expected object)
        if "cgiBreakthroughs" in props and props["cgiBreakthroughs"] is not None:
            if not isinstance(props["cgiBreakthroughs"], object):
                try:
                    # Attempt to convert
                    props["cgiBreakthroughs"] = object(props["cgiBreakthroughs"])
                except:
                    raise TypeError(f"Property cgiBreakthroughs must be of type object, got {type(props['cgiBreakthroughs']).__name__}")
    
        # Type check specialEffectsBreakthrough (expected bool)
        if "specialEffectsBreakthrough" in props and props["specialEffectsBreakthrough"] is not None:
            if not isinstance(props["specialEffectsBreakthrough"], bool):
                try:
                    # Attempt to convert
                    props["specialEffectsBreakthrough"] = bool(props["specialEffectsBreakthrough"])
                except:
                    raise TypeError(f"Property specialEffectsBreakthrough must be of type bool, got {type(props['specialEffectsBreakthrough']).__name__}")
    
        # Type check politicalCareer (expected bool)
        if "politicalCareer" in props and props["politicalCareer"] is not None:
            if not isinstance(props["politicalCareer"], bool):
                try:
                    # Attempt to convert
                    props["politicalCareer"] = bool(props["politicalCareer"])
                except:
                    raise TypeError(f"Property politicalCareer must be of type bool, got {type(props['politicalCareer']).__name__}")
    
        # Type check governorYears (expected str)
        if "governorYears" in props and props["governorYears"] is not None:
            if not isinstance(props["governorYears"], str):
                try:
                    # Attempt to convert
                    props["governorYears"] = str(props["governorYears"])
                except:
                    raise TypeError(f"Property governorYears must be of type str, got {type(props['governorYears']).__name__}")
    
        # Type check westernRemakes (expected str)
        if "westernRemakes" in props and props["westernRemakes"] is not None:
            if not isinstance(props["westernRemakes"], str):
                try:
                    # Attempt to convert
                    props["westernRemakes"] = str(props["westernRemakes"])
                except:
                    raise TypeError(f"Property westernRemakes must be of type str, got {type(props['westernRemakes']).__name__}")
    
        # Type check filmPreservation (expected str)
        if "filmPreservation" in props and props["filmPreservation"] is not None:
            if not isinstance(props["filmPreservation"], str):
                try:
                    # Attempt to convert
                    props["filmPreservation"] = str(props["filmPreservation"])
                except:
                    raise TypeError(f"Property filmPreservation must be of type str, got {type(props['filmPreservation']).__name__}")
    
        # Type check westernInfluence (expected str)
        if "westernInfluence" in props and props["westernInfluence"] is not None:
            if not isinstance(props["westernInfluence"], str):
                try:
                    # Attempt to convert
                    props["westernInfluence"] = str(props["westernInfluence"])
                except:
                    raise TypeError(f"Property westernInfluence must be of type str, got {type(props['westernInfluence']).__name__}")
    
        # Type check globalInfluence (expected str)
        if "globalInfluence" in props and props["globalInfluence"] is not None:
            if not isinstance(props["globalInfluence"], str):
                try:
                    # Attempt to convert
                    props["globalInfluence"] = str(props["globalInfluence"])
                except:
                    raise TypeError(f"Property globalInfluence must be of type str, got {type(props['globalInfluence']).__name__}")
    
        # Type check paintingBackground (expected bool)
        if "paintingBackground" in props and props["paintingBackground"] is not None:
            if not isinstance(props["paintingBackground"], bool):
                try:
                    # Attempt to convert
                    props["paintingBackground"] = bool(props["paintingBackground"])
                except:
                    raise TypeError(f"Property paintingBackground must be of type bool, got {type(props['paintingBackground']).__name__}")
    
        # Type check actingStyle (expected str)
        if "actingStyle" in props and props["actingStyle"] is not None:
            if not isinstance(props["actingStyle"], str):
                try:
                    # Attempt to convert
                    props["actingStyle"] = str(props["actingStyle"])
                except:
                    raise TypeError(f"Property actingStyle must be of type str, got {type(props['actingStyle']).__name__}")
    
        # Type check collaborationsWithKurosawa (expected int)
        if "collaborationsWithKurosawa" in props and props["collaborationsWithKurosawa"] is not None:
            if not isinstance(props["collaborationsWithKurosawa"], int):
                try:
                    # Attempt to convert
                    props["collaborationsWithKurosawa"] = int(props["collaborationsWithKurosawa"])
                except:
                    raise TypeError(f"Property collaborationsWithKurosawa must be of type int, got {type(props['collaborationsWithKurosawa']).__name__}")
    
        # Type check actingInfluence (expected str)
        if "actingInfluence" in props and props["actingInfluence"] is not None:
            if not isinstance(props["actingInfluence"], str):
                try:
                    # Attempt to convert
                    props["actingInfluence"] = str(props["actingInfluence"])
                except:
                    raise TypeError(f"Property actingInfluence must be of type str, got {type(props['actingInfluence']).__name__}")
    
        # Type check methodActingPioneer (expected bool)
        if "methodActingPioneer" in props and props["methodActingPioneer"] is not None:
            if not isinstance(props["methodActingPioneer"], bool):
                try:
                    # Attempt to convert
                    props["methodActingPioneer"] = bool(props["methodActingPioneer"])
                except:
                    raise TypeError(f"Property methodActingPioneer must be of type bool, got {type(props['methodActingPioneer']).__name__}")
    
        # Type check athleticBackground (expected bool)
        if "athleticBackground" in props and props["athleticBackground"] is not None:
            if not isinstance(props["athleticBackground"], bool):
                try:
                    # Attempt to convert
                    props["athleticBackground"] = bool(props["athleticBackground"])
                except:
                    raise TypeError(f"Property athleticBackground must be of type bool, got {type(props['athleticBackground']).__name__}")
    
        # Type check sportsPassions (expected object)
        if "sportsPassions" in props and props["sportsPassions"] is not None:
            if not isinstance(props["sportsPassions"], object):
                try:
                    # Attempt to convert
                    props["sportsPassions"] = object(props["sportsPassions"])
                except:
                    raise TypeError(f"Property sportsPassions must be of type object, got {type(props['sportsPassions']).__name__}")
    
        # Type check directorCredits (expected int)
        if "directorCredits" in props and props["directorCredits"] is not None:
            if not isinstance(props["directorCredits"], int):
                try:
                    # Attempt to convert
                    props["directorCredits"] = int(props["directorCredits"])
                except:
                    raise TypeError(f"Property directorCredits must be of type int, got {type(props['directorCredits']).__name__}")
    
        # Type check militaryService (expected str)
        if "militaryService" in props and props["militaryService"] is not None:
            if not isinstance(props["militaryService"], str):
                try:
                    # Attempt to convert
                    props["militaryService"] = str(props["militaryService"])
                except:
                    raise TypeError(f"Property militaryService must be of type str, got {type(props['militaryService']).__name__}")
    
        # Type check photographyExhibits (expected int)
        if "photographyExhibits" in props and props["photographyExhibits"] is not None:
            if not isinstance(props["photographyExhibits"], int):
                try:
                    # Attempt to convert
                    props["photographyExhibits"] = int(props["photographyExhibits"])
                except:
                    raise TypeError(f"Property photographyExhibits must be of type int, got {type(props['photographyExhibits']).__name__}")
    
        # Type check bookAuthor (expected bool)
        if "bookAuthor" in props and props["bookAuthor"] is not None:
            if not isinstance(props["bookAuthor"], bool):
                try:
                    # Attempt to convert
                    props["bookAuthor"] = bool(props["bookAuthor"])
                except:
                    raise TypeError(f"Property bookAuthor must be of type bool, got {type(props['bookAuthor']).__name__}")
    
        # Type check book_years (expected object)
        if "book_years" in props and props["book_years"] is not None:
            if not isinstance(props["book_years"], object):
                try:
                    # Attempt to convert
                    props["book_years"] = object(props["book_years"])
                except:
                    raise TypeError(f"Property book_years must be of type object, got {type(props['book_years']).__name__}")
    
        # Type check screenplay_credits (expected object)
        if "screenplay_credits" in props and props["screenplay_credits"] is not None:
            if not isinstance(props["screenplay_credits"], object):
                try:
                    # Attempt to convert
                    props["screenplay_credits"] = object(props["screenplay_credits"])
                except:
                    raise TypeError(f"Property screenplay_credits must be of type object, got {type(props['screenplay_credits']).__name__}")
    
        # Type check mafia_knowledge (expected str)
        if "mafia_knowledge" in props and props["mafia_knowledge"] is not None:
            if not isinstance(props["mafia_knowledge"], str):
                try:
                    # Attempt to convert
                    props["mafia_knowledge"] = str(props["mafia_knowledge"])
                except:
                    raise TypeError(f"Property mafia_knowledge must be of type str, got {type(props['mafia_knowledge']).__name__}")
    
        # Type check firstNovel (expected object)
        if "firstNovel" in props and props["firstNovel"] is not None:
            if not isinstance(props["firstNovel"], object):
                try:
                    # Attempt to convert
                    props["firstNovel"] = object(props["firstNovel"])
                except:
                    raise TypeError(f"Property firstNovel must be of type object, got {type(props['firstNovel']).__name__}")
    
        # Type check book_titles (expected object)
        if "book_titles" in props and props["book_titles"] is not None:
            if not isinstance(props["book_titles"], object):
                try:
                    # Attempt to convert
                    props["book_titles"] = object(props["book_titles"])
                except:
                    raise TypeError(f"Property book_titles must be of type object, got {type(props['book_titles']).__name__}")
    
        # Type check lastNovel (expected object)
        if "lastNovel" in props and props["lastNovel"] is not None:
            if not isinstance(props["lastNovel"], object):
                try:
                    # Attempt to convert
                    props["lastNovel"] = object(props["lastNovel"])
                except:
                    raise TypeError(f"Property lastNovel must be of type object, got {type(props['lastNovel']).__name__}")
    
        # Type check novelistFirst (expected bool)
        if "novelistFirst" in props and props["novelistFirst"] is not None:
            if not isinstance(props["novelistFirst"], bool):
                try:
                    # Attempt to convert
                    props["novelistFirst"] = bool(props["novelistFirst"])
                except:
                    raise TypeError(f"Property novelistFirst must be of type bool, got {type(props['novelistFirst']).__name__}")
    
        # Type check film_rights_cost (expected int)
        if "film_rights_cost" in props and props["film_rights_cost"] is not None:
            if not isinstance(props["film_rights_cost"], int):
                try:
                    # Attempt to convert
                    props["film_rights_cost"] = int(props["film_rights_cost"])
                except:
                    raise TypeError(f"Property film_rights_cost must be of type int, got {type(props['film_rights_cost']).__name__}")
    
        # Type check cultural_impact_rating (expected float)
        if "cultural_impact_rating" in props and props["cultural_impact_rating"] is not None:
            if not isinstance(props["cultural_impact_rating"], float):
                try:
                    # Attempt to convert
                    props["cultural_impact_rating"] = float(props["cultural_impact_rating"])
                except:
                    raise TypeError(f"Property cultural_impact_rating must be of type float, got {type(props['cultural_impact_rating']).__name__}")
    
        # Type check wordCount (expected int)
        if "wordCount" in props and props["wordCount"] is not None:
            if not isinstance(props["wordCount"], int):
                try:
                    # Attempt to convert
                    props["wordCount"] = int(props["wordCount"])
                except:
                    raise TypeError(f"Property wordCount must be of type int, got {type(props['wordCount']).__name__}")
    
        # Type check publicationDate (expected object)
        if "publicationDate" in props and props["publicationDate"] is not None:
            if not isinstance(props["publicationDate"], object):
                try:
                    # Attempt to convert
                    props["publicationDate"] = object(props["publicationDate"])
                except:
                    raise TypeError(f"Property publicationDate must be of type object, got {type(props['publicationDate']).__name__}")
    
        # Type check themes (expected object)
        if "themes" in props and props["themes"] is not None:
            if not isinstance(props["themes"], object):
                try:
                    # Attempt to convert
                    props["themes"] = object(props["themes"])
                except:
                    raise TypeError(f"Property themes must be of type object, got {type(props['themes']).__name__}")
    
        # Type check literary_awards (expected object)
        if "literary_awards" in props and props["literary_awards"] is not None:
            if not isinstance(props["literary_awards"], object):
                try:
                    # Attempt to convert
                    props["literary_awards"] = object(props["literary_awards"])
                except:
                    raise TypeError(f"Property literary_awards must be of type object, got {type(props['literary_awards']).__name__}")
    
        # Type check publisher (expected str)
        if "publisher" in props and props["publisher"] is not None:
            if not isinstance(props["publisher"], str):
                try:
                    # Attempt to convert
                    props["publisher"] = str(props["publisher"])
                except:
                    raise TypeError(f"Property publisher must be of type str, got {type(props['publisher']).__name__}")
    
        # Type check languages_translated (expected int)
        if "languages_translated" in props and props["languages_translated"] is not None:
            if not isinstance(props["languages_translated"], int):
                try:
                    # Attempt to convert
                    props["languages_translated"] = int(props["languages_translated"])
                except:
                    raise TypeError(f"Property languages_translated must be of type int, got {type(props['languages_translated']).__name__}")
    
        # Type check genre (expected str)
        if "genre" in props and props["genre"] is not None:
            if not isinstance(props["genre"], str):
                try:
                    # Attempt to convert
                    props["genre"] = str(props["genre"])
                except:
                    raise TypeError(f"Property genre must be of type str, got {type(props['genre']).__name__}")
    
        # Type check published (expected int)
        if "published" in props and props["published"] is not None:
            if not isinstance(props["published"], int):
                try:
                    # Attempt to convert
                    props["published"] = int(props["published"])
                except:
                    raise TypeError(f"Property published must be of type int, got {type(props['published']).__name__}")
    
        # Type check initialPrintRun (expected int)
        if "initialPrintRun" in props and props["initialPrintRun"] is not None:
            if not isinstance(props["initialPrintRun"], int):
                try:
                    # Attempt to convert
                    props["initialPrintRun"] = int(props["initialPrintRun"])
                except:
                    raise TypeError(f"Property initialPrintRun must be of type int, got {type(props['initialPrintRun']).__name__}")
    
        # Type check advancePayment (expected int)
        if "advancePayment" in props and props["advancePayment"] is not None:
            if not isinstance(props["advancePayment"], int):
                try:
                    # Attempt to convert
                    props["advancePayment"] = int(props["advancePayment"])
                except:
                    raise TypeError(f"Property advancePayment must be of type int, got {type(props['advancePayment']).__name__}")
    
        # Type check isbn (expected str)
        if "isbn" in props and props["isbn"] is not None:
            if not isinstance(props["isbn"], str):
                try:
                    # Attempt to convert
                    props["isbn"] = str(props["isbn"])
                except:
                    raise TypeError(f"Property isbn must be of type str, got {type(props['isbn']).__name__}")
    
        # Type check totalSales (expected int)
        if "totalSales" in props and props["totalSales"] is not None:
            if not isinstance(props["totalSales"], int):
                try:
                    # Attempt to convert
                    props["totalSales"] = int(props["totalSales"])
                except:
                    raise TypeError(f"Property totalSales must be of type int, got {type(props['totalSales']).__name__}")
    
        # Type check weeksOnBestsellerList (expected int)
        if "weeksOnBestsellerList" in props and props["weeksOnBestsellerList"] is not None:
            if not isinstance(props["weeksOnBestsellerList"], int):
                try:
                    # Attempt to convert
                    props["weeksOnBestsellerList"] = int(props["weeksOnBestsellerList"])
                except:
                    raise TypeError(f"Property weeksOnBestsellerList must be of type int, got {type(props['weeksOnBestsellerList']).__name__}")
    
        # Type check pageCount (expected int)
        if "pageCount" in props and props["pageCount"] is not None:
            if not isinstance(props["pageCount"], int):
                try:
                    # Attempt to convert
                    props["pageCount"] = int(props["pageCount"])
                except:
                    raise TypeError(f"Property pageCount must be of type int, got {type(props['pageCount']).__name__}")
    
        # Type check historicalContext (expected str)
        if "historicalContext" in props and props["historicalContext"] is not None:
            if not isinstance(props["historicalContext"], str):
                try:
                    # Attempt to convert
                    props["historicalContext"] = str(props["historicalContext"])
                except:
                    raise TypeError(f"Property historicalContext must be of type str, got {type(props['historicalContext']).__name__}")
    
        # Type check district (expected str)
        if "district" in props and props["district"] is not None:
            if not isinstance(props["district"], str):
                try:
                    # Attempt to convert
                    props["district"] = str(props["district"])
                except:
                    raise TypeError(f"Property district must be of type str, got {type(props['district']).__name__}")
    
        # Type check culturalSignificance (expected str)
        if "culturalSignificance" in props and props["culturalSignificance"] is not None:
            if not isinstance(props["culturalSignificance"], str):
                try:
                    # Attempt to convert
                    props["culturalSignificance"] = str(props["culturalSignificance"])
                except:
                    raise TypeError(f"Property culturalSignificance must be of type str, got {type(props['culturalSignificance']).__name__}")
    
        # Type check breed (expected str)
        if "breed" in props and props["breed"] is not None:
            if not isinstance(props["breed"], str):
                try:
                    # Attempt to convert
                    props["breed"] = str(props["breed"])
                except:
                    raise TypeError(f"Property breed must be of type str, got {type(props['breed']).__name__}")
    
        # Type check handlerCount (expected int)
        if "handlerCount" in props and props["handlerCount"] is not None:
            if not isinstance(props["handlerCount"], int):
                try:
                    # Attempt to convert
                    props["handlerCount"] = int(props["handlerCount"])
                except:
                    raise TypeError(f"Property handlerCount must be of type int, got {type(props['handlerCount']).__name__}")
    
        # Type check type (expected str)
        if "type" in props and props["type"] is not None:
            if not isinstance(props["type"], str):
                try:
                    # Attempt to convert
                    props["type"] = str(props["type"])
                except:
                    raise TypeError(f"Property type must be of type str, got {type(props['type']).__name__}")
    
        # Type check isImprovised (expected bool)
        if "isImprovised" in props and props["isImprovised"] is not None:
            if not isinstance(props["isImprovised"], bool):
                try:
                    # Attempt to convert
                    props["isImprovised"] = bool(props["isImprovised"])
                except:
                    raise TypeError(f"Property isImprovised must be of type bool, got {type(props['isImprovised']).__name__}")
    
        # Type check animal (expected str)
        if "animal" in props and props["animal"] is not None:
            if not isinstance(props["animal"], str):
                try:
                    # Attempt to convert
                    props["animal"] = str(props["animal"])
                except:
                    raise TypeError(f"Property animal must be of type str, got {type(props['animal']).__name__}")
    
        # Type check isConsumed (expected bool)
        if "isConsumed" in props and props["isConsumed"] is not None:
            if not isinstance(props["isConsumed"], bool):
                try:
                    # Attempt to convert
                    props["isConsumed"] = bool(props["isConsumed"])
                except:
                    raise TypeError(f"Property isConsumed must be of type bool, got {type(props['isConsumed']).__name__}")
    
        # Type check propMaster (expected str)
        if "propMaster" in props and props["propMaster"] is not None:
            if not isinstance(props["propMaster"], str):
                try:
                    # Attempt to convert
                    props["propMaster"] = str(props["propMaster"])
                except:
                    raise TypeError(f"Property propMaster must be of type str, got {type(props['propMaster']).__name__}")
    
        # Type check composition_style (expected str)
        if "composition_style" in props and props["composition_style"] is not None:
            if not isinstance(props["composition_style"], str):
                try:
                    # Attempt to convert
                    props["composition_style"] = str(props["composition_style"])
                except:
                    raise TypeError(f"Property composition_style must be of type str, got {type(props['composition_style']).__name__}")
    
        # Type check musical_education (expected str)
        if "musical_education" in props and props["musical_education"] is not None:
            if not isinstance(props["musical_education"], str):
                try:
                    # Attempt to convert
                    props["musical_education"] = str(props["musical_education"])
                except:
                    raise TypeError(f"Property musical_education must be of type str, got {type(props['musical_education']).__name__}")
    
        # Type check compositionsCount (expected int)
        if "compositionsCount" in props and props["compositionsCount"] is not None:
            if not isinstance(props["compositionsCount"], int):
                try:
                    # Attempt to convert
                    props["compositionsCount"] = int(props["compositionsCount"])
                except:
                    raise TypeError(f"Property compositionsCount must be of type int, got {type(props['compositionsCount']).__name__}")
    
        # Type check collaboration_directors (expected object)
        if "collaboration_directors" in props and props["collaboration_directors"] is not None:
            if not isinstance(props["collaboration_directors"], object):
                try:
                    # Attempt to convert
                    props["collaboration_directors"] = object(props["collaboration_directors"])
                except:
                    raise TypeError(f"Property collaboration_directors must be of type object, got {type(props['collaboration_directors']).__name__}")
    
        # Type check collaboration_years (expected object)
        if "collaboration_years" in props and props["collaboration_years"] is not None:
            if not isinstance(props["collaboration_years"], object):
                try:
                    # Attempt to convert
                    props["collaboration_years"] = object(props["collaboration_years"])
                except:
                    raise TypeError(f"Property collaboration_years must be of type object, got {type(props['collaboration_years']).__name__}")
    
        # Type check research_methodology (expected str)
        if "research_methodology" in props and props["research_methodology"] is not None:
            if not isinstance(props["research_methodology"], str):
                try:
                    # Attempt to convert
                    props["research_methodology"] = str(props["research_methodology"])
                except:
                    raise TypeError(f"Property research_methodology must be of type str, got {type(props['research_methodology']).__name__}")
    
        # Type check designPhilosophy (expected str)
        if "designPhilosophy" in props and props["designPhilosophy"] is not None:
            if not isinstance(props["designPhilosophy"], str):
                try:
                    # Attempt to convert
                    props["designPhilosophy"] = str(props["designPhilosophy"])
                except:
                    raise TypeError(f"Property designPhilosophy must be of type str, got {type(props['designPhilosophy']).__name__}")
    
        # Type check design_specialties (expected object)
        if "design_specialties" in props and props["design_specialties"] is not None:
            if not isinstance(props["design_specialties"], object):
                try:
                    # Attempt to convert
                    props["design_specialties"] = object(props["design_specialties"])
                except:
                    raise TypeError(f"Property design_specialties must be of type object, got {type(props['design_specialties']).__name__}")
    
        # Type check preservationEfforts (expected bool)
        if "preservationEfforts" in props and props["preservationEfforts"] is not None:
            if not isinstance(props["preservationEfforts"], bool):
                try:
                    # Attempt to convert
                    props["preservationEfforts"] = bool(props["preservationEfforts"])
                except:
                    raise TypeError(f"Property preservationEfforts must be of type bool, got {type(props['preservationEfforts']).__name__}")
    
        # Type check academicContributions (expected int)
        if "academicContributions" in props and props["academicContributions"] is not None:
            if not isinstance(props["academicContributions"], int):
                try:
                    # Attempt to convert
                    props["academicContributions"] = int(props["academicContributions"])
                except:
                    raise TypeError(f"Property academicContributions must be of type int, got {type(props['academicContributions']).__name__}")
    
        # Type check formalized (expected object)
        if "formalized" in props and props["formalized"] is not None:
            if not isinstance(props["formalized"], object):
                try:
                    # Attempt to convert
                    props["formalized"] = object(props["formalized"])
                except:
                    raise TypeError(f"Property formalized must be of type object, got {type(props['formalized']).__name__}")
    
        # Type check endowment (expected int)
        if "endowment" in props and props["endowment"] is not None:
            if not isinstance(props["endowment"], int):
                try:
                    # Attempt to convert
                    props["endowment"] = int(props["endowment"])
                except:
                    raise TypeError(f"Property endowment must be of type int, got {type(props['endowment']).__name__}")
    
        # Type check prestigeRanking (expected int)
        if "prestigeRanking" in props and props["prestigeRanking"] is not None:
            if not isinstance(props["prestigeRanking"], int):
                try:
                    # Attempt to convert
                    props["prestigeRanking"] = int(props["prestigeRanking"])
                except:
                    raise TypeError(f"Property prestigeRanking must be of type int, got {type(props['prestigeRanking']).__name__}")
    
        # Type check politicalImpact (expected str)
        if "politicalImpact" in props and props["politicalImpact"] is not None:
            if not isinstance(props["politicalImpact"], str):
                try:
                    # Attempt to convert
                    props["politicalImpact"] = str(props["politicalImpact"])
                except:
                    raise TypeError(f"Property politicalImpact must be of type str, got {type(props['politicalImpact']).__name__}")
    
        # Type check influentialWorks (expected int)
        if "influentialWorks" in props and props["influentialWorks"] is not None:
            if not isinstance(props["influentialWorks"], int):
                try:
                    # Attempt to convert
                    props["influentialWorks"] = int(props["influentialWorks"])
                except:
                    raise TypeError(f"Property influentialWorks must be of type int, got {type(props['influentialWorks']).__name__}")
    
        # Type check culturalInstitutions (expected int)
        if "culturalInstitutions" in props and props["culturalInstitutions"] is not None:
            if not isinstance(props["culturalInstitutions"], int):
                try:
                    # Attempt to convert
                    props["culturalInstitutions"] = int(props["culturalInstitutions"])
                except:
                    raise TypeError(f"Property culturalInstitutions must be of type int, got {type(props['culturalInstitutions']).__name__}")
    
        # Type check family_origin (expected str)
        if "family_origin" in props and props["family_origin"] is not None:
            if not isinstance(props["family_origin"], str):
                try:
                    # Attempt to convert
                    props["family_origin"] = str(props["family_origin"])
                except:
                    raise TypeError(f"Property family_origin must be of type str, got {type(props['family_origin']).__name__}")
    
        # Type check public_titles (expected object)
        if "public_titles" in props and props["public_titles"] is not None:
            if not isinstance(props["public_titles"], object):
                try:
                    # Attempt to convert
                    props["public_titles"] = object(props["public_titles"])
                except:
                    raise TypeError(f"Property public_titles must be of type object, got {type(props['public_titles']).__name__}")
    
        # Type check activities (expected object)
        if "activities" in props and props["activities"] is not None:
            if not isinstance(props["activities"], object):
                try:
                    # Attempt to convert
                    props["activities"] = object(props["activities"])
                except:
                    raise TypeError(f"Property activities must be of type object, got {type(props['activities']).__name__}")
    
        # Type check livedInSicily (expected bool)
        if "livedInSicily" in props and props["livedInSicily"] is not None:
            if not isinstance(props["livedInSicily"], bool):
                try:
                    # Attempt to convert
                    props["livedInSicily"] = bool(props["livedInSicily"])
                except:
                    raise TypeError(f"Property livedInSicily must be of type bool, got {type(props['livedInSicily']).__name__}")
    
        # Type check lastPublicAppearance (expected object)
        if "lastPublicAppearance" in props and props["lastPublicAppearance"] is not None:
            if not isinstance(props["lastPublicAppearance"], object):
                try:
                    # Attempt to convert
                    props["lastPublicAppearance"] = object(props["lastPublicAppearance"])
                except:
                    raise TypeError(f"Property lastPublicAppearance must be of type object, got {type(props['lastPublicAppearance']).__name__}")
    
        # Type check firstPublicAppearance (expected object)
        if "firstPublicAppearance" in props and props["firstPublicAppearance"] is not None:
            if not isinstance(props["firstPublicAppearance"], object):
                try:
                    # Attempt to convert
                    props["firstPublicAppearance"] = object(props["firstPublicAppearance"])
                except:
                    raise TypeError(f"Property firstPublicAppearance must be of type object, got {type(props['firstPublicAppearance']).__name__}")
    
        # Type check memoirAuthor (expected bool)
        if "memoirAuthor" in props and props["memoirAuthor"] is not None:
            if not isinstance(props["memoirAuthor"], bool):
                try:
                    # Attempt to convert
                    props["memoirAuthor"] = bool(props["memoirAuthor"])
                except:
                    raise TypeError(f"Property memoirAuthor must be of type bool, got {type(props['memoirAuthor']).__name__}")
    
        # Type check locationCount (expected int)
        if "locationCount" in props and props["locationCount"] is not None:
            if not isinstance(props["locationCount"], int):
                try:
                    # Attempt to convert
                    props["locationCount"] = int(props["locationCount"])
                except:
                    raise TypeError(f"Property locationCount must be of type int, got {type(props['locationCount']).__name__}")
    
        # Type check animalsUsed (expected int)
        if "animalsUsed" in props and props["animalsUsed"] is not None:
            if not isinstance(props["animalsUsed"], int):
                try:
                    # Attempt to convert
                    props["animalsUsed"] = int(props["animalsUsed"])
                except:
                    raise TypeError(f"Property animalsUsed must be of type int, got {type(props['animalsUsed']).__name__}")
    
        # Type check stuntsRequired (expected int)
        if "stuntsRequired" in props and props["stuntsRequired"] is not None:
            if not isinstance(props["stuntsRequired"], int):
                try:
                    # Attempt to convert
                    props["stuntsRequired"] = int(props["stuntsRequired"])
                except:
                    raise TypeError(f"Property stuntsRequired must be of type int, got {type(props['stuntsRequired']).__name__}")
    
        # Type check actors (expected int)
        if "actors" in props and props["actors"] is not None:
            if not isinstance(props["actors"], int):
                try:
                    # Attempt to convert
                    props["actors"] = int(props["actors"])
                except:
                    raise TypeError(f"Property actors must be of type int, got {type(props['actors']).__name__}")
    
        # Type check interiorsOnly (expected bool)
        if "interiorsOnly" in props and props["interiorsOnly"] is not None:
            if not isinstance(props["interiorsOnly"], bool):
                try:
                    # Attempt to convert
                    props["interiorsOnly"] = bool(props["interiorsOnly"])
                except:
                    raise TypeError(f"Property interiorsOnly must be of type bool, got {type(props['interiorsOnly']).__name__}")
    
        # Type check dialogueLines (expected int)
        if "dialogueLines" in props and props["dialogueLines"] is not None:
            if not isinstance(props["dialogueLines"], int):
                try:
                    # Attempt to convert
                    props["dialogueLines"] = int(props["dialogueLines"])
                except:
                    raise TypeError(f"Property dialogueLines must be of type int, got {type(props['dialogueLines']).__name__}")
    
        # Type check sceneNumber (expected int)
        if "sceneNumber" in props and props["sceneNumber"] is not None:
            if not isinstance(props["sceneNumber"], int):
                try:
                    # Attempt to convert
                    props["sceneNumber"] = int(props["sceneNumber"])
                except:
                    raise TypeError(f"Property sceneNumber must be of type int, got {type(props['sceneNumber']).__name__}")
    
        # Type check extras (expected int)
        if "extras" in props and props["extras"] is not None:
            if not isinstance(props["extras"], int):
                try:
                    # Attempt to convert
                    props["extras"] = int(props["extras"])
                except:
                    raise TypeError(f"Property extras must be of type int, got {type(props['extras']).__name__}")
    
        # Type check specialEffectsComplexity (expected str)
        if "specialEffectsComplexity" in props and props["specialEffectsComplexity"] is not None:
            if not isinstance(props["specialEffectsComplexity"], str):
                try:
                    # Attempt to convert
                    props["specialEffectsComplexity"] = str(props["specialEffectsComplexity"])
                except:
                    raise TypeError(f"Property specialEffectsComplexity must be of type str, got {type(props['specialEffectsComplexity']).__name__}")
    
        # Type check scriptPages (expected int)
        if "scriptPages" in props and props["scriptPages"] is not None:
            if not isinstance(props["scriptPages"], int):
                try:
                    # Attempt to convert
                    props["scriptPages"] = int(props["scriptPages"])
                except:
                    raise TypeError(f"Property scriptPages must be of type int, got {type(props['scriptPages']).__name__}")
    
        # Type check digitalTransformation (expected object)
        if "digitalTransformation" in props and props["digitalTransformation"] is not None:
            if not isinstance(props["digitalTransformation"], object):
                try:
                    # Attempt to convert
                    props["digitalTransformation"] = object(props["digitalTransformation"])
                except:
                    raise TypeError(f"Property digitalTransformation must be of type object, got {type(props['digitalTransformation']).__name__}")
    
        # Type check marketValueUSD (expected int)
        if "marketValueUSD" in props and props["marketValueUSD"] is not None:
            if not isinstance(props["marketValueUSD"], int):
                try:
                    # Attempt to convert
                    props["marketValueUSD"] = int(props["marketValueUSD"])
                except:
                    raise TypeError(f"Property marketValueUSD must be of type int, got {type(props['marketValueUSD']).__name__}")
    
        # Type check publiclyTraded (expected bool)
        if "publiclyTraded" in props and props["publiclyTraded"] is not None:
            if not isinstance(props["publiclyTraded"], bool):
                try:
                    # Attempt to convert
                    props["publiclyTraded"] = bool(props["publiclyTraded"])
                except:
                    raise TypeError(f"Property publiclyTraded must be of type bool, got {type(props['publiclyTraded']).__name__}")
    
        # Type check ceoCompensation (expected int)
        if "ceoCompensation" in props and props["ceoCompensation"] is not None:
            if not isinstance(props["ceoCompensation"], int):
                try:
                    # Attempt to convert
                    props["ceoCompensation"] = int(props["ceoCompensation"])
                except:
                    raise TypeError(f"Property ceoCompensation must be of type int, got {type(props['ceoCompensation']).__name__}")
    
        # Type check globalOffices (expected int)
        if "globalOffices" in props and props["globalOffices"] is not None:
            if not isinstance(props["globalOffices"], int):
                try:
                    # Attempt to convert
                    props["globalOffices"] = int(props["globalOffices"])
                except:
                    raise TypeError(f"Property globalOffices must be of type int, got {type(props['globalOffices']).__name__}")
    
        # Type check tickerSymbol (expected str)
        if "tickerSymbol" in props and props["tickerSymbol"] is not None:
            if not isinstance(props["tickerSymbol"], str):
                try:
                    # Attempt to convert
                    props["tickerSymbol"] = str(props["tickerSymbol"])
                except:
                    raise TypeError(f"Property tickerSymbol must be of type str, got {type(props['tickerSymbol']).__name__}")
    
        # Type check employees (expected int)
        if "employees" in props and props["employees"] is not None:
            if not isinstance(props["employees"], int):
                try:
                    # Attempt to convert
                    props["employees"] = int(props["employees"])
                except:
                    raise TypeError(f"Property employees must be of type int, got {type(props['employees']).__name__}")
    
        # Type check supervisionLevel (expected str)
        if "supervisionLevel" in props and props["supervisionLevel"] is not None:
            if not isinstance(props["supervisionLevel"], str):
                try:
                    # Attempt to convert
                    props["supervisionLevel"] = str(props["supervisionLevel"])
                except:
                    raise TypeError(f"Property supervisionLevel must be of type str, got {type(props['supervisionLevel']).__name__}")
    
        # Type check criticalInfluence (expected str)
        if "criticalInfluence" in props and props["criticalInfluence"] is not None:
            if not isinstance(props["criticalInfluence"], str):
                try:
                    # Attempt to convert
                    props["criticalInfluence"] = str(props["criticalInfluence"])
                except:
                    raise TypeError(f"Property criticalInfluence must be of type str, got {type(props['criticalInfluence']).__name__}")
    
        # Type check author (expected str)
        if "author" in props and props["author"] is not None:
            if not isinstance(props["author"], str):
                try:
                    # Attempt to convert
                    props["author"] = str(props["author"])
                except:
                    raise TypeError(f"Property author must be of type str, got {type(props['author']).__name__}")
    
        # Type check publication (expected str)
        if "publication" in props and props["publication"] is not None:
            if not isinstance(props["publication"], str):
                try:
                    # Attempt to convert
                    props["publication"] = str(props["publication"])
                except:
                    raise TypeError(f"Property publication must be of type str, got {type(props['publication']).__name__}")
    
        # Type check writing_style (expected str)
        if "writing_style" in props and props["writing_style"] is not None:
            if not isinstance(props["writing_style"], str):
                try:
                    # Attempt to convert
                    props["writing_style"] = str(props["writing_style"])
                except:
                    raise TypeError(f"Property writing_style must be of type str, got {type(props['writing_style']).__name__}")
    
        # Type check lastReview (expected object)
        if "lastReview" in props and props["lastReview"] is not None:
            if not isinstance(props["lastReview"], object):
                try:
                    # Attempt to convert
                    props["lastReview"] = object(props["lastReview"])
                except:
                    raise TypeError(f"Property lastReview must be of type object, got {type(props['lastReview']).__name__}")
    
        # Type check critical_philosophy (expected str)
        if "critical_philosophy" in props and props["critical_philosophy"] is not None:
            if not isinstance(props["critical_philosophy"], str):
                try:
                    # Attempt to convert
                    props["critical_philosophy"] = str(props["critical_philosophy"])
                except:
                    raise TypeError(f"Property critical_philosophy must be of type str, got {type(props['critical_philosophy']).__name__}")
    
        # Type check criticalApproach (expected str)
        if "criticalApproach" in props and props["criticalApproach"] is not None:
            if not isinstance(props["criticalApproach"], str):
                try:
                    # Attempt to convert
                    props["criticalApproach"] = str(props["criticalApproach"])
                except:
                    raise TypeError(f"Property criticalApproach must be of type str, got {type(props['criticalApproach']).__name__}")
    
        # Type check books (expected object)
        if "books" in props and props["books"] is not None:
            if not isinstance(props["books"], object):
                try:
                    # Attempt to convert
                    props["books"] = object(props["books"])
                except:
                    raise TypeError(f"Property books must be of type object, got {type(props['books']).__name__}")
    
        # Type check firstReview (expected object)
        if "firstReview" in props and props["firstReview"] is not None:
            if not isinstance(props["firstReview"], object):
                try:
                    # Attempt to convert
                    props["firstReview"] = object(props["firstReview"])
                except:
                    raise TypeError(f"Property firstReview must be of type object, got {type(props['firstReview']).__name__}")
    
        # Type check oscarInfluence (expected str)
        if "oscarInfluence" in props and props["oscarInfluence"] is not None:
            if not isinstance(props["oscarInfluence"], str):
                try:
                    # Attempt to convert
                    props["oscarInfluence"] = str(props["oscarInfluence"])
                except:
                    raise TypeError(f"Property oscarInfluence must be of type str, got {type(props['oscarInfluence']).__name__}")
    
        # Type check reviewCount (expected int)
        if "reviewCount" in props and props["reviewCount"] is not None:
            if not isinstance(props["reviewCount"], int):
                try:
                    # Attempt to convert
                    props["reviewCount"] = int(props["reviewCount"])
                except:
                    raise TypeError(f"Property reviewCount must be of type int, got {type(props['reviewCount']).__name__}")
    
        # Type check publications (expected object)
        if "publications" in props and props["publications"] is not None:
            if not isinstance(props["publications"], object):
                try:
                    # Attempt to convert
                    props["publications"] = object(props["publications"])
                except:
                    raise TypeError(f"Property publications must be of type object, got {type(props['publications']).__name__}")
    
        # Type check heightUnit (expected str)
        if "heightUnit" in props and props["heightUnit"] is not None:
            if not isinstance(props["heightUnit"], str):
                try:
                    # Attempt to convert
                    props["heightUnit"] = str(props["heightUnit"])
                except:
                    raise TypeError(f"Property heightUnit must be of type str, got {type(props['heightUnit']).__name__}")
    
        # Type check category (expected str)
        if "category" in props and props["category"] is not None:
            if not isinstance(props["category"], str):
                try:
                    # Attempt to convert
                    props["category"] = str(props["category"])
                except:
                    raise TypeError(f"Property category must be of type str, got {type(props['category']).__name__}")
    
        # Type check presentedBy (expected str)
        if "presentedBy" in props and props["presentedBy"] is not None:
            if not isinstance(props["presentedBy"], str):
                try:
                    # Attempt to convert
                    props["presentedBy"] = str(props["presentedBy"])
                except:
                    raise TypeError(f"Property presentedBy must be of type str, got {type(props['presentedBy']).__name__}")
    
        # Type check awardMaterial (expected str)
        if "awardMaterial" in props and props["awardMaterial"] is not None:
            if not isinstance(props["awardMaterial"], str):
                try:
                    # Attempt to convert
                    props["awardMaterial"] = str(props["awardMaterial"])
                except:
                    raise TypeError(f"Property awardMaterial must be of type str, got {type(props['awardMaterial']).__name__}")
    
        # Type check awardWeight (expected float)
        if "awardWeight" in props and props["awardWeight"] is not None:
            if not isinstance(props["awardWeight"], float):
                try:
                    # Attempt to convert
                    props["awardWeight"] = float(props["awardWeight"])
                except:
                    raise TypeError(f"Property awardWeight must be of type float, got {type(props['awardWeight']).__name__}")
    
        # Type check applicationRequired (expected bool)
        if "applicationRequired" in props and props["applicationRequired"] is not None:
            if not isinstance(props["applicationRequired"], bool):
                try:
                    # Attempt to convert
                    props["applicationRequired"] = bool(props["applicationRequired"])
                except:
                    raise TypeError(f"Property applicationRequired must be of type bool, got {type(props['applicationRequired']).__name__}")
    
        # Type check recipients (expected int)
        if "recipients" in props and props["recipients"] is not None:
            if not isinstance(props["recipients"], int):
                try:
                    # Attempt to convert
                    props["recipients"] = int(props["recipients"])
                except:
                    raise TypeError(f"Property recipients must be of type int, got {type(props['recipients']).__name__}")
    
        # Type check firstAwarded (expected object)
        if "firstAwarded" in props and props["firstAwarded"] is not None:
            if not isinstance(props["firstAwarded"], object):
                try:
                    # Attempt to convert
                    props["firstAwarded"] = object(props["firstAwarded"])
                except:
                    raise TypeError(f"Property firstAwarded must be of type object, got {type(props['firstAwarded']).__name__}")
    
        # Type check awardHeight (expected float)
        if "awardHeight" in props and props["awardHeight"] is not None:
            if not isinstance(props["awardHeight"], float):
                try:
                    # Attempt to convert
                    props["awardHeight"] = float(props["awardHeight"])
                except:
                    raise TypeError(f"Property awardHeight must be of type float, got {type(props['awardHeight']).__name__}")
    
        # Type check monetary (expected bool)
        if "monetary" in props and props["monetary"] is not None:
            if not isinstance(props["monetary"], bool):
                try:
                    # Attempt to convert
                    props["monetary"] = bool(props["monetary"])
                except:
                    raise TypeError(f"Property monetary must be of type bool, got {type(props['monetary']).__name__}")
    
        # Type check physicalAward (expected bool)
        if "physicalAward" in props and props["physicalAward"] is not None:
            if not isinstance(props["physicalAward"], bool):
                try:
                    # Attempt to convert
                    props["physicalAward"] = bool(props["physicalAward"])
                except:
                    raise TypeError(f"Property physicalAward must be of type bool, got {type(props['physicalAward']).__name__}")
    
        # Type check prestige (expected float)
        if "prestige" in props and props["prestige"] is not None:
            if not isinstance(props["prestige"], float):
                try:
                    # Attempt to convert
                    props["prestige"] = float(props["prestige"])
                except:
                    raise TypeError(f"Property prestige must be of type float, got {type(props['prestige']).__name__}")
    
        # Type check working_style (expected str)
        if "working_style" in props and props["working_style"] is not None:
            if not isinstance(props["working_style"], str):
                try:
                    # Attempt to convert
                    props["working_style"] = str(props["working_style"])
                except:
                    raise TypeError(f"Property working_style must be of type str, got {type(props['working_style']).__name__}")
    
        # Type check technical_expertise (expected str)
        if "technical_expertise" in props and props["technical_expertise"] is not None:
            if not isinstance(props["technical_expertise"], str):
                try:
                    # Attempt to convert
                    props["technical_expertise"] = str(props["technical_expertise"])
                except:
                    raise TypeError(f"Property technical_expertise must be of type str, got {type(props['technical_expertise']).__name__}")
    
        # Type check editingStyle (expected str)
        if "editingStyle" in props and props["editingStyle"] is not None:
            if not isinstance(props["editingStyle"], str):
                try:
                    # Attempt to convert
                    props["editingStyle"] = str(props["editingStyle"])
                except:
                    raise TypeError(f"Property editingStyle must be of type str, got {type(props['editingStyle']).__name__}")
    
        # Type check industryLessons (expected str)
        if "industryLessons" in props and props["industryLessons"] is not None:
            if not isinstance(props["industryLessons"], str):
                try:
                    # Attempt to convert
                    props["industryLessons"] = str(props["industryLessons"])
                except:
                    raise TypeError(f"Property industryLessons must be of type str, got {type(props['industryLessons']).__name__}")
    
        # Type check documentationLevel (expected str)
        if "documentationLevel" in props and props["documentationLevel"] is not None:
            if not isinstance(props["documentationLevel"], str):
                try:
                    # Attempt to convert
                    props["documentationLevel"] = str(props["documentationLevel"])
                except:
                    raise TypeError(f"Property documentationLevel must be of type str, got {type(props['documentationLevel']).__name__}")
    
        # Type check scheduleImpact (expected object)
        if "scheduleImpact" in props and props["scheduleImpact"] is not None:
            if not isinstance(props["scheduleImpact"], object):
                try:
                    # Attempt to convert
                    props["scheduleImpact"] = object(props["scheduleImpact"])
                except:
                    raise TypeError(f"Property scheduleImpact must be of type object, got {type(props['scheduleImpact']).__name__}")
    
        # Type check productionPhase (expected str)
        if "productionPhase" in props and props["productionPhase"] is not None:
            if not isinstance(props["productionPhase"], str):
                try:
                    # Attempt to convert
                    props["productionPhase"] = str(props["productionPhase"])
                except:
                    raise TypeError(f"Property productionPhase must be of type str, got {type(props['productionPhase']).__name__}")
    
        # Type check budgetImpact (expected int)
        if "budgetImpact" in props and props["budgetImpact"] is not None:
            if not isinstance(props["budgetImpact"], int):
                try:
                    # Attempt to convert
                    props["budgetImpact"] = int(props["budgetImpact"])
                except:
                    raise TypeError(f"Property budgetImpact must be of type int, got {type(props['budgetImpact']).__name__}")
    
        # Type check resolutionSuccess (expected float)
        if "resolutionSuccess" in props and props["resolutionSuccess"] is not None:
            if not isinstance(props["resolutionSuccess"], float):
                try:
                    # Attempt to convert
                    props["resolutionSuccess"] = float(props["resolutionSuccess"])
                except:
                    raise TypeError(f"Property resolutionSuccess must be of type float, got {type(props['resolutionSuccess']).__name__}")
    
        # Type check departmentsAffected (expected int)
        if "departmentsAffected" in props and props["departmentsAffected"] is not None:
            if not isinstance(props["departmentsAffected"], int):
                try:
                    # Attempt to convert
                    props["departmentsAffected"] = int(props["departmentsAffected"])
                except:
                    raise TypeError(f"Property departmentsAffected must be of type int, got {type(props['departmentsAffected']).__name__}")
    
        # Type check severityLevel (expected float)
        if "severityLevel" in props and props["severityLevel"] is not None:
            if not isinstance(props["severityLevel"], float):
                try:
                    # Attempt to convert
                    props["severityLevel"] = float(props["severityLevel"])
                except:
                    raise TypeError(f"Property severityLevel must be of type float, got {type(props['severityLevel']).__name__}")
    
        # Type check dialect_expertise (expected object)
        if "dialect_expertise" in props and props["dialect_expertise"] is not None:
            if not isinstance(props["dialect_expertise"], object):
                try:
                    # Attempt to convert
                    props["dialect_expertise"] = object(props["dialect_expertise"])
                except:
                    raise TypeError(f"Property dialect_expertise must be of type object, got {type(props['dialect_expertise']).__name__}")
    
        # Type check teaching_methodology (expected str)
        if "teaching_methodology" in props and props["teaching_methodology"] is not None:
            if not isinstance(props["teaching_methodology"], str):
                try:
                    # Attempt to convert
                    props["teaching_methodology"] = str(props["teaching_methodology"])
                except:
                    raise TypeError(f"Property teaching_methodology must be of type str, got {type(props['teaching_methodology']).__name__}")
    
        # Type check film_appearances (expected object)
        if "film_appearances" in props and props["film_appearances"] is not None:
            if not isinstance(props["film_appearances"], object):
                try:
                    # Attempt to convert
                    props["film_appearances"] = object(props["film_appearances"])
                except:
                    raise TypeError(f"Property film_appearances must be of type object, got {type(props['film_appearances']).__name__}")
    
        # Type check appearance_years (expected object)
        if "appearance_years" in props and props["appearance_years"] is not None:
            if not isinstance(props["appearance_years"], object):
                try:
                    # Attempt to convert
                    props["appearance_years"] = object(props["appearance_years"])
                except:
                    raise TypeError(f"Property appearance_years must be of type object, got {type(props['appearance_years']).__name__}")
    
        # Type check sicilianNative (expected bool)
        if "sicilianNative" in props and props["sicilianNative"] is not None:
            if not isinstance(props["sicilianNative"], bool):
                try:
                    # Attempt to convert
                    props["sicilianNative"] = bool(props["sicilianNative"])
                except:
                    raise TypeError(f"Property sicilianNative must be of type bool, got {type(props['sicilianNative']).__name__}")
    
        # Type check dialectsKnown (expected int)
        if "dialectsKnown" in props and props["dialectsKnown"] is not None:
            if not isinstance(props["dialectsKnown"], int):
                try:
                    # Attempt to convert
                    props["dialectsKnown"] = int(props["dialectsKnown"])
                except:
                    raise TypeError(f"Property dialectsKnown must be of type int, got {type(props['dialectsKnown']).__name__}")
    
        # Type check actingCredits (expected int)
        if "actingCredits" in props and props["actingCredits"] is not None:
            if not isinstance(props["actingCredits"], int):
                try:
                    # Attempt to convert
                    props["actingCredits"] = int(props["actingCredits"])
                except:
                    raise TypeError(f"Property actingCredits must be of type int, got {type(props['actingCredits']).__name__}")
    
        # Type check dimensions (expected str)
        if "dimensions" in props and props["dimensions"] is not None:
            if not isinstance(props["dimensions"], str):
                try:
                    # Attempt to convert
                    props["dimensions"] = str(props["dimensions"])
                except:
                    raise TypeError(f"Property dimensions must be of type str, got {type(props['dimensions']).__name__}")
    
        # Type check valuation_currency (expected str)
        if "valuation_currency" in props and props["valuation_currency"] is not None:
            if not isinstance(props["valuation_currency"], str):
                try:
                    # Attempt to convert
                    props["valuation_currency"] = str(props["valuation_currency"])
                except:
                    raise TypeError(f"Property valuation_currency must be of type str, got {type(props['valuation_currency']).__name__}")
    
        # Type check creationDate (expected object)
        if "creationDate" in props and props["creationDate"] is not None:
            if not isinstance(props["creationDate"], object):
                try:
                    # Attempt to convert
                    props["creationDate"] = object(props["creationDate"])
                except:
                    raise TypeError(f"Property creationDate must be of type object, got {type(props['creationDate']).__name__}")
    
        # Type check condition (expected str)
        if "condition" in props and props["condition"] is not None:
            if not isinstance(props["condition"], str):
                try:
                    # Attempt to convert
                    props["condition"] = str(props["condition"])
                except:
                    raise TypeError(f"Property condition must be of type str, got {type(props['condition']).__name__}")
    
        # Type check insured (expected bool)
        if "insured" in props and props["insured"] is not None:
            if not isinstance(props["insured"], bool):
                try:
                    # Attempt to convert
                    props["insured"] = bool(props["insured"])
                except:
                    raise TypeError(f"Property insured must be of type bool, got {type(props['insured']).__name__}")
    
        # Type check appraised_value (expected int)
        if "appraised_value" in props and props["appraised_value"] is not None:
            if not isinstance(props["appraised_value"], int):
                try:
                    # Attempt to convert
                    props["appraised_value"] = int(props["appraised_value"])
                except:
                    raise TypeError(f"Property appraised_value must be of type int, got {type(props['appraised_value']).__name__}")
    
        # Type check dimensionUnit (expected str)
        if "dimensionUnit" in props and props["dimensionUnit"] is not None:
            if not isinstance(props["dimensionUnit"], str):
                try:
                    # Attempt to convert
                    props["dimensionUnit"] = str(props["dimensionUnit"])
                except:
                    raise TypeError(f"Property dimensionUnit must be of type str, got {type(props['dimensionUnit']).__name__}")
    
        # Type check authenticity_verified (expected bool)
        if "authenticity_verified" in props and props["authenticity_verified"] is not None:
            if not isinstance(props["authenticity_verified"], bool):
                try:
                    # Attempt to convert
                    props["authenticity_verified"] = bool(props["authenticity_verified"])
                except:
                    raise TypeError(f"Property authenticity_verified must be of type bool, got {type(props['authenticity_verified']).__name__}")
    
        # Type check negotiation_style (expected str)
        if "negotiation_style" in props and props["negotiation_style"] is not None:
            if not isinstance(props["negotiation_style"], str):
                try:
                    # Attempt to convert
                    props["negotiation_style"] = str(props["negotiation_style"])
                except:
                    raise TypeError(f"Property negotiation_style must be of type str, got {type(props['negotiation_style']).__name__}")
    
        # Type check production_titles (expected object)
        if "production_titles" in props and props["production_titles"] is not None:
            if not isinstance(props["production_titles"], object):
                try:
                    # Attempt to convert
                    props["production_titles"] = object(props["production_titles"])
                except:
                    raise TypeError(f"Property production_titles must be of type object, got {type(props['production_titles']).__name__}")
    
        # Type check production_years (expected object)
        if "production_years" in props and props["production_years"] is not None:
            if not isinstance(props["production_years"], object):
                try:
                    # Attempt to convert
                    props["production_years"] = object(props["production_years"])
                except:
                    raise TypeError(f"Property production_years must be of type object, got {type(props['production_years']).__name__}")
    
        # Type check education (expected str)
        if "education" in props and props["education"] is not None:
            if not isinstance(props["education"], str):
                try:
                    # Attempt to convert
                    props["education"] = str(props["education"])
                except:
                    raise TypeError(f"Property education must be of type str, got {type(props['education']).__name__}")
    
        # Type check businessBackground (expected str)
        if "businessBackground" in props and props["businessBackground"] is not None:
            if not isinstance(props["businessBackground"], str):
                try:
                    # Attempt to convert
                    props["businessBackground"] = str(props["businessBackground"])
                except:
                    raise TypeError(f"Property businessBackground must be of type str, got {type(props['businessBackground']).__name__}")
    
        # Type check firstProduction (expected object)
        if "firstProduction" in props and props["firstProduction"] is not None:
            if not isinstance(props["firstProduction"], object):
                try:
                    # Attempt to convert
                    props["firstProduction"] = object(props["firstProduction"])
                except:
                    raise TypeError(f"Property firstProduction must be of type object, got {type(props['firstProduction']).__name__}")
    
        # Type check business_background (expected str)
        if "business_background" in props and props["business_background"] is not None:
            if not isinstance(props["business_background"], str):
                try:
                    # Attempt to convert
                    props["business_background"] = str(props["business_background"])
                except:
                    raise TypeError(f"Property business_background must be of type str, got {type(props['business_background']).__name__}")
    
        # Type check lastProduction (expected object)
        if "lastProduction" in props and props["lastProduction"] is not None:
            if not isinstance(props["lastProduction"], object):
                try:
                    # Attempt to convert
                    props["lastProduction"] = object(props["lastProduction"])
                except:
                    raise TypeError(f"Property lastProduction must be of type object, got {type(props['lastProduction']).__name__}")
    
        # Type check key_productions (expected object)
        if "key_productions" in props and props["key_productions"] is not None:
            if not isinstance(props["key_productions"], object):
                try:
                    # Attempt to convert
                    props["key_productions"] = object(props["key_productions"])
                except:
                    raise TypeError(f"Property key_productions must be of type object, got {type(props['key_productions']).__name__}")
    
        # Type check studioExecutive (expected bool)
        if "studioExecutive" in props and props["studioExecutive"] is not None:
            if not isinstance(props["studioExecutive"], bool):
                try:
                    # Attempt to convert
                    props["studioExecutive"] = bool(props["studioExecutive"])
                except:
                    raise TypeError(f"Property studioExecutive must be of type bool, got {type(props['studioExecutive']).__name__}")
    
        # Type check studio_role (expected str)
        if "studio_role" in props and props["studio_role"] is not None:
            if not isinstance(props["studio_role"], str):
                try:
                    # Attempt to convert
                    props["studio_role"] = str(props["studio_role"])
                except:
                    raise TypeError(f"Property studio_role must be of type str, got {type(props['studio_role']).__name__}")
    
        # Type check acquisition_strategy (expected str)
        if "acquisition_strategy" in props and props["acquisition_strategy"] is not None:
            if not isinstance(props["acquisition_strategy"], str):
                try:
                    # Attempt to convert
                    props["acquisition_strategy"] = str(props["acquisition_strategy"])
                except:
                    raise TypeError(f"Property acquisition_strategy must be of type str, got {type(props['acquisition_strategy']).__name__}")
    
        # Type check business_entities (expected object)
        if "business_entities" in props and props["business_entities"] is not None:
            if not isinstance(props["business_entities"], object):
                try:
                    # Attempt to convert
                    props["business_entities"] = object(props["business_entities"])
                except:
                    raise TypeError(f"Property business_entities must be of type object, got {type(props['business_entities']).__name__}")
    
        # Type check leadership_years (expected object)
        if "leadership_years" in props and props["leadership_years"] is not None:
            if not isinstance(props["leadership_years"], object):
                try:
                    # Attempt to convert
                    props["leadership_years"] = object(props["leadership_years"])
                except:
                    raise TypeError(f"Property leadership_years must be of type object, got {type(props['leadership_years']).__name__}")
    
        # Type check business_titles (expected object)
        if "business_titles" in props and props["business_titles"] is not None:
            if not isinstance(props["business_titles"], object):
                try:
                    # Attempt to convert
                    props["business_titles"] = object(props["business_titles"])
                except:
                    raise TypeError(f"Property business_titles must be of type object, got {type(props['business_titles']).__name__}")
    
        # Type check corporateRole (expected str)
        if "corporateRole" in props and props["corporateRole"] is not None:
            if not isinstance(props["corporateRole"], str):
                try:
                    # Attempt to convert
                    props["corporateRole"] = str(props["corporateRole"])
                except:
                    raise TypeError(f"Property corporateRole must be of type str, got {type(props['corporateRole']).__name__}")
    
        # Type check firstPosition (expected object)
        if "firstPosition" in props and props["firstPosition"] is not None:
            if not isinstance(props["firstPosition"], object):
                try:
                    # Attempt to convert
                    props["firstPosition"] = object(props["firstPosition"])
                except:
                    raise TypeError(f"Property firstPosition must be of type object, got {type(props['firstPosition']).__name__}")
    
        # Type check tradePublicationLeadership (expected bool)
        if "tradePublicationLeadership" in props and props["tradePublicationLeadership"] is not None:
            if not isinstance(props["tradePublicationLeadership"], bool):
                try:
                    # Attempt to convert
                    props["tradePublicationLeadership"] = bool(props["tradePublicationLeadership"])
                except:
                    raise TypeError(f"Property tradePublicationLeadership must be of type bool, got {type(props['tradePublicationLeadership']).__name__}")
    
        # Type check executiveRole (expected str)
        if "executiveRole" in props and props["executiveRole"] is not None:
            if not isinstance(props["executiveRole"], str):
                try:
                    # Attempt to convert
                    props["executiveRole"] = str(props["executiveRole"])
                except:
                    raise TypeError(f"Property executiveRole must be of type str, got {type(props['executiveRole']).__name__}")
    
        # Type check journalismBackground (expected bool)
        if "journalismBackground" in props and props["journalismBackground"] is not None:
            if not isinstance(props["journalismBackground"], bool):
                try:
                    # Attempt to convert
                    props["journalismBackground"] = bool(props["journalismBackground"])
                except:
                    raise TypeError(f"Property journalismBackground must be of type bool, got {type(props['journalismBackground']).__name__}")
    
        # Type check development_years (expected object)
        if "development_years" in props and props["development_years"] is not None:
            if not isinstance(props["development_years"], object):
                try:
                    # Attempt to convert
                    props["development_years"] = object(props["development_years"])
                except:
                    raise TypeError(f"Property development_years must be of type object, got {type(props['development_years']).__name__}")
    
        # Type check career_positions (expected object)
        if "career_positions" in props and props["career_positions"] is not None:
            if not isinstance(props["career_positions"], object):
                try:
                    # Attempt to convert
                    props["career_positions"] = object(props["career_positions"])
                except:
                    raise TypeError(f"Property career_positions must be of type object, got {type(props['career_positions']).__name__}")
    
        # Type check position_years (expected object)
        if "position_years" in props and props["position_years"] is not None:
            if not isinstance(props["position_years"], object):
                try:
                    # Attempt to convert
                    props["position_years"] = object(props["position_years"])
                except:
                    raise TypeError(f"Property position_years must be of type object, got {type(props['position_years']).__name__}")
    
        # Type check key_developments (expected object)
        if "key_developments" in props and props["key_developments"] is not None:
            if not isinstance(props["key_developments"], object):
                try:
                    # Attempt to convert
                    props["key_developments"] = object(props["key_developments"])
                except:
                    raise TypeError(f"Property key_developments must be of type object, got {type(props['key_developments']).__name__}")
    
        # Type check mountain_logo (expected bool)
        if "mountain_logo" in props and props["mountain_logo"] is not None:
            if not isinstance(props["mountain_logo"], bool):
                try:
                    # Attempt to convert
                    props["mountain_logo"] = bool(props["mountain_logo"])
                except:
                    raise TypeError(f"Property mountain_logo must be of type bool, got {type(props['mountain_logo']).__name__}")
    
        # Type check production_heads (expected object)
        if "production_heads" in props and props["production_heads"] is not None:
            if not isinstance(props["production_heads"], object):
                try:
                    # Attempt to convert
                    props["production_heads"] = object(props["production_heads"])
                except:
                    raise TypeError(f"Property production_heads must be of type object, got {type(props['production_heads']).__name__}")
    
        # Type check distribution_markets (expected object)
        if "distribution_markets" in props and props["distribution_markets"] is not None:
            if not isinstance(props["distribution_markets"], object):
                try:
                    # Attempt to convert
                    props["distribution_markets"] = object(props["distribution_markets"])
                except:
                    raise TypeError(f"Property distribution_markets must be of type object, got {type(props['distribution_markets']).__name__}")
    
        # Type check totalSoundstages (expected int)
        if "totalSoundstages" in props and props["totalSoundstages"] is not None:
            if not isinstance(props["totalSoundstages"], int):
                try:
                    # Attempt to convert
                    props["totalSoundstages"] = int(props["totalSoundstages"])
                except:
                    raise TypeError(f"Property totalSoundstages must be of type int, got {type(props['totalSoundstages']).__name__}")
    
        # Type check yearlyRevenue1973 (expected int)
        if "yearlyRevenue1973" in props and props["yearlyRevenue1973"] is not None:
            if not isinstance(props["yearlyRevenue1973"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1973"] = int(props["yearlyRevenue1973"])
                except:
                    raise TypeError(f"Property yearlyRevenue1973 must be of type int, got {type(props['yearlyRevenue1973']).__name__}")
    
        # Type check yearlyRevenue1972 (expected int)
        if "yearlyRevenue1972" in props and props["yearlyRevenue1972"] is not None:
            if not isinstance(props["yearlyRevenue1972"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1972"] = int(props["yearlyRevenue1972"])
                except:
                    raise TypeError(f"Property yearlyRevenue1972 must be of type int, got {type(props['yearlyRevenue1972']).__name__}")
    
        # Type check yearlyRevenue1971 (expected int)
        if "yearlyRevenue1971" in props and props["yearlyRevenue1971"] is not None:
            if not isinstance(props["yearlyRevenue1971"], int):
                try:
                    # Attempt to convert
                    props["yearlyRevenue1971"] = int(props["yearlyRevenue1971"])
                except:
                    raise TypeError(f"Property yearlyRevenue1971 must be of type int, got {type(props['yearlyRevenue1971']).__name__}")
    
        # Type check filmReleases1972 (expected int)
        if "filmReleases1972" in props and props["filmReleases1972"] is not None:
            if not isinstance(props["filmReleases1972"], int):
                try:
                    # Attempt to convert
                    props["filmReleases1972"] = int(props["filmReleases1972"])
                except:
                    raise TypeError(f"Property filmReleases1972 must be of type int, got {type(props['filmReleases1972']).__name__}")
    
        # Type check reorganized (expected object)
        if "reorganized" in props and props["reorganized"] is not None:
            if not isinstance(props["reorganized"], object):
                try:
                    # Attempt to convert
                    props["reorganized"] = object(props["reorganized"])
                except:
                    raise TypeError(f"Property reorganized must be of type object, got {type(props['reorganized']).__name__}")
    
        # Type check chairmen_history (expected object)
        if "chairmen_history" in props and props["chairmen_history"] is not None:
            if not isinstance(props["chairmen_history"], object):
                try:
                    # Attempt to convert
                    props["chairmen_history"] = object(props["chairmen_history"])
                except:
                    raise TypeError(f"Property chairmen_history must be of type object, got {type(props['chairmen_history']).__name__}")
    
        # Type check totalStudioLots (expected int)
        if "totalStudioLots" in props and props["totalStudioLots"] is not None:
            if not isinstance(props["totalStudioLots"], int):
                try:
                    # Attempt to convert
                    props["totalStudioLots"] = int(props["totalStudioLots"])
                except:
                    raise TypeError(f"Property totalStudioLots must be of type int, got {type(props['totalStudioLots']).__name__}")
    
        # Type check founded_for (expected str)
        if "founded_for" in props and props["founded_for"] is not None:
            if not isinstance(props["founded_for"], str):
                try:
                    # Attempt to convert
                    props["founded_for"] = str(props["founded_for"])
                except:
                    raise TypeError(f"Property founded_for must be of type str, got {type(props['founded_for']).__name__}")
    
        # Type check namedFor (expected str)
        if "namedFor" in props and props["namedFor"] is not None:
            if not isinstance(props["namedFor"], str):
                try:
                    # Attempt to convert
                    props["namedFor"] = str(props["namedFor"])
                except:
                    raise TypeError(f"Property namedFor must be of type str, got {type(props['namedFor']).__name__}")
    
        # Type check officeSpace (expected int)
        if "officeSpace" in props and props["officeSpace"] is not None:
            if not isinstance(props["officeSpace"], int):
                try:
                    # Attempt to convert
                    props["officeSpace"] = int(props["officeSpace"])
                except:
                    raise TypeError(f"Property officeSpace must be of type int, got {type(props['officeSpace']).__name__}")
    
        # Type check companyType (expected str)
        if "companyType" in props and props["companyType"] is not None:
            if not isinstance(props["companyType"], str):
                try:
                    # Attempt to convert
                    props["companyType"] = str(props["companyType"])
                except:
                    raise TypeError(f"Property companyType must be of type str, got {type(props['companyType']).__name__}")
    
        # Type check headquarters (expected str)
        if "headquarters" in props and props["headquarters"] is not None:
            if not isinstance(props["headquarters"], str):
                try:
                    # Attempt to convert
                    props["headquarters"] = str(props["headquarters"])
                except:
                    raise TypeError(f"Property headquarters must be of type str, got {type(props['headquarters']).__name__}")
    
        # Type check officeSpaceUnit (expected str)
        if "officeSpaceUnit" in props and props["officeSpaceUnit"] is not None:
            if not isinstance(props["officeSpaceUnit"], str):
                try:
                    # Attempt to convert
                    props["officeSpaceUnit"] = str(props["officeSpaceUnit"])
                except:
                    raise TypeError(f"Property officeSpaceUnit must be of type str, got {type(props['officeSpaceUnit']).__name__}")
    
        # Type check company_structure (expected str)
        if "company_structure" in props and props["company_structure"] is not None:
            if not isinstance(props["company_structure"], str):
                try:
                    # Attempt to convert
                    props["company_structure"] = str(props["company_structure"])
                except:
                    raise TypeError(f"Property company_structure must be of type str, got {type(props['company_structure']).__name__}")
    
        # Type check studio_partnerships (expected object)
        if "studio_partnerships" in props and props["studio_partnerships"] is not None:
            if not isinstance(props["studio_partnerships"], object):
                try:
                    # Attempt to convert
                    props["studio_partnerships"] = object(props["studio_partnerships"])
                except:
                    raise TypeError(f"Property studio_partnerships must be of type object, got {type(props['studio_partnerships']).__name__}")
    
        # Type check ceo_tenure (expected str)
        if "ceo_tenure" in props and props["ceo_tenure"] is not None:
            if not isinstance(props["ceo_tenure"], str):
                try:
                    # Attempt to convert
                    props["ceo_tenure"] = str(props["ceo_tenure"])
                except:
                    raise TypeError(f"Property ceo_tenure must be of type str, got {type(props['ceo_tenure']).__name__}")
    
        # Type check business_sectors (expected object)
        if "business_sectors" in props and props["business_sectors"] is not None:
            if not isinstance(props["business_sectors"], object):
                try:
                    # Attempt to convert
                    props["business_sectors"] = object(props["business_sectors"])
                except:
                    raise TypeError(f"Property business_sectors must be of type object, got {type(props['business_sectors']).__name__}")
    
        # Type check key_subsidiaries (expected object)
        if "key_subsidiaries" in props and props["key_subsidiaries"] is not None:
            if not isinstance(props["key_subsidiaries"], object):
                try:
                    # Attempt to convert
                    props["key_subsidiaries"] = object(props["key_subsidiaries"])
                except:
                    raise TypeError(f"Property key_subsidiaries must be of type object, got {type(props['key_subsidiaries']).__name__}")
    
        # Type check annual_reports (expected object)
        if "annual_reports" in props and props["annual_reports"] is not None:
            if not isinstance(props["annual_reports"], object):
                try:
                    # Attempt to convert
                    props["annual_reports"] = object(props["annual_reports"])
                except:
                    raise TypeError(f"Property annual_reports must be of type object, got {type(props['annual_reports']).__name__}")
    
        # Type check marketValueUSD1972 (expected int)
        if "marketValueUSD1972" in props and props["marketValueUSD1972"] is not None:
            if not isinstance(props["marketValueUSD1972"], int):
                try:
                    # Attempt to convert
                    props["marketValueUSD1972"] = int(props["marketValueUSD1972"])
                except:
                    raise TypeError(f"Property marketValueUSD1972 must be of type int, got {type(props['marketValueUSD1972']).__name__}")
    
        # Type check conglomerateStructure (expected bool)
        if "conglomerateStructure" in props and props["conglomerateStructure"] is not None:
            if not isinstance(props["conglomerateStructure"], bool):
                try:
                    # Attempt to convert
                    props["conglomerateStructure"] = bool(props["conglomerateStructure"])
                except:
                    raise TypeError(f"Property conglomerateStructure must be of type bool, got {type(props['conglomerateStructure']).__name__}")
    
        # Type check annualRevenue1972 (expected int)
        if "annualRevenue1972" in props and props["annualRevenue1972"] is not None:
            if not isinstance(props["annualRevenue1972"], int):
                try:
                    # Attempt to convert
                    props["annualRevenue1972"] = int(props["annualRevenue1972"])
                except:
                    raise TypeError(f"Property annualRevenue1972 must be of type int, got {type(props['annualRevenue1972']).__name__}")
    
        # Type check globalOperations (expected int)
        if "globalOperations" in props and props["globalOperations"] is not None:
            if not isinstance(props["globalOperations"], int):
                try:
                    # Attempt to convert
                    props["globalOperations"] = int(props["globalOperations"])
                except:
                    raise TypeError(f"Property globalOperations must be of type int, got {type(props['globalOperations']).__name__}")
    
        # Type check acquired_paramount (expected object)
        if "acquired_paramount" in props and props["acquired_paramount"] is not None:
            if not isinstance(props["acquired_paramount"], object):
                try:
                    # Attempt to convert
                    props["acquired_paramount"] = object(props["acquired_paramount"])
                except:
                    raise TypeError(f"Property acquired_paramount must be of type object, got {type(props['acquired_paramount']).__name__}")
    
        # Type check diversificationLevel (expected str)
        if "diversificationLevel" in props and props["diversificationLevel"] is not None:
            if not isinstance(props["diversificationLevel"], str):
                try:
                    # Attempt to convert
                    props["diversificationLevel"] = str(props["diversificationLevel"])
                except:
                    raise TypeError(f"Property diversificationLevel must be of type str, got {type(props['diversificationLevel']).__name__}")
    
        # Type check major_overages (expected object)
        if "major_overages" in props and props["major_overages"] is not None:
            if not isinstance(props["major_overages"], object):
                try:
                    # Attempt to convert
                    props["major_overages"] = object(props["major_overages"])
                except:
                    raise TypeError(f"Property major_overages must be of type object, got {type(props['major_overages']).__name__}")
    
        # Type check completion_bond (expected int)
        if "completion_bond" in props and props["completion_bond"] is not None:
            if not isinstance(props["completion_bond"], int):
                try:
                    # Attempt to convert
                    props["completion_bond"] = int(props["completion_bond"])
                except:
                    raise TypeError(f"Property completion_bond must be of type int, got {type(props['completion_bond']).__name__}")
    
        # Type check overage_amounts (expected object)
        if "overage_amounts" in props and props["overage_amounts"] is not None:
            if not isinstance(props["overage_amounts"], object):
                try:
                    # Attempt to convert
                    props["overage_amounts"] = object(props["overage_amounts"])
                except:
                    raise TypeError(f"Property overage_amounts must be of type object, got {type(props['overage_amounts']).__name__}")
    
        # Type check department_amounts (expected object)
        if "department_amounts" in props and props["department_amounts"] is not None:
            if not isinstance(props["department_amounts"], object):
                try:
                    # Attempt to convert
                    props["department_amounts"] = object(props["department_amounts"])
                except:
                    raise TypeError(f"Property department_amounts must be of type object, got {type(props['department_amounts']).__name__}")
    
        # Type check tracking_system (expected str)
        if "tracking_system" in props and props["tracking_system"] is not None:
            if not isinstance(props["tracking_system"], str):
                try:
                    # Attempt to convert
                    props["tracking_system"] = str(props["tracking_system"])
                except:
                    raise TypeError(f"Property tracking_system must be of type str, got {type(props['tracking_system']).__name__}")
    
        # Type check insurance_costs (expected int)
        if "insurance_costs" in props and props["insurance_costs"] is not None:
            if not isinstance(props["insurance_costs"], int):
                try:
                    # Attempt to convert
                    props["insurance_costs"] = int(props["insurance_costs"])
                except:
                    raise TypeError(f"Property insurance_costs must be of type int, got {type(props['insurance_costs']).__name__}")
    
        # Type check currency (expected str)
        if "currency" in props and props["currency"] is not None:
            if not isinstance(props["currency"], str):
                try:
                    # Attempt to convert
                    props["currency"] = str(props["currency"])
                except:
                    raise TypeError(f"Property currency must be of type str, got {type(props['currency']).__name__}")
    
        # Type check revisions (expected int)
        if "revisions" in props and props["revisions"] is not None:
            if not isinstance(props["revisions"], int):
                try:
                    # Attempt to convert
                    props["revisions"] = int(props["revisions"])
                except:
                    raise TypeError(f"Property revisions must be of type int, got {type(props['revisions']).__name__}")
    
        # Type check department_allocations (expected object)
        if "department_allocations" in props and props["department_allocations"] is not None:
            if not isinstance(props["department_allocations"], object):
                try:
                    # Attempt to convert
                    props["department_allocations"] = object(props["department_allocations"])
                except:
                    raise TypeError(f"Property department_allocations must be of type object, got {type(props['department_allocations']).__name__}")
    
        # Type check contingency_amount (expected int)
        if "contingency_amount" in props and props["contingency_amount"] is not None:
            if not isinstance(props["contingency_amount"], int):
                try:
                    # Attempt to convert
                    props["contingency_amount"] = int(props["contingency_amount"])
                except:
                    raise TypeError(f"Property contingency_amount must be of type int, got {type(props['contingency_amount']).__name__}")
    
        # Type check preservation_status (expected str)
        if "preservation_status" in props and props["preservation_status"] is not None:
            if not isinstance(props["preservation_status"], str):
                try:
                    # Attempt to convert
                    props["preservation_status"] = str(props["preservation_status"])
                except:
                    raise TypeError(f"Property preservation_status must be of type str, got {type(props['preservation_status']).__name__}")
    
        # Type check accounting_firm (expected str)
        if "accounting_firm" in props and props["accounting_firm"] is not None:
            if not isinstance(props["accounting_firm"], str):
                try:
                    # Attempt to convert
                    props["accounting_firm"] = str(props["accounting_firm"])
                except:
                    raise TypeError(f"Property accounting_firm must be of type str, got {type(props['accounting_firm']).__name__}")
    
        # Type check total_amount (expected int)
        if "total_amount" in props and props["total_amount"] is not None:
            if not isinstance(props["total_amount"], int):
                try:
                    # Attempt to convert
                    props["total_amount"] = int(props["total_amount"])
                except:
                    raise TypeError(f"Property total_amount must be of type int, got {type(props['total_amount']).__name__}")
    
        # Type check audit_status (expected str)
        if "audit_status" in props and props["audit_status"] is not None:
            if not isinstance(props["audit_status"], str):
                try:
                    # Attempt to convert
                    props["audit_status"] = str(props["audit_status"])
                except:
                    raise TypeError(f"Property audit_status must be of type str, got {type(props['audit_status']).__name__}")
    
        # Type check finalized (expected object)
        if "finalized" in props and props["finalized"] is not None:
            if not isinstance(props["finalized"], object):
                try:
                    # Attempt to convert
                    props["finalized"] = object(props["finalized"])
                except:
                    raise TypeError(f"Property finalized must be of type object, got {type(props['finalized']).__name__}")
    
        # Type check final_approval (expected object)
        if "final_approval" in props and props["final_approval"] is not None:
            if not isinstance(props["final_approval"], object):
                try:
                    # Attempt to convert
                    props["final_approval"] = object(props["final_approval"])
                except:
                    raise TypeError(f"Property final_approval must be of type object, got {type(props['final_approval']).__name__}")
    
        # Type check accounting_standard (expected str)
        if "accounting_standard" in props and props["accounting_standard"] is not None:
            if not isinstance(props["accounting_standard"], str):
                try:
                    # Attempt to convert
                    props["accounting_standard"] = str(props["accounting_standard"])
                except:
                    raise TypeError(f"Property accounting_standard must be of type str, got {type(props['accounting_standard']).__name__}")
    
        # Type check line_items (expected int)
        if "line_items" in props and props["line_items"] is not None:
            if not isinstance(props["line_items"], int):
                try:
                    # Attempt to convert
                    props["line_items"] = int(props["line_items"])
                except:
                    raise TypeError(f"Property line_items must be of type int, got {type(props['line_items']).__name__}")
    
        # Type check created (expected object)
        if "created" in props and props["created"] is not None:
            if not isinstance(props["created"], object):
                try:
                    # Attempt to convert
                    props["created"] = object(props["created"])
                except:
                    raise TypeError(f"Property created must be of type object, got {type(props['created']).__name__}")
    
        # Type check peak_theaters (expected int)
        if "peak_theaters" in props and props["peak_theaters"] is not None:
            if not isinstance(props["peak_theaters"], int):
                try:
                    # Attempt to convert
                    props["peak_theaters"] = int(props["peak_theaters"])
                except:
                    raise TypeError(f"Property peak_theaters must be of type int, got {type(props['peak_theaters']).__name__}")
    
        # Type check weeks_in_release (expected int)
        if "weeks_in_release" in props and props["weeks_in_release"] is not None:
            if not isinstance(props["weeks_in_release"], int):
                try:
                    # Attempt to convert
                    props["weeks_in_release"] = int(props["weeks_in_release"])
                except:
                    raise TypeError(f"Property weeks_in_release must be of type int, got {type(props['weeks_in_release']).__name__}")
    
        # Type check market_revenues (expected object)
        if "market_revenues" in props and props["market_revenues"] is not None:
            if not isinstance(props["market_revenues"], object):
                try:
                    # Attempt to convert
                    props["market_revenues"] = object(props["market_revenues"])
                except:
                    raise TypeError(f"Property market_revenues must be of type object, got {type(props['market_revenues']).__name__}")
    
        # Type check revenue_amounts (expected object)
        if "revenue_amounts" in props and props["revenue_amounts"] is not None:
            if not isinstance(props["revenue_amounts"], object):
                try:
                    # Attempt to convert
                    props["revenue_amounts"] = object(props["revenue_amounts"])
                except:
                    raise TypeError(f"Property revenue_amounts must be of type object, got {type(props['revenue_amounts']).__name__}")
    
        # Type check theatrical_runs (expected int)
        if "theatrical_runs" in props and props["theatrical_runs"] is not None:
            if not isinstance(props["theatrical_runs"], int):
                try:
                    # Attempt to convert
                    props["theatrical_runs"] = int(props["theatrical_runs"])
                except:
                    raise TypeError(f"Property theatrical_runs must be of type int, got {type(props['theatrical_runs']).__name__}")
    
        # Type check updated (expected object)
        if "updated" in props and props["updated"] is not None:
            if not isinstance(props["updated"], object):
                try:
                    # Attempt to convert
                    props["updated"] = object(props["updated"])
                except:
                    raise TypeError(f"Property updated must be of type object, got {type(props['updated']).__name__}")
    
        # Type check final_certification (expected object)
        if "final_certification" in props and props["final_certification"] is not None:
            if not isinstance(props["final_certification"], object):
                try:
                    # Attempt to convert
                    props["final_certification"] = object(props["final_certification"])
                except:
                    raise TypeError(f"Property final_certification must be of type object, got {type(props['final_certification']).__name__}")
    
        # Type check revenue_streams (expected object)
        if "revenue_streams" in props and props["revenue_streams"] is not None:
            if not isinstance(props["revenue_streams"], object):
                try:
                    # Attempt to convert
                    props["revenue_streams"] = object(props["revenue_streams"])
                except:
                    raise TypeError(f"Property revenue_streams must be of type object, got {type(props['revenue_streams']).__name__}")
    
        # Type check top_markets (expected object)
        if "top_markets" in props and props["top_markets"] is not None:
            if not isinstance(props["top_markets"], object):
                try:
                    # Attempt to convert
                    props["top_markets"] = object(props["top_markets"])
                except:
                    raise TypeError(f"Property top_markets must be of type object, got {type(props['top_markets']).__name__}")
    
        # Type check theatrical_windows (expected str)
        if "theatrical_windows" in props and props["theatrical_windows"] is not None:
            if not isinstance(props["theatrical_windows"], str):
                try:
                    # Attempt to convert
                    props["theatrical_windows"] = str(props["theatrical_windows"])
                except:
                    raise TypeError(f"Property theatrical_windows must be of type str, got {type(props['theatrical_windows']).__name__}")
    
        # Type check distribution_partners (expected int)
        if "distribution_partners" in props and props["distribution_partners"] is not None:
            if not isinstance(props["distribution_partners"], int):
                try:
                    # Attempt to convert
                    props["distribution_partners"] = int(props["distribution_partners"])
                except:
                    raise TypeError(f"Property distribution_partners must be of type int, got {type(props['distribution_partners']).__name__}")
    
        # Type check release_strategy (expected str)
        if "release_strategy" in props and props["release_strategy"] is not None:
            if not isinstance(props["release_strategy"], str):
                try:
                    # Attempt to convert
                    props["release_strategy"] = str(props["release_strategy"])
                except:
                    raise TypeError(f"Property release_strategy must be of type str, got {type(props['release_strategy']).__name__}")
    
        # Type check domestic_theaters_wide (expected int)
        if "domestic_theaters_wide" in props and props["domestic_theaters_wide"] is not None:
            if not isinstance(props["domestic_theaters_wide"], int):
                try:
                    # Attempt to convert
                    props["domestic_theaters_wide"] = int(props["domestic_theaters_wide"])
                except:
                    raise TypeError(f"Property domestic_theaters_wide must be of type int, got {type(props['domestic_theaters_wide']).__name__}")
    
        # Type check key_markets (expected object)
        if "key_markets" in props and props["key_markets"] is not None:
            if not isinstance(props["key_markets"], object):
                try:
                    # Attempt to convert
                    props["key_markets"] = object(props["key_markets"])
                except:
                    raise TypeError(f"Property key_markets must be of type object, got {type(props['key_markets']).__name__}")
    
        # Type check release_dates (expected object)
        if "release_dates" in props and props["release_dates"] is not None:
            if not isinstance(props["release_dates"], object):
                try:
                    # Attempt to convert
                    props["release_dates"] = object(props["release_dates"])
                except:
                    raise TypeError(f"Property release_dates must be of type object, got {type(props['release_dates']).__name__}")
    
        # Type check censorship_issues (expected object)
        if "censorship_issues" in props and props["censorship_issues"] is not None:
            if not isinstance(props["censorship_issues"], object):
                try:
                    # Attempt to convert
                    props["censorship_issues"] = object(props["censorship_issues"])
                except:
                    raise TypeError(f"Property censorship_issues must be of type object, got {type(props['censorship_issues']).__name__}")
    
        # Type check territories (expected int)
        if "territories" in props and props["territories"] is not None:
            if not isinstance(props["territories"], int):
                try:
                    # Attempt to convert
                    props["territories"] = int(props["territories"])
                except:
                    raise TypeError(f"Property territories must be of type int, got {type(props['territories']).__name__}")
    
        # Type check implemented (expected object)
        if "implemented" in props and props["implemented"] is not None:
            if not isinstance(props["implemented"], object):
                try:
                    # Attempt to convert
                    props["implemented"] = object(props["implemented"])
                except:
                    raise TypeError(f"Property implemented must be of type object, got {type(props['implemented']).__name__}")
    
        # Type check subtitled_versions (expected int)
        if "subtitled_versions" in props and props["subtitled_versions"] is not None:
            if not isinstance(props["subtitled_versions"], int):
                try:
                    # Attempt to convert
                    props["subtitled_versions"] = int(props["subtitled_versions"])
                except:
                    raise TypeError(f"Property subtitled_versions must be of type int, got {type(props['subtitled_versions']).__name__}")
    
        # Type check marketing_territories (expected int)
        if "marketing_territories" in props and props["marketing_territories"] is not None:
            if not isinstance(props["marketing_territories"], int):
                try:
                    # Attempt to convert
                    props["marketing_territories"] = int(props["marketing_territories"])
                except:
                    raise TypeError(f"Property marketing_territories must be of type int, got {type(props['marketing_territories']).__name__}")
    
        # Type check print_count_domestic (expected int)
        if "print_count_domestic" in props and props["print_count_domestic"] is not None:
            if not isinstance(props["print_count_domestic"], int):
                try:
                    # Attempt to convert
                    props["print_count_domestic"] = int(props["print_count_domestic"])
                except:
                    raise TypeError(f"Property print_count_domestic must be of type int, got {type(props['print_count_domestic']).__name__}")
    
        # Type check print_count_international (expected int)
        if "print_count_international" in props and props["print_count_international"] is not None:
            if not isinstance(props["print_count_international"], int):
                try:
                    # Attempt to convert
                    props["print_count_international"] = int(props["print_count_international"])
                except:
                    raise TypeError(f"Property print_count_international must be of type int, got {type(props['print_count_international']).__name__}")
    
        # Type check dubbed_versions (expected int)
        if "dubbed_versions" in props and props["dubbed_versions"] is not None:
            if not isinstance(props["dubbed_versions"], int):
                try:
                    # Attempt to convert
                    props["dubbed_versions"] = int(props["dubbed_versions"])
                except:
                    raise TypeError(f"Property dubbed_versions must be of type int, got {type(props['dubbed_versions']).__name__}")
    
        # Type check language_versions (expected int)
        if "language_versions" in props and props["language_versions"] is not None:
            if not isinstance(props["language_versions"], int):
                try:
                    # Attempt to convert
                    props["language_versions"] = int(props["language_versions"])
                except:
                    raise TypeError(f"Property language_versions must be of type int, got {type(props['language_versions']).__name__}")
    
        # Type check domestic_theaters_initial (expected int)
        if "domestic_theaters_initial" in props and props["domestic_theaters_initial"] is not None:
            if not isinstance(props["domestic_theaters_initial"], int):
                try:
                    # Attempt to convert
                    props["domestic_theaters_initial"] = int(props["domestic_theaters_initial"])
                except:
                    raise TypeError(f"Property domestic_theaters_initial must be of type int, got {type(props['domestic_theaters_initial']).__name__}")
    
        # Type check international_territories (expected int)
        if "international_territories" in props and props["international_territories"] is not None:
            if not isinstance(props["international_territories"], int):
                try:
                    # Attempt to convert
                    props["international_territories"] = int(props["international_territories"])
                except:
                    raise TypeError(f"Property international_territories must be of type int, got {type(props['international_territories']).__name__}")
    
        # Type check tv_networks (expected object)
        if "tv_networks" in props and props["tv_networks"] is not None:
            if not isinstance(props["tv_networks"], object):
                try:
                    # Attempt to convert
                    props["tv_networks"] = object(props["tv_networks"])
                except:
                    raise TypeError(f"Property tv_networks must be of type object, got {type(props['tv_networks']).__name__}")
    
        # Type check key_visuals (expected object)
        if "key_visuals" in props and props["key_visuals"] is not None:
            if not isinstance(props["key_visuals"], object):
                try:
                    # Attempt to convert
                    props["key_visuals"] = object(props["key_visuals"])
                except:
                    raise TypeError(f"Property key_visuals must be of type object, got {type(props['key_visuals']).__name__}")
    
        # Type check campaign_phases (expected object)
        if "campaign_phases" in props and props["campaign_phases"] is not None:
            if not isinstance(props["campaign_phases"], object):
                try:
                    # Attempt to convert
                    props["campaign_phases"] = object(props["campaign_phases"])
                except:
                    raise TypeError(f"Property campaign_phases must be of type object, got {type(props['campaign_phases']).__name__}")
    
        # Type check channel_allocation (expected object)
        if "channel_allocation" in props and props["channel_allocation"] is not None:
            if not isinstance(props["channel_allocation"], object):
                try:
                    # Attempt to convert
                    props["channel_allocation"] = object(props["channel_allocation"])
                except:
                    raise TypeError(f"Property channel_allocation must be of type object, got {type(props['channel_allocation']).__name__}")
    
        # Type check key_publications (expected object)
        if "key_publications" in props and props["key_publications"] is not None:
            if not isinstance(props["key_publications"], object):
                try:
                    # Attempt to convert
                    props["key_publications"] = object(props["key_publications"])
                except:
                    raise TypeError(f"Property key_publications must be of type object, got {type(props['key_publications']).__name__}")
    
        # Type check creative_agencies (expected int)
        if "creative_agencies" in props and props["creative_agencies"] is not None:
            if not isinstance(props["creative_agencies"], int):
                try:
                    # Attempt to convert
                    props["creative_agencies"] = int(props["creative_agencies"])
                except:
                    raise TypeError(f"Property creative_agencies must be of type int, got {type(props['creative_agencies']).__name__}")
    
        # Type check media_buyers (expected int)
        if "media_buyers" in props and props["media_buyers"] is not None:
            if not isinstance(props["media_buyers"], int):
                try:
                    # Attempt to convert
                    props["media_buyers"] = int(props["media_buyers"])
                except:
                    raise TypeError(f"Property media_buyers must be of type int, got {type(props['media_buyers']).__name__}")
    
        # Type check publicists (expected int)
        if "publicists" in props and props["publicists"] is not None:
            if not isinstance(props["publicists"], int):
                try:
                    # Attempt to convert
                    props["publicists"] = int(props["publicists"])
                except:
                    raise TypeError(f"Property publicists must be of type int, got {type(props['publicists']).__name__}")
    
        # Type check marketing_channels (expected object)
        if "marketing_channels" in props and props["marketing_channels"] is not None:
            if not isinstance(props["marketing_channels"], object):
                try:
                    # Attempt to convert
                    props["marketing_channels"] = object(props["marketing_channels"])
                except:
                    raise TypeError(f"Property marketing_channels must be of type object, got {type(props['marketing_channels']).__name__}")
    
        # Type check markets (expected str)
        if "markets" in props and props["markets"] is not None:
            if not isinstance(props["markets"], str):
                try:
                    # Attempt to convert
                    props["markets"] = str(props["markets"])
                except:
                    raise TypeError(f"Property markets must be of type str, got {type(props['markets']).__name__}")
    
        # Type check launched (expected object)
        if "launched" in props and props["launched"] is not None:
            if not isinstance(props["launched"], object):
                try:
                    # Attempt to convert
                    props["launched"] = object(props["launched"])
                except:
                    raise TypeError(f"Property launched must be of type object, got {type(props['launched']).__name__}")
    
        # Type check taglines (expected int)
        if "taglines" in props and props["taglines"] is not None:
            if not isinstance(props["taglines"], int):
                try:
                    # Attempt to convert
                    props["taglines"] = int(props["taglines"])
                except:
                    raise TypeError(f"Property taglines must be of type int, got {type(props['taglines']).__name__}")
    
        # Type check press_events (expected int)
        if "press_events" in props and props["press_events"] is not None:
            if not isinstance(props["press_events"], int):
                try:
                    # Attempt to convert
                    props["press_events"] = int(props["press_events"])
                except:
                    raise TypeError(f"Property press_events must be of type int, got {type(props['press_events']).__name__}")
    
        # Type check premieres (expected int)
        if "premieres" in props and props["premieres"] is not None:
            if not isinstance(props["premieres"], int):
                try:
                    # Attempt to convert
                    props["premieres"] = int(props["premieres"])
                except:
                    raise TypeError(f"Property premieres must be of type int, got {type(props['premieres']).__name__}")
    
        # Type check awards_campaign (expected bool)
        if "awards_campaign" in props and props["awards_campaign"] is not None:
            if not isinstance(props["awards_campaign"], bool):
                try:
                    # Attempt to convert
                    props["awards_campaign"] = bool(props["awards_campaign"])
                except:
                    raise TypeError(f"Property awards_campaign must be of type bool, got {type(props['awards_campaign']).__name__}")
    
        # Type check total_budget (expected int)
        if "total_budget" in props and props["total_budget"] is not None:
            if not isinstance(props["total_budget"], int):
                try:
                    # Attempt to convert
                    props["total_budget"] = int(props["total_budget"])
                except:
                    raise TypeError(f"Property total_budget must be of type int, got {type(props['total_budget']).__name__}")
    
        # Type check target_demographics (expected str)
        if "target_demographics" in props and props["target_demographics"] is not None:
            if not isinstance(props["target_demographics"], str):
                try:
                    # Attempt to convert
                    props["target_demographics"] = str(props["target_demographics"])
                except:
                    raise TypeError(f"Property target_demographics must be of type str, got {type(props['target_demographics']).__name__}")
    
        # Type check recoupment_priority (expected object)
        if "recoupment_priority" in props and props["recoupment_priority"] is not None:
            if not isinstance(props["recoupment_priority"], object):
                try:
                    # Attempt to convert
                    props["recoupment_priority"] = object(props["recoupment_priority"])
                except:
                    raise TypeError(f"Property recoupment_priority must be of type object, got {type(props['recoupment_priority']).__name__}")
    
        # Type check risk_mitigation (expected str)
        if "risk_mitigation" in props and props["risk_mitigation"] is not None:
            if not isinstance(props["risk_mitigation"], str):
                try:
                    # Attempt to convert
                    props["risk_mitigation"] = str(props["risk_mitigation"])
                except:
                    raise TypeError(f"Property risk_mitigation must be of type str, got {type(props['risk_mitigation']).__name__}")
    
        # Type check financial_triggers (expected object)
        if "financial_triggers" in props and props["financial_triggers"] is not None:
            if not isinstance(props["financial_triggers"], object):
                try:
                    # Attempt to convert
                    props["financial_triggers"] = object(props["financial_triggers"])
                except:
                    raise TypeError(f"Property financial_triggers must be of type object, got {type(props['financial_triggers']).__name__}")
    
        # Type check trigger_payments (expected object)
        if "trigger_payments" in props and props["trigger_payments"] is not None:
            if not isinstance(props["trigger_payments"], object):
                try:
                    # Attempt to convert
                    props["trigger_payments"] = object(props["trigger_payments"])
                except:
                    raise TypeError(f"Property trigger_payments must be of type object, got {type(props['trigger_payments']).__name__}")
    
        # Type check funding_sources (expected object)
        if "funding_sources" in props and props["funding_sources"] is not None:
            if not isinstance(props["funding_sources"], object):
                try:
                    # Attempt to convert
                    props["funding_sources"] = object(props["funding_sources"])
                except:
                    raise TypeError(f"Property funding_sources must be of type object, got {type(props['funding_sources']).__name__}")
    
        # Type check funding_amounts (expected object)
        if "funding_amounts" in props and props["funding_amounts"] is not None:
            if not isinstance(props["funding_amounts"], object):
                try:
                    # Attempt to convert
                    props["funding_amounts"] = object(props["funding_amounts"])
                except:
                    raise TypeError(f"Property funding_amounts must be of type object, got {type(props['funding_amounts']).__name__}")
    
        # Type check legal_counsel (expected str)
        if "legal_counsel" in props and props["legal_counsel"] is not None:
            if not isinstance(props["legal_counsel"], str):
                try:
                    # Attempt to convert
                    props["legal_counsel"] = str(props["legal_counsel"])
                except:
                    raise TypeError(f"Property legal_counsel must be of type str, got {type(props['legal_counsel']).__name__}")
    
        # Type check banking_partner (expected str)
        if "banking_partner" in props and props["banking_partner"] is not None:
            if not isinstance(props["banking_partner"], str):
                try:
                    # Attempt to convert
                    props["banking_partner"] = str(props["banking_partner"])
                except:
                    raise TypeError(f"Property banking_partner must be of type str, got {type(props['banking_partner']).__name__}")
    
        # Type check tax_structures (expected str)
        if "tax_structures" in props and props["tax_structures"] is not None:
            if not isinstance(props["tax_structures"], str):
                try:
                    # Attempt to convert
                    props["tax_structures"] = str(props["tax_structures"])
                except:
                    raise TypeError(f"Property tax_structures must be of type str, got {type(props['tax_structures']).__name__}")
    
        # Type check secondary_investors (expected str)
        if "secondary_investors" in props and props["secondary_investors"] is not None:
            if not isinstance(props["secondary_investors"], str):
                try:
                    # Attempt to convert
                    props["secondary_investors"] = str(props["secondary_investors"])
                except:
                    raise TypeError(f"Property secondary_investors must be of type str, got {type(props['secondary_investors']).__name__}")
    
        # Type check primary_investor (expected str)
        if "primary_investor" in props and props["primary_investor"] is not None:
            if not isinstance(props["primary_investor"], str):
                try:
                    # Attempt to convert
                    props["primary_investor"] = str(props["primary_investor"])
                except:
                    raise TypeError(f"Property primary_investor must be of type str, got {type(props['primary_investor']).__name__}")
    
        # Type check structure_type (expected str)
        if "structure_type" in props and props["structure_type"] is not None:
            if not isinstance(props["structure_type"], str):
                try:
                    # Attempt to convert
                    props["structure_type"] = str(props["structure_type"])
                except:
                    raise TypeError(f"Property structure_type must be of type str, got {type(props['structure_type']).__name__}")
    
        # Type check gap_financing (expected str)
        if "gap_financing" in props and props["gap_financing"] is not None:
            if not isinstance(props["gap_financing"], str):
                try:
                    # Attempt to convert
                    props["gap_financing"] = str(props["gap_financing"])
                except:
                    raise TypeError(f"Property gap_financing must be of type str, got {type(props['gap_financing']).__name__}")
    
        # Type check executed (expected object)
        if "executed" in props and props["executed"] is not None:
            if not isinstance(props["executed"], object):
                try:
                    # Attempt to convert
                    props["executed"] = object(props["executed"])
                except:
                    raise TypeError(f"Property executed must be of type object, got {type(props['executed']).__name__}")
    
        # Type check completion_guarantor (expected str)
        if "completion_guarantor" in props and props["completion_guarantor"] is not None:
            if not isinstance(props["completion_guarantor"], str):
                try:
                    # Attempt to convert
                    props["completion_guarantor"] = str(props["completion_guarantor"])
                except:
                    raise TypeError(f"Property completion_guarantor must be of type str, got {type(props['completion_guarantor']).__name__}")
    
        # Type check template_sources (expected object)
        if "template_sources" in props and props["template_sources"] is not None:
            if not isinstance(props["template_sources"], object):
                try:
                    # Attempt to convert
                    props["template_sources"] = object(props["template_sources"])
                except:
                    raise TypeError(f"Property template_sources must be of type object, got {type(props['template_sources']).__name__}")
    
        # Type check contract_counts (expected object)
        if "contract_counts" in props and props["contract_counts"] is not None:
            if not isinstance(props["contract_counts"], object):
                try:
                    # Attempt to convert
                    props["contract_counts"] = object(props["contract_counts"])
                except:
                    raise TypeError(f"Property contract_counts must be of type object, got {type(props['contract_counts']).__name__}")
    
        # Type check legal_disputes (expected int)
        if "legal_disputes" in props and props["legal_disputes"] is not None:
            if not isinstance(props["legal_disputes"], int):
                try:
                    # Attempt to convert
                    props["legal_disputes"] = int(props["legal_disputes"])
                except:
                    raise TypeError(f"Property legal_disputes must be of type int, got {type(props['legal_disputes']).__name__}")
    
        # Type check dispute_resolutions (expected object)
        if "dispute_resolutions" in props and props["dispute_resolutions"] is not None:
            if not isinstance(props["dispute_resolutions"], object):
                try:
                    # Attempt to convert
                    props["dispute_resolutions"] = object(props["dispute_resolutions"])
                except:
                    raise TypeError(f"Property dispute_resolutions must be of type object, got {type(props['dispute_resolutions']).__name__}")
    
        # Type check governing_law (expected str)
        if "governing_law" in props and props["governing_law"] is not None:
            if not isinstance(props["governing_law"], str):
                try:
                    # Attempt to convert
                    props["governing_law"] = str(props["governing_law"])
                except:
                    raise TypeError(f"Property governing_law must be of type str, got {type(props['governing_law']).__name__}")
    
        # Type check contract_types (expected object)
        if "contract_types" in props and props["contract_types"] is not None:
            if not isinstance(props["contract_types"], object):
                try:
                    # Attempt to convert
                    props["contract_types"] = object(props["contract_types"])
                except:
                    raise TypeError(f"Property contract_types must be of type object, got {type(props['contract_types']).__name__}")
    
        # Type check key_signatories (expected object)
        if "key_signatories" in props and props["key_signatories"] is not None:
            if not isinstance(props["key_signatories"], object):
                try:
                    # Attempt to convert
                    props["key_signatories"] = object(props["key_signatories"])
                except:
                    raise TypeError(f"Property key_signatories must be of type object, got {type(props['key_signatories']).__name__}")
    
        # Type check legal_jurisdictions (expected int)
        if "legal_jurisdictions" in props and props["legal_jurisdictions"] is not None:
            if not isinstance(props["legal_jurisdictions"], int):
                try:
                    # Attempt to convert
                    props["legal_jurisdictions"] = int(props["legal_jurisdictions"])
                except:
                    raise TypeError(f"Property legal_jurisdictions must be of type int, got {type(props['legal_jurisdictions']).__name__}")
    
        # Type check pages_total (expected int)
        if "pages_total" in props and props["pages_total"] is not None:
            if not isinstance(props["pages_total"], int):
                try:
                    # Attempt to convert
                    props["pages_total"] = int(props["pages_total"])
                except:
                    raise TypeError(f"Property pages_total must be of type int, got {type(props['pages_total']).__name__}")
    
        # Type check amendments (expected int)
        if "amendments" in props and props["amendments"] is not None:
            if not isinstance(props["amendments"], int):
                try:
                    # Attempt to convert
                    props["amendments"] = int(props["amendments"])
                except:
                    raise TypeError(f"Property amendments must be of type int, got {type(props['amendments']).__name__}")
    
        # Type check confidentiality_level (expected str)
        if "confidentiality_level" in props and props["confidentiality_level"] is not None:
            if not isinstance(props["confidentiality_level"], str):
                try:
                    # Attempt to convert
                    props["confidentiality_level"] = str(props["confidentiality_level"])
                except:
                    raise TypeError(f"Property confidentiality_level must be of type str, got {type(props['confidentiality_level']).__name__}")
    
        # Type check storage_location (expected str)
        if "storage_location" in props and props["storage_location"] is not None:
            if not isinstance(props["storage_location"], str):
                try:
                    # Attempt to convert
                    props["storage_location"] = str(props["storage_location"])
                except:
                    raise TypeError(f"Property storage_location must be of type str, got {type(props['storage_location']).__name__}")
    
        # Type check document_count (expected int)
        if "document_count" in props and props["document_count"] is not None:
            if not isinstance(props["document_count"], int):
                try:
                    # Attempt to convert
                    props["document_count"] = int(props["document_count"])
                except:
                    raise TypeError(f"Property document_count must be of type int, got {type(props['document_count']).__name__}")
    
        # Type check dispute_mechanisms (expected str)
        if "dispute_mechanisms" in props and props["dispute_mechanisms"] is not None:
            if not isinstance(props["dispute_mechanisms"], str):
                try:
                    # Attempt to convert
                    props["dispute_mechanisms"] = str(props["dispute_mechanisms"])
                except:
                    raise TypeError(f"Property dispute_mechanisms must be of type str, got {type(props['dispute_mechanisms']).__name__}")
    
        # Type check signatories (expected int)
        if "signatories" in props and props["signatories"] is not None:
            if not isinstance(props["signatories"], int):
                try:
                    # Attempt to convert
                    props["signatories"] = int(props["signatories"])
                except:
                    raise TypeError(f"Property signatories must be of type int, got {type(props['signatories']).__name__}")
    
        # Type check fleet_counts (expected object)
        if "fleet_counts" in props and props["fleet_counts"] is not None:
            if not isinstance(props["fleet_counts"], object):
                try:
                    # Attempt to convert
                    props["fleet_counts"] = object(props["fleet_counts"])
                except:
                    raise TypeError(f"Property fleet_counts must be of type object, got {type(props['fleet_counts']).__name__}")
    
        # Type check location_shooting_days (expected object)
        if "location_shooting_days" in props and props["location_shooting_days"] is not None:
            if not isinstance(props["location_shooting_days"], object):
                try:
                    # Attempt to convert
                    props["location_shooting_days"] = object(props["location_shooting_days"])
                except:
                    raise TypeError(f"Property location_shooting_days must be of type object, got {type(props['location_shooting_days']).__name__}")
    
        # Type check location_days (expected object)
        if "location_days" in props and props["location_days"] is not None:
            if not isinstance(props["location_days"], object):
                try:
                    # Attempt to convert
                    props["location_days"] = object(props["location_days"])
                except:
                    raise TypeError(f"Property location_days must be of type object, got {type(props['location_days']).__name__}")
    
        # Type check soundstages (expected int)
        if "soundstages" in props and props["soundstages"] is not None:
            if not isinstance(props["soundstages"], int):
                try:
                    # Attempt to convert
                    props["soundstages"] = int(props["soundstages"])
                except:
                    raise TypeError(f"Property soundstages must be of type int, got {type(props['soundstages']).__name__}")
    
        # Type check primary_locations (expected object)
        if "primary_locations" in props and props["primary_locations"] is not None:
            if not isinstance(props["primary_locations"], object):
                try:
                    # Attempt to convert
                    props["primary_locations"] = object(props["primary_locations"])
                except:
                    raise TypeError(f"Property primary_locations must be of type object, got {type(props['primary_locations']).__name__}")
    
        # Type check location_types (expected object)
        if "location_types" in props and props["location_types"] is not None:
            if not isinstance(props["location_types"], object):
                try:
                    # Attempt to convert
                    props["location_types"] = object(props["location_types"])
                except:
                    raise TypeError(f"Property location_types must be of type object, got {type(props['location_types']).__name__}")
    
        # Type check transportation_fleet (expected object)
        if "transportation_fleet" in props and props["transportation_fleet"] is not None:
            if not isinstance(props["transportation_fleet"], object):
                try:
                    # Attempt to convert
                    props["transportation_fleet"] = object(props["transportation_fleet"])
                except:
                    raise TypeError(f"Property transportation_fleet must be of type object, got {type(props['transportation_fleet']).__name__}")
    
        # Type check equipment_vendors (expected int)
        if "equipment_vendors" in props and props["equipment_vendors"] is not None:
            if not isinstance(props["equipment_vendors"], int):
                try:
                    # Attempt to convert
                    props["equipment_vendors"] = int(props["equipment_vendors"])
                except:
                    raise TypeError(f"Property equipment_vendors must be of type int, got {type(props['equipment_vendors']).__name__}")
    
        # Type check locations (expected int)
        if "locations" in props and props["locations"] is not None:
            if not isinstance(props["locations"], int):
                try:
                    # Attempt to convert
                    props["locations"] = int(props["locations"])
                except:
                    raise TypeError(f"Property locations must be of type int, got {type(props['locations']).__name__}")
    
        # Type check catering_services (expected int)
        if "catering_services" in props and props["catering_services"] is not None:
            if not isinstance(props["catering_services"], int):
                try:
                    # Attempt to convert
                    props["catering_services"] = int(props["catering_services"])
                except:
                    raise TypeError(f"Property catering_services must be of type int, got {type(props['catering_services']).__name__}")
    
        # Type check total_shooting_days (expected int)
        if "total_shooting_days" in props and props["total_shooting_days"] is not None:
            if not isinstance(props["total_shooting_days"], int):
                try:
                    # Attempt to convert
                    props["total_shooting_days"] = int(props["total_shooting_days"])
                except:
                    raise TypeError(f"Property total_shooting_days must be of type int, got {type(props['total_shooting_days']).__name__}")
    
        # Type check crew_size (expected int)
        if "crew_size" in props and props["crew_size"] is not None:
            if not isinstance(props["crew_size"], int):
                try:
                    # Attempt to convert
                    props["crew_size"] = int(props["crew_size"])
                except:
                    raise TypeError(f"Property crew_size must be of type int, got {type(props['crew_size']).__name__}")
    
        # Type check hotel_room_nights (expected int)
        if "hotel_room_nights" in props and props["hotel_room_nights"] is not None:
            if not isinstance(props["hotel_room_nights"], int):
                try:
                    # Attempt to convert
                    props["hotel_room_nights"] = int(props["hotel_room_nights"])
                except:
                    raise TypeError(f"Property hotel_room_nights must be of type int, got {type(props['hotel_room_nights']).__name__}")
    
        # Type check extras_total (expected int)
        if "extras_total" in props and props["extras_total"] is not None:
            if not isinstance(props["extras_total"], int):
                try:
                    # Attempt to convert
                    props["extras_total"] = int(props["extras_total"])
                except:
                    raise TypeError(f"Property extras_total must be of type int, got {type(props['extras_total']).__name__}")
    
        # Type check cast_members (expected int)
        if "cast_members" in props and props["cast_members"] is not None:
            if not isinstance(props["cast_members"], int):
                try:
                    # Attempt to convert
                    props["cast_members"] = int(props["cast_members"])
                except:
                    raise TypeError(f"Property cast_members must be of type int, got {type(props['cast_members']).__name__}")
    
        # Type check vehicles_used (expected int)
        if "vehicles_used" in props and props["vehicles_used"] is not None:
            if not isinstance(props["vehicles_used"], int):
                try:
                    # Attempt to convert
                    props["vehicles_used"] = int(props["vehicles_used"])
                except:
                    raise TypeError(f"Property vehicles_used must be of type int, got {type(props['vehicles_used']).__name__}")
    
        # Type check international_awards (expected int)
        if "international_awards" in props and props["international_awards"] is not None:
            if not isinstance(props["international_awards"], int):
                try:
                    # Attempt to convert
                    props["international_awards"] = int(props["international_awards"])
                except:
                    raise TypeError(f"Property international_awards must be of type int, got {type(props['international_awards']).__name__}")
    
        # Type check subtitled_markets (expected int)
        if "subtitled_markets" in props and props["subtitled_markets"] is not None:
            if not isinstance(props["subtitled_markets"], int):
                try:
                    # Attempt to convert
                    props["subtitled_markets"] = int(props["subtitled_markets"])
                except:
                    raise TypeError(f"Property subtitled_markets must be of type int, got {type(props['subtitled_markets']).__name__}")
    
        # Type check activated (expected object)
        if "activated" in props and props["activated"] is not None:
            if not isinstance(props["activated"], object):
                try:
                    # Attempt to convert
                    props["activated"] = object(props["activated"])
                except:
                    raise TypeError(f"Property activated must be of type object, got {type(props['activated']).__name__}")
    
        # Type check market_distributors (expected object)
        if "market_distributors" in props and props["market_distributors"] is not None:
            if not isinstance(props["market_distributors"], object):
                try:
                    # Attempt to convert
                    props["market_distributors"] = object(props["market_distributors"])
                except:
                    raise TypeError(f"Property market_distributors must be of type object, got {type(props['market_distributors']).__name__}")
    
        # Type check censorship_countries (expected object)
        if "censorship_countries" in props and props["censorship_countries"] is not None:
            if not isinstance(props["censorship_countries"], object):
                try:
                    # Attempt to convert
                    props["censorship_countries"] = object(props["censorship_countries"])
                except:
                    raise TypeError(f"Property censorship_countries must be of type object, got {type(props['censorship_countries']).__name__}")
    
        # Type check marketing_localization (expected int)
        if "marketing_localization" in props and props["marketing_localization"] is not None:
            if not isinstance(props["marketing_localization"], int):
                try:
                    # Attempt to convert
                    props["marketing_localization"] = int(props["marketing_localization"])
                except:
                    raise TypeError(f"Property marketing_localization must be of type int, got {type(props['marketing_localization']).__name__}")
    
        # Type check box_office_reporting (expected str)
        if "box_office_reporting" in props and props["box_office_reporting"] is not None:
            if not isinstance(props["box_office_reporting"], str):
                try:
                    # Attempt to convert
                    props["box_office_reporting"] = str(props["box_office_reporting"])
                except:
                    raise TypeError(f"Property box_office_reporting must be of type str, got {type(props['box_office_reporting']).__name__}")
    
        # Type check material_delivery_date (expected object)
        if "material_delivery_date" in props and props["material_delivery_date"] is not None:
            if not isinstance(props["material_delivery_date"], object):
                try:
                    # Attempt to convert
                    props["material_delivery_date"] = object(props["material_delivery_date"])
                except:
                    raise TypeError(f"Property material_delivery_date must be of type object, got {type(props['material_delivery_date']).__name__}")
    
        # Type check censorship_challenges (expected int)
        if "censorship_challenges" in props and props["censorship_challenges"] is not None:
            if not isinstance(props["censorship_challenges"], int):
                try:
                    # Attempt to convert
                    props["censorship_challenges"] = int(props["censorship_challenges"])
                except:
                    raise TypeError(f"Property censorship_challenges must be of type int, got {type(props['censorship_challenges']).__name__}")
    
        # Type check international_prints (expected int)
        if "international_prints" in props and props["international_prints"] is not None:
            if not isinstance(props["international_prints"], int):
                try:
                    # Attempt to convert
                    props["international_prints"] = int(props["international_prints"])
                except:
                    raise TypeError(f"Property international_prints must be of type int, got {type(props['international_prints']).__name__}")
    
        # Type check dubbed_markets (expected int)
        if "dubbed_markets" in props and props["dubbed_markets"] is not None:
            if not isinstance(props["dubbed_markets"], int):
                try:
                    # Attempt to convert
                    props["dubbed_markets"] = int(props["dubbed_markets"])
                except:
                    raise TypeError(f"Property dubbed_markets must be of type int, got {type(props['dubbed_markets']).__name__}")
    
        # Type check excluded_risks (expected object)
        if "excluded_risks" in props and props["excluded_risks"] is not None:
            if not isinstance(props["excluded_risks"], object):
                try:
                    # Attempt to convert
                    props["excluded_risks"] = object(props["excluded_risks"])
                except:
                    raise TypeError(f"Property excluded_risks must be of type object, got {type(props['excluded_risks']).__name__}")
    
        # Type check policy_extensions (expected int)
        if "policy_extensions" in props and props["policy_extensions"] is not None:
            if not isinstance(props["policy_extensions"], int):
                try:
                    # Attempt to convert
                    props["policy_extensions"] = int(props["policy_extensions"])
                except:
                    raise TypeError(f"Property policy_extensions must be of type int, got {type(props['policy_extensions']).__name__}")
    
        # Type check special_endorsements (expected object)
        if "special_endorsements" in props and props["special_endorsements"] is not None:
            if not isinstance(props["special_endorsements"], object):
                try:
                    # Attempt to convert
                    props["special_endorsements"] = object(props["special_endorsements"])
                except:
                    raise TypeError(f"Property special_endorsements must be of type object, got {type(props['special_endorsements']).__name__}")
    
        # Type check premium_allocations (expected object)
        if "premium_allocations" in props and props["premium_allocations"] is not None:
            if not isinstance(props["premium_allocations"], object):
                try:
                    # Attempt to convert
                    props["premium_allocations"] = object(props["premium_allocations"])
                except:
                    raise TypeError(f"Property premium_allocations must be of type object, got {type(props['premium_allocations']).__name__}")
    
        # Type check coverage_types (expected object)
        if "coverage_types" in props and props["coverage_types"] is not None:
            if not isinstance(props["coverage_types"], object):
                try:
                    # Attempt to convert
                    props["coverage_types"] = object(props["coverage_types"])
                except:
                    raise TypeError(f"Property coverage_types must be of type object, got {type(props['coverage_types']).__name__}")
    
        # Type check coverage_limits (expected object)
        if "coverage_limits" in props and props["coverage_limits"] is not None:
            if not isinstance(props["coverage_limits"], object):
                try:
                    # Attempt to convert
                    props["coverage_limits"] = object(props["coverage_limits"])
                except:
                    raise TypeError(f"Property coverage_limits must be of type object, got {type(props['coverage_limits']).__name__}")
    
        # Type check underwriter (expected str)
        if "underwriter" in props and props["underwriter"] is not None:
            if not isinstance(props["underwriter"], str):
                try:
                    # Attempt to convert
                    props["underwriter"] = str(props["underwriter"])
                except:
                    raise TypeError(f"Property underwriter must be of type str, got {type(props['underwriter']).__name__}")
    
        # Type check premium_total (expected int)
        if "premium_total" in props and props["premium_total"] is not None:
            if not isinstance(props["premium_total"], int):
                try:
                    # Attempt to convert
                    props["premium_total"] = int(props["premium_total"])
                except:
                    raise TypeError(f"Property premium_total must be of type int, got {type(props['premium_total']).__name__}")
    
        # Type check expiration (expected object)
        if "expiration" in props and props["expiration"] is not None:
            if not isinstance(props["expiration"], object):
                try:
                    # Attempt to convert
                    props["expiration"] = object(props["expiration"])
                except:
                    raise TypeError(f"Property expiration must be of type object, got {type(props['expiration']).__name__}")
    
        # Type check issued (expected object)
        if "issued" in props and props["issued"] is not None:
            if not isinstance(props["issued"], object):
                try:
                    # Attempt to convert
                    props["issued"] = object(props["issued"])
                except:
                    raise TypeError(f"Property issued must be of type object, got {type(props['issued']).__name__}")
    
        # Type check claims_paid (expected int)
        if "claims_paid" in props and props["claims_paid"] is not None:
            if not isinstance(props["claims_paid"], int):
                try:
                    # Attempt to convert
                    props["claims_paid"] = int(props["claims_paid"])
                except:
                    raise TypeError(f"Property claims_paid must be of type int, got {type(props['claims_paid']).__name__}")
    
        # Type check policy_number (expected str)
        if "policy_number" in props and props["policy_number"] is not None:
            if not isinstance(props["policy_number"], str):
                try:
                    # Attempt to convert
                    props["policy_number"] = str(props["policy_number"])
                except:
                    raise TypeError(f"Property policy_number must be of type str, got {type(props['policy_number']).__name__}")
    
        # Type check deductible (expected int)
        if "deductible" in props and props["deductible"] is not None:
            if not isinstance(props["deductible"], int):
                try:
                    # Attempt to convert
                    props["deductible"] = int(props["deductible"])
                except:
                    raise TypeError(f"Property deductible must be of type int, got {type(props['deductible']).__name__}")
    
        # Type check broker (expected str)
        if "broker" in props and props["broker"] is not None:
            if not isinstance(props["broker"], str):
                try:
                    # Attempt to convert
                    props["broker"] = str(props["broker"])
                except:
                    raise TypeError(f"Property broker must be of type str, got {type(props['broker']).__name__}")
    
        # Type check effective (expected object)
        if "effective" in props and props["effective"] is not None:
            if not isinstance(props["effective"], object):
                try:
                    # Attempt to convert
                    props["effective"] = object(props["effective"])
                except:
                    raise TypeError(f"Property effective must be of type object, got {type(props['effective']).__name__}")
    
        # Type check coverage_limit (expected int)
        if "coverage_limit" in props and props["coverage_limit"] is not None:
            if not isinstance(props["coverage_limit"], int):
                try:
                    # Attempt to convert
                    props["coverage_limit"] = int(props["coverage_limit"])
                except:
                    raise TypeError(f"Property coverage_limit must be of type int, got {type(props['coverage_limit']).__name__}")
    
        # Type check claims_filed (expected int)
        if "claims_filed" in props and props["claims_filed"] is not None:
            if not isinstance(props["claims_filed"], int):
                try:
                    # Attempt to convert
                    props["claims_filed"] = int(props["claims_filed"])
                except:
                    raise TypeError(f"Property claims_filed must be of type int, got {type(props['claims_filed']).__name__}")
    
        # Type check claims_total (expected int)
        if "claims_total" in props and props["claims_total"] is not None:
            if not isinstance(props["claims_total"], int):
                try:
                    # Attempt to convert
                    props["claims_total"] = int(props["claims_total"])
                except:
                    raise TypeError(f"Property claims_total must be of type int, got {type(props['claims_total']).__name__}")
    
        # Type check access_requests_annual (expected int)
        if "access_requests_annual" in props and props["access_requests_annual"] is not None:
            if not isinstance(props["access_requests_annual"], int):
                try:
                    # Attempt to convert
                    props["access_requests_annual"] = int(props["access_requests_annual"])
                except:
                    raise TypeError(f"Property access_requests_annual must be of type int, got {type(props['access_requests_annual']).__name__}")
    
        # Type check storage_facilities (expected object)
        if "storage_facilities" in props and props["storage_facilities"] is not None:
            if not isinstance(props["storage_facilities"], object):
                try:
                    # Attempt to convert
                    props["storage_facilities"] = object(props["storage_facilities"])
                except:
                    raise TypeError(f"Property storage_facilities must be of type object, got {type(props['storage_facilities']).__name__}")
    
        # Type check restoration_years (expected object)
        if "restoration_years" in props and props["restoration_years"] is not None:
            if not isinstance(props["restoration_years"], object):
                try:
                    # Attempt to convert
                    props["restoration_years"] = object(props["restoration_years"])
                except:
                    raise TypeError(f"Property restoration_years must be of type object, got {type(props['restoration_years']).__name__}")
    
        # Type check restoration_technologies (expected object)
        if "restoration_technologies" in props and props["restoration_technologies"] is not None:
            if not isinstance(props["restoration_technologies"], object):
                try:
                    # Attempt to convert
                    props["restoration_technologies"] = object(props["restoration_technologies"])
                except:
                    raise TypeError(f"Property restoration_technologies must be of type object, got {type(props['restoration_technologies']).__name__}")
    
        # Type check physical_elements (expected int)
        if "physical_elements" in props and props["physical_elements"] is not None:
            if not isinstance(props["physical_elements"], int):
                try:
                    # Attempt to convert
                    props["physical_elements"] = int(props["physical_elements"])
                except:
                    raise TypeError(f"Property physical_elements must be of type int, got {type(props['physical_elements']).__name__}")
    
        # Type check material_types (expected object)
        if "material_types" in props and props["material_types"] is not None:
            if not isinstance(props["material_types"], object):
                try:
                    # Attempt to convert
                    props["material_types"] = object(props["material_types"])
                except:
                    raise TypeError(f"Property material_types must be of type object, got {type(props['material_types']).__name__}")
    
        # Type check material_counts (expected object)
        if "material_counts" in props and props["material_counts"] is not None:
            if not isinstance(props["material_counts"], object):
                try:
                    # Attempt to convert
                    props["material_counts"] = object(props["material_counts"])
                except:
                    raise TypeError(f"Property material_counts must be of type object, got {type(props['material_counts']).__name__}")
    
        # Type check storage_locations (expected int)
        if "storage_locations" in props and props["storage_locations"] is not None:
            if not isinstance(props["storage_locations"], int):
                try:
                    # Attempt to convert
                    props["storage_locations"] = int(props["storage_locations"])
                except:
                    raise TypeError(f"Property storage_locations must be of type int, got {type(props['storage_locations']).__name__}")
    
        # Type check historical_designation (expected str)
        if "historical_designation" in props and props["historical_designation"] is not None:
            if not isinstance(props["historical_designation"], str):
                try:
                    # Attempt to convert
                    props["historical_designation"] = str(props["historical_designation"])
                except:
                    raise TypeError(f"Property historical_designation must be of type str, got {type(props['historical_designation']).__name__}")
    
        # Type check scholarly_access (expected str)
        if "scholarly_access" in props and props["scholarly_access"] is not None:
            if not isinstance(props["scholarly_access"], str):
                try:
                    # Attempt to convert
                    props["scholarly_access"] = str(props["scholarly_access"])
                except:
                    raise TypeError(f"Property scholarly_access must be of type str, got {type(props['scholarly_access']).__name__}")
    
        # Type check access_level (expected str)
        if "access_level" in props and props["access_level"] is not None:
            if not isinstance(props["access_level"], str):
                try:
                    # Attempt to convert
                    props["access_level"] = str(props["access_level"])
                except:
                    raise TypeError(f"Property access_level must be of type str, got {type(props['access_level']).__name__}")
    
        # Type check digital_elements (expected int)
        if "digital_elements" in props and props["digital_elements"] is not None:
            if not isinstance(props["digital_elements"], int):
                try:
                    # Attempt to convert
                    props["digital_elements"] = int(props["digital_elements"])
                except:
                    raise TypeError(f"Property digital_elements must be of type int, got {type(props['digital_elements']).__name__}")
    
        # Type check preservation_budget (expected int)
        if "preservation_budget" in props and props["preservation_budget"] is not None:
            if not isinstance(props["preservation_budget"], int):
                try:
                    # Attempt to convert
                    props["preservation_budget"] = int(props["preservation_budget"])
                except:
                    raise TypeError(f"Property preservation_budget must be of type int, got {type(props['preservation_budget']).__name__}")
    
        # Type check climate_controlled (expected bool)
        if "climate_controlled" in props and props["climate_controlled"] is not None:
            if not isinstance(props["climate_controlled"], bool):
                try:
                    # Attempt to convert
                    props["climate_controlled"] = bool(props["climate_controlled"])
                except:
                    raise TypeError(f"Property climate_controlled must be of type bool, got {type(props['climate_controlled']).__name__}")
    
        # Type check public_exhibitions (expected int)
        if "public_exhibitions" in props and props["public_exhibitions"] is not None:
            if not isinstance(props["public_exhibitions"], int):
                try:
                    # Attempt to convert
                    props["public_exhibitions"] = int(props["public_exhibitions"])
                except:
                    raise TypeError(f"Property public_exhibitions must be of type int, got {type(props['public_exhibitions']).__name__}")
    
        # Type check restoration_projects (expected int)
        if "restoration_projects" in props and props["restoration_projects"] is not None:
            if not isinstance(props["restoration_projects"], int):
                try:
                    # Attempt to convert
                    props["restoration_projects"] = int(props["restoration_projects"])
                except:
                    raise TypeError(f"Property restoration_projects must be of type int, got {type(props['restoration_projects']).__name__}")
    
        # Type check disaster_recovery_plan (expected bool)
        if "disaster_recovery_plan" in props and props["disaster_recovery_plan"] is not None:
            if not isinstance(props["disaster_recovery_plan"], bool):
                try:
                    # Attempt to convert
                    props["disaster_recovery_plan"] = bool(props["disaster_recovery_plan"])
                except:
                    raise TypeError(f"Property disaster_recovery_plan must be of type bool, got {type(props['disaster_recovery_plan']).__name__}")
    
        # Type check materials_cataloged (expected int)
        if "materials_cataloged" in props and props["materials_cataloged"] is not None:
            if not isinstance(props["materials_cataloged"], int):
                try:
                    # Attempt to convert
                    props["materials_cataloged"] = int(props["materials_cataloged"])
                except:
                    raise TypeError(f"Property materials_cataloged must be of type int, got {type(props['materials_cataloged']).__name__}")
    
        # Type check payroll_totals (expected object)
        if "payroll_totals" in props and props["payroll_totals"] is not None:
            if not isinstance(props["payroll_totals"], object):
                try:
                    # Attempt to convert
                    props["payroll_totals"] = object(props["payroll_totals"])
                except:
                    raise TypeError(f"Property payroll_totals must be of type object, got {type(props['payroll_totals']).__name__}")
    
        # Type check agreement_variations (expected object)
        if "agreement_variations" in props and props["agreement_variations"] is not None:
            if not isinstance(props["agreement_variations"], object):
                try:
                    # Attempt to convert
                    props["agreement_variations"] = object(props["agreement_variations"])
                except:
                    raise TypeError(f"Property agreement_variations must be of type object, got {type(props['agreement_variations']).__name__}")
    
        # Type check payroll_categories (expected object)
        if "payroll_categories" in props and props["payroll_categories"] is not None:
            if not isinstance(props["payroll_categories"], object):
                try:
                    # Attempt to convert
                    props["payroll_categories"] = object(props["payroll_categories"])
                except:
                    raise TypeError(f"Property payroll_categories must be of type object, got {type(props['payroll_categories']).__name__}")
    
        # Type check overtime_hours (expected int)
        if "overtime_hours" in props and props["overtime_hours"] is not None:
            if not isinstance(props["overtime_hours"], int):
                try:
                    # Attempt to convert
                    props["overtime_hours"] = int(props["overtime_hours"])
                except:
                    raise TypeError(f"Property overtime_hours must be of type int, got {type(props['overtime_hours']).__name__}")
    
        # Type check contract_variations (expected int)
        if "contract_variations" in props and props["contract_variations"] is not None:
            if not isinstance(props["contract_variations"], int):
                try:
                    # Attempt to convert
                    props["contract_variations"] = int(props["contract_variations"])
                except:
                    raise TypeError(f"Property contract_variations must be of type int, got {type(props['contract_variations']).__name__}")
    
        # Type check work_stoppages (expected int)
        if "work_stoppages" in props and props["work_stoppages"] is not None:
            if not isinstance(props["work_stoppages"], int):
                try:
                    # Attempt to convert
                    props["work_stoppages"] = int(props["work_stoppages"])
                except:
                    raise TypeError(f"Property work_stoppages must be of type int, got {type(props['work_stoppages']).__name__}")
    
        # Type check total_union_members (expected int)
        if "total_union_members" in props and props["total_union_members"] is not None:
            if not isinstance(props["total_union_members"], int):
                try:
                    # Attempt to convert
                    props["total_union_members"] = int(props["total_union_members"])
                except:
                    raise TypeError(f"Property total_union_members must be of type int, got {type(props['total_union_members']).__name__}")
    
        # Type check union_agreements (expected object)
        if "union_agreements" in props and props["union_agreements"] is not None:
            if not isinstance(props["union_agreements"], object):
                try:
                    # Attempt to convert
                    props["union_agreements"] = object(props["union_agreements"])
                except:
                    raise TypeError(f"Property union_agreements must be of type object, got {type(props['union_agreements']).__name__}")
    
        # Type check compliance_audit (expected object)
        if "compliance_audit" in props and props["compliance_audit"] is not None:
            if not isinstance(props["compliance_audit"], object):
                try:
                    # Attempt to convert
                    props["compliance_audit"] = object(props["compliance_audit"])
                except:
                    raise TypeError(f"Property compliance_audit must be of type object, got {type(props['compliance_audit']).__name__}")
    
        # Type check grievances_filed (expected int)
        if "grievances_filed" in props and props["grievances_filed"] is not None:
            if not isinstance(props["grievances_filed"], int):
                try:
                    # Attempt to convert
                    props["grievances_filed"] = int(props["grievances_filed"])
                except:
                    raise TypeError(f"Property grievances_filed must be of type int, got {type(props['grievances_filed']).__name__}")
    
        # Type check payroll_service (expected str)
        if "payroll_service" in props and props["payroll_service"] is not None:
            if not isinstance(props["payroll_service"], str):
                try:
                    # Attempt to convert
                    props["payroll_service"] = str(props["payroll_service"])
                except:
                    raise TypeError(f"Property payroll_service must be of type str, got {type(props['payroll_service']).__name__}")
    
        # Type check negotiated (expected object)
        if "negotiated" in props and props["negotiated"] is not None:
            if not isinstance(props["negotiated"], object):
                try:
                    # Attempt to convert
                    props["negotiated"] = object(props["negotiated"])
                except:
                    raise TypeError(f"Property negotiated must be of type object, got {type(props['negotiated']).__name__}")
    
        # Type check pension_contributions (expected int)
        if "pension_contributions" in props and props["pension_contributions"] is not None:
            if not isinstance(props["pension_contributions"], int):
                try:
                    # Attempt to convert
                    props["pension_contributions"] = int(props["pension_contributions"])
                except:
                    raise TypeError(f"Property pension_contributions must be of type int, got {type(props['pension_contributions']).__name__}")
    
        # Type check signatory_unions (expected int)
        if "signatory_unions" in props and props["signatory_unions"] is not None:
            if not isinstance(props["signatory_unions"], int):
                try:
                    # Attempt to convert
                    props["signatory_unions"] = int(props["signatory_unions"])
                except:
                    raise TypeError(f"Property signatory_unions must be of type int, got {type(props['signatory_unions']).__name__}")
    
        # Type check grievances_resolved (expected int)
        if "grievances_resolved" in props and props["grievances_resolved"] is not None:
            if not isinstance(props["grievances_resolved"], int):
                try:
                    # Attempt to convert
                    props["grievances_resolved"] = int(props["grievances_resolved"])
                except:
                    raise TypeError(f"Property grievances_resolved must be of type int, got {type(props['grievances_resolved']).__name__}")
    
        # Type check meal_penalties (expected int)
        if "meal_penalties" in props and props["meal_penalties"] is not None:
            if not isinstance(props["meal_penalties"], int):
                try:
                    # Attempt to convert
                    props["meal_penalties"] = int(props["meal_penalties"])
                except:
                    raise TypeError(f"Property meal_penalties must be of type int, got {type(props['meal_penalties']).__name__}")
    
        # Type check health_contributions (expected int)
        if "health_contributions" in props and props["health_contributions"] is not None:
            if not isinstance(props["health_contributions"], int):
                try:
                    # Attempt to convert
                    props["health_contributions"] = int(props["health_contributions"])
                except:
                    raise TypeError(f"Property health_contributions must be of type int, got {type(props['health_contributions']).__name__}")
    
        # Type check design_guidelines (expected str)
        if "design_guidelines" in props and props["design_guidelines"] is not None:
            if not isinstance(props["design_guidelines"], str):
                try:
                    # Attempt to convert
                    props["design_guidelines"] = str(props["design_guidelines"])
                except:
                    raise TypeError(f"Property design_guidelines must be of type str, got {type(props['design_guidelines']).__name__}")
    
        # Type check logo_treatments (expected int)
        if "logo_treatments" in props and props["logo_treatments"] is not None:
            if not isinstance(props["logo_treatments"], int):
                try:
                    # Attempt to convert
                    props["logo_treatments"] = int(props["logo_treatments"])
                except:
                    raise TypeError(f"Property logo_treatments must be of type int, got {type(props['logo_treatments']).__name__}")
    
        # Type check licensee_advances (expected object)
        if "licensee_advances" in props and props["licensee_advances"] is not None:
            if not isinstance(props["licensee_advances"], object):
                try:
                    # Attempt to convert
                    props["licensee_advances"] = object(props["licensee_advances"])
                except:
                    raise TypeError(f"Property licensee_advances must be of type object, got {type(props['licensee_advances']).__name__}")
    
        # Type check quality_control (expected str)
        if "quality_control" in props and props["quality_control"] is not None:
            if not isinstance(props["quality_control"], str):
                try:
                    # Attempt to convert
                    props["quality_control"] = str(props["quality_control"])
                except:
                    raise TypeError(f"Property quality_control must be of type str, got {type(props['quality_control']).__name__}")
    
        # Type check license_term (expected object)
        if "license_term" in props and props["license_term"] is not None:
            if not isinstance(props["license_term"], object):
                try:
                    # Attempt to convert
                    props["license_term"] = object(props["license_term"])
                except:
                    raise TypeError(f"Property license_term must be of type object, got {type(props['license_term']).__name__}")
    
        # Type check approval_process (expected str)
        if "approval_process" in props and props["approval_process"] is not None:
            if not isinstance(props["approval_process"], str):
                try:
                    # Attempt to convert
                    props["approval_process"] = str(props["approval_process"])
                except:
                    raise TypeError(f"Property approval_process must be of type str, got {type(props['approval_process']).__name__}")
    
        # Type check royalty_rates (expected str)
        if "royalty_rates" in props and props["royalty_rates"] is not None:
            if not isinstance(props["royalty_rates"], str):
                try:
                    # Attempt to convert
                    props["royalty_rates"] = str(props["royalty_rates"])
                except:
                    raise TypeError(f"Property royalty_rates must be of type str, got {type(props['royalty_rates']).__name__}")
    
        # Type check product_categories (expected object)
        if "product_categories" in props and props["product_categories"] is not None:
            if not isinstance(props["product_categories"], object):
                try:
                    # Attempt to convert
                    props["product_categories"] = object(props["product_categories"])
                except:
                    raise TypeError(f"Property product_categories must be of type object, got {type(props['product_categories']).__name__}")
    
        # Type check product_lines (expected object)
        if "product_lines" in props and props["product_lines"] is not None:
            if not isinstance(props["product_lines"], object):
                try:
                    # Attempt to convert
                    props["product_lines"] = object(props["product_lines"])
                except:
                    raise TypeError(f"Property product_lines must be of type object, got {type(props['product_lines']).__name__}")
    
        # Type check marketing_support (expected str)
        if "marketing_support" in props and props["marketing_support"] is not None:
            if not isinstance(props["marketing_support"], str):
                try:
                    # Attempt to convert
                    props["marketing_support"] = str(props["marketing_support"])
                except:
                    raise TypeError(f"Property marketing_support must be of type str, got {type(props['marketing_support']).__name__}")
    
        # Type check program_manager (expected str)
        if "program_manager" in props and props["program_manager"] is not None:
            if not isinstance(props["program_manager"], str):
                try:
                    # Attempt to convert
                    props["program_manager"] = str(props["program_manager"])
                except:
                    raise TypeError(f"Property program_manager must be of type str, got {type(props['program_manager']).__name__}")
    
        # Type check minimum_guarantees (expected int)
        if "minimum_guarantees" in props and props["minimum_guarantees"] is not None:
            if not isinstance(props["minimum_guarantees"], int):
                try:
                    # Attempt to convert
                    props["minimum_guarantees"] = int(props["minimum_guarantees"])
                except:
                    raise TypeError(f"Property minimum_guarantees must be of type int, got {type(props['minimum_guarantees']).__name__}")
    
        # Type check renewal_options (expected int)
        if "renewal_options" in props and props["renewal_options"] is not None:
            if not isinstance(props["renewal_options"], int):
                try:
                    # Attempt to convert
                    props["renewal_options"] = int(props["renewal_options"])
                except:
                    raise TypeError(f"Property renewal_options must be of type int, got {type(props['renewal_options']).__name__}")
    
        # Type check licensees (expected int)
        if "licensees" in props and props["licensees"] is not None:
            if not isinstance(props["licensees"], int):
                try:
                    # Attempt to convert
                    props["licensees"] = int(props["licensees"])
                except:
                    raise TypeError(f"Property licensees must be of type int, got {type(props['licensees']).__name__}")
    
        # Type check compensation_values (expected object)
        if "compensation_values" in props and props["compensation_values"] is not None:
            if not isinstance(props["compensation_values"], object):
                try:
                    # Attempt to convert
                    props["compensation_values"] = object(props["compensation_values"])
                except:
                    raise TypeError(f"Property compensation_values must be of type object, got {type(props['compensation_values']).__name__}")
    
        # Type check contract_pages (expected int)
        if "contract_pages" in props and props["contract_pages"] is not None:
            if not isinstance(props["contract_pages"], int):
                try:
                    # Attempt to convert
                    props["contract_pages"] = int(props["contract_pages"])
                except:
                    raise TypeError(f"Property contract_pages must be of type int, got {type(props['contract_pages']).__name__}")
    
        # Type check brand_names (expected object)
        if "brand_names" in props and props["brand_names"] is not None:
            if not isinstance(props["brand_names"], object):
                try:
                    # Attempt to convert
                    props["brand_names"] = object(props["brand_names"])
                except:
                    raise TypeError(f"Property brand_names must be of type object, got {type(props['brand_names']).__name__}")
    
        # Type check compensation_types (expected object)
        if "compensation_types" in props and props["compensation_types"] is not None:
            if not isinstance(props["compensation_types"], object):
                try:
                    # Attempt to convert
                    props["compensation_types"] = object(props["compensation_types"])
                except:
                    raise TypeError(f"Property compensation_types must be of type object, got {type(props['compensation_types']).__name__}")
    
        # Type check screen_placements (expected object)
        if "screen_placements" in props and props["screen_placements"] is not None:
            if not isinstance(props["screen_placements"], object):
                try:
                    # Attempt to convert
                    props["screen_placements"] = object(props["screen_placements"])
                except:
                    raise TypeError(f"Property screen_placements must be of type object, got {type(props['screen_placements']).__name__}")
    
        # Type check screen_time_total (expected object)
        if "screen_time_total" in props and props["screen_time_total"] is not None:
            if not isinstance(props["screen_time_total"], object):
                try:
                    # Attempt to convert
                    props["screen_time_total"] = object(props["screen_time_total"])
                except:
                    raise TypeError(f"Property screen_time_total must be of type object, got {type(props['screen_time_total']).__name__}")
    
        # Type check cash_compensation (expected int)
        if "cash_compensation" in props and props["cash_compensation"] is not None:
            if not isinstance(props["cash_compensation"], int):
                try:
                    # Attempt to convert
                    props["cash_compensation"] = int(props["cash_compensation"])
                except:
                    raise TypeError(f"Property cash_compensation must be of type int, got {type(props['cash_compensation']).__name__}")
    
        # Type check in_kind_value (expected int)
        if "in_kind_value" in props and props["in_kind_value"] is not None:
            if not isinstance(props["in_kind_value"], int):
                try:
                    # Attempt to convert
                    props["in_kind_value"] = int(props["in_kind_value"])
                except:
                    raise TypeError(f"Property in_kind_value must be of type int, got {type(props['in_kind_value']).__name__}")
    
        # Type check negotiation_rounds (expected int)
        if "negotiation_rounds" in props and props["negotiation_rounds"] is not None:
            if not isinstance(props["negotiation_rounds"], int):
                try:
                    # Attempt to convert
                    props["negotiation_rounds"] = int(props["negotiation_rounds"])
                except:
                    raise TypeError(f"Property negotiation_rounds must be of type int, got {type(props['negotiation_rounds']).__name__}")
    
        # Type check legal_review_hours (expected int)
        if "legal_review_hours" in props and props["legal_review_hours"] is not None:
            if not isinstance(props["legal_review_hours"], int):
                try:
                    # Attempt to convert
                    props["legal_review_hours"] = int(props["legal_review_hours"])
                except:
                    raise TypeError(f"Property legal_review_hours must be of type int, got {type(props['legal_review_hours']).__name__}")
    
        # Type check director_approvals (expected str)
        if "director_approvals" in props and props["director_approvals"] is not None:
            if not isinstance(props["director_approvals"], str):
                try:
                    # Attempt to convert
                    props["director_approvals"] = str(props["director_approvals"])
                except:
                    raise TypeError(f"Property director_approvals must be of type str, got {type(props['director_approvals']).__name__}")
    
        # Type check brands_featured (expected int)
        if "brands_featured" in props and props["brands_featured"] is not None:
            if not isinstance(props["brands_featured"], int):
                try:
                    # Attempt to convert
                    props["brands_featured"] = int(props["brands_featured"])
                except:
                    raise TypeError(f"Property brands_featured must be of type int, got {type(props['brands_featured']).__name__}")
    
        # Type check authenticity_restrictions (expected str)
        if "authenticity_restrictions" in props and props["authenticity_restrictions"] is not None:
            if not isinstance(props["authenticity_restrictions"], str):
                try:
                    # Attempt to convert
                    props["authenticity_restrictions"] = str(props["authenticity_restrictions"])
                except:
                    raise TypeError(f"Property authenticity_restrictions must be of type str, got {type(props['authenticity_restrictions']).__name__}")
    
        # Type check anachronism_avoidance (expected str)
        if "anachronism_avoidance" in props and props["anachronism_avoidance"] is not None:
            if not isinstance(props["anachronism_avoidance"], str):
                try:
                    # Attempt to convert
                    props["anachronism_avoidance"] = str(props["anachronism_avoidance"])
                except:
                    raise TypeError(f"Property anachronism_avoidance must be of type str, got {type(props['anachronism_avoidance']).__name__}")
    
        # Type check placement_seconds (expected object)
        if "placement_seconds" in props and props["placement_seconds"] is not None:
            if not isinstance(props["placement_seconds"], object):
                try:
                    # Attempt to convert
                    props["placement_seconds"] = object(props["placement_seconds"])
                except:
                    raise TypeError(f"Property placement_seconds must be of type object, got {type(props['placement_seconds']).__name__}")
    
        # Type check facility_names (expected object)
        if "facility_names" in props and props["facility_names"] is not None:
            if not isinstance(props["facility_names"], object):
                try:
                    # Attempt to convert
                    props["facility_names"] = object(props["facility_names"])
                except:
                    raise TypeError(f"Property facility_names must be of type object, got {type(props['facility_names']).__name__}")
    
        # Type check service_durations_unit (expected str)
        if "service_durations_unit" in props and props["service_durations_unit"] is not None:
            if not isinstance(props["service_durations_unit"], str):
                try:
                    # Attempt to convert
                    props["service_durations_unit"] = str(props["service_durations_unit"])
                except:
                    raise TypeError(f"Property service_durations_unit must be of type str, got {type(props['service_durations_unit']).__name__}")
    
        # Type check technical_systems (expected object)
        if "technical_systems" in props and props["technical_systems"] is not None:
            if not isinstance(props["technical_systems"], object):
                try:
                    # Attempt to convert
                    props["technical_systems"] = object(props["technical_systems"])
                except:
                    raise TypeError(f"Property technical_systems must be of type object, got {type(props['technical_systems']).__name__}")
    
        # Type check deliverable_formats (expected object)
        if "deliverable_formats" in props and props["deliverable_formats"] is not None:
            if not isinstance(props["deliverable_formats"], object):
                try:
                    # Attempt to convert
                    props["deliverable_formats"] = object(props["deliverable_formats"])
                except:
                    raise TypeError(f"Property deliverable_formats must be of type object, got {type(props['deliverable_formats']).__name__}")
    
        # Type check editing_suites (expected int)
        if "editing_suites" in props and props["editing_suites"] is not None:
            if not isinstance(props["editing_suites"], int):
                try:
                    # Attempt to convert
                    props["editing_suites"] = int(props["editing_suites"])
                except:
                    raise TypeError(f"Property editing_suites must be of type int, got {type(props['editing_suites']).__name__}")
    
        # Type check service_categories (expected object)
        if "service_categories" in props and props["service_categories"] is not None:
            if not isinstance(props["service_categories"], object):
                try:
                    # Attempt to convert
                    props["service_categories"] = object(props["service_categories"])
                except:
                    raise TypeError(f"Property service_categories must be of type object, got {type(props['service_categories']).__name__}")
    
        # Type check service_durations (expected object)
        if "service_durations" in props and props["service_durations"] is not None:
            if not isinstance(props["service_durations"], object):
                try:
                    # Attempt to convert
                    props["service_durations"] = object(props["service_durations"])
                except:
                    raise TypeError(f"Property service_durations must be of type object, got {type(props['service_durations']).__name__}")
    
        # Type check facility_locations (expected int)
        if "facility_locations" in props and props["facility_locations"] is not None:
            if not isinstance(props["facility_locations"], int):
                try:
                    # Attempt to convert
                    props["facility_locations"] = int(props["facility_locations"])
                except:
                    raise TypeError(f"Property facility_locations must be of type int, got {type(props['facility_locations']).__name__}")
    
        # Type check mixing_rooms (expected int)
        if "mixing_rooms" in props and props["mixing_rooms"] is not None:
            if not isinstance(props["mixing_rooms"], int):
                try:
                    # Attempt to convert
                    props["mixing_rooms"] = int(props["mixing_rooms"])
                except:
                    raise TypeError(f"Property mixing_rooms must be of type int, got {type(props['mixing_rooms']).__name__}")
    
        # Type check screening_rooms (expected int)
        if "screening_rooms" in props and props["screening_rooms"] is not None:
            if not isinstance(props["screening_rooms"], int):
                try:
                    # Attempt to convert
                    props["screening_rooms"] = int(props["screening_rooms"])
                except:
                    raise TypeError(f"Property screening_rooms must be of type int, got {type(props['screening_rooms']).__name__}")
    
        # Type check dailies_processed (expected int)
        if "dailies_processed" in props and props["dailies_processed"] is not None:
            if not isinstance(props["dailies_processed"], int):
                try:
                    # Attempt to convert
                    props["dailies_processed"] = int(props["dailies_processed"])
                except:
                    raise TypeError(f"Property dailies_processed must be of type int, got {type(props['dailies_processed']).__name__}")
    
        # Type check dailies_unit (expected str)
        if "dailies_unit" in props and props["dailies_unit"] is not None:
            if not isinstance(props["dailies_unit"], str):
                try:
                    # Attempt to convert
                    props["dailies_unit"] = str(props["dailies_unit"])
                except:
                    raise TypeError(f"Property dailies_unit must be of type str, got {type(props['dailies_unit']).__name__}")
    
        # Type check technical_staff (expected int)
        if "technical_staff" in props and props["technical_staff"] is not None:
            if not isinstance(props["technical_staff"], int):
                try:
                    # Attempt to convert
                    props["technical_staff"] = int(props["technical_staff"])
                except:
                    raise TypeError(f"Property technical_staff must be of type int, got {type(props['technical_staff']).__name__}")
    
        # Type check sound_stages (expected int)
        if "sound_stages" in props and props["sound_stages"] is not None:
            if not isinstance(props["sound_stages"], int):
                try:
                    # Attempt to convert
                    props["sound_stages"] = int(props["sound_stages"])
                except:
                    raise TypeError(f"Property sound_stages must be of type int, got {type(props['sound_stages']).__name__}")
    
        # Type check creative_staff (expected int)
        if "creative_staff" in props and props["creative_staff"] is not None:
            if not isinstance(props["creative_staff"], int):
                try:
                    # Attempt to convert
                    props["creative_staff"] = int(props["creative_staff"])
                except:
                    raise TypeError(f"Property creative_staff must be of type int, got {type(props['creative_staff']).__name__}")
    
        # Type check final_runtime (expected object)
        if "final_runtime" in props and props["final_runtime"] is not None:
            if not isinstance(props["final_runtime"], object):
                try:
                    # Attempt to convert
                    props["final_runtime"] = object(props["final_runtime"])
                except:
                    raise TypeError(f"Property final_runtime must be of type object, got {type(props['final_runtime']).__name__}")
    
        # Type check engaged (expected object)
        if "engaged" in props and props["engaged"] is not None:
            if not isinstance(props["engaged"], object):
                try:
                    # Attempt to convert
                    props["engaged"] = object(props["engaged"])
                except:
                    raise TypeError(f"Property engaged must be of type object, got {type(props['engaged']).__name__}")
    
        # Type check equipment_value (expected int)
        if "equipment_value" in props and props["equipment_value"] is not None:
            if not isinstance(props["equipment_value"], int):
                try:
                    # Attempt to convert
                    props["equipment_value"] = int(props["equipment_value"])
                except:
                    raise TypeError(f"Property equipment_value must be of type int, got {type(props['equipment_value']).__name__}")
    
        # Type check processing_capacity (expected int)
        if "processing_capacity" in props and props["processing_capacity"] is not None:
            if not isinstance(props["processing_capacity"], int):
                try:
                    # Attempt to convert
                    props["processing_capacity"] = int(props["processing_capacity"])
                except:
                    raise TypeError(f"Property processing_capacity must be of type int, got {type(props['processing_capacity']).__name__}")
    
        # Type check facility_size_unit (expected str)
        if "facility_size_unit" in props and props["facility_size_unit"] is not None:
            if not isinstance(props["facility_size_unit"], str):
                try:
                    # Attempt to convert
                    props["facility_size_unit"] = str(props["facility_size_unit"])
                except:
                    raise TypeError(f"Property facility_size_unit must be of type str, got {type(props['facility_size_unit']).__name__}")
    
        # Type check film_formats (expected str)
        if "film_formats" in props and props["film_formats"] is not None:
            if not isinstance(props["film_formats"], str):
                try:
                    # Attempt to convert
                    props["film_formats"] = str(props["film_formats"])
                except:
                    raise TypeError(f"Property film_formats must be of type str, got {type(props['film_formats']).__name__}")
    
        # Type check project_engaged (expected object)
        if "project_engaged" in props and props["project_engaged"] is not None:
            if not isinstance(props["project_engaged"], object):
                try:
                    # Attempt to convert
                    props["project_engaged"] = object(props["project_engaged"])
                except:
                    raise TypeError(f"Property project_engaged must be of type object, got {type(props['project_engaged']).__name__}")
    
        # Type check industry_leadership (expected str)
        if "industry_leadership" in props and props["industry_leadership"] is not None:
            if not isinstance(props["industry_leadership"], str):
                try:
                    # Attempt to convert
                    props["industry_leadership"] = str(props["industry_leadership"])
                except:
                    raise TypeError(f"Property industry_leadership must be of type str, got {type(props['industry_leadership']).__name__}")
    
        # Type check project_completed (expected object)
        if "project_completed" in props and props["project_completed"] is not None:
            if not isinstance(props["project_completed"], object):
                try:
                    # Attempt to convert
                    props["project_completed"] = object(props["project_completed"])
                except:
                    raise TypeError(f"Property project_completed must be of type object, got {type(props['project_completed']).__name__}")
    
        # Type check capacity_unit (expected str)
        if "capacity_unit" in props and props["capacity_unit"] is not None:
            if not isinstance(props["capacity_unit"], str):
                try:
                    # Attempt to convert
                    props["capacity_unit"] = str(props["capacity_unit"])
                except:
                    raise TypeError(f"Property capacity_unit must be of type str, got {type(props['capacity_unit']).__name__}")
    
        # Type check processing_standards (expected object)
        if "processing_standards" in props and props["processing_standards"] is not None:
            if not isinstance(props["processing_standards"], object):
                try:
                    # Attempt to convert
                    props["processing_standards"] = object(props["processing_standards"])
                except:
                    raise TypeError(f"Property processing_standards must be of type object, got {type(props['processing_standards']).__name__}")
    
        # Type check client_list (expected object)
        if "client_list" in props and props["client_list"] is not None:
            if not isinstance(props["client_list"], object):
                try:
                    # Attempt to convert
                    props["client_list"] = object(props["client_list"])
                except:
                    raise TypeError(f"Property client_list must be of type object, got {type(props['client_list']).__name__}")
    
        # Type check facility_size (expected int)
        if "facility_size" in props and props["facility_size"] is not None:
            if not isinstance(props["facility_size"], int):
                try:
                    # Attempt to convert
                    props["facility_size"] = int(props["facility_size"])
                except:
                    raise TypeError(f"Property facility_size must be of type int, got {type(props['facility_size']).__name__}")
    
        # Type check equipment_types (expected object)
        if "equipment_types" in props and props["equipment_types"] is not None:
            if not isinstance(props["equipment_types"], object):
                try:
                    # Attempt to convert
                    props["equipment_types"] = object(props["equipment_types"])
                except:
                    raise TypeError(f"Property equipment_types must be of type object, got {type(props['equipment_types']).__name__}")
    
        # Type check equipment_counts (expected object)
        if "equipment_counts" in props and props["equipment_counts"] is not None:
            if not isinstance(props["equipment_counts"], object):
                try:
                    # Attempt to convert
                    props["equipment_counts"] = object(props["equipment_counts"])
                except:
                    raise TypeError(f"Property equipment_counts must be of type object, got {type(props['equipment_counts']).__name__}")
    
        # Type check chemical_systems (expected object)
        if "chemical_systems" in props and props["chemical_systems"] is not None:
            if not isinstance(props["chemical_systems"], object):
                try:
                    # Attempt to convert
                    props["chemical_systems"] = object(props["chemical_systems"])
                except:
                    raise TypeError(f"Property chemical_systems must be of type object, got {type(props['chemical_systems']).__name__}")
    
        # Type check quality_control_points (expected int)
        if "quality_control_points" in props and props["quality_control_points"] is not None:
            if not isinstance(props["quality_control_points"], int):
                try:
                    # Attempt to convert
                    props["quality_control_points"] = int(props["quality_control_points"])
                except:
                    raise TypeError(f"Property quality_control_points must be of type int, got {type(props['quality_control_points']).__name__}")
    
        # Type check processing_systems (expected str)
        if "processing_systems" in props and props["processing_systems"] is not None:
            if not isinstance(props["processing_systems"], str):
                try:
                    # Attempt to convert
                    props["processing_systems"] = str(props["processing_systems"])
                except:
                    raise TypeError(f"Property processing_systems must be of type str, got {type(props['processing_systems']).__name__}")
    
        # Type check technical_certifications (expected int)
        if "technical_certifications" in props and props["technical_certifications"] is not None:
            if not isinstance(props["technical_certifications"], int):
                try:
                    # Attempt to convert
                    props["technical_certifications"] = int(props["technical_certifications"])
                except:
                    raise TypeError(f"Property technical_certifications must be of type int, got {type(props['technical_certifications']).__name__}")
    
        # Type check services_provided (expected object)
        if "services_provided" in props and props["services_provided"] is not None:
            if not isinstance(props["services_provided"], object):
                try:
                    # Attempt to convert
                    props["services_provided"] = object(props["services_provided"])
                except:
                    raise TypeError(f"Property services_provided must be of type object, got {type(props['services_provided']).__name__}")
    
        # Type check report_recipients (expected object)
        if "report_recipients" in props and props["report_recipients"] is not None:
            if not isinstance(props["report_recipients"], object):
                try:
                    # Attempt to convert
                    props["report_recipients"] = object(props["report_recipients"])
                except:
                    raise TypeError(f"Property report_recipients must be of type object, got {type(props['report_recipients']).__name__}")
    
        # Type check compliance_frameworks (expected object)
        if "compliance_frameworks" in props and props["compliance_frameworks"] is not None:
            if not isinstance(props["compliance_frameworks"], object):
                try:
                    # Attempt to convert
                    props["compliance_frameworks"] = object(props["compliance_frameworks"])
                except:
                    raise TypeError(f"Property compliance_frameworks must be of type object, got {type(props['compliance_frameworks']).__name__}")
    
        # Type check record_retention (expected str)
        if "record_retention" in props and props["record_retention"] is not None:
            if not isinstance(props["record_retention"], str):
                try:
                    # Attempt to convert
                    props["record_retention"] = str(props["record_retention"])
                except:
                    raise TypeError(f"Property record_retention must be of type str, got {type(props['record_retention']).__name__}")
    
        # Type check chart_of_accounts (expected str)
        if "chart_of_accounts" in props and props["chart_of_accounts"] is not None:
            if not isinstance(props["chart_of_accounts"], str):
                try:
                    # Attempt to convert
                    props["chart_of_accounts"] = str(props["chart_of_accounts"])
                except:
                    raise TypeError(f"Property chart_of_accounts must be of type str, got {type(props['chart_of_accounts']).__name__}")
    
        # Type check accounting_system (expected str)
        if "accounting_system" in props and props["accounting_system"] is not None:
            if not isinstance(props["accounting_system"], str):
                try:
                    # Attempt to convert
                    props["accounting_system"] = str(props["accounting_system"])
                except:
                    raise TypeError(f"Property accounting_system must be of type str, got {type(props['accounting_system']).__name__}")
    
        # Type check fiscal_year (expected str)
        if "fiscal_year" in props and props["fiscal_year"] is not None:
            if not isinstance(props["fiscal_year"], str):
                try:
                    # Attempt to convert
                    props["fiscal_year"] = str(props["fiscal_year"])
                except:
                    raise TypeError(f"Property fiscal_year must be of type str, got {type(props['fiscal_year']).__name__}")
    
        # Type check invoices_processed (expected int)
        if "invoices_processed" in props and props["invoices_processed"] is not None:
            if not isinstance(props["invoices_processed"], int):
                try:
                    # Attempt to convert
                    props["invoices_processed"] = int(props["invoices_processed"])
                except:
                    raise TypeError(f"Property invoices_processed must be of type int, got {type(props['invoices_processed']).__name__}")
    
        # Type check report_types (expected object)
        if "report_types" in props and props["report_types"] is not None:
            if not isinstance(props["report_types"], object):
                try:
                    # Attempt to convert
                    props["report_types"] = object(props["report_types"])
                except:
                    raise TypeError(f"Property report_types must be of type object, got {type(props['report_types']).__name__}")
    
        # Type check audits_conducted (expected int)
        if "audits_conducted" in props and props["audits_conducted"] is not None:
            if not isinstance(props["audits_conducted"], int):
                try:
                    # Attempt to convert
                    props["audits_conducted"] = int(props["audits_conducted"])
                except:
                    raise TypeError(f"Property audits_conducted must be of type int, got {type(props['audits_conducted']).__name__}")
    
        # Type check financial_reports (expected int)
        if "financial_reports" in props and props["financial_reports"] is not None:
            if not isinstance(props["financial_reports"], int):
                try:
                    # Attempt to convert
                    props["financial_reports"] = int(props["financial_reports"])
                except:
                    raise TypeError(f"Property financial_reports must be of type int, got {type(props['financial_reports']).__name__}")
    
        # Type check transactions_processed (expected int)
        if "transactions_processed" in props and props["transactions_processed"] is not None:
            if not isinstance(props["transactions_processed"], int):
                try:
                    # Attempt to convert
                    props["transactions_processed"] = int(props["transactions_processed"])
                except:
                    raise TypeError(f"Property transactions_processed must be of type int, got {type(props['transactions_processed']).__name__}")
    
        # Type check accounting_staff (expected int)
        if "accounting_staff" in props and props["accounting_staff"] is not None:
            if not isinstance(props["accounting_staff"], int):
                try:
                    # Attempt to convert
                    props["accounting_staff"] = int(props["accounting_staff"])
                except:
                    raise TypeError(f"Property accounting_staff must be of type int, got {type(props['accounting_staff']).__name__}")
    
        # Type check payroll_transactions (expected int)
        if "payroll_transactions" in props and props["payroll_transactions"] is not None:
            if not isinstance(props["payroll_transactions"], int):
                try:
                    # Attempt to convert
                    props["payroll_transactions"] = int(props["payroll_transactions"])
                except:
                    raise TypeError(f"Property payroll_transactions must be of type int, got {type(props['payroll_transactions']).__name__}")
    
        # Type check tax_filings (expected int)
        if "tax_filings" in props and props["tax_filings"] is not None:
            if not isinstance(props["tax_filings"], int):
                try:
                    # Attempt to convert
                    props["tax_filings"] = int(props["tax_filings"])
                except:
                    raise TypeError(f"Property tax_filings must be of type int, got {type(props['tax_filings']).__name__}")
    
        # Type check software_systems (expected object)
        if "software_systems" in props and props["software_systems"] is not None:
            if not isinstance(props["software_systems"], object):
                try:
                    # Attempt to convert
                    props["software_systems"] = object(props["software_systems"])
                except:
                    raise TypeError(f"Property software_systems must be of type object, got {type(props['software_systems']).__name__}")
    
        # Type check banking_relationships (expected object)
        if "banking_relationships" in props and props["banking_relationships"] is not None:
            if not isinstance(props["banking_relationships"], object):
                try:
                    # Attempt to convert
                    props["banking_relationships"] = object(props["banking_relationships"])
                except:
                    raise TypeError(f"Property banking_relationships must be of type object, got {type(props['banking_relationships']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="GeneratedByClaudeAI", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def carmodel(uuid=None, **props):
        """
        Find nodes with label CarModel matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check manufactureLocationLong (expected float)
        if "manufactureLocationLong" in props and props["manufactureLocationLong"] is not None:
            if not isinstance(props["manufactureLocationLong"], float):
                try:
                    # Attempt to convert
                    props["manufactureLocationLong"] = float(props["manufactureLocationLong"])
                except:
                    raise TypeError(f"Property manufactureLocationLong must be of type float, got {type(props['manufactureLocationLong']).__name__}")
    
        # Type check vehicleType (expected str)
        if "vehicleType" in props and props["vehicleType"] is not None:
            if not isinstance(props["vehicleType"], str):
                try:
                    # Attempt to convert
                    props["vehicleType"] = str(props["vehicleType"])
                except:
                    raise TypeError(f"Property vehicleType must be of type str, got {type(props['vehicleType']).__name__}")
    
        # Type check manufactureLocation (expected str)
        if "manufactureLocation" in props and props["manufactureLocation"] is not None:
            if not isinstance(props["manufactureLocation"], str):
                try:
                    # Attempt to convert
                    props["manufactureLocation"] = str(props["manufactureLocation"])
                except:
                    raise TypeError(f"Property manufactureLocation must be of type str, got {type(props['manufactureLocation']).__name__}")
    
        # Type check productPlacementCost (expected int)
        if "productPlacementCost" in props and props["productPlacementCost"] is not None:
            if not isinstance(props["productPlacementCost"], int):
                try:
                    # Attempt to convert
                    props["productPlacementCost"] = int(props["productPlacementCost"])
                except:
                    raise TypeError(f"Property productPlacementCost must be of type int, got {type(props['productPlacementCost']).__name__}")
    
        # Type check featuredInMovies (expected object)
        if "featuredInMovies" in props and props["featuredInMovies"] is not None:
            if not isinstance(props["featuredInMovies"], object):
                try:
                    # Attempt to convert
                    props["featuredInMovies"] = object(props["featuredInMovies"])
                except:
                    raise TypeError(f"Property featuredInMovies must be of type object, got {type(props['featuredInMovies']).__name__}")
    
        # Type check manufactureLocationLat (expected float)
        if "manufactureLocationLat" in props and props["manufactureLocationLat"] is not None:
            if not isinstance(props["manufactureLocationLat"], float):
                try:
                    # Attempt to convert
                    props["manufactureLocationLat"] = float(props["manufactureLocationLat"])
                except:
                    raise TypeError(f"Property manufactureLocationLat must be of type float, got {type(props['manufactureLocationLat']).__name__}")
    
        # Type check maxSpeed (expected int)
        if "maxSpeed" in props and props["maxSpeed"] is not None:
            if not isinstance(props["maxSpeed"], int):
                try:
                    # Attempt to convert
                    props["maxSpeed"] = int(props["maxSpeed"])
                except:
                    raise TypeError(f"Property maxSpeed must be of type int, got {type(props['maxSpeed']).__name__}")
    
        # Type check featuredInYears (expected object)
        if "featuredInYears" in props and props["featuredInYears"] is not None:
            if not isinstance(props["featuredInYears"], object):
                try:
                    # Attempt to convert
                    props["featuredInYears"] = object(props["featuredInYears"])
                except:
                    raise TypeError(f"Property featuredInYears must be of type object, got {type(props['featuredInYears']).__name__}")
    
        # Type check featured (expected bool)
        if "featured" in props and props["featured"] is not None:
            if not isinstance(props["featured"], bool):
                try:
                    # Attempt to convert
                    props["featured"] = bool(props["featured"])
                except:
                    raise TypeError(f"Property featured must be of type bool, got {type(props['featured']).__name__}")
    
        # Type check introduced (expected object)
        if "introduced" in props and props["introduced"] is not None:
            if not isinstance(props["introduced"], object):
                try:
                    # Attempt to convert
                    props["introduced"] = object(props["introduced"])
                except:
                    raise TypeError(f"Property introduced must be of type object, got {type(props['introduced']).__name__}")
    
        # Type check maxSpeedUnit (expected str)
        if "maxSpeedUnit" in props and props["maxSpeedUnit"] is not None:
            if not isinstance(props["maxSpeedUnit"], str):
                try:
                    # Attempt to convert
                    props["maxSpeedUnit"] = str(props["maxSpeedUnit"])
                except:
                    raise TypeError(f"Property maxSpeedUnit must be of type str, got {type(props['maxSpeedUnit']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="CarModel", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def prop(uuid=None, **props):
        """
        Find nodes with label Prop matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check copiesMade (expected int)
        if "copiesMade" in props and props["copiesMade"] is not None:
            if not isinstance(props["copiesMade"], int):
                try:
                    # Attempt to convert
                    props["copiesMade"] = int(props["copiesMade"])
                except:
                    raise TypeError(f"Property copiesMade must be of type int, got {type(props['copiesMade']).__name__}")
    
        # Type check weight (expected int)
        if "weight" in props and props["weight"] is not None:
            if not isinstance(props["weight"], int):
                try:
                    # Attempt to convert
                    props["weight"] = int(props["weight"])
                except:
                    raise TypeError(f"Property weight must be of type int, got {type(props['weight']).__name__}")
    
        # Type check isIconic (expected bool)
        if "isIconic" in props and props["isIconic"] is not None:
            if not isinstance(props["isIconic"], bool):
                try:
                    # Attempt to convert
                    props["isIconic"] = bool(props["isIconic"])
                except:
                    raise TypeError(f"Property isIconic must be of type bool, got {type(props['isIconic']).__name__}")
    
        # Type check weightUnit (expected str)
        if "weightUnit" in props and props["weightUnit"] is not None:
            if not isinstance(props["weightUnit"], str):
                try:
                    # Attempt to convert
                    props["weightUnit"] = str(props["weightUnit"])
                except:
                    raise TypeError(f"Property weightUnit must be of type str, got {type(props['weightUnit']).__name__}")
    
        # Type check screenTime (expected object)
        if "screenTime" in props and props["screenTime"] is not None:
            if not isinstance(props["screenTime"], object):
                try:
                    # Attempt to convert
                    props["screenTime"] = object(props["screenTime"])
                except:
                    raise TypeError(f"Property screenTime must be of type object, got {type(props['screenTime']).__name__}")
    
        # Type check movie (expected str)
        if "movie" in props and props["movie"] is not None:
            if not isinstance(props["movie"], str):
                try:
                    # Attempt to convert
                    props["movie"] = str(props["movie"])
                except:
                    raise TypeError(f"Property movie must be of type str, got {type(props['movie']).__name__}")
    
        # Type check material (expected str)
        if "material" in props and props["material"] is not None:
            if not isinstance(props["material"], str):
                try:
                    # Attempt to convert
                    props["material"] = str(props["material"])
                except:
                    raise TypeError(f"Property material must be of type str, got {type(props['material']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check auctionValue (expected int)
        if "auctionValue" in props and props["auctionValue"] is not None:
            if not isinstance(props["auctionValue"], int):
                try:
                    # Attempt to convert
                    props["auctionValue"] = int(props["auctionValue"])
                except:
                    raise TypeError(f"Property auctionValue must be of type int, got {type(props['auctionValue']).__name__}")
    
        # Type check createdDate (expected object)
        if "createdDate" in props and props["createdDate"] is not None:
            if not isinstance(props["createdDate"], object):
                try:
                    # Attempt to convert
                    props["createdDate"] = object(props["createdDate"])
                except:
                    raise TypeError(f"Property createdDate must be of type object, got {type(props['createdDate']).__name__}")
    
        # Type check constructionCost (expected int)
        if "constructionCost" in props and props["constructionCost"] is not None:
            if not isinstance(props["constructionCost"], int):
                try:
                    # Attempt to convert
                    props["constructionCost"] = int(props["constructionCost"])
                except:
                    raise TypeError(f"Property constructionCost must be of type int, got {type(props['constructionCost']).__name__}")
    
        # Type check breed (expected str)
        if "breed" in props and props["breed"] is not None:
            if not isinstance(props["breed"], str):
                try:
                    # Attempt to convert
                    props["breed"] = str(props["breed"])
                except:
                    raise TypeError(f"Property breed must be of type str, got {type(props['breed']).__name__}")
    
        # Type check handlerCount (expected int)
        if "handlerCount" in props and props["handlerCount"] is not None:
            if not isinstance(props["handlerCount"], int):
                try:
                    # Attempt to convert
                    props["handlerCount"] = int(props["handlerCount"])
                except:
                    raise TypeError(f"Property handlerCount must be of type int, got {type(props['handlerCount']).__name__}")
    
        # Type check type (expected str)
        if "type" in props and props["type"] is not None:
            if not isinstance(props["type"], str):
                try:
                    # Attempt to convert
                    props["type"] = str(props["type"])
                except:
                    raise TypeError(f"Property type must be of type str, got {type(props['type']).__name__}")
    
        # Type check isImprovised (expected bool)
        if "isImprovised" in props and props["isImprovised"] is not None:
            if not isinstance(props["isImprovised"], bool):
                try:
                    # Attempt to convert
                    props["isImprovised"] = bool(props["isImprovised"])
                except:
                    raise TypeError(f"Property isImprovised must be of type bool, got {type(props['isImprovised']).__name__}")
    
        # Type check animal (expected str)
        if "animal" in props and props["animal"] is not None:
            if not isinstance(props["animal"], str):
                try:
                    # Attempt to convert
                    props["animal"] = str(props["animal"])
                except:
                    raise TypeError(f"Property animal must be of type str, got {type(props['animal']).__name__}")
    
        # Type check acquisitionDate (expected object)
        if "acquisitionDate" in props and props["acquisitionDate"] is not None:
            if not isinstance(props["acquisitionDate"], object):
                try:
                    # Attempt to convert
                    props["acquisitionDate"] = object(props["acquisitionDate"])
                except:
                    raise TypeError(f"Property acquisitionDate must be of type object, got {type(props['acquisitionDate']).__name__}")
    
        # Type check isConsumed (expected bool)
        if "isConsumed" in props and props["isConsumed"] is not None:
            if not isinstance(props["isConsumed"], bool):
                try:
                    # Attempt to convert
                    props["isConsumed"] = bool(props["isConsumed"])
                except:
                    raise TypeError(f"Property isConsumed must be of type bool, got {type(props['isConsumed']).__name__}")
    
        # Type check propMaster (expected str)
        if "propMaster" in props and props["propMaster"] is not None:
            if not isinstance(props["propMaster"], str):
                try:
                    # Attempt to convert
                    props["propMaster"] = str(props["propMaster"])
                except:
                    raise TypeError(f"Property propMaster must be of type str, got {type(props['propMaster']).__name__}")
    
        # Type check replicas (expected int)
        if "replicas" in props and props["replicas"] is not None:
            if not isinstance(props["replicas"], int):
                try:
                    # Attempt to convert
                    props["replicas"] = int(props["replicas"])
                except:
                    raise TypeError(f"Property replicas must be of type int, got {type(props['replicas']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Prop", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def soundtrack(uuid=None, **props):
        """
        Find nodes with label Soundtrack matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check duration (expected object)
        if "duration" in props and props["duration"] is not None:
            if not isinstance(props["duration"], object):
                try:
                    # Attempt to convert
                    props["duration"] = object(props["duration"])
                except:
                    raise TypeError(f"Property duration must be of type object, got {type(props['duration']).__name__}")
    
        # Type check salesUnits (expected int)
        if "salesUnits" in props and props["salesUnits"] is not None:
            if not isinstance(props["salesUnits"], int):
                try:
                    # Attempt to convert
                    props["salesUnits"] = int(props["salesUnits"])
                except:
                    raise TypeError(f"Property salesUnits must be of type int, got {type(props['salesUnits']).__name__}")
    
        # Type check peakChartPosition (expected int)
        if "peakChartPosition" in props and props["peakChartPosition"] is not None:
            if not isinstance(props["peakChartPosition"], int):
                try:
                    # Attempt to convert
                    props["peakChartPosition"] = int(props["peakChartPosition"])
                except:
                    raise TypeError(f"Property peakChartPosition must be of type int, got {type(props['peakChartPosition']).__name__}")
    
        # Type check title (expected str)
        if "title" in props and props["title"] is not None:
            if not isinstance(props["title"], str):
                try:
                    # Attempt to convert
                    props["title"] = str(props["title"])
                except:
                    raise TypeError(f"Property title must be of type str, got {type(props['title']).__name__}")
    
        # Type check released (expected object)
        if "released" in props and props["released"] is not None:
            if not isinstance(props["released"], object):
                try:
                    # Attempt to convert
                    props["released"] = object(props["released"])
                except:
                    raise TypeError(f"Property released must be of type object, got {type(props['released']).__name__}")
    
        # Type check recordingStudio (expected str)
        if "recordingStudio" in props and props["recordingStudio"] is not None:
            if not isinstance(props["recordingStudio"], str):
                try:
                    # Attempt to convert
                    props["recordingStudio"] = str(props["recordingStudio"])
                except:
                    raise TypeError(f"Property recordingStudio must be of type str, got {type(props['recordingStudio']).__name__}")
    
        # Type check composer (expected str)
        if "composer" in props and props["composer"] is not None:
            if not isinstance(props["composer"], str):
                try:
                    # Attempt to convert
                    props["composer"] = str(props["composer"])
                except:
                    raise TypeError(f"Property composer must be of type str, got {type(props['composer']).__name__}")
    
        # Type check recordingStudioLong (expected float)
        if "recordingStudioLong" in props and props["recordingStudioLong"] is not None:
            if not isinstance(props["recordingStudioLong"], float):
                try:
                    # Attempt to convert
                    props["recordingStudioLong"] = float(props["recordingStudioLong"])
                except:
                    raise TypeError(f"Property recordingStudioLong must be of type float, got {type(props['recordingStudioLong']).__name__}")
    
        # Type check recordingStudioLat (expected float)
        if "recordingStudioLat" in props and props["recordingStudioLat"] is not None:
            if not isinstance(props["recordingStudioLat"], float):
                try:
                    # Attempt to convert
                    props["recordingStudioLat"] = float(props["recordingStudioLat"])
                except:
                    raise TypeError(f"Property recordingStudioLat must be of type float, got {type(props['recordingStudioLat']).__name__}")
    
        # Type check trackCount (expected int)
        if "trackCount" in props and props["trackCount"] is not None:
            if not isinstance(props["trackCount"], int):
                try:
                    # Attempt to convert
                    props["trackCount"] = int(props["trackCount"])
                except:
                    raise TypeError(f"Property trackCount must be of type int, got {type(props['trackCount']).__name__}")
    
        # Type check streamingCount (expected int)
        if "streamingCount" in props and props["streamingCount"] is not None:
            if not isinstance(props["streamingCount"], int):
                try:
                    # Attempt to convert
                    props["streamingCount"] = int(props["streamingCount"])
                except:
                    raise TypeError(f"Property streamingCount must be of type int, got {type(props['streamingCount']).__name__}")
    
        # Type check lyricist (expected str)
        if "lyricist" in props and props["lyricist"] is not None:
            if not isinstance(props["lyricist"], str):
                try:
                    # Attempt to convert
                    props["lyricist"] = str(props["lyricist"])
                except:
                    raise TypeError(f"Property lyricist must be of type str, got {type(props['lyricist']).__name__}")
    
        # Type check weeksAtNumberOne (expected int)
        if "weeksAtNumberOne" in props and props["weeksAtNumberOne"] is not None:
            if not isinstance(props["weeksAtNumberOne"], int):
                try:
                    # Attempt to convert
                    props["weeksAtNumberOne"] = int(props["weeksAtNumberOne"])
                except:
                    raise TypeError(f"Property weeksAtNumberOne must be of type int, got {type(props['weeksAtNumberOne']).__name__}")
    
        # Type check stringsOnly (expected bool)
        if "stringsOnly" in props and props["stringsOnly"] is not None:
            if not isinstance(props["stringsOnly"], bool):
                try:
                    # Attempt to convert
                    props["stringsOnly"] = bool(props["stringsOnly"])
                except:
                    raise TypeError(f"Property stringsOnly must be of type bool, got {type(props['stringsOnly']).__name__}")
    
        # Type check culturalInfluence (expected str)
        if "culturalInfluence" in props and props["culturalInfluence"] is not None:
            if not isinstance(props["culturalInfluence"], str):
                try:
                    # Attempt to convert
                    props["culturalInfluence"] = str(props["culturalInfluence"])
                except:
                    raise TypeError(f"Property culturalInfluence must be of type str, got {type(props['culturalInfluence']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Soundtrack", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def filminglocation(uuid=None, **props):
        """
        Find nodes with label FilmingLocation matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check longitude (expected float)
        if "longitude" in props and props["longitude"] is not None:
            if not isinstance(props["longitude"], float):
                try:
                    # Attempt to convert
                    props["longitude"] = float(props["longitude"])
                except:
                    raise TypeError(f"Property longitude must be of type float, got {type(props['longitude']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check latitude (expected float)
        if "latitude" in props and props["latitude"] is not None:
            if not isinstance(props["latitude"], float):
                try:
                    # Attempt to convert
                    props["latitude"] = float(props["latitude"])
                except:
                    raise TypeError(f"Property latitude must be of type float, got {type(props['latitude']).__name__}")
    
        # Type check climate (expected str)
        if "climate" in props and props["climate"] is not None:
            if not isinstance(props["climate"], str):
                try:
                    # Attempt to convert
                    props["climate"] = str(props["climate"])
                except:
                    raise TypeError(f"Property climate must be of type str, got {type(props['climate']).__name__}")
    
        # Type check permitCurrency (expected str)
        if "permitCurrency" in props and props["permitCurrency"] is not None:
            if not isinstance(props["permitCurrency"], str):
                try:
                    # Attempt to convert
                    props["permitCurrency"] = str(props["permitCurrency"])
                except:
                    raise TypeError(f"Property permitCurrency must be of type str, got {type(props['permitCurrency']).__name__}")
    
        # Type check firstUsed (expected object)
        if "firstUsed" in props and props["firstUsed"] is not None:
            if not isinstance(props["firstUsed"], object):
                try:
                    # Attempt to convert
                    props["firstUsed"] = object(props["firstUsed"])
                except:
                    raise TypeError(f"Property firstUsed must be of type object, got {type(props['firstUsed']).__name__}")
    
        # Type check permitCost (expected int)
        if "permitCost" in props and props["permitCost"] is not None:
            if not isinstance(props["permitCost"], int):
                try:
                    # Attempt to convert
                    props["permitCost"] = int(props["permitCost"])
                except:
                    raise TypeError(f"Property permitCost must be of type int, got {type(props['permitCost']).__name__}")
    
        # Type check elevationUnit (expected str)
        if "elevationUnit" in props and props["elevationUnit"] is not None:
            if not isinstance(props["elevationUnit"], str):
                try:
                    # Attempt to convert
                    props["elevationUnit"] = str(props["elevationUnit"])
                except:
                    raise TypeError(f"Property elevationUnit must be of type str, got {type(props['elevationUnit']).__name__}")
    
        # Type check region (expected str)
        if "region" in props and props["region"] is not None:
            if not isinstance(props["region"], str):
                try:
                    # Attempt to convert
                    props["region"] = str(props["region"])
                except:
                    raise TypeError(f"Property region must be of type str, got {type(props['region']).__name__}")
    
        # Type check country (expected str)
        if "country" in props and props["country"] is not None:
            if not isinstance(props["country"], str):
                try:
                    # Attempt to convert
                    props["country"] = str(props["country"])
                except:
                    raise TypeError(f"Property country must be of type str, got {type(props['country']).__name__}")
    
        # Type check lastUsed (expected object)
        if "lastUsed" in props and props["lastUsed"] is not None:
            if not isinstance(props["lastUsed"], object):
                try:
                    # Attempt to convert
                    props["lastUsed"] = object(props["lastUsed"])
                except:
                    raise TypeError(f"Property lastUsed must be of type object, got {type(props['lastUsed']).__name__}")
    
        # Type check elevation (expected int)
        if "elevation" in props and props["elevation"] is not None:
            if not isinstance(props["elevation"], int):
                try:
                    # Attempt to convert
                    props["elevation"] = int(props["elevation"])
                except:
                    raise TypeError(f"Property elevation must be of type int, got {type(props['elevation']).__name__}")
    
        # Type check tourismIncrease (expected int)
        if "tourismIncrease" in props and props["tourismIncrease"] is not None:
            if not isinstance(props["tourismIncrease"], int):
                try:
                    # Attempt to convert
                    props["tourismIncrease"] = int(props["tourismIncrease"])
                except:
                    raise TypeError(f"Property tourismIncrease must be of type int, got {type(props['tourismIncrease']).__name__}")
    
        # Type check studioOwned (expected bool)
        if "studioOwned" in props and props["studioOwned"] is not None:
            if not isinstance(props["studioOwned"], bool):
                try:
                    # Attempt to convert
                    props["studioOwned"] = bool(props["studioOwned"])
                except:
                    raise TypeError(f"Property studioOwned must be of type bool, got {type(props['studioOwned']).__name__}")
    
        # Type check filmCount (expected int)
        if "filmCount" in props and props["filmCount"] is not None:
            if not isinstance(props["filmCount"], int):
                try:
                    # Attempt to convert
                    props["filmCount"] = int(props["filmCount"])
                except:
                    raise TypeError(f"Property filmCount must be of type int, got {type(props['filmCount']).__name__}")
    
        # Type check purpose (expected str)
        if "purpose" in props and props["purpose"] is not None:
            if not isinstance(props["purpose"], str):
                try:
                    # Attempt to convert
                    props["purpose"] = str(props["purpose"])
                except:
                    raise TypeError(f"Property purpose must be of type str, got {type(props['purpose']).__name__}")
    
        # Type check buildingAccess (expected str)
        if "buildingAccess" in props and props["buildingAccess"] is not None:
            if not isinstance(props["buildingAccess"], str):
                try:
                    # Attempt to convert
                    props["buildingAccess"] = str(props["buildingAccess"])
                except:
                    raise TypeError(f"Property buildingAccess must be of type str, got {type(props['buildingAccess']).__name__}")
    
        # Type check historicalContext (expected str)
        if "historicalContext" in props and props["historicalContext"] is not None:
            if not isinstance(props["historicalContext"], str):
                try:
                    # Attempt to convert
                    props["historicalContext"] = str(props["historicalContext"])
                except:
                    raise TypeError(f"Property historicalContext must be of type str, got {type(props['historicalContext']).__name__}")
    
        # Type check district (expected str)
        if "district" in props and props["district"] is not None:
            if not isinstance(props["district"], str):
                try:
                    # Attempt to convert
                    props["district"] = str(props["district"])
                except:
                    raise TypeError(f"Property district must be of type str, got {type(props['district']).__name__}")
    
        # Type check culturalSignificance (expected str)
        if "culturalSignificance" in props and props["culturalSignificance"] is not None:
            if not isinstance(props["culturalSignificance"], str):
                try:
                    # Attempt to convert
                    props["culturalSignificance"] = str(props["culturalSignificance"])
                except:
                    raise TypeError(f"Property culturalSignificance must be of type str, got {type(props['culturalSignificance']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="FilmingLocation", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def organization(uuid=None, **props):
        """
        Find nodes with label Organization matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check established (expected object)
        if "established" in props and props["established"] is not None:
            if not isinstance(props["established"], object):
                try:
                    # Attempt to convert
                    props["established"] = object(props["established"])
                except:
                    raise TypeError(f"Property established must be of type object, got {type(props['established']).__name__}")
    
        # Type check earliestPreservedFilm (expected str)
        if "earliestPreservedFilm" in props and props["earliestPreservedFilm"] is not None:
            if not isinstance(props["earliestPreservedFilm"], str):
                try:
                    # Attempt to convert
                    props["earliestPreservedFilm"] = str(props["earliestPreservedFilm"])
                except:
                    raise TypeError(f"Property earliestPreservedFilm must be of type str, got {type(props['earliestPreservedFilm']).__name__}")
    
        # Type check digitalPreservationBudget (expected int)
        if "digitalPreservationBudget" in props and props["digitalPreservationBudget"] is not None:
            if not isinstance(props["digitalPreservationBudget"], int):
                try:
                    # Attempt to convert
                    props["digitalPreservationBudget"] = int(props["digitalPreservationBudget"])
                except:
                    raise TypeError(f"Property digitalPreservationBudget must be of type int, got {type(props['digitalPreservationBudget']).__name__}")
    
        # Type check headquartersLat (expected float)
        if "headquartersLat" in props and props["headquartersLat"] is not None:
            if not isinstance(props["headquartersLat"], float):
                try:
                    # Attempt to convert
                    props["headquartersLat"] = float(props["headquartersLat"])
                except:
                    raise TypeError(f"Property headquartersLat must be of type float, got {type(props['headquartersLat']).__name__}")
    
        # Type check earliestPreservationYear (expected int)
        if "earliestPreservationYear" in props and props["earliestPreservationYear"] is not None:
            if not isinstance(props["earliestPreservationYear"], int):
                try:
                    # Attempt to convert
                    props["earliestPreservationYear"] = int(props["earliestPreservationYear"])
                except:
                    raise TypeError(f"Property earliestPreservationYear must be of type int, got {type(props['earliestPreservationYear']).__name__}")
    
        # Type check earliestFilmYear (expected int)
        if "earliestFilmYear" in props and props["earliestFilmYear"] is not None:
            if not isinstance(props["earliestFilmYear"], int):
                try:
                    # Attempt to convert
                    props["earliestFilmYear"] = int(props["earliestFilmYear"])
                except:
                    raise TypeError(f"Property earliestFilmYear must be of type int, got {type(props['earliestFilmYear']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check preservedFilmsCount (expected int)
        if "preservedFilmsCount" in props and props["preservedFilmsCount"] is not None:
            if not isinstance(props["preservedFilmsCount"], int):
                try:
                    # Attempt to convert
                    props["preservedFilmsCount"] = int(props["preservedFilmsCount"])
                except:
                    raise TypeError(f"Property preservedFilmsCount must be of type int, got {type(props['preservedFilmsCount']).__name__}")
    
        # Type check digitalizedFilmsCount (expected int)
        if "digitalizedFilmsCount" in props and props["digitalizedFilmsCount"] is not None:
            if not isinstance(props["digitalizedFilmsCount"], int):
                try:
                    # Attempt to convert
                    props["digitalizedFilmsCount"] = int(props["digitalizedFilmsCount"])
                except:
                    raise TypeError(f"Property digitalizedFilmsCount must be of type int, got {type(props['digitalizedFilmsCount']).__name__}")
    
        # Type check preservationCriteria (expected object)
        if "preservationCriteria" in props and props["preservationCriteria"] is not None:
            if not isinstance(props["preservationCriteria"], object):
                try:
                    # Attempt to convert
                    props["preservationCriteria"] = object(props["preservationCriteria"])
                except:
                    raise TypeError(f"Property preservationCriteria must be of type object, got {type(props['preservationCriteria']).__name__}")
    
        # Type check criteriaWeights (expected object)
        if "criteriaWeights" in props and props["criteriaWeights"] is not None:
            if not isinstance(props["criteriaWeights"], object):
                try:
                    # Attempt to convert
                    props["criteriaWeights"] = object(props["criteriaWeights"])
                except:
                    raise TypeError(f"Property criteriaWeights must be of type object, got {type(props['criteriaWeights']).__name__}")
    
        # Type check nextPreservationAnnouncement (expected object)
        if "nextPreservationAnnouncement" in props and props["nextPreservationAnnouncement"] is not None:
            if not isinstance(props["nextPreservationAnnouncement"], object):
                try:
                    # Attempt to convert
                    props["nextPreservationAnnouncement"] = object(props["nextPreservationAnnouncement"])
                except:
                    raise TypeError(f"Property nextPreservationAnnouncement must be of type object, got {type(props['nextPreservationAnnouncement']).__name__}")
    
        # Type check annualBudget (expected int)
        if "annualBudget" in props and props["annualBudget"] is not None:
            if not isinstance(props["annualBudget"], int):
                try:
                    # Attempt to convert
                    props["annualBudget"] = int(props["annualBudget"])
                except:
                    raise TypeError(f"Property annualBudget must be of type int, got {type(props['annualBudget']).__name__}")
    
        # Type check headquartersLong (expected float)
        if "headquartersLong" in props and props["headquartersLong"] is not None:
            if not isinstance(props["headquartersLong"], float):
                try:
                    # Attempt to convert
                    props["headquartersLong"] = float(props["headquartersLong"])
                except:
                    raise TypeError(f"Property headquartersLong must be of type float, got {type(props['headquartersLong']).__name__}")
    
        # Type check isGovernmentFunded (expected bool)
        if "isGovernmentFunded" in props and props["isGovernmentFunded"] is not None:
            if not isinstance(props["isGovernmentFunded"], bool):
                try:
                    # Attempt to convert
                    props["isGovernmentFunded"] = bool(props["isGovernmentFunded"])
                except:
                    raise TypeError(f"Property isGovernmentFunded must be of type bool, got {type(props['isGovernmentFunded']).__name__}")
    
        # Type check memberOrganizations (expected int)
        if "memberOrganizations" in props and props["memberOrganizations"] is not None:
            if not isinstance(props["memberOrganizations"], int):
                try:
                    # Attempt to convert
                    props["memberOrganizations"] = int(props["memberOrganizations"])
                except:
                    raise TypeError(f"Property memberOrganizations must be of type int, got {type(props['memberOrganizations']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Organization", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def institution(uuid=None, **props):
        """
        Find nodes with label Institution matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check digitalArchiveSize (expected int)
        if "digitalArchiveSize" in props and props["digitalArchiveSize"] is not None:
            if not isinstance(props["digitalArchiveSize"], int):
                try:
                    # Attempt to convert
                    props["digitalArchiveSize"] = int(props["digitalArchiveSize"])
                except:
                    raise TypeError(f"Property digitalArchiveSize must be of type int, got {type(props['digitalArchiveSize']).__name__}")
    
        # Type check courseCount (expected int)
        if "courseCount" in props and props["courseCount"] is not None:
            if not isinstance(props["courseCount"], int):
                try:
                    # Attempt to convert
                    props["courseCount"] = int(props["courseCount"])
                except:
                    raise TypeError(f"Property courseCount must be of type int, got {type(props['courseCount']).__name__}")
    
        # Type check facultyCount (expected int)
        if "facultyCount" in props and props["facultyCount"] is not None:
            if not isinstance(props["facultyCount"], int):
                try:
                    # Attempt to convert
                    props["facultyCount"] = int(props["facultyCount"])
                except:
                    raise TypeError(f"Property facultyCount must be of type int, got {type(props['facultyCount']).__name__}")
    
        # Type check digitalArchiveUnit (expected str)
        if "digitalArchiveUnit" in props and props["digitalArchiveUnit"] is not None:
            if not isinstance(props["digitalArchiveUnit"], str):
                try:
                    # Attempt to convert
                    props["digitalArchiveUnit"] = str(props["digitalArchiveUnit"])
                except:
                    raise TypeError(f"Property digitalArchiveUnit must be of type str, got {type(props['digitalArchiveUnit']).__name__}")
    
        # Type check filmArchiveSize (expected int)
        if "filmArchiveSize" in props and props["filmArchiveSize"] is not None:
            if not isinstance(props["filmArchiveSize"], int):
                try:
                    # Attempt to convert
                    props["filmArchiveSize"] = int(props["filmArchiveSize"])
                except:
                    raise TypeError(f"Property filmArchiveSize must be of type int, got {type(props['filmArchiveSize']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check annualBudget (expected int)
        if "annualBudget" in props and props["annualBudget"] is not None:
            if not isinstance(props["annualBudget"], int):
                try:
                    # Attempt to convert
                    props["annualBudget"] = int(props["annualBudget"])
                except:
                    raise TypeError(f"Property annualBudget must be of type int, got {type(props['annualBudget']).__name__}")
    
        # Type check founded (expected object)
        if "founded" in props and props["founded"] is not None:
            if not isinstance(props["founded"], object):
                try:
                    # Attempt to convert
                    props["founded"] = object(props["founded"])
                except:
                    raise TypeError(f"Property founded must be of type object, got {type(props['founded']).__name__}")
    
        # Type check studentCount (expected int)
        if "studentCount" in props and props["studentCount"] is not None:
            if not isinstance(props["studentCount"], int):
                try:
                    # Attempt to convert
                    props["studentCount"] = int(props["studentCount"])
                except:
                    raise TypeError(f"Property studentCount must be of type int, got {type(props['studentCount']).__name__}")
    
        # Type check headquartersLong (expected float)
        if "headquartersLong" in props and props["headquartersLong"] is not None:
            if not isinstance(props["headquartersLong"], float):
                try:
                    # Attempt to convert
                    props["headquartersLong"] = float(props["headquartersLong"])
                except:
                    raise TypeError(f"Property headquartersLong must be of type float, got {type(props['headquartersLong']).__name__}")
    
        # Type check headquartersLat (expected float)
        if "headquartersLat" in props and props["headquartersLat"] is not None:
            if not isinstance(props["headquartersLat"], float):
                try:
                    # Attempt to convert
                    props["headquartersLat"] = float(props["headquartersLat"])
                except:
                    raise TypeError(f"Property headquartersLat must be of type float, got {type(props['headquartersLat']).__name__}")
    
        # Type check endowment (expected int)
        if "endowment" in props and props["endowment"] is not None:
            if not isinstance(props["endowment"], int):
                try:
                    # Attempt to convert
                    props["endowment"] = int(props["endowment"])
                except:
                    raise TypeError(f"Property endowment must be of type int, got {type(props['endowment']).__name__}")
    
        # Type check prestigeRanking (expected int)
        if "prestigeRanking" in props and props["prestigeRanking"] is not None:
            if not isinstance(props["prestigeRanking"], int):
                try:
                    # Attempt to convert
                    props["prestigeRanking"] = int(props["prestigeRanking"])
                except:
                    raise TypeError(f"Property prestigeRanking must be of type int, got {type(props['prestigeRanking']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Institution", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def equipment(uuid=None, **props):
        """
        Find nodes with label Equipment matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check weightUnit (expected str)
        if "weightUnit" in props and props["weightUnit"] is not None:
            if not isinstance(props["weightUnit"], str):
                try:
                    # Attempt to convert
                    props["weightUnit"] = str(props["weightUnit"])
                except:
                    raise TypeError(f"Property weightUnit must be of type str, got {type(props['weightUnit']).__name__}")
    
        # Type check featureImpact (expected object)
        if "featureImpact" in props and props["featureImpact"] is not None:
            if not isinstance(props["featureImpact"], object):
                try:
                    # Attempt to convert
                    props["featureImpact"] = object(props["featureImpact"])
                except:
                    raise TypeError(f"Property featureImpact must be of type object, got {type(props['featureImpact']).__name__}")
    
        # Type check manufactured (expected object)
        if "manufactured" in props and props["manufactured"] is not None:
            if not isinstance(props["manufactured"], object):
                try:
                    # Attempt to convert
                    props["manufactured"] = object(props["manufactured"])
                except:
                    raise TypeError(f"Property manufactured must be of type object, got {type(props['manufactured']).__name__}")
    
        # Type check historicalSignificance (expected str)
        if "historicalSignificance" in props and props["historicalSignificance"] is not None:
            if not isinstance(props["historicalSignificance"], str):
                try:
                    # Attempt to convert
                    props["historicalSignificance"] = str(props["historicalSignificance"])
                except:
                    raise TypeError(f"Property historicalSignificance must be of type str, got {type(props['historicalSignificance']).__name__}")
    
        # Type check weight (expected int)
        if "weight" in props and props["weight"] is not None:
            if not isinstance(props["weight"], int):
                try:
                    # Attempt to convert
                    props["weight"] = int(props["weight"])
                except:
                    raise TypeError(f"Property weight must be of type int, got {type(props['weight']).__name__}")
    
        # Type check revolutionaryFeatures (expected object)
        if "revolutionaryFeatures" in props and props["revolutionaryFeatures"] is not None:
            if not isinstance(props["revolutionaryFeatures"], object):
                try:
                    # Attempt to convert
                    props["revolutionaryFeatures"] = object(props["revolutionaryFeatures"])
                except:
                    raise TypeError(f"Property revolutionaryFeatures must be of type object, got {type(props['revolutionaryFeatures']).__name__}")
    
        # Type check manufacturerLong (expected float)
        if "manufacturerLong" in props and props["manufacturerLong"] is not None:
            if not isinstance(props["manufacturerLong"], float):
                try:
                    # Attempt to convert
                    props["manufacturerLong"] = float(props["manufacturerLong"])
                except:
                    raise TypeError(f"Property manufacturerLong must be of type float, got {type(props['manufacturerLong']).__name__}")
    
        # Type check purchaseYear (expected int)
        if "purchaseYear" in props and props["purchaseYear"] is not None:
            if not isinstance(props["purchaseYear"], int):
                try:
                    # Attempt to convert
                    props["purchaseYear"] = int(props["purchaseYear"])
                except:
                    raise TypeError(f"Property purchaseYear must be of type int, got {type(props['purchaseYear']).__name__}")
    
        # Type check cost (expected int)
        if "cost" in props and props["cost"] is not None:
            if not isinstance(props["cost"], int):
                try:
                    # Attempt to convert
                    props["cost"] = int(props["cost"])
                except:
                    raise TypeError(f"Property cost must be of type int, got {type(props['cost']).__name__}")
    
        # Type check technicalSpecifications (expected str)
        if "technicalSpecifications" in props and props["technicalSpecifications"] is not None:
            if not isinstance(props["technicalSpecifications"], str):
                try:
                    # Attempt to convert
                    props["technicalSpecifications"] = str(props["technicalSpecifications"])
                except:
                    raise TypeError(f"Property technicalSpecifications must be of type str, got {type(props['technicalSpecifications']).__name__}")
    
        # Type check manufacturerLat (expected float)
        if "manufacturerLat" in props and props["manufacturerLat"] is not None:
            if not isinstance(props["manufacturerLat"], float):
                try:
                    # Attempt to convert
                    props["manufacturerLat"] = float(props["manufacturerLat"])
                except:
                    raise TypeError(f"Property manufacturerLat must be of type float, got {type(props['manufacturerLat']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Equipment", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def costume(uuid=None, **props):
        """
        Find nodes with label Costume matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check designed (expected object)
        if "designed" in props and props["designed"] is not None:
            if not isinstance(props["designed"], object):
                try:
                    # Attempt to convert
                    props["designed"] = object(props["designed"])
                except:
                    raise TypeError(f"Property designed must be of type object, got {type(props['designed']).__name__}")
    
        # Type check constructionHours (expected int)
        if "constructionHours" in props and props["constructionHours"] is not None:
            if not isinstance(props["constructionHours"], int):
                try:
                    # Attempt to convert
                    props["constructionHours"] = int(props["constructionHours"])
                except:
                    raise TypeError(f"Property constructionHours must be of type int, got {type(props['constructionHours']).__name__}")
    
        # Type check designer (expected str)
        if "designer" in props and props["designer"] is not None:
            if not isinstance(props["designer"], str):
                try:
                    # Attempt to convert
                    props["designer"] = str(props["designer"])
                except:
                    raise TypeError(f"Property designer must be of type str, got {type(props['designer']).__name__}")
    
        # Type check colorPalette (expected object)
        if "colorPalette" in props and props["colorPalette"] is not None:
            if not isinstance(props["colorPalette"], object):
                try:
                    # Attempt to convert
                    props["colorPalette"] = object(props["colorPalette"])
                except:
                    raise TypeError(f"Property colorPalette must be of type object, got {type(props['colorPalette']).__name__}")
    
        # Type check paletteMeaning (expected object)
        if "paletteMeaning" in props and props["paletteMeaning"] is not None:
            if not isinstance(props["paletteMeaning"], object):
                try:
                    # Attempt to convert
                    props["paletteMeaning"] = object(props["paletteMeaning"])
                except:
                    raise TypeError(f"Property paletteMeaning must be of type object, got {type(props['paletteMeaning']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check materialTypes (expected int)
        if "materialTypes" in props and props["materialTypes"] is not None:
            if not isinstance(props["materialTypes"], int):
                try:
                    # Attempt to convert
                    props["materialTypes"] = int(props["materialTypes"])
                except:
                    raise TypeError(f"Property materialTypes must be of type int, got {type(props['materialTypes']).__name__}")
    
        # Type check costumeBudget (expected int)
        if "costumeBudget" in props and props["costumeBudget"] is not None:
            if not isinstance(props["costumeBudget"], int):
                try:
                    # Attempt to convert
                    props["costumeBudget"] = int(props["costumeBudget"])
                except:
                    raise TypeError(f"Property costumeBudget must be of type int, got {type(props['costumeBudget']).__name__}")
    
        # Type check symbolismRating (expected float)
        if "symbolismRating" in props and props["symbolismRating"] is not None:
            if not isinstance(props["symbolismRating"], float):
                try:
                    # Attempt to convert
                    props["symbolismRating"] = float(props["symbolismRating"])
                except:
                    raise TypeError(f"Property symbolismRating must be of type float, got {type(props['symbolismRating']).__name__}")
    
        # Type check costumePieces (expected int)
        if "costumePieces" in props and props["costumePieces"] is not None:
            if not isinstance(props["costumePieces"], int):
                try:
                    # Attempt to convert
                    props["costumePieces"] = int(props["costumePieces"])
                except:
                    raise TypeError(f"Property costumePieces must be of type int, got {type(props['costumePieces']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Costume", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def environmentalfactor(uuid=None, **props):
        """
        Find nodes with label EnvironmentalFactor matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check longitude (expected float)
        if "longitude" in props and props["longitude"] is not None:
            if not isinstance(props["longitude"], float):
                try:
                    # Attempt to convert
                    props["longitude"] = float(props["longitude"])
                except:
                    raise TypeError(f"Property longitude must be of type float, got {type(props['longitude']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check temperatureUnit (expected str)
        if "temperatureUnit" in props and props["temperatureUnit"] is not None:
            if not isinstance(props["temperatureUnit"], str):
                try:
                    # Attempt to convert
                    props["temperatureUnit"] = str(props["temperatureUnit"])
                except:
                    raise TypeError(f"Property temperatureUnit must be of type str, got {type(props['temperatureUnit']).__name__}")
    
        # Type check latitude (expected float)
        if "latitude" in props and props["latitude"] is not None:
            if not isinstance(props["latitude"], float):
                try:
                    # Attempt to convert
                    props["latitude"] = float(props["latitude"])
                except:
                    raise TypeError(f"Property latitude must be of type float, got {type(props['latitude']).__name__}")
    
        # Type check location (expected str)
        if "location" in props and props["location"] is not None:
            if not isinstance(props["location"], str):
                try:
                    # Attempt to convert
                    props["location"] = str(props["location"])
                except:
                    raise TypeError(f"Property location must be of type str, got {type(props['location']).__name__}")
    
        # Type check daylight (expected str)
        if "daylight" in props and props["daylight"] is not None:
            if not isinstance(props["daylight"], str):
                try:
                    # Attempt to convert
                    props["daylight"] = str(props["daylight"])
                except:
                    raise TypeError(f"Property daylight must be of type str, got {type(props['daylight']).__name__}")
    
        # Type check windSpeedMax (expected int)
        if "windSpeedMax" in props and props["windSpeedMax"] is not None:
            if not isinstance(props["windSpeedMax"], int):
                try:
                    # Attempt to convert
                    props["windSpeedMax"] = int(props["windSpeedMax"])
                except:
                    raise TypeError(f"Property windSpeedMax must be of type int, got {type(props['windSpeedMax']).__name__}")
    
        # Type check windSpeedAverage (expected int)
        if "windSpeedAverage" in props and props["windSpeedAverage"] is not None:
            if not isinstance(props["windSpeedAverage"], int):
                try:
                    # Attempt to convert
                    props["windSpeedAverage"] = int(props["windSpeedAverage"])
                except:
                    raise TypeError(f"Property windSpeedAverage must be of type int, got {type(props['windSpeedAverage']).__name__}")
    
        # Type check precipitationAnnual (expected int)
        if "precipitationAnnual" in props and props["precipitationAnnual"] is not None:
            if not isinstance(props["precipitationAnnual"], int):
                try:
                    # Attempt to convert
                    props["precipitationAnnual"] = int(props["precipitationAnnual"])
                except:
                    raise TypeError(f"Property precipitationAnnual must be of type int, got {type(props['precipitationAnnual']).__name__}")
    
        # Type check averageTemperature (expected int)
        if "averageTemperature" in props and props["averageTemperature"] is not None:
            if not isinstance(props["averageTemperature"], int):
                try:
                    # Attempt to convert
                    props["averageTemperature"] = int(props["averageTemperature"])
                except:
                    raise TypeError(f"Property averageTemperature must be of type int, got {type(props['averageTemperature']).__name__}")
    
        # Type check extremityIndex (expected float)
        if "extremityIndex" in props and props["extremityIndex"] is not None:
            if not isinstance(props["extremityIndex"], float):
                try:
                    # Attempt to convert
                    props["extremityIndex"] = float(props["extremityIndex"])
                except:
                    raise TypeError(f"Property extremityIndex must be of type float, got {type(props['extremityIndex']).__name__}")
    
        # Type check windSpeedUnit (expected str)
        if "windSpeedUnit" in props and props["windSpeedUnit"] is not None:
            if not isinstance(props["windSpeedUnit"], str):
                try:
                    # Attempt to convert
                    props["windSpeedUnit"] = str(props["windSpeedUnit"])
                except:
                    raise TypeError(f"Property windSpeedUnit must be of type str, got {type(props['windSpeedUnit']).__name__}")
    
        # Type check precipitationUnit (expected str)
        if "precipitationUnit" in props and props["precipitationUnit"] is not None:
            if not isinstance(props["precipitationUnit"], str):
                try:
                    # Attempt to convert
                    props["precipitationUnit"] = str(props["precipitationUnit"])
                except:
                    raise TypeError(f"Property precipitationUnit must be of type str, got {type(props['precipitationUnit']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="EnvironmentalFactor", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def academicfield(uuid=None, **props):
        """
        Find nodes with label AcademicField matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check established (expected object)
        if "established" in props and props["established"] is not None:
            if not isinstance(props["established"], object):
                try:
                    # Attempt to convert
                    props["established"] = object(props["established"])
                except:
                    raise TypeError(f"Property established must be of type object, got {type(props['established']).__name__}")
    
        # Type check mostCitedTheories (expected object)
        if "mostCitedTheories" in props and props["mostCitedTheories"] is not None:
            if not isinstance(props["mostCitedTheories"], object):
                try:
                    # Attempt to convert
                    props["mostCitedTheories"] = object(props["mostCitedTheories"])
                except:
                    raise TypeError(f"Property mostCitedTheories must be of type object, got {type(props['mostCitedTheories']).__name__}")
    
        # Type check annualPublications (expected int)
        if "annualPublications" in props and props["annualPublications"] is not None:
            if not isinstance(props["annualPublications"], int):
                try:
                    # Attempt to convert
                    props["annualPublications"] = int(props["annualPublications"])
                except:
                    raise TypeError(f"Property annualPublications must be of type int, got {type(props['annualPublications']).__name__}")
    
        # Type check digitalArchives (expected int)
        if "digitalArchives" in props and props["digitalArchives"] is not None:
            if not isinstance(props["digitalArchives"], int):
                try:
                    # Attempt to convert
                    props["digitalArchives"] = int(props["digitalArchives"])
                except:
                    raise TypeError(f"Property digitalArchives must be of type int, got {type(props['digitalArchives']).__name__}")
    
        # Type check institutionsCount (expected int)
        if "institutionsCount" in props and props["institutionsCount"] is not None:
            if not isinstance(props["institutionsCount"], int):
                try:
                    # Attempt to convert
                    props["institutionsCount"] = int(props["institutionsCount"])
                except:
                    raise TypeError(f"Property institutionsCount must be of type int, got {type(props['institutionsCount']).__name__}")
    
        # Type check peerReviewedJournals (expected int)
        if "peerReviewedJournals" in props and props["peerReviewedJournals"] is not None:
            if not isinstance(props["peerReviewedJournals"], int):
                try:
                    # Attempt to convert
                    props["peerReviewedJournals"] = int(props["peerReviewedJournals"])
                except:
                    raise TypeError(f"Property peerReviewedJournals must be of type int, got {type(props['peerReviewedJournals']).__name__}")
    
        # Type check theoriesDevelopmentYears (expected object)
        if "theoriesDevelopmentYears" in props and props["theoriesDevelopmentYears"] is not None:
            if not isinstance(props["theoriesDevelopmentYears"], object):
                try:
                    # Attempt to convert
                    props["theoriesDevelopmentYears"] = object(props["theoriesDevelopmentYears"])
                except:
                    raise TypeError(f"Property theoriesDevelopmentYears must be of type object, got {type(props['theoriesDevelopmentYears']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check scholarCount (expected int)
        if "scholarCount" in props and props["scholarCount"] is not None:
            if not isinstance(props["scholarCount"], int):
                try:
                    # Attempt to convert
                    props["scholarCount"] = int(props["scholarCount"])
                except:
                    raise TypeError(f"Property scholarCount must be of type int, got {type(props['scholarCount']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="AcademicField", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def culturalmovement(uuid=None, **props):
        """
        Find nodes with label CulturalMovement matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check influentialDirectors (expected int)
        if "influentialDirectors" in props and props["influentialDirectors"] is not None:
            if not isinstance(props["influentialDirectors"], int):
                try:
                    # Attempt to convert
                    props["influentialDirectors"] = int(props["influentialDirectors"])
                except:
                    raise TypeError(f"Property influentialDirectors must be of type int, got {type(props['influentialDirectors']).__name__}")
    
        # Type check academicStudies (expected int)
        if "academicStudies" in props and props["academicStudies"] is not None:
            if not isinstance(props["academicStudies"], int):
                try:
                    # Attempt to convert
                    props["academicStudies"] = int(props["academicStudies"])
                except:
                    raise TypeError(f"Property academicStudies must be of type int, got {type(props['academicStudies']).__name__}")
    
        # Type check established (expected object)
        if "established" in props and props["established"] is not None:
            if not isinstance(props["established"], object):
                try:
                    # Attempt to convert
                    props["established"] = object(props["established"])
                except:
                    raise TypeError(f"Property established must be of type object, got {type(props['established']).__name__}")
    
        # Type check criticalReception (expected str)
        if "criticalReception" in props and props["criticalReception"] is not None:
            if not isinstance(props["criticalReception"], str):
                try:
                    # Attempt to convert
                    props["criticalReception"] = str(props["criticalReception"])
                except:
                    raise TypeError(f"Property criticalReception must be of type str, got {type(props['criticalReception']).__name__}")
    
        # Type check internationalFestivals (expected int)
        if "internationalFestivals" in props and props["internationalFestivals"] is not None:
            if not isinstance(props["internationalFestivals"], int):
                try:
                    # Attempt to convert
                    props["internationalFestivals"] = int(props["internationalFestivals"])
                except:
                    raise TypeError(f"Property internationalFestivals must be of type int, got {type(props['internationalFestivals']).__name__}")
    
        # Type check periodStart (expected object)
        if "periodStart" in props and props["periodStart"] is not None:
            if not isinstance(props["periodStart"], object):
                try:
                    # Attempt to convert
                    props["periodStart"] = object(props["periodStart"])
                except:
                    raise TypeError(f"Property periodStart must be of type object, got {type(props['periodStart']).__name__}")
    
        # Type check periodPeak (expected object)
        if "periodPeak" in props and props["periodPeak"] is not None:
            if not isinstance(props["periodPeak"], object):
                try:
                    # Attempt to convert
                    props["periodPeak"] = object(props["periodPeak"])
                except:
                    raise TypeError(f"Property periodPeak must be of type object, got {type(props['periodPeak']).__name__}")
    
        # Type check geographicalSpread (expected str)
        if "geographicalSpread" in props and props["geographicalSpread"] is not None:
            if not isinstance(props["geographicalSpread"], str):
                try:
                    # Attempt to convert
                    props["geographicalSpread"] = str(props["geographicalSpread"])
                except:
                    raise TypeError(f"Property geographicalSpread must be of type str, got {type(props['geographicalSpread']).__name__}")
    
        # Type check majorAwards (expected int)
        if "majorAwards" in props and props["majorAwards"] is not None:
            if not isinstance(props["majorAwards"], int):
                try:
                    # Attempt to convert
                    props["majorAwards"] = int(props["majorAwards"])
                except:
                    raise TypeError(f"Property majorAwards must be of type int, got {type(props['majorAwards']).__name__}")
    
        # Type check politicalImpact (expected str)
        if "politicalImpact" in props and props["politicalImpact"] is not None:
            if not isinstance(props["politicalImpact"], str):
                try:
                    # Attempt to convert
                    props["politicalImpact"] = str(props["politicalImpact"])
                except:
                    raise TypeError(f"Property politicalImpact must be of type str, got {type(props['politicalImpact']).__name__}")
    
        # Type check influentialWorks (expected int)
        if "influentialWorks" in props and props["influentialWorks"] is not None:
            if not isinstance(props["influentialWorks"], int):
                try:
                    # Attempt to convert
                    props["influentialWorks"] = int(props["influentialWorks"])
                except:
                    raise TypeError(f"Property influentialWorks must be of type int, got {type(props['influentialWorks']).__name__}")
    
        # Type check culturalInstitutions (expected int)
        if "culturalInstitutions" in props and props["culturalInstitutions"] is not None:
            if not isinstance(props["culturalInstitutions"], int):
                try:
                    # Attempt to convert
                    props["culturalInstitutions"] = int(props["culturalInstitutions"])
                except:
                    raise TypeError(f"Property culturalInstitutions must be of type int, got {type(props['culturalInstitutions']).__name__}")
    
        # Type check formalized (expected object)
        if "formalized" in props and props["formalized"] is not None:
            if not isinstance(props["formalized"], object):
                try:
                    # Attempt to convert
                    props["formalized"] = object(props["formalized"])
                except:
                    raise TypeError(f"Property formalized must be of type object, got {type(props['formalized']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="CulturalMovement", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def techcompany(uuid=None, **props):
        """
        Find nodes with label TechCompany matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check oscarsWon (expected int)
        if "oscarsWon" in props and props["oscarsWon"] is not None:
            if not isinstance(props["oscarsWon"], int):
                try:
                    # Attempt to convert
                    props["oscarsWon"] = int(props["oscarsWon"])
                except:
                    raise TypeError(f"Property oscarsWon must be of type int, got {type(props['oscarsWon']).__name__}")
    
        # Type check technologyPatents (expected int)
        if "technologyPatents" in props and props["technologyPatents"] is not None:
            if not isinstance(props["technologyPatents"], int):
                try:
                    # Attempt to convert
                    props["technologyPatents"] = int(props["technologyPatents"])
                except:
                    raise TypeError(f"Property technologyPatents must be of type int, got {type(props['technologyPatents']).__name__}")
    
        # Type check annualRevenue (expected int)
        if "annualRevenue" in props and props["annualRevenue"] is not None:
            if not isinstance(props["annualRevenue"], int):
                try:
                    # Attempt to convert
                    props["annualRevenue"] = int(props["annualRevenue"])
                except:
                    raise TypeError(f"Property annualRevenue must be of type int, got {type(props['annualRevenue']).__name__}")
    
        # Type check proprietarySoftware (expected int)
        if "proprietarySoftware" in props and props["proprietarySoftware"] is not None:
            if not isinstance(props["proprietarySoftware"], int):
                try:
                    # Attempt to convert
                    props["proprietarySoftware"] = int(props["proprietarySoftware"])
                except:
                    raise TypeError(f"Property proprietarySoftware must be of type int, got {type(props['proprietarySoftware']).__name__}")
    
        # Type check computingUnit (expected str)
        if "computingUnit" in props and props["computingUnit"] is not None:
            if not isinstance(props["computingUnit"], str):
                try:
                    # Attempt to convert
                    props["computingUnit"] = str(props["computingUnit"])
                except:
                    raise TypeError(f"Property computingUnit must be of type str, got {type(props['computingUnit']).__name__}")
    
        # Type check technicalAwards (expected int)
        if "technicalAwards" in props and props["technicalAwards"] is not None:
            if not isinstance(props["technicalAwards"], int):
                try:
                    # Attempt to convert
                    props["technicalAwards"] = int(props["technicalAwards"])
                except:
                    raise TypeError(f"Property technicalAwards must be of type int, got {type(props['technicalAwards']).__name__}")
    
        # Type check employeeCount (expected int)
        if "employeeCount" in props and props["employeeCount"] is not None:
            if not isinstance(props["employeeCount"], int):
                try:
                    # Attempt to convert
                    props["employeeCount"] = int(props["employeeCount"])
                except:
                    raise TypeError(f"Property employeeCount must be of type int, got {type(props['employeeCount']).__name__}")
    
        # Type check founded (expected object)
        if "founded" in props and props["founded"] is not None:
            if not isinstance(props["founded"], object):
                try:
                    # Attempt to convert
                    props["founded"] = object(props["founded"])
                except:
                    raise TypeError(f"Property founded must be of type object, got {type(props['founded']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check computingPower (expected int)
        if "computingPower" in props and props["computingPower"] is not None:
            if not isinstance(props["computingPower"], int):
                try:
                    # Attempt to convert
                    props["computingPower"] = int(props["computingPower"])
                except:
                    raise TypeError(f"Property computingPower must be of type int, got {type(props['computingPower']).__name__}")
    
        # Type check headquartersLong (expected float)
        if "headquartersLong" in props and props["headquartersLong"] is not None:
            if not isinstance(props["headquartersLong"], float):
                try:
                    # Attempt to convert
                    props["headquartersLong"] = float(props["headquartersLong"])
                except:
                    raise TypeError(f"Property headquartersLong must be of type float, got {type(props['headquartersLong']).__name__}")
    
        # Type check headquartersLat (expected float)
        if "headquartersLat" in props and props["headquartersLat"] is not None:
            if not isinstance(props["headquartersLat"], float):
                try:
                    # Attempt to convert
                    props["headquartersLat"] = float(props["headquartersLat"])
                except:
                    raise TypeError(f"Property headquartersLat must be of type float, got {type(props['headquartersLat']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="TechCompany", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def attraction(uuid=None, **props):
        """
        Find nodes with label Attraction matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check locationLat (expected float)
        if "locationLat" in props and props["locationLat"] is not None:
            if not isinstance(props["locationLat"], float):
                try:
                    # Attempt to convert
                    props["locationLat"] = float(props["locationLat"])
                except:
                    raise TypeError(f"Property locationLat must be of type float, got {type(props['locationLat']).__name__}")
    
        # Type check opened (expected object)
        if "opened" in props and props["opened"] is not None:
            if not isinstance(props["opened"], object):
                try:
                    # Attempt to convert
                    props["opened"] = object(props["opened"])
                except:
                    raise TypeError(f"Property opened must be of type object, got {type(props['opened']).__name__}")
    
        # Type check developmentCost (expected int)
        if "developmentCost" in props and props["developmentCost"] is not None:
            if not isinstance(props["developmentCost"], int):
                try:
                    # Attempt to convert
                    props["developmentCost"] = int(props["developmentCost"])
                except:
                    raise TypeError(f"Property developmentCost must be of type int, got {type(props['developmentCost']).__name__}")
    
        # Type check visitorCapacity (expected int)
        if "visitorCapacity" in props and props["visitorCapacity"] is not None:
            if not isinstance(props["visitorCapacity"], int):
                try:
                    # Attempt to convert
                    props["visitorCapacity"] = int(props["visitorCapacity"])
                except:
                    raise TypeError(f"Property visitorCapacity must be of type int, got {type(props['visitorCapacity']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check historicalArtifacts (expected int)
        if "historicalArtifacts" in props and props["historicalArtifacts"] is not None:
            if not isinstance(props["historicalArtifacts"], int):
                try:
                    # Attempt to convert
                    props["historicalArtifacts"] = int(props["historicalArtifacts"])
                except:
                    raise TypeError(f"Property historicalArtifacts must be of type int, got {type(props['historicalArtifacts']).__name__}")
    
        # Type check interactiveElements (expected int)
        if "interactiveElements" in props and props["interactiveElements"] is not None:
            if not isinstance(props["interactiveElements"], int):
                try:
                    # Attempt to convert
                    props["interactiveElements"] = int(props["interactiveElements"])
                except:
                    raise TypeError(f"Property interactiveElements must be of type int, got {type(props['interactiveElements']).__name__}")
    
        # Type check sizeUnit (expected str)
        if "sizeUnit" in props and props["sizeUnit"] is not None:
            if not isinstance(props["sizeUnit"], str):
                try:
                    # Attempt to convert
                    props["sizeUnit"] = str(props["sizeUnit"])
                except:
                    raise TypeError(f"Property sizeUnit must be of type str, got {type(props['sizeUnit']).__name__}")
    
        # Type check visitorDuration (expected object)
        if "visitorDuration" in props and props["visitorDuration"] is not None:
            if not isinstance(props["visitorDuration"], object):
                try:
                    # Attempt to convert
                    props["visitorDuration"] = object(props["visitorDuration"])
                except:
                    raise TypeError(f"Property visitorDuration must be of type object, got {type(props['visitorDuration']).__name__}")
    
        # Type check locationLong (expected float)
        if "locationLong" in props and props["locationLong"] is not None:
            if not isinstance(props["locationLong"], float):
                try:
                    # Attempt to convert
                    props["locationLong"] = float(props["locationLong"])
                except:
                    raise TypeError(f"Property locationLong must be of type float, got {type(props['locationLong']).__name__}")
    
        # Type check exhibitSize (expected int)
        if "exhibitSize" in props and props["exhibitSize"] is not None:
            if not isinstance(props["exhibitSize"], int):
                try:
                    # Attempt to convert
                    props["exhibitSize"] = int(props["exhibitSize"])
                except:
                    raise TypeError(f"Property exhibitSize must be of type int, got {type(props['exhibitSize']).__name__}")
    
        # Type check annualVisitors (expected int)
        if "annualVisitors" in props and props["annualVisitors"] is not None:
            if not isinstance(props["annualVisitors"], int):
                try:
                    # Attempt to convert
                    props["annualVisitors"] = int(props["annualVisitors"])
                except:
                    raise TypeError(f"Property annualVisitors must be of type int, got {type(props['annualVisitors']).__name__}")
    
        # Type check historicalSites (expected int)
        if "historicalSites" in props and props["historicalSites"] is not None:
            if not isinstance(props["historicalSites"], int):
                try:
                    # Attempt to convert
                    props["historicalSites"] = int(props["historicalSites"])
                except:
                    raise TypeError(f"Property historicalSites must be of type int, got {type(props['historicalSites']).__name__}")
    
        # Type check lengthUnit (expected str)
        if "lengthUnit" in props and props["lengthUnit"] is not None:
            if not isinstance(props["lengthUnit"], str):
                try:
                    # Attempt to convert
                    props["lengthUnit"] = str(props["lengthUnit"])
                except:
                    raise TypeError(f"Property lengthUnit must be of type str, got {type(props['lengthUnit']).__name__}")
    
        # Type check routeLength (expected int)
        if "routeLength" in props and props["routeLength"] is not None:
            if not isinstance(props["routeLength"], int):
                try:
                    # Attempt to convert
                    props["routeLength"] = int(props["routeLength"])
                except:
                    raise TypeError(f"Property routeLength must be of type int, got {type(props['routeLength']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Attraction", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def merchandise(uuid=None, **props):
        """
        Find nodes with label Merchandise matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check contributionPercentage (expected float)
        if "contributionPercentage" in props and props["contributionPercentage"] is not None:
            if not isinstance(props["contributionPercentage"], float):
                try:
                    # Attempt to convert
                    props["contributionPercentage"] = float(props["contributionPercentage"])
                except:
                    raise TypeError(f"Property contributionPercentage must be of type float, got {type(props['contributionPercentage']).__name__}")
    
        # Type check retailPrice (expected float)
        if "retailPrice" in props and props["retailPrice"] is not None:
            if not isinstance(props["retailPrice"], float):
                try:
                    # Attempt to convert
                    props["retailPrice"] = float(props["retailPrice"])
                except:
                    raise TypeError(f"Property retailPrice must be of type float, got {type(props['retailPrice']).__name__}")
    
        # Type check conservationContribution (expected float)
        if "conservationContribution" in props and props["conservationContribution"] is not None:
            if not isinstance(props["conservationContribution"], float):
                try:
                    # Attempt to convert
                    props["conservationContribution"] = float(props["conservationContribution"])
                except:
                    raise TypeError(f"Property conservationContribution must be of type float, got {type(props['conservationContribution']).__name__}")
    
        # Type check manufacturerLocationLong (expected float)
        if "manufacturerLocationLong" in props and props["manufacturerLocationLong"] is not None:
            if not isinstance(props["manufacturerLocationLong"], float):
                try:
                    # Attempt to convert
                    props["manufacturerLocationLong"] = float(props["manufacturerLocationLong"])
                except:
                    raise TypeError(f"Property manufacturerLocationLong must be of type float, got {type(props['manufacturerLocationLong']).__name__}")
    
        # Type check priceCurrency (expected str)
        if "priceCurrency" in props and props["priceCurrency"] is not None:
            if not isinstance(props["priceCurrency"], str):
                try:
                    # Attempt to convert
                    props["priceCurrency"] = str(props["priceCurrency"])
                except:
                    raise TypeError(f"Property priceCurrency must be of type str, got {type(props['priceCurrency']).__name__}")
    
        # Type check manufacturerLocationLat (expected float)
        if "manufacturerLocationLat" in props and props["manufacturerLocationLat"] is not None:
            if not isinstance(props["manufacturerLocationLat"], float):
                try:
                    # Attempt to convert
                    props["manufacturerLocationLat"] = float(props["manufacturerLocationLat"])
                except:
                    raise TypeError(f"Property manufacturerLocationLat must be of type float, got {type(props['manufacturerLocationLat']).__name__}")
    
        # Type check educationalMaterials (expected bool)
        if "educationalMaterials" in props and props["educationalMaterials"] is not None:
            if not isinstance(props["educationalMaterials"], bool):
                try:
                    # Attempt to convert
                    props["educationalMaterials"] = bool(props["educationalMaterials"])
                except:
                    raise TypeError(f"Property educationalMaterials must be of type bool, got {type(props['educationalMaterials']).__name__}")
    
        # Type check released (expected object)
        if "released" in props and props["released"] is not None:
            if not isinstance(props["released"], object):
                try:
                    # Attempt to convert
                    props["released"] = object(props["released"])
                except:
                    raise TypeError(f"Property released must be of type object, got {type(props['released']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check productionRun (expected int)
        if "productionRun" in props and props["productionRun"] is not None:
            if not isinstance(props["productionRun"], int):
                try:
                    # Attempt to convert
                    props["productionRun"] = int(props["productionRun"])
                except:
                    raise TypeError(f"Property productionRun must be of type int, got {type(props['productionRun']).__name__}")
    
        # Type check ageRange (expected str)
        if "ageRange" in props and props["ageRange"] is not None:
            if not isinstance(props["ageRange"], str):
                try:
                    # Attempt to convert
                    props["ageRange"] = str(props["ageRange"])
                except:
                    raise TypeError(f"Property ageRange must be of type str, got {type(props['ageRange']).__name__}")
    
        # Type check manufacturer (expected str)
        if "manufacturer" in props and props["manufacturer"] is not None:
            if not isinstance(props["manufacturer"], str):
                try:
                    # Attempt to convert
                    props["manufacturer"] = str(props["manufacturer"])
                except:
                    raise TypeError(f"Property manufacturer must be of type str, got {type(props['manufacturer']).__name__}")
    
        # Type check limitedEdition (expected bool)
        if "limitedEdition" in props and props["limitedEdition"] is not None:
            if not isinstance(props["limitedEdition"], bool):
                try:
                    # Attempt to convert
                    props["limitedEdition"] = bool(props["limitedEdition"])
                except:
                    raise TypeError(f"Property limitedEdition must be of type bool, got {type(props['limitedEdition']).__name__}")
    
        # Type check packagingInnovation (expected str)
        if "packagingInnovation" in props and props["packagingInnovation"] is not None:
            if not isinstance(props["packagingInnovation"], str):
                try:
                    # Attempt to convert
                    props["packagingInnovation"] = str(props["packagingInnovation"])
                except:
                    raise TypeError(f"Property packagingInnovation must be of type str, got {type(props['packagingInnovation']).__name__}")
    
        # Type check specialFeatures (expected int)
        if "specialFeatures" in props and props["specialFeatures"] is not None:
            if not isinstance(props["specialFeatures"], int):
                try:
                    # Attempt to convert
                    props["specialFeatures"] = int(props["specialFeatures"])
                except:
                    raise TypeError(f"Property specialFeatures must be of type int, got {type(props['specialFeatures']).__name__}")
    
        # Type check collectorValue (expected str)
        if "collectorValue" in props and props["collectorValue"] is not None:
            if not isinstance(props["collectorValue"], str):
                try:
                    # Attempt to convert
                    props["collectorValue"] = str(props["collectorValue"])
                except:
                    raise TypeError(f"Property collectorValue must be of type str, got {type(props['collectorValue']).__name__}")
    
        # Type check materialQuality (expected str)
        if "materialQuality" in props and props["materialQuality"] is not None:
            if not isinstance(props["materialQuality"], str):
                try:
                    # Attempt to convert
                    props["materialQuality"] = str(props["materialQuality"])
                except:
                    raise TypeError(f"Property materialQuality must be of type str, got {type(props['materialQuality']).__name__}")
    
        # Type check marketingTagline (expected str)
        if "marketingTagline" in props and props["marketingTagline"] is not None:
            if not isinstance(props["marketingTagline"], str):
                try:
                    # Attempt to convert
                    props["marketingTagline"] = str(props["marketingTagline"])
                except:
                    raise TypeError(f"Property marketingTagline must be of type str, got {type(props['marketingTagline']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Merchandise", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def educationalprogram(uuid=None, **props):
        """
        Find nodes with label EducationalProgram matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check developed (expected object)
        if "developed" in props and props["developed"] is not None:
            if not isinstance(props["developed"], object):
                try:
                    # Attempt to convert
                    props["developed"] = object(props["developed"])
                except:
                    raise TypeError(f"Property developed must be of type object, got {type(props['developed']).__name__}")
    
        # Type check scholarlyEndorsements (expected int)
        if "scholarlyEndorsements" in props and props["scholarlyEndorsements"] is not None:
            if not isinstance(props["scholarlyEndorsements"], int):
                try:
                    # Attempt to convert
                    props["scholarlyEndorsements"] = int(props["scholarlyEndorsements"])
                except:
                    raise TypeError(f"Property scholarlyEndorsements must be of type int, got {type(props['scholarlyEndorsements']).__name__}")
    
        # Type check educatorRating (expected float)
        if "educatorRating" in props and props["educatorRating"] is not None:
            if not isinstance(props["educatorRating"], float):
                try:
                    # Attempt to convert
                    props["educatorRating"] = float(props["educatorRating"])
                except:
                    raise TypeError(f"Property educatorRating must be of type float, got {type(props['educatorRating']).__name__}")
    
        # Type check languagesAvailable (expected int)
        if "languagesAvailable" in props and props["languagesAvailable"] is not None:
            if not isinstance(props["languagesAvailable"], int):
                try:
                    # Attempt to convert
                    props["languagesAvailable"] = int(props["languagesAvailable"])
                except:
                    raise TypeError(f"Property languagesAvailable must be of type int, got {type(props['languagesAvailable']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check courseDuration (expected object)
        if "courseDuration" in props and props["courseDuration"] is not None:
            if not isinstance(props["courseDuration"], object):
                try:
                    # Attempt to convert
                    props["courseDuration"] = object(props["courseDuration"])
                except:
                    raise TypeError(f"Property courseDuration must be of type object, got {type(props['courseDuration']).__name__}")
    
        # Type check institutionsAdopting (expected int)
        if "institutionsAdopting" in props and props["institutionsAdopting"] is not None:
            if not isinstance(props["institutionsAdopting"], int):
                try:
                    # Attempt to convert
                    props["institutionsAdopting"] = int(props["institutionsAdopting"])
                except:
                    raise TypeError(f"Property institutionsAdopting must be of type int, got {type(props['institutionsAdopting']).__name__}")
    
        # Type check materialFormats (expected object)
        if "materialFormats" in props and props["materialFormats"] is not None:
            if not isinstance(props["materialFormats"], object):
                try:
                    # Attempt to convert
                    props["materialFormats"] = object(props["materialFormats"])
                except:
                    raise TypeError(f"Property materialFormats must be of type object, got {type(props['materialFormats']).__name__}")
    
        # Type check targetEducationLevels (expected object)
        if "targetEducationLevels" in props and props["targetEducationLevels"] is not None:
            if not isinstance(props["targetEducationLevels"], object):
                try:
                    # Attempt to convert
                    props["targetEducationLevels"] = object(props["targetEducationLevels"])
                except:
                    raise TypeError(f"Property targetEducationLevels must be of type object, got {type(props['targetEducationLevels']).__name__}")
    
        # Type check totalLessonHours (expected int)
        if "totalLessonHours" in props and props["totalLessonHours"] is not None:
            if not isinstance(props["totalLessonHours"], int):
                try:
                    # Attempt to convert
                    props["totalLessonHours"] = int(props["totalLessonHours"])
                except:
                    raise TypeError(f"Property totalLessonHours must be of type int, got {type(props['totalLessonHours']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="EducationalProgram", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def digitalproject(uuid=None, **props):
        """
        Find nodes with label DigitalProject matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check storageSizeUnit (expected str)
        if "storageSizeUnit" in props and props["storageSizeUnit"] is not None:
            if not isinstance(props["storageSizeUnit"], str):
                try:
                    # Attempt to convert
                    props["storageSizeUnit"] = str(props["storageSizeUnit"])
                except:
                    raise TypeError(f"Property storageSizeUnit must be of type str, got {type(props['storageSizeUnit']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check finalMasterUnit (expected str)
        if "finalMasterUnit" in props and props["finalMasterUnit"] is not None:
            if not isinstance(props["finalMasterUnit"], str):
                try:
                    # Attempt to convert
                    props["finalMasterUnit"] = str(props["finalMasterUnit"])
                except:
                    raise TypeError(f"Property finalMasterUnit must be of type str, got {type(props['finalMasterUnit']).__name__}")
    
        # Type check budget (expected int)
        if "budget" in props and props["budget"] is not None:
            if not isinstance(props["budget"], int):
                try:
                    # Attempt to convert
                    props["budget"] = int(props["budget"])
                except:
                    raise TypeError(f"Property budget must be of type int, got {type(props['budget']).__name__}")
    
        # Type check resolutionOutput (expected str)
        if "resolutionOutput" in props and props["resolutionOutput"] is not None:
            if not isinstance(props["resolutionOutput"], str):
                try:
                    # Attempt to convert
                    props["resolutionOutput"] = str(props["resolutionOutput"])
                except:
                    raise TypeError(f"Property resolutionOutput must be of type str, got {type(props['resolutionOutput']).__name__}")
    
        # Type check finalMasterSize (expected int)
        if "finalMasterSize" in props and props["finalMasterSize"] is not None:
            if not isinstance(props["finalMasterSize"], int):
                try:
                    # Attempt to convert
                    props["finalMasterSize"] = int(props["finalMasterSize"])
                except:
                    raise TypeError(f"Property finalMasterSize must be of type int, got {type(props['finalMasterSize']).__name__}")
    
        # Type check completed (expected object)
        if "completed" in props and props["completed"] is not None:
            if not isinstance(props["completed"], object):
                try:
                    # Attempt to convert
                    props["completed"] = object(props["completed"])
                except:
                    raise TypeError(f"Property completed must be of type object, got {type(props['completed']).__name__}")
    
        # Type check colorDepth (expected str)
        if "colorDepth" in props and props["colorDepth"] is not None:
            if not isinstance(props["colorDepth"], str):
                try:
                    # Attempt to convert
                    props["colorDepth"] = str(props["colorDepth"])
                except:
                    raise TypeError(f"Property colorDepth must be of type str, got {type(props['colorDepth']).__name__}")
    
        # Type check teamSize (expected int)
        if "teamSize" in props and props["teamSize"] is not None:
            if not isinstance(props["teamSize"], int):
                try:
                    # Attempt to convert
                    props["teamSize"] = int(props["teamSize"])
                except:
                    raise TypeError(f"Property teamSize must be of type int, got {type(props['teamSize']).__name__}")
    
        # Type check storageSizeRaw (expected int)
        if "storageSizeRaw" in props and props["storageSizeRaw"] is not None:
            if not isinstance(props["storageSizeRaw"], int):
                try:
                    # Attempt to convert
                    props["storageSizeRaw"] = int(props["storageSizeRaw"])
                except:
                    raise TypeError(f"Property storageSizeRaw must be of type int, got {type(props['storageSizeRaw']).__name__}")
    
        # Type check originalNegativeUsed (expected bool)
        if "originalNegativeUsed" in props and props["originalNegativeUsed"] is not None:
            if not isinstance(props["originalNegativeUsed"], bool):
                try:
                    # Attempt to convert
                    props["originalNegativeUsed"] = bool(props["originalNegativeUsed"])
                except:
                    raise TypeError(f"Property originalNegativeUsed must be of type bool, got {type(props['originalNegativeUsed']).__name__}")
    
        # Type check started (expected object)
        if "started" in props and props["started"] is not None:
            if not isinstance(props["started"], object):
                try:
                    # Attempt to convert
                    props["started"] = object(props["started"])
                except:
                    raise TypeError(f"Property started must be of type object, got {type(props['started']).__name__}")
    
        # Type check supervisionLevel (expected str)
        if "supervisionLevel" in props and props["supervisionLevel"] is not None:
            if not isinstance(props["supervisionLevel"], str):
                try:
                    # Attempt to convert
                    props["supervisionLevel"] = str(props["supervisionLevel"])
                except:
                    raise TypeError(f"Property supervisionLevel must be of type str, got {type(props['supervisionLevel']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="DigitalProject", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def fancommunity(uuid=None, **props):
        """
        Find nodes with label FanCommunity matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check established (expected object)
        if "established" in props and props["established"] is not None:
            if not isinstance(props["established"], object):
                try:
                    # Attempt to convert
                    props["established"] = object(props["established"])
                except:
                    raise TypeError(f"Property established must be of type object, got {type(props['established']).__name__}")
    
        # Type check fanfictionCount (expected int)
        if "fanfictionCount" in props and props["fanfictionCount"] is not None:
            if not isinstance(props["fanfictionCount"], int):
                try:
                    # Attempt to convert
                    props["fanfictionCount"] = int(props["fanfictionCount"])
                except:
                    raise TypeError(f"Property fanfictionCount must be of type int, got {type(props['fanfictionCount']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check expansion2049 (expected object)
        if "expansion2049" in props and props["expansion2049"] is not None:
            if not isinstance(props["expansion2049"], object):
                try:
                    # Attempt to convert
                    props["expansion2049"] = object(props["expansion2049"])
                except:
                    raise TypeError(f"Property expansion2049 must be of type object, got {type(props['expansion2049']).__name__}")
    
        # Type check largestEventAttendance (expected int)
        if "largestEventAttendance" in props and props["largestEventAttendance"] is not None:
            if not isinstance(props["largestEventAttendance"], int):
                try:
                    # Attempt to convert
                    props["largestEventAttendance"] = int(props["largestEventAttendance"])
                except:
                    raise TypeError(f"Property largestEventAttendance must be of type int, got {type(props['largestEventAttendance']).__name__}")
    
        # Type check academicPapers (expected int)
        if "academicPapers" in props and props["academicPapers"] is not None:
            if not isinstance(props["academicPapers"], int):
                try:
                    # Attempt to convert
                    props["academicPapers"] = int(props["academicPapers"])
                except:
                    raise TypeError(f"Property academicPapers must be of type int, got {type(props['academicPapers']).__name__}")
    
        # Type check contentCreators (expected int)
        if "contentCreators" in props and props["contentCreators"] is not None:
            if not isinstance(props["contentCreators"], int):
                try:
                    # Attempt to convert
                    props["contentCreators"] = int(props["contentCreators"])
                except:
                    raise TypeError(f"Property contentCreators must be of type int, got {type(props['contentCreators']).__name__}")
    
        # Type check memberCount (expected int)
        if "memberCount" in props and props["memberCount"] is not None:
            if not isinstance(props["memberCount"], int):
                try:
                    # Attempt to convert
                    props["memberCount"] = int(props["memberCount"])
                except:
                    raise TypeError(f"Property memberCount must be of type int, got {type(props['memberCount']).__name__}")
    
        # Type check annualConventions (expected int)
        if "annualConventions" in props and props["annualConventions"] is not None:
            if not isinstance(props["annualConventions"], int):
                try:
                    # Attempt to convert
                    props["annualConventions"] = int(props["annualConventions"])
                except:
                    raise TypeError(f"Property annualConventions must be of type int, got {type(props['annualConventions']).__name__}")
    
        # Type check fanArtCount (expected int)
        if "fanArtCount" in props and props["fanArtCount"] is not None:
            if not isinstance(props["fanArtCount"], int):
                try:
                    # Attempt to convert
                    props["fanArtCount"] = int(props["fanArtCount"])
                except:
                    raise TypeError(f"Property fanArtCount must be of type int, got {type(props['fanArtCount']).__name__}")
    
        # Type check onlinePlatforms (expected int)
        if "onlinePlatforms" in props and props["onlinePlatforms"] is not None:
            if not isinstance(props["onlinePlatforms"], int):
                try:
                    # Attempt to convert
                    props["onlinePlatforms"] = int(props["onlinePlatforms"])
                except:
                    raise TypeError(f"Property onlinePlatforms must be of type int, got {type(props['onlinePlatforms']).__name__}")
    
        # Type check reactivation (expected object)
        if "reactivation" in props and props["reactivation"] is not None:
            if not isinstance(props["reactivation"], object):
                try:
                    # Attempt to convert
                    props["reactivation"] = object(props["reactivation"])
                except:
                    raise TypeError(f"Property reactivation must be of type object, got {type(props['reactivation']).__name__}")
    
        # Type check tourismRevenueCurrency (expected str)
        if "tourismRevenueCurrency" in props and props["tourismRevenueCurrency"] is not None:
            if not isinstance(props["tourismRevenueCurrency"], str):
                try:
                    # Attempt to convert
                    props["tourismRevenueCurrency"] = str(props["tourismRevenueCurrency"])
                except:
                    raise TypeError(f"Property tourismRevenueCurrency must be of type str, got {type(props['tourismRevenueCurrency']).__name__}")
    
        # Type check tourismRevenue (expected int)
        if "tourismRevenue" in props and props["tourismRevenue"] is not None:
            if not isinstance(props["tourismRevenue"], int):
                try:
                    # Attempt to convert
                    props["tourismRevenue"] = int(props["tourismRevenue"])
                except:
                    raise TypeError(f"Property tourismRevenue must be of type int, got {type(props['tourismRevenue']).__name__}")
    
        # Type check revival (expected object)
        if "revival" in props and props["revival"] is not None:
            if not isinstance(props["revival"], object):
                try:
                    # Attempt to convert
                    props["revival"] = object(props["revival"])
                except:
                    raise TypeError(f"Property revival must be of type object, got {type(props['revival']).__name__}")
    
        # Type check annualTours (expected int)
        if "annualTours" in props and props["annualTours"] is not None:
            if not isinstance(props["annualTours"], int):
                try:
                    # Attempt to convert
                    props["annualTours"] = int(props["annualTours"])
                except:
                    raise TypeError(f"Property annualTours must be of type int, got {type(props['annualTours']).__name__}")
    
        # Type check academicStudies (expected int)
        if "academicStudies" in props and props["academicStudies"] is not None:
            if not isinstance(props["academicStudies"], int):
                try:
                    # Attempt to convert
                    props["academicStudies"] = int(props["academicStudies"])
                except:
                    raise TypeError(f"Property academicStudies must be of type int, got {type(props['academicStudies']).__name__}")
    
        # Type check singAlongEvents (expected int)
        if "singAlongEvents" in props and props["singAlongEvents"] is not None:
            if not isinstance(props["singAlongEvents"], int):
                try:
                    # Attempt to convert
                    props["singAlongEvents"] = int(props["singAlongEvents"])
                except:
                    raise TypeError(f"Property singAlongEvents must be of type int, got {type(props['singAlongEvents']).__name__}")
    
        # Type check annualEvents (expected int)
        if "annualEvents" in props and props["annualEvents"] is not None:
            if not isinstance(props["annualEvents"], int):
                try:
                    # Attempt to convert
                    props["annualEvents"] = int(props["annualEvents"])
                except:
                    raise TypeError(f"Property annualEvents must be of type int, got {type(props['annualEvents']).__name__}")
    
        # Type check preservationEfforts (expected bool)
        if "preservationEfforts" in props and props["preservationEfforts"] is not None:
            if not isinstance(props["preservationEfforts"], bool):
                try:
                    # Attempt to convert
                    props["preservationEfforts"] = bool(props["preservationEfforts"])
                except:
                    raise TypeError(f"Property preservationEfforts must be of type bool, got {type(props['preservationEfforts']).__name__}")
    
        # Type check academicContributions (expected int)
        if "academicContributions" in props and props["academicContributions"] is not None:
            if not isinstance(props["academicContributions"], int):
                try:
                    # Attempt to convert
                    props["academicContributions"] = int(props["academicContributions"])
                except:
                    raise TypeError(f"Property academicContributions must be of type int, got {type(props['academicContributions']).__name__}")
    
        # Type check formalized (expected object)
        if "formalized" in props and props["formalized"] is not None:
            if not isinstance(props["formalized"], object):
                try:
                    # Attempt to convert
                    props["formalized"] = object(props["formalized"])
                except:
                    raise TypeError(f"Property formalized must be of type object, got {type(props['formalized']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="FanCommunity", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def book(uuid=None, **props):
        """
        Find nodes with label Book matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check film_rights_cost (expected int)
        if "film_rights_cost" in props and props["film_rights_cost"] is not None:
            if not isinstance(props["film_rights_cost"], int):
                try:
                    # Attempt to convert
                    props["film_rights_cost"] = int(props["film_rights_cost"])
                except:
                    raise TypeError(f"Property film_rights_cost must be of type int, got {type(props['film_rights_cost']).__name__}")
    
        # Type check cultural_impact_rating (expected float)
        if "cultural_impact_rating" in props and props["cultural_impact_rating"] is not None:
            if not isinstance(props["cultural_impact_rating"], float):
                try:
                    # Attempt to convert
                    props["cultural_impact_rating"] = float(props["cultural_impact_rating"])
                except:
                    raise TypeError(f"Property cultural_impact_rating must be of type float, got {type(props['cultural_impact_rating']).__name__}")
    
        # Type check wordCount (expected int)
        if "wordCount" in props and props["wordCount"] is not None:
            if not isinstance(props["wordCount"], int):
                try:
                    # Attempt to convert
                    props["wordCount"] = int(props["wordCount"])
                except:
                    raise TypeError(f"Property wordCount must be of type int, got {type(props['wordCount']).__name__}")
    
        # Type check publicationDate (expected object)
        if "publicationDate" in props and props["publicationDate"] is not None:
            if not isinstance(props["publicationDate"], object):
                try:
                    # Attempt to convert
                    props["publicationDate"] = object(props["publicationDate"])
                except:
                    raise TypeError(f"Property publicationDate must be of type object, got {type(props['publicationDate']).__name__}")
    
        # Type check themes (expected object)
        if "themes" in props and props["themes"] is not None:
            if not isinstance(props["themes"], object):
                try:
                    # Attempt to convert
                    props["themes"] = object(props["themes"])
                except:
                    raise TypeError(f"Property themes must be of type object, got {type(props['themes']).__name__}")
    
        # Type check literary_awards (expected object)
        if "literary_awards" in props and props["literary_awards"] is not None:
            if not isinstance(props["literary_awards"], object):
                try:
                    # Attempt to convert
                    props["literary_awards"] = object(props["literary_awards"])
                except:
                    raise TypeError(f"Property literary_awards must be of type object, got {type(props['literary_awards']).__name__}")
    
        # Type check publisher (expected str)
        if "publisher" in props and props["publisher"] is not None:
            if not isinstance(props["publisher"], str):
                try:
                    # Attempt to convert
                    props["publisher"] = str(props["publisher"])
                except:
                    raise TypeError(f"Property publisher must be of type str, got {type(props['publisher']).__name__}")
    
        # Type check languages_translated (expected int)
        if "languages_translated" in props and props["languages_translated"] is not None:
            if not isinstance(props["languages_translated"], int):
                try:
                    # Attempt to convert
                    props["languages_translated"] = int(props["languages_translated"])
                except:
                    raise TypeError(f"Property languages_translated must be of type int, got {type(props['languages_translated']).__name__}")
    
        # Type check genre (expected str)
        if "genre" in props and props["genre"] is not None:
            if not isinstance(props["genre"], str):
                try:
                    # Attempt to convert
                    props["genre"] = str(props["genre"])
                except:
                    raise TypeError(f"Property genre must be of type str, got {type(props['genre']).__name__}")
    
        # Type check published (expected int)
        if "published" in props and props["published"] is not None:
            if not isinstance(props["published"], int):
                try:
                    # Attempt to convert
                    props["published"] = int(props["published"])
                except:
                    raise TypeError(f"Property published must be of type int, got {type(props['published']).__name__}")
    
        # Type check initialPrintRun (expected int)
        if "initialPrintRun" in props and props["initialPrintRun"] is not None:
            if not isinstance(props["initialPrintRun"], int):
                try:
                    # Attempt to convert
                    props["initialPrintRun"] = int(props["initialPrintRun"])
                except:
                    raise TypeError(f"Property initialPrintRun must be of type int, got {type(props['initialPrintRun']).__name__}")
    
        # Type check advancePayment (expected int)
        if "advancePayment" in props and props["advancePayment"] is not None:
            if not isinstance(props["advancePayment"], int):
                try:
                    # Attempt to convert
                    props["advancePayment"] = int(props["advancePayment"])
                except:
                    raise TypeError(f"Property advancePayment must be of type int, got {type(props['advancePayment']).__name__}")
    
        # Type check isbn (expected str)
        if "isbn" in props and props["isbn"] is not None:
            if not isinstance(props["isbn"], str):
                try:
                    # Attempt to convert
                    props["isbn"] = str(props["isbn"])
                except:
                    raise TypeError(f"Property isbn must be of type str, got {type(props['isbn']).__name__}")
    
        # Type check totalSales (expected int)
        if "totalSales" in props and props["totalSales"] is not None:
            if not isinstance(props["totalSales"], int):
                try:
                    # Attempt to convert
                    props["totalSales"] = int(props["totalSales"])
                except:
                    raise TypeError(f"Property totalSales must be of type int, got {type(props['totalSales']).__name__}")
    
        # Type check title (expected str)
        if "title" in props and props["title"] is not None:
            if not isinstance(props["title"], str):
                try:
                    # Attempt to convert
                    props["title"] = str(props["title"])
                except:
                    raise TypeError(f"Property title must be of type str, got {type(props['title']).__name__}")
    
        # Type check weeksOnBestsellerList (expected int)
        if "weeksOnBestsellerList" in props and props["weeksOnBestsellerList"] is not None:
            if not isinstance(props["weeksOnBestsellerList"], int):
                try:
                    # Attempt to convert
                    props["weeksOnBestsellerList"] = int(props["weeksOnBestsellerList"])
                except:
                    raise TypeError(f"Property weeksOnBestsellerList must be of type int, got {type(props['weeksOnBestsellerList']).__name__}")
    
        # Type check pageCount (expected int)
        if "pageCount" in props and props["pageCount"] is not None:
            if not isinstance(props["pageCount"], int):
                try:
                    # Attempt to convert
                    props["pageCount"] = int(props["pageCount"])
                except:
                    raise TypeError(f"Property pageCount must be of type int, got {type(props['pageCount']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Book", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def scene(uuid=None, **props):
        """
        Find nodes with label Scene matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check duration (expected object)
        if "duration" in props and props["duration"] is not None:
            if not isinstance(props["duration"], object):
                try:
                    # Attempt to convert
                    props["duration"] = object(props["duration"])
                except:
                    raise TypeError(f"Property duration must be of type object, got {type(props['duration']).__name__}")
    
        # Type check locationCount (expected int)
        if "locationCount" in props and props["locationCount"] is not None:
            if not isinstance(props["locationCount"], int):
                try:
                    # Attempt to convert
                    props["locationCount"] = int(props["locationCount"])
                except:
                    raise TypeError(f"Property locationCount must be of type int, got {type(props['locationCount']).__name__}")
    
        # Type check animalsUsed (expected int)
        if "animalsUsed" in props and props["animalsUsed"] is not None:
            if not isinstance(props["animalsUsed"], int):
                try:
                    # Attempt to convert
                    props["animalsUsed"] = int(props["animalsUsed"])
                except:
                    raise TypeError(f"Property animalsUsed must be of type int, got {type(props['animalsUsed']).__name__}")
    
        # Type check stuntsRequired (expected int)
        if "stuntsRequired" in props and props["stuntsRequired"] is not None:
            if not isinstance(props["stuntsRequired"], int):
                try:
                    # Attempt to convert
                    props["stuntsRequired"] = int(props["stuntsRequired"])
                except:
                    raise TypeError(f"Property stuntsRequired must be of type int, got {type(props['stuntsRequired']).__name__}")
    
        # Type check movie (expected str)
        if "movie" in props and props["movie"] is not None:
            if not isinstance(props["movie"], str):
                try:
                    # Attempt to convert
                    props["movie"] = str(props["movie"])
                except:
                    raise TypeError(f"Property movie must be of type str, got {type(props['movie']).__name__}")
    
        # Type check actors (expected int)
        if "actors" in props and props["actors"] is not None:
            if not isinstance(props["actors"], int):
                try:
                    # Attempt to convert
                    props["actors"] = int(props["actors"])
                except:
                    raise TypeError(f"Property actors must be of type int, got {type(props['actors']).__name__}")
    
        # Type check interiorsOnly (expected bool)
        if "interiorsOnly" in props and props["interiorsOnly"] is not None:
            if not isinstance(props["interiorsOnly"], bool):
                try:
                    # Attempt to convert
                    props["interiorsOnly"] = bool(props["interiorsOnly"])
                except:
                    raise TypeError(f"Property interiorsOnly must be of type bool, got {type(props['interiorsOnly']).__name__}")
    
        # Type check dialogueLines (expected int)
        if "dialogueLines" in props and props["dialogueLines"] is not None:
            if not isinstance(props["dialogueLines"], int):
                try:
                    # Attempt to convert
                    props["dialogueLines"] = int(props["dialogueLines"])
                except:
                    raise TypeError(f"Property dialogueLines must be of type int, got {type(props['dialogueLines']).__name__}")
    
        # Type check sceneNumber (expected int)
        if "sceneNumber" in props and props["sceneNumber"] is not None:
            if not isinstance(props["sceneNumber"], int):
                try:
                    # Attempt to convert
                    props["sceneNumber"] = int(props["sceneNumber"])
                except:
                    raise TypeError(f"Property sceneNumber must be of type int, got {type(props['sceneNumber']).__name__}")
    
        # Type check extras (expected int)
        if "extras" in props and props["extras"] is not None:
            if not isinstance(props["extras"], int):
                try:
                    # Attempt to convert
                    props["extras"] = int(props["extras"])
                except:
                    raise TypeError(f"Property extras must be of type int, got {type(props['extras']).__name__}")
    
        # Type check specialEffectsComplexity (expected str)
        if "specialEffectsComplexity" in props and props["specialEffectsComplexity"] is not None:
            if not isinstance(props["specialEffectsComplexity"], str):
                try:
                    # Attempt to convert
                    props["specialEffectsComplexity"] = str(props["specialEffectsComplexity"])
                except:
                    raise TypeError(f"Property specialEffectsComplexity must be of type str, got {type(props['specialEffectsComplexity']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check scriptPages (expected int)
        if "scriptPages" in props and props["scriptPages"] is not None:
            if not isinstance(props["scriptPages"], int):
                try:
                    # Attempt to convert
                    props["scriptPages"] = int(props["scriptPages"])
                except:
                    raise TypeError(f"Property scriptPages must be of type int, got {type(props['scriptPages']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Scene", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def business(uuid=None, **props):
        """
        Find nodes with label Business matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check founded (expected object)
        if "founded" in props and props["founded"] is not None:
            if not isinstance(props["founded"], object):
                try:
                    # Attempt to convert
                    props["founded"] = object(props["founded"])
                except:
                    raise TypeError(f"Property founded must be of type object, got {type(props['founded']).__name__}")
    
        # Type check headquartersLat (expected float)
        if "headquartersLat" in props and props["headquartersLat"] is not None:
            if not isinstance(props["headquartersLat"], float):
                try:
                    # Attempt to convert
                    props["headquartersLat"] = float(props["headquartersLat"])
                except:
                    raise TypeError(f"Property headquartersLat must be of type float, got {type(props['headquartersLat']).__name__}")
    
        # Type check digitalTransformation (expected object)
        if "digitalTransformation" in props and props["digitalTransformation"] is not None:
            if not isinstance(props["digitalTransformation"], object):
                try:
                    # Attempt to convert
                    props["digitalTransformation"] = object(props["digitalTransformation"])
                except:
                    raise TypeError(f"Property digitalTransformation must be of type object, got {type(props['digitalTransformation']).__name__}")
    
        # Type check annualRevenue (expected int)
        if "annualRevenue" in props and props["annualRevenue"] is not None:
            if not isinstance(props["annualRevenue"], int):
                try:
                    # Attempt to convert
                    props["annualRevenue"] = int(props["annualRevenue"])
                except:
                    raise TypeError(f"Property annualRevenue must be of type int, got {type(props['annualRevenue']).__name__}")
    
        # Type check marketValueUSD (expected int)
        if "marketValueUSD" in props and props["marketValueUSD"] is not None:
            if not isinstance(props["marketValueUSD"], int):
                try:
                    # Attempt to convert
                    props["marketValueUSD"] = int(props["marketValueUSD"])
                except:
                    raise TypeError(f"Property marketValueUSD must be of type int, got {type(props['marketValueUSD']).__name__}")
    
        # Type check headquartersLong (expected float)
        if "headquartersLong" in props and props["headquartersLong"] is not None:
            if not isinstance(props["headquartersLong"], float):
                try:
                    # Attempt to convert
                    props["headquartersLong"] = float(props["headquartersLong"])
                except:
                    raise TypeError(f"Property headquartersLong must be of type float, got {type(props['headquartersLong']).__name__}")
    
        # Type check publiclyTraded (expected bool)
        if "publiclyTraded" in props and props["publiclyTraded"] is not None:
            if not isinstance(props["publiclyTraded"], bool):
                try:
                    # Attempt to convert
                    props["publiclyTraded"] = bool(props["publiclyTraded"])
                except:
                    raise TypeError(f"Property publiclyTraded must be of type bool, got {type(props['publiclyTraded']).__name__}")
    
        # Type check ceoCompensation (expected int)
        if "ceoCompensation" in props and props["ceoCompensation"] is not None:
            if not isinstance(props["ceoCompensation"], int):
                try:
                    # Attempt to convert
                    props["ceoCompensation"] = int(props["ceoCompensation"])
                except:
                    raise TypeError(f"Property ceoCompensation must be of type int, got {type(props['ceoCompensation']).__name__}")
    
        # Type check globalOffices (expected int)
        if "globalOffices" in props and props["globalOffices"] is not None:
            if not isinstance(props["globalOffices"], int):
                try:
                    # Attempt to convert
                    props["globalOffices"] = int(props["globalOffices"])
                except:
                    raise TypeError(f"Property globalOffices must be of type int, got {type(props['globalOffices']).__name__}")
    
        # Type check tickerSymbol (expected str)
        if "tickerSymbol" in props and props["tickerSymbol"] is not None:
            if not isinstance(props["tickerSymbol"], str):
                try:
                    # Attempt to convert
                    props["tickerSymbol"] = str(props["tickerSymbol"])
                except:
                    raise TypeError(f"Property tickerSymbol must be of type str, got {type(props['tickerSymbol']).__name__}")
    
        # Type check employees (expected int)
        if "employees" in props and props["employees"] is not None:
            if not isinstance(props["employees"], int):
                try:
                    # Attempt to convert
                    props["employees"] = int(props["employees"])
                except:
                    raise TypeError(f"Property employees must be of type int, got {type(props['employees']).__name__}")
    
        # Type check acquisition_strategy (expected str)
        if "acquisition_strategy" in props and props["acquisition_strategy"] is not None:
            if not isinstance(props["acquisition_strategy"], str):
                try:
                    # Attempt to convert
                    props["acquisition_strategy"] = str(props["acquisition_strategy"])
                except:
                    raise TypeError(f"Property acquisition_strategy must be of type str, got {type(props['acquisition_strategy']).__name__}")
    
        # Type check ceo_tenure (expected str)
        if "ceo_tenure" in props and props["ceo_tenure"] is not None:
            if not isinstance(props["ceo_tenure"], str):
                try:
                    # Attempt to convert
                    props["ceo_tenure"] = str(props["ceo_tenure"])
                except:
                    raise TypeError(f"Property ceo_tenure must be of type str, got {type(props['ceo_tenure']).__name__}")
    
        # Type check business_sectors (expected object)
        if "business_sectors" in props and props["business_sectors"] is not None:
            if not isinstance(props["business_sectors"], object):
                try:
                    # Attempt to convert
                    props["business_sectors"] = object(props["business_sectors"])
                except:
                    raise TypeError(f"Property business_sectors must be of type object, got {type(props['business_sectors']).__name__}")
    
        # Type check key_subsidiaries (expected object)
        if "key_subsidiaries" in props and props["key_subsidiaries"] is not None:
            if not isinstance(props["key_subsidiaries"], object):
                try:
                    # Attempt to convert
                    props["key_subsidiaries"] = object(props["key_subsidiaries"])
                except:
                    raise TypeError(f"Property key_subsidiaries must be of type object, got {type(props['key_subsidiaries']).__name__}")
    
        # Type check annual_reports (expected object)
        if "annual_reports" in props and props["annual_reports"] is not None:
            if not isinstance(props["annual_reports"], object):
                try:
                    # Attempt to convert
                    props["annual_reports"] = object(props["annual_reports"])
                except:
                    raise TypeError(f"Property annual_reports must be of type object, got {type(props['annual_reports']).__name__}")
    
        # Type check marketValueUSD1972 (expected int)
        if "marketValueUSD1972" in props and props["marketValueUSD1972"] is not None:
            if not isinstance(props["marketValueUSD1972"], int):
                try:
                    # Attempt to convert
                    props["marketValueUSD1972"] = int(props["marketValueUSD1972"])
                except:
                    raise TypeError(f"Property marketValueUSD1972 must be of type int, got {type(props['marketValueUSD1972']).__name__}")
    
        # Type check conglomerateStructure (expected bool)
        if "conglomerateStructure" in props and props["conglomerateStructure"] is not None:
            if not isinstance(props["conglomerateStructure"], bool):
                try:
                    # Attempt to convert
                    props["conglomerateStructure"] = bool(props["conglomerateStructure"])
                except:
                    raise TypeError(f"Property conglomerateStructure must be of type bool, got {type(props['conglomerateStructure']).__name__}")
    
        # Type check annualRevenue1972 (expected int)
        if "annualRevenue1972" in props and props["annualRevenue1972"] is not None:
            if not isinstance(props["annualRevenue1972"], int):
                try:
                    # Attempt to convert
                    props["annualRevenue1972"] = int(props["annualRevenue1972"])
                except:
                    raise TypeError(f"Property annualRevenue1972 must be of type int, got {type(props['annualRevenue1972']).__name__}")
    
        # Type check globalOperations (expected int)
        if "globalOperations" in props and props["globalOperations"] is not None:
            if not isinstance(props["globalOperations"], int):
                try:
                    # Attempt to convert
                    props["globalOperations"] = int(props["globalOperations"])
                except:
                    raise TypeError(f"Property globalOperations must be of type int, got {type(props['globalOperations']).__name__}")
    
        # Type check acquired_paramount (expected object)
        if "acquired_paramount" in props and props["acquired_paramount"] is not None:
            if not isinstance(props["acquired_paramount"], object):
                try:
                    # Attempt to convert
                    props["acquired_paramount"] = object(props["acquired_paramount"])
                except:
                    raise TypeError(f"Property acquired_paramount must be of type object, got {type(props['acquired_paramount']).__name__}")
    
        # Type check diversificationLevel (expected str)
        if "diversificationLevel" in props and props["diversificationLevel"] is not None:
            if not isinstance(props["diversificationLevel"], str):
                try:
                    # Attempt to convert
                    props["diversificationLevel"] = str(props["diversificationLevel"])
                except:
                    raise TypeError(f"Property diversificationLevel must be of type str, got {type(props['diversificationLevel']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Business", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def award(uuid=None, **props):
        """
        Find nodes with label Award matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check heightUnit (expected str)
        if "heightUnit" in props and props["heightUnit"] is not None:
            if not isinstance(props["heightUnit"], str):
                try:
                    # Attempt to convert
                    props["heightUnit"] = str(props["heightUnit"])
                except:
                    raise TypeError(f"Property heightUnit must be of type str, got {type(props['heightUnit']).__name__}")
    
        # Type check category (expected str)
        if "category" in props and props["category"] is not None:
            if not isinstance(props["category"], str):
                try:
                    # Attempt to convert
                    props["category"] = str(props["category"])
                except:
                    raise TypeError(f"Property category must be of type str, got {type(props['category']).__name__}")
    
        # Type check weightUnit (expected str)
        if "weightUnit" in props and props["weightUnit"] is not None:
            if not isinstance(props["weightUnit"], str):
                try:
                    # Attempt to convert
                    props["weightUnit"] = str(props["weightUnit"])
                except:
                    raise TypeError(f"Property weightUnit must be of type str, got {type(props['weightUnit']).__name__}")
    
        # Type check presentedBy (expected str)
        if "presentedBy" in props and props["presentedBy"] is not None:
            if not isinstance(props["presentedBy"], str):
                try:
                    # Attempt to convert
                    props["presentedBy"] = str(props["presentedBy"])
                except:
                    raise TypeError(f"Property presentedBy must be of type str, got {type(props['presentedBy']).__name__}")
    
        # Type check awardMaterial (expected str)
        if "awardMaterial" in props and props["awardMaterial"] is not None:
            if not isinstance(props["awardMaterial"], str):
                try:
                    # Attempt to convert
                    props["awardMaterial"] = str(props["awardMaterial"])
                except:
                    raise TypeError(f"Property awardMaterial must be of type str, got {type(props['awardMaterial']).__name__}")
    
        # Type check awardWeight (expected float)
        if "awardWeight" in props and props["awardWeight"] is not None:
            if not isinstance(props["awardWeight"], float):
                try:
                    # Attempt to convert
                    props["awardWeight"] = float(props["awardWeight"])
                except:
                    raise TypeError(f"Property awardWeight must be of type float, got {type(props['awardWeight']).__name__}")
    
        # Type check applicationRequired (expected bool)
        if "applicationRequired" in props and props["applicationRequired"] is not None:
            if not isinstance(props["applicationRequired"], bool):
                try:
                    # Attempt to convert
                    props["applicationRequired"] = bool(props["applicationRequired"])
                except:
                    raise TypeError(f"Property applicationRequired must be of type bool, got {type(props['applicationRequired']).__name__}")
    
        # Type check recipients (expected int)
        if "recipients" in props and props["recipients"] is not None:
            if not isinstance(props["recipients"], int):
                try:
                    # Attempt to convert
                    props["recipients"] = int(props["recipients"])
                except:
                    raise TypeError(f"Property recipients must be of type int, got {type(props['recipients']).__name__}")
    
        # Type check firstAwarded (expected object)
        if "firstAwarded" in props and props["firstAwarded"] is not None:
            if not isinstance(props["firstAwarded"], object):
                try:
                    # Attempt to convert
                    props["firstAwarded"] = object(props["firstAwarded"])
                except:
                    raise TypeError(f"Property firstAwarded must be of type object, got {type(props['firstAwarded']).__name__}")
    
        # Type check awardHeight (expected float)
        if "awardHeight" in props and props["awardHeight"] is not None:
            if not isinstance(props["awardHeight"], float):
                try:
                    # Attempt to convert
                    props["awardHeight"] = float(props["awardHeight"])
                except:
                    raise TypeError(f"Property awardHeight must be of type float, got {type(props['awardHeight']).__name__}")
    
        # Type check monetary (expected bool)
        if "monetary" in props and props["monetary"] is not None:
            if not isinstance(props["monetary"], bool):
                try:
                    # Attempt to convert
                    props["monetary"] = bool(props["monetary"])
                except:
                    raise TypeError(f"Property monetary must be of type bool, got {type(props['monetary']).__name__}")
    
        # Type check physicalAward (expected bool)
        if "physicalAward" in props and props["physicalAward"] is not None:
            if not isinstance(props["physicalAward"], bool):
                try:
                    # Attempt to convert
                    props["physicalAward"] = bool(props["physicalAward"])
                except:
                    raise TypeError(f"Property physicalAward must be of type bool, got {type(props['physicalAward']).__name__}")
    
        # Type check prestige (expected float)
        if "prestige" in props and props["prestige"] is not None:
            if not isinstance(props["prestige"], float):
                try:
                    # Attempt to convert
                    props["prestige"] = float(props["prestige"])
                except:
                    raise TypeError(f"Property prestige must be of type float, got {type(props['prestige']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Award", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def productionchallenge(uuid=None, **props):
        """
        Find nodes with label ProductionChallenge matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check industryLessons (expected str)
        if "industryLessons" in props and props["industryLessons"] is not None:
            if not isinstance(props["industryLessons"], str):
                try:
                    # Attempt to convert
                    props["industryLessons"] = str(props["industryLessons"])
                except:
                    raise TypeError(f"Property industryLessons must be of type str, got {type(props['industryLessons']).__name__}")
    
        # Type check documentationLevel (expected str)
        if "documentationLevel" in props and props["documentationLevel"] is not None:
            if not isinstance(props["documentationLevel"], str):
                try:
                    # Attempt to convert
                    props["documentationLevel"] = str(props["documentationLevel"])
                except:
                    raise TypeError(f"Property documentationLevel must be of type str, got {type(props['documentationLevel']).__name__}")
    
        # Type check endDate (expected object)
        if "endDate" in props and props["endDate"] is not None:
            if not isinstance(props["endDate"], object):
                try:
                    # Attempt to convert
                    props["endDate"] = object(props["endDate"])
                except:
                    raise TypeError(f"Property endDate must be of type object, got {type(props['endDate']).__name__}")
    
        # Type check scheduleImpact (expected object)
        if "scheduleImpact" in props and props["scheduleImpact"] is not None:
            if not isinstance(props["scheduleImpact"], object):
                try:
                    # Attempt to convert
                    props["scheduleImpact"] = object(props["scheduleImpact"])
                except:
                    raise TypeError(f"Property scheduleImpact must be of type object, got {type(props['scheduleImpact']).__name__}")
    
        # Type check productionPhase (expected str)
        if "productionPhase" in props and props["productionPhase"] is not None:
            if not isinstance(props["productionPhase"], str):
                try:
                    # Attempt to convert
                    props["productionPhase"] = str(props["productionPhase"])
                except:
                    raise TypeError(f"Property productionPhase must be of type str, got {type(props['productionPhase']).__name__}")
    
        # Type check budgetImpact (expected int)
        if "budgetImpact" in props and props["budgetImpact"] is not None:
            if not isinstance(props["budgetImpact"], int):
                try:
                    # Attempt to convert
                    props["budgetImpact"] = int(props["budgetImpact"])
                except:
                    raise TypeError(f"Property budgetImpact must be of type int, got {type(props['budgetImpact']).__name__}")
    
        # Type check resolutionSuccess (expected float)
        if "resolutionSuccess" in props and props["resolutionSuccess"] is not None:
            if not isinstance(props["resolutionSuccess"], float):
                try:
                    # Attempt to convert
                    props["resolutionSuccess"] = float(props["resolutionSuccess"])
                except:
                    raise TypeError(f"Property resolutionSuccess must be of type float, got {type(props['resolutionSuccess']).__name__}")
    
        # Type check startDate (expected object)
        if "startDate" in props and props["startDate"] is not None:
            if not isinstance(props["startDate"], object):
                try:
                    # Attempt to convert
                    props["startDate"] = object(props["startDate"])
                except:
                    raise TypeError(f"Property startDate must be of type object, got {type(props['startDate']).__name__}")
    
        # Type check departmentsAffected (expected int)
        if "departmentsAffected" in props and props["departmentsAffected"] is not None:
            if not isinstance(props["departmentsAffected"], int):
                try:
                    # Attempt to convert
                    props["departmentsAffected"] = int(props["departmentsAffected"])
                except:
                    raise TypeError(f"Property departmentsAffected must be of type int, got {type(props['departmentsAffected']).__name__}")
    
        # Type check severityLevel (expected float)
        if "severityLevel" in props and props["severityLevel"] is not None:
            if not isinstance(props["severityLevel"], float):
                try:
                    # Attempt to convert
                    props["severityLevel"] = float(props["severityLevel"])
                except:
                    raise TypeError(f"Property severityLevel must be of type float, got {type(props['severityLevel']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="ProductionChallenge", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def collectible(uuid=None, **props):
        """
        Find nodes with label Collectible matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check dimensions (expected str)
        if "dimensions" in props and props["dimensions"] is not None:
            if not isinstance(props["dimensions"], str):
                try:
                    # Attempt to convert
                    props["dimensions"] = str(props["dimensions"])
                except:
                    raise TypeError(f"Property dimensions must be of type str, got {type(props['dimensions']).__name__}")
    
        # Type check type (expected str)
        if "type" in props and props["type"] is not None:
            if not isinstance(props["type"], str):
                try:
                    # Attempt to convert
                    props["type"] = str(props["type"])
                except:
                    raise TypeError(f"Property type must be of type str, got {type(props['type']).__name__}")
    
        # Type check material (expected str)
        if "material" in props and props["material"] is not None:
            if not isinstance(props["material"], str):
                try:
                    # Attempt to convert
                    props["material"] = str(props["material"])
                except:
                    raise TypeError(f"Property material must be of type str, got {type(props['material']).__name__}")
    
        # Type check valuation_currency (expected str)
        if "valuation_currency" in props and props["valuation_currency"] is not None:
            if not isinstance(props["valuation_currency"], str):
                try:
                    # Attempt to convert
                    props["valuation_currency"] = str(props["valuation_currency"])
                except:
                    raise TypeError(f"Property valuation_currency must be of type str, got {type(props['valuation_currency']).__name__}")
    
        # Type check weightUnit (expected str)
        if "weightUnit" in props and props["weightUnit"] is not None:
            if not isinstance(props["weightUnit"], str):
                try:
                    # Attempt to convert
                    props["weightUnit"] = str(props["weightUnit"])
                except:
                    raise TypeError(f"Property weightUnit must be of type str, got {type(props['weightUnit']).__name__}")
    
        # Type check creationDate (expected object)
        if "creationDate" in props and props["creationDate"] is not None:
            if not isinstance(props["creationDate"], object):
                try:
                    # Attempt to convert
                    props["creationDate"] = object(props["creationDate"])
                except:
                    raise TypeError(f"Property creationDate must be of type object, got {type(props['creationDate']).__name__}")
    
        # Type check condition (expected str)
        if "condition" in props and props["condition"] is not None:
            if not isinstance(props["condition"], str):
                try:
                    # Attempt to convert
                    props["condition"] = str(props["condition"])
                except:
                    raise TypeError(f"Property condition must be of type str, got {type(props['condition']).__name__}")
    
        # Type check weight (expected int)
        if "weight" in props and props["weight"] is not None:
            if not isinstance(props["weight"], int):
                try:
                    # Attempt to convert
                    props["weight"] = int(props["weight"])
                except:
                    raise TypeError(f"Property weight must be of type int, got {type(props['weight']).__name__}")
    
        # Type check insured (expected bool)
        if "insured" in props and props["insured"] is not None:
            if not isinstance(props["insured"], bool):
                try:
                    # Attempt to convert
                    props["insured"] = bool(props["insured"])
                except:
                    raise TypeError(f"Property insured must be of type bool, got {type(props['insured']).__name__}")
    
        # Type check appraised_value (expected int)
        if "appraised_value" in props and props["appraised_value"] is not None:
            if not isinstance(props["appraised_value"], int):
                try:
                    # Attempt to convert
                    props["appraised_value"] = int(props["appraised_value"])
                except:
                    raise TypeError(f"Property appraised_value must be of type int, got {type(props['appraised_value']).__name__}")
    
        # Type check dimensionUnit (expected str)
        if "dimensionUnit" in props and props["dimensionUnit"] is not None:
            if not isinstance(props["dimensionUnit"], str):
                try:
                    # Attempt to convert
                    props["dimensionUnit"] = str(props["dimensionUnit"])
                except:
                    raise TypeError(f"Property dimensionUnit must be of type str, got {type(props['dimensionUnit']).__name__}")
    
        # Type check authenticity_verified (expected bool)
        if "authenticity_verified" in props and props["authenticity_verified"] is not None:
            if not isinstance(props["authenticity_verified"], bool):
                try:
                    # Attempt to convert
                    props["authenticity_verified"] = bool(props["authenticity_verified"])
                except:
                    raise TypeError(f"Property authenticity_verified must be of type bool, got {type(props['authenticity_verified']).__name__}")
    
        # Type check acquisitionDate (expected object)
        if "acquisitionDate" in props and props["acquisitionDate"] is not None:
            if not isinstance(props["acquisitionDate"], object):
                try:
                    # Attempt to convert
                    props["acquisitionDate"] = object(props["acquisitionDate"])
                except:
                    raise TypeError(f"Property acquisitionDate must be of type object, got {type(props['acquisitionDate']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="Collectible", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def financialrecord(uuid=None, **props):
        """
        Find nodes with label FinancialRecord matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check major_overages (expected object)
        if "major_overages" in props and props["major_overages"] is not None:
            if not isinstance(props["major_overages"], object):
                try:
                    # Attempt to convert
                    props["major_overages"] = object(props["major_overages"])
                except:
                    raise TypeError(f"Property major_overages must be of type object, got {type(props['major_overages']).__name__}")
    
        # Type check completion_bond (expected int)
        if "completion_bond" in props and props["completion_bond"] is not None:
            if not isinstance(props["completion_bond"], int):
                try:
                    # Attempt to convert
                    props["completion_bond"] = int(props["completion_bond"])
                except:
                    raise TypeError(f"Property completion_bond must be of type int, got {type(props['completion_bond']).__name__}")
    
        # Type check overage_amounts (expected object)
        if "overage_amounts" in props and props["overage_amounts"] is not None:
            if not isinstance(props["overage_amounts"], object):
                try:
                    # Attempt to convert
                    props["overage_amounts"] = object(props["overage_amounts"])
                except:
                    raise TypeError(f"Property overage_amounts must be of type object, got {type(props['overage_amounts']).__name__}")
    
        # Type check department_amounts (expected object)
        if "department_amounts" in props and props["department_amounts"] is not None:
            if not isinstance(props["department_amounts"], object):
                try:
                    # Attempt to convert
                    props["department_amounts"] = object(props["department_amounts"])
                except:
                    raise TypeError(f"Property department_amounts must be of type object, got {type(props['department_amounts']).__name__}")
    
        # Type check tracking_system (expected str)
        if "tracking_system" in props and props["tracking_system"] is not None:
            if not isinstance(props["tracking_system"], str):
                try:
                    # Attempt to convert
                    props["tracking_system"] = str(props["tracking_system"])
                except:
                    raise TypeError(f"Property tracking_system must be of type str, got {type(props['tracking_system']).__name__}")
    
        # Type check insurance_costs (expected int)
        if "insurance_costs" in props and props["insurance_costs"] is not None:
            if not isinstance(props["insurance_costs"], int):
                try:
                    # Attempt to convert
                    props["insurance_costs"] = int(props["insurance_costs"])
                except:
                    raise TypeError(f"Property insurance_costs must be of type int, got {type(props['insurance_costs']).__name__}")
    
        # Type check currency (expected str)
        if "currency" in props and props["currency"] is not None:
            if not isinstance(props["currency"], str):
                try:
                    # Attempt to convert
                    props["currency"] = str(props["currency"])
                except:
                    raise TypeError(f"Property currency must be of type str, got {type(props['currency']).__name__}")
    
        # Type check revisions (expected int)
        if "revisions" in props and props["revisions"] is not None:
            if not isinstance(props["revisions"], int):
                try:
                    # Attempt to convert
                    props["revisions"] = int(props["revisions"])
                except:
                    raise TypeError(f"Property revisions must be of type int, got {type(props['revisions']).__name__}")
    
        # Type check department_allocations (expected object)
        if "department_allocations" in props and props["department_allocations"] is not None:
            if not isinstance(props["department_allocations"], object):
                try:
                    # Attempt to convert
                    props["department_allocations"] = object(props["department_allocations"])
                except:
                    raise TypeError(f"Property department_allocations must be of type object, got {type(props['department_allocations']).__name__}")
    
        # Type check contingency_amount (expected int)
        if "contingency_amount" in props and props["contingency_amount"] is not None:
            if not isinstance(props["contingency_amount"], int):
                try:
                    # Attempt to convert
                    props["contingency_amount"] = int(props["contingency_amount"])
                except:
                    raise TypeError(f"Property contingency_amount must be of type int, got {type(props['contingency_amount']).__name__}")
    
        # Type check preservation_status (expected str)
        if "preservation_status" in props and props["preservation_status"] is not None:
            if not isinstance(props["preservation_status"], str):
                try:
                    # Attempt to convert
                    props["preservation_status"] = str(props["preservation_status"])
                except:
                    raise TypeError(f"Property preservation_status must be of type str, got {type(props['preservation_status']).__name__}")
    
        # Type check accounting_firm (expected str)
        if "accounting_firm" in props and props["accounting_firm"] is not None:
            if not isinstance(props["accounting_firm"], str):
                try:
                    # Attempt to convert
                    props["accounting_firm"] = str(props["accounting_firm"])
                except:
                    raise TypeError(f"Property accounting_firm must be of type str, got {type(props['accounting_firm']).__name__}")
    
        # Type check total_amount (expected int)
        if "total_amount" in props and props["total_amount"] is not None:
            if not isinstance(props["total_amount"], int):
                try:
                    # Attempt to convert
                    props["total_amount"] = int(props["total_amount"])
                except:
                    raise TypeError(f"Property total_amount must be of type int, got {type(props['total_amount']).__name__}")
    
        # Type check audit_status (expected str)
        if "audit_status" in props and props["audit_status"] is not None:
            if not isinstance(props["audit_status"], str):
                try:
                    # Attempt to convert
                    props["audit_status"] = str(props["audit_status"])
                except:
                    raise TypeError(f"Property audit_status must be of type str, got {type(props['audit_status']).__name__}")
    
        # Type check finalized (expected object)
        if "finalized" in props and props["finalized"] is not None:
            if not isinstance(props["finalized"], object):
                try:
                    # Attempt to convert
                    props["finalized"] = object(props["finalized"])
                except:
                    raise TypeError(f"Property finalized must be of type object, got {type(props['finalized']).__name__}")
    
        # Type check final_approval (expected object)
        if "final_approval" in props and props["final_approval"] is not None:
            if not isinstance(props["final_approval"], object):
                try:
                    # Attempt to convert
                    props["final_approval"] = object(props["final_approval"])
                except:
                    raise TypeError(f"Property final_approval must be of type object, got {type(props['final_approval']).__name__}")
    
        # Type check accounting_standard (expected str)
        if "accounting_standard" in props and props["accounting_standard"] is not None:
            if not isinstance(props["accounting_standard"], str):
                try:
                    # Attempt to convert
                    props["accounting_standard"] = str(props["accounting_standard"])
                except:
                    raise TypeError(f"Property accounting_standard must be of type str, got {type(props['accounting_standard']).__name__}")
    
        # Type check line_items (expected int)
        if "line_items" in props and props["line_items"] is not None:
            if not isinstance(props["line_items"], int):
                try:
                    # Attempt to convert
                    props["line_items"] = int(props["line_items"])
                except:
                    raise TypeError(f"Property line_items must be of type int, got {type(props['line_items']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check created (expected object)
        if "created" in props and props["created"] is not None:
            if not isinstance(props["created"], object):
                try:
                    # Attempt to convert
                    props["created"] = object(props["created"])
                except:
                    raise TypeError(f"Property created must be of type object, got {type(props['created']).__name__}")
    
        # Type check peak_theaters (expected int)
        if "peak_theaters" in props and props["peak_theaters"] is not None:
            if not isinstance(props["peak_theaters"], int):
                try:
                    # Attempt to convert
                    props["peak_theaters"] = int(props["peak_theaters"])
                except:
                    raise TypeError(f"Property peak_theaters must be of type int, got {type(props['peak_theaters']).__name__}")
    
        # Type check weeks_in_release (expected int)
        if "weeks_in_release" in props and props["weeks_in_release"] is not None:
            if not isinstance(props["weeks_in_release"], int):
                try:
                    # Attempt to convert
                    props["weeks_in_release"] = int(props["weeks_in_release"])
                except:
                    raise TypeError(f"Property weeks_in_release must be of type int, got {type(props['weeks_in_release']).__name__}")
    
        # Type check market_revenues (expected object)
        if "market_revenues" in props and props["market_revenues"] is not None:
            if not isinstance(props["market_revenues"], object):
                try:
                    # Attempt to convert
                    props["market_revenues"] = object(props["market_revenues"])
                except:
                    raise TypeError(f"Property market_revenues must be of type object, got {type(props['market_revenues']).__name__}")
    
        # Type check revenue_amounts (expected object)
        if "revenue_amounts" in props and props["revenue_amounts"] is not None:
            if not isinstance(props["revenue_amounts"], object):
                try:
                    # Attempt to convert
                    props["revenue_amounts"] = object(props["revenue_amounts"])
                except:
                    raise TypeError(f"Property revenue_amounts must be of type object, got {type(props['revenue_amounts']).__name__}")
    
        # Type check theatrical_runs (expected int)
        if "theatrical_runs" in props and props["theatrical_runs"] is not None:
            if not isinstance(props["theatrical_runs"], int):
                try:
                    # Attempt to convert
                    props["theatrical_runs"] = int(props["theatrical_runs"])
                except:
                    raise TypeError(f"Property theatrical_runs must be of type int, got {type(props['theatrical_runs']).__name__}")
    
        # Type check updated (expected object)
        if "updated" in props and props["updated"] is not None:
            if not isinstance(props["updated"], object):
                try:
                    # Attempt to convert
                    props["updated"] = object(props["updated"])
                except:
                    raise TypeError(f"Property updated must be of type object, got {type(props['updated']).__name__}")
    
        # Type check final_certification (expected object)
        if "final_certification" in props and props["final_certification"] is not None:
            if not isinstance(props["final_certification"], object):
                try:
                    # Attempt to convert
                    props["final_certification"] = object(props["final_certification"])
                except:
                    raise TypeError(f"Property final_certification must be of type object, got {type(props['final_certification']).__name__}")
    
        # Type check revenue_streams (expected object)
        if "revenue_streams" in props and props["revenue_streams"] is not None:
            if not isinstance(props["revenue_streams"], object):
                try:
                    # Attempt to convert
                    props["revenue_streams"] = object(props["revenue_streams"])
                except:
                    raise TypeError(f"Property revenue_streams must be of type object, got {type(props['revenue_streams']).__name__}")
    
        # Type check top_markets (expected object)
        if "top_markets" in props and props["top_markets"] is not None:
            if not isinstance(props["top_markets"], object):
                try:
                    # Attempt to convert
                    props["top_markets"] = object(props["top_markets"])
                except:
                    raise TypeError(f"Property top_markets must be of type object, got {type(props['top_markets']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="FinancialRecord", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def distributionplan(uuid=None, **props):
        """
        Find nodes with label DistributionPlan matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check theatrical_windows (expected str)
        if "theatrical_windows" in props and props["theatrical_windows"] is not None:
            if not isinstance(props["theatrical_windows"], str):
                try:
                    # Attempt to convert
                    props["theatrical_windows"] = str(props["theatrical_windows"])
                except:
                    raise TypeError(f"Property theatrical_windows must be of type str, got {type(props['theatrical_windows']).__name__}")
    
        # Type check distribution_partners (expected object)
        if "distribution_partners" in props and props["distribution_partners"] is not None:
            if not isinstance(props["distribution_partners"], object):
                try:
                    # Attempt to convert
                    props["distribution_partners"] = object(props["distribution_partners"])
                except:
                    raise TypeError(f"Property distribution_partners must be of type object, got {type(props['distribution_partners']).__name__}")
    
        # Type check release_strategy (expected str)
        if "release_strategy" in props and props["release_strategy"] is not None:
            if not isinstance(props["release_strategy"], str):
                try:
                    # Attempt to convert
                    props["release_strategy"] = str(props["release_strategy"])
                except:
                    raise TypeError(f"Property release_strategy must be of type str, got {type(props['release_strategy']).__name__}")
    
        # Type check domestic_theaters_wide (expected int)
        if "domestic_theaters_wide" in props and props["domestic_theaters_wide"] is not None:
            if not isinstance(props["domestic_theaters_wide"], int):
                try:
                    # Attempt to convert
                    props["domestic_theaters_wide"] = int(props["domestic_theaters_wide"])
                except:
                    raise TypeError(f"Property domestic_theaters_wide must be of type int, got {type(props['domestic_theaters_wide']).__name__}")
    
        # Type check key_markets (expected object)
        if "key_markets" in props and props["key_markets"] is not None:
            if not isinstance(props["key_markets"], object):
                try:
                    # Attempt to convert
                    props["key_markets"] = object(props["key_markets"])
                except:
                    raise TypeError(f"Property key_markets must be of type object, got {type(props['key_markets']).__name__}")
    
        # Type check release_dates (expected object)
        if "release_dates" in props and props["release_dates"] is not None:
            if not isinstance(props["release_dates"], object):
                try:
                    # Attempt to convert
                    props["release_dates"] = object(props["release_dates"])
                except:
                    raise TypeError(f"Property release_dates must be of type object, got {type(props['release_dates']).__name__}")
    
        # Type check censorship_issues (expected object)
        if "censorship_issues" in props and props["censorship_issues"] is not None:
            if not isinstance(props["censorship_issues"], object):
                try:
                    # Attempt to convert
                    props["censorship_issues"] = object(props["censorship_issues"])
                except:
                    raise TypeError(f"Property censorship_issues must be of type object, got {type(props['censorship_issues']).__name__}")
    
        # Type check territories (expected int)
        if "territories" in props and props["territories"] is not None:
            if not isinstance(props["territories"], int):
                try:
                    # Attempt to convert
                    props["territories"] = int(props["territories"])
                except:
                    raise TypeError(f"Property territories must be of type int, got {type(props['territories']).__name__}")
    
        # Type check implemented (expected object)
        if "implemented" in props and props["implemented"] is not None:
            if not isinstance(props["implemented"], object):
                try:
                    # Attempt to convert
                    props["implemented"] = object(props["implemented"])
                except:
                    raise TypeError(f"Property implemented must be of type object, got {type(props['implemented']).__name__}")
    
        # Type check subtitled_versions (expected int)
        if "subtitled_versions" in props and props["subtitled_versions"] is not None:
            if not isinstance(props["subtitled_versions"], int):
                try:
                    # Attempt to convert
                    props["subtitled_versions"] = int(props["subtitled_versions"])
                except:
                    raise TypeError(f"Property subtitled_versions must be of type int, got {type(props['subtitled_versions']).__name__}")
    
        # Type check marketing_territories (expected int)
        if "marketing_territories" in props and props["marketing_territories"] is not None:
            if not isinstance(props["marketing_territories"], int):
                try:
                    # Attempt to convert
                    props["marketing_territories"] = int(props["marketing_territories"])
                except:
                    raise TypeError(f"Property marketing_territories must be of type int, got {type(props['marketing_territories']).__name__}")
    
        # Type check print_count_domestic (expected int)
        if "print_count_domestic" in props and props["print_count_domestic"] is not None:
            if not isinstance(props["print_count_domestic"], int):
                try:
                    # Attempt to convert
                    props["print_count_domestic"] = int(props["print_count_domestic"])
                except:
                    raise TypeError(f"Property print_count_domestic must be of type int, got {type(props['print_count_domestic']).__name__}")
    
        # Type check print_count_international (expected int)
        if "print_count_international" in props and props["print_count_international"] is not None:
            if not isinstance(props["print_count_international"], int):
                try:
                    # Attempt to convert
                    props["print_count_international"] = int(props["print_count_international"])
                except:
                    raise TypeError(f"Property print_count_international must be of type int, got {type(props['print_count_international']).__name__}")
    
        # Type check dubbed_versions (expected int)
        if "dubbed_versions" in props and props["dubbed_versions"] is not None:
            if not isinstance(props["dubbed_versions"], int):
                try:
                    # Attempt to convert
                    props["dubbed_versions"] = int(props["dubbed_versions"])
                except:
                    raise TypeError(f"Property dubbed_versions must be of type int, got {type(props['dubbed_versions']).__name__}")
    
        # Type check language_versions (expected int)
        if "language_versions" in props and props["language_versions"] is not None:
            if not isinstance(props["language_versions"], int):
                try:
                    # Attempt to convert
                    props["language_versions"] = int(props["language_versions"])
                except:
                    raise TypeError(f"Property language_versions must be of type int, got {type(props['language_versions']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check domestic_theaters_initial (expected int)
        if "domestic_theaters_initial" in props and props["domestic_theaters_initial"] is not None:
            if not isinstance(props["domestic_theaters_initial"], int):
                try:
                    # Attempt to convert
                    props["domestic_theaters_initial"] = int(props["domestic_theaters_initial"])
                except:
                    raise TypeError(f"Property domestic_theaters_initial must be of type int, got {type(props['domestic_theaters_initial']).__name__}")
    
        # Type check international_territories (expected int)
        if "international_territories" in props and props["international_territories"] is not None:
            if not isinstance(props["international_territories"], int):
                try:
                    # Attempt to convert
                    props["international_territories"] = int(props["international_territories"])
                except:
                    raise TypeError(f"Property international_territories must be of type int, got {type(props['international_territories']).__name__}")
    
        # Type check created (expected object)
        if "created" in props and props["created"] is not None:
            if not isinstance(props["created"], object):
                try:
                    # Attempt to convert
                    props["created"] = object(props["created"])
                except:
                    raise TypeError(f"Property created must be of type object, got {type(props['created']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="DistributionPlan", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def marketingcampaign(uuid=None, **props):
        """
        Find nodes with label MarketingCampaign matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check currency (expected str)
        if "currency" in props and props["currency"] is not None:
            if not isinstance(props["currency"], str):
                try:
                    # Attempt to convert
                    props["currency"] = str(props["currency"])
                except:
                    raise TypeError(f"Property currency must be of type str, got {type(props['currency']).__name__}")
    
        # Type check tv_networks (expected object)
        if "tv_networks" in props and props["tv_networks"] is not None:
            if not isinstance(props["tv_networks"], object):
                try:
                    # Attempt to convert
                    props["tv_networks"] = object(props["tv_networks"])
                except:
                    raise TypeError(f"Property tv_networks must be of type object, got {type(props['tv_networks']).__name__}")
    
        # Type check key_visuals (expected object)
        if "key_visuals" in props and props["key_visuals"] is not None:
            if not isinstance(props["key_visuals"], object):
                try:
                    # Attempt to convert
                    props["key_visuals"] = object(props["key_visuals"])
                except:
                    raise TypeError(f"Property key_visuals must be of type object, got {type(props['key_visuals']).__name__}")
    
        # Type check campaign_phases (expected object)
        if "campaign_phases" in props and props["campaign_phases"] is not None:
            if not isinstance(props["campaign_phases"], object):
                try:
                    # Attempt to convert
                    props["campaign_phases"] = object(props["campaign_phases"])
                except:
                    raise TypeError(f"Property campaign_phases must be of type object, got {type(props['campaign_phases']).__name__}")
    
        # Type check created (expected object)
        if "created" in props and props["created"] is not None:
            if not isinstance(props["created"], object):
                try:
                    # Attempt to convert
                    props["created"] = object(props["created"])
                except:
                    raise TypeError(f"Property created must be of type object, got {type(props['created']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check channel_allocation (expected object)
        if "channel_allocation" in props and props["channel_allocation"] is not None:
            if not isinstance(props["channel_allocation"], object):
                try:
                    # Attempt to convert
                    props["channel_allocation"] = object(props["channel_allocation"])
                except:
                    raise TypeError(f"Property channel_allocation must be of type object, got {type(props['channel_allocation']).__name__}")
    
        # Type check key_publications (expected object)
        if "key_publications" in props and props["key_publications"] is not None:
            if not isinstance(props["key_publications"], object):
                try:
                    # Attempt to convert
                    props["key_publications"] = object(props["key_publications"])
                except:
                    raise TypeError(f"Property key_publications must be of type object, got {type(props['key_publications']).__name__}")
    
        # Type check creative_agencies (expected int)
        if "creative_agencies" in props and props["creative_agencies"] is not None:
            if not isinstance(props["creative_agencies"], int):
                try:
                    # Attempt to convert
                    props["creative_agencies"] = int(props["creative_agencies"])
                except:
                    raise TypeError(f"Property creative_agencies must be of type int, got {type(props['creative_agencies']).__name__}")
    
        # Type check media_buyers (expected int)
        if "media_buyers" in props and props["media_buyers"] is not None:
            if not isinstance(props["media_buyers"], int):
                try:
                    # Attempt to convert
                    props["media_buyers"] = int(props["media_buyers"])
                except:
                    raise TypeError(f"Property media_buyers must be of type int, got {type(props['media_buyers']).__name__}")
    
        # Type check publicists (expected int)
        if "publicists" in props and props["publicists"] is not None:
            if not isinstance(props["publicists"], int):
                try:
                    # Attempt to convert
                    props["publicists"] = int(props["publicists"])
                except:
                    raise TypeError(f"Property publicists must be of type int, got {type(props['publicists']).__name__}")
    
        # Type check marketing_channels (expected object)
        if "marketing_channels" in props and props["marketing_channels"] is not None:
            if not isinstance(props["marketing_channels"], object):
                try:
                    # Attempt to convert
                    props["marketing_channels"] = object(props["marketing_channels"])
                except:
                    raise TypeError(f"Property marketing_channels must be of type object, got {type(props['marketing_channels']).__name__}")
    
        # Type check markets (expected str)
        if "markets" in props and props["markets"] is not None:
            if not isinstance(props["markets"], str):
                try:
                    # Attempt to convert
                    props["markets"] = str(props["markets"])
                except:
                    raise TypeError(f"Property markets must be of type str, got {type(props['markets']).__name__}")
    
        # Type check launched (expected object)
        if "launched" in props and props["launched"] is not None:
            if not isinstance(props["launched"], object):
                try:
                    # Attempt to convert
                    props["launched"] = object(props["launched"])
                except:
                    raise TypeError(f"Property launched must be of type object, got {type(props['launched']).__name__}")
    
        # Type check taglines (expected int)
        if "taglines" in props and props["taglines"] is not None:
            if not isinstance(props["taglines"], int):
                try:
                    # Attempt to convert
                    props["taglines"] = int(props["taglines"])
                except:
                    raise TypeError(f"Property taglines must be of type int, got {type(props['taglines']).__name__}")
    
        # Type check press_events (expected int)
        if "press_events" in props and props["press_events"] is not None:
            if not isinstance(props["press_events"], int):
                try:
                    # Attempt to convert
                    props["press_events"] = int(props["press_events"])
                except:
                    raise TypeError(f"Property press_events must be of type int, got {type(props['press_events']).__name__}")
    
        # Type check premieres (expected int)
        if "premieres" in props and props["premieres"] is not None:
            if not isinstance(props["premieres"], int):
                try:
                    # Attempt to convert
                    props["premieres"] = int(props["premieres"])
                except:
                    raise TypeError(f"Property premieres must be of type int, got {type(props['premieres']).__name__}")
    
        # Type check awards_campaign (expected bool)
        if "awards_campaign" in props and props["awards_campaign"] is not None:
            if not isinstance(props["awards_campaign"], bool):
                try:
                    # Attempt to convert
                    props["awards_campaign"] = bool(props["awards_campaign"])
                except:
                    raise TypeError(f"Property awards_campaign must be of type bool, got {type(props['awards_campaign']).__name__}")
    
        # Type check total_budget (expected int)
        if "total_budget" in props and props["total_budget"] is not None:
            if not isinstance(props["total_budget"], int):
                try:
                    # Attempt to convert
                    props["total_budget"] = int(props["total_budget"])
                except:
                    raise TypeError(f"Property total_budget must be of type int, got {type(props['total_budget']).__name__}")
    
        # Type check completed (expected object)
        if "completed" in props and props["completed"] is not None:
            if not isinstance(props["completed"], object):
                try:
                    # Attempt to convert
                    props["completed"] = object(props["completed"])
                except:
                    raise TypeError(f"Property completed must be of type object, got {type(props['completed']).__name__}")
    
        # Type check target_demographics (expected str)
        if "target_demographics" in props and props["target_demographics"] is not None:
            if not isinstance(props["target_demographics"], str):
                try:
                    # Attempt to convert
                    props["target_demographics"] = str(props["target_demographics"])
                except:
                    raise TypeError(f"Property target_demographics must be of type str, got {type(props['target_demographics']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="MarketingCampaign", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def financialstructure(uuid=None, **props):
        """
        Find nodes with label FinancialStructure matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check recoupment_priority (expected object)
        if "recoupment_priority" in props and props["recoupment_priority"] is not None:
            if not isinstance(props["recoupment_priority"], object):
                try:
                    # Attempt to convert
                    props["recoupment_priority"] = object(props["recoupment_priority"])
                except:
                    raise TypeError(f"Property recoupment_priority must be of type object, got {type(props['recoupment_priority']).__name__}")
    
        # Type check risk_mitigation (expected str)
        if "risk_mitigation" in props and props["risk_mitigation"] is not None:
            if not isinstance(props["risk_mitigation"], str):
                try:
                    # Attempt to convert
                    props["risk_mitigation"] = str(props["risk_mitigation"])
                except:
                    raise TypeError(f"Property risk_mitigation must be of type str, got {type(props['risk_mitigation']).__name__}")
    
        # Type check financial_triggers (expected object)
        if "financial_triggers" in props and props["financial_triggers"] is not None:
            if not isinstance(props["financial_triggers"], object):
                try:
                    # Attempt to convert
                    props["financial_triggers"] = object(props["financial_triggers"])
                except:
                    raise TypeError(f"Property financial_triggers must be of type object, got {type(props['financial_triggers']).__name__}")
    
        # Type check trigger_payments (expected object)
        if "trigger_payments" in props and props["trigger_payments"] is not None:
            if not isinstance(props["trigger_payments"], object):
                try:
                    # Attempt to convert
                    props["trigger_payments"] = object(props["trigger_payments"])
                except:
                    raise TypeError(f"Property trigger_payments must be of type object, got {type(props['trigger_payments']).__name__}")
    
        # Type check currency (expected str)
        if "currency" in props and props["currency"] is not None:
            if not isinstance(props["currency"], str):
                try:
                    # Attempt to convert
                    props["currency"] = str(props["currency"])
                except:
                    raise TypeError(f"Property currency must be of type str, got {type(props['currency']).__name__}")
    
        # Type check funding_sources (expected object)
        if "funding_sources" in props and props["funding_sources"] is not None:
            if not isinstance(props["funding_sources"], object):
                try:
                    # Attempt to convert
                    props["funding_sources"] = object(props["funding_sources"])
                except:
                    raise TypeError(f"Property funding_sources must be of type object, got {type(props['funding_sources']).__name__}")
    
        # Type check funding_amounts (expected object)
        if "funding_amounts" in props and props["funding_amounts"] is not None:
            if not isinstance(props["funding_amounts"], object):
                try:
                    # Attempt to convert
                    props["funding_amounts"] = object(props["funding_amounts"])
                except:
                    raise TypeError(f"Property funding_amounts must be of type object, got {type(props['funding_amounts']).__name__}")
    
        # Type check legal_counsel (expected str)
        if "legal_counsel" in props and props["legal_counsel"] is not None:
            if not isinstance(props["legal_counsel"], str):
                try:
                    # Attempt to convert
                    props["legal_counsel"] = str(props["legal_counsel"])
                except:
                    raise TypeError(f"Property legal_counsel must be of type str, got {type(props['legal_counsel']).__name__}")
    
        # Type check banking_partner (expected str)
        if "banking_partner" in props and props["banking_partner"] is not None:
            if not isinstance(props["banking_partner"], str):
                try:
                    # Attempt to convert
                    props["banking_partner"] = str(props["banking_partner"])
                except:
                    raise TypeError(f"Property banking_partner must be of type str, got {type(props['banking_partner']).__name__}")
    
        # Type check total_amount (expected int)
        if "total_amount" in props and props["total_amount"] is not None:
            if not isinstance(props["total_amount"], int):
                try:
                    # Attempt to convert
                    props["total_amount"] = int(props["total_amount"])
                except:
                    raise TypeError(f"Property total_amount must be of type int, got {type(props['total_amount']).__name__}")
    
        # Type check tax_structures (expected str)
        if "tax_structures" in props and props["tax_structures"] is not None:
            if not isinstance(props["tax_structures"], str):
                try:
                    # Attempt to convert
                    props["tax_structures"] = str(props["tax_structures"])
                except:
                    raise TypeError(f"Property tax_structures must be of type str, got {type(props['tax_structures']).__name__}")
    
        # Type check secondary_investors (expected str)
        if "secondary_investors" in props and props["secondary_investors"] is not None:
            if not isinstance(props["secondary_investors"], str):
                try:
                    # Attempt to convert
                    props["secondary_investors"] = str(props["secondary_investors"])
                except:
                    raise TypeError(f"Property secondary_investors must be of type str, got {type(props['secondary_investors']).__name__}")
    
        # Type check primary_investor (expected str)
        if "primary_investor" in props and props["primary_investor"] is not None:
            if not isinstance(props["primary_investor"], str):
                try:
                    # Attempt to convert
                    props["primary_investor"] = str(props["primary_investor"])
                except:
                    raise TypeError(f"Property primary_investor must be of type str, got {type(props['primary_investor']).__name__}")
    
        # Type check structure_type (expected str)
        if "structure_type" in props and props["structure_type"] is not None:
            if not isinstance(props["structure_type"], str):
                try:
                    # Attempt to convert
                    props["structure_type"] = str(props["structure_type"])
                except:
                    raise TypeError(f"Property structure_type must be of type str, got {type(props['structure_type']).__name__}")
    
        # Type check gap_financing (expected str)
        if "gap_financing" in props and props["gap_financing"] is not None:
            if not isinstance(props["gap_financing"], str):
                try:
                    # Attempt to convert
                    props["gap_financing"] = str(props["gap_financing"])
                except:
                    raise TypeError(f"Property gap_financing must be of type str, got {type(props['gap_financing']).__name__}")
    
        # Type check executed (expected object)
        if "executed" in props and props["executed"] is not None:
            if not isinstance(props["executed"], object):
                try:
                    # Attempt to convert
                    props["executed"] = object(props["executed"])
                except:
                    raise TypeError(f"Property executed must be of type object, got {type(props['executed']).__name__}")
    
        # Type check completion_guarantor (expected str)
        if "completion_guarantor" in props and props["completion_guarantor"] is not None:
            if not isinstance(props["completion_guarantor"], str):
                try:
                    # Attempt to convert
                    props["completion_guarantor"] = str(props["completion_guarantor"])
                except:
                    raise TypeError(f"Property completion_guarantor must be of type str, got {type(props['completion_guarantor']).__name__}")
    
        # Type check created (expected object)
        if "created" in props and props["created"] is not None:
            if not isinstance(props["created"], object):
                try:
                    # Attempt to convert
                    props["created"] = object(props["created"])
                except:
                    raise TypeError(f"Property created must be of type object, got {type(props['created']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="FinancialStructure", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def legaldocument(uuid=None, **props):
        """
        Find nodes with label LegalDocument matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check template_sources (expected object)
        if "template_sources" in props and props["template_sources"] is not None:
            if not isinstance(props["template_sources"], object):
                try:
                    # Attempt to convert
                    props["template_sources"] = object(props["template_sources"])
                except:
                    raise TypeError(f"Property template_sources must be of type object, got {type(props['template_sources']).__name__}")
    
        # Type check created (expected object)
        if "created" in props and props["created"] is not None:
            if not isinstance(props["created"], object):
                try:
                    # Attempt to convert
                    props["created"] = object(props["created"])
                except:
                    raise TypeError(f"Property created must be of type object, got {type(props['created']).__name__}")
    
        # Type check executed (expected object)
        if "executed" in props and props["executed"] is not None:
            if not isinstance(props["executed"], object):
                try:
                    # Attempt to convert
                    props["executed"] = object(props["executed"])
                except:
                    raise TypeError(f"Property executed must be of type object, got {type(props['executed']).__name__}")
    
        # Type check contract_counts (expected object)
        if "contract_counts" in props and props["contract_counts"] is not None:
            if not isinstance(props["contract_counts"], object):
                try:
                    # Attempt to convert
                    props["contract_counts"] = object(props["contract_counts"])
                except:
                    raise TypeError(f"Property contract_counts must be of type object, got {type(props['contract_counts']).__name__}")
    
        # Type check legal_disputes (expected int)
        if "legal_disputes" in props and props["legal_disputes"] is not None:
            if not isinstance(props["legal_disputes"], int):
                try:
                    # Attempt to convert
                    props["legal_disputes"] = int(props["legal_disputes"])
                except:
                    raise TypeError(f"Property legal_disputes must be of type int, got {type(props['legal_disputes']).__name__}")
    
        # Type check dispute_resolutions (expected object)
        if "dispute_resolutions" in props and props["dispute_resolutions"] is not None:
            if not isinstance(props["dispute_resolutions"], object):
                try:
                    # Attempt to convert
                    props["dispute_resolutions"] = object(props["dispute_resolutions"])
                except:
                    raise TypeError(f"Property dispute_resolutions must be of type object, got {type(props['dispute_resolutions']).__name__}")
    
        # Type check governing_law (expected str)
        if "governing_law" in props and props["governing_law"] is not None:
            if not isinstance(props["governing_law"], str):
                try:
                    # Attempt to convert
                    props["governing_law"] = str(props["governing_law"])
                except:
                    raise TypeError(f"Property governing_law must be of type str, got {type(props['governing_law']).__name__}")
    
        # Type check contract_types (expected object)
        if "contract_types" in props and props["contract_types"] is not None:
            if not isinstance(props["contract_types"], object):
                try:
                    # Attempt to convert
                    props["contract_types"] = object(props["contract_types"])
                except:
                    raise TypeError(f"Property contract_types must be of type object, got {type(props['contract_types']).__name__}")
    
        # Type check key_signatories (expected object)
        if "key_signatories" in props and props["key_signatories"] is not None:
            if not isinstance(props["key_signatories"], object):
                try:
                    # Attempt to convert
                    props["key_signatories"] = object(props["key_signatories"])
                except:
                    raise TypeError(f"Property key_signatories must be of type object, got {type(props['key_signatories']).__name__}")
    
        # Type check legal_jurisdictions (expected int)
        if "legal_jurisdictions" in props and props["legal_jurisdictions"] is not None:
            if not isinstance(props["legal_jurisdictions"], int):
                try:
                    # Attempt to convert
                    props["legal_jurisdictions"] = int(props["legal_jurisdictions"])
                except:
                    raise TypeError(f"Property legal_jurisdictions must be of type int, got {type(props['legal_jurisdictions']).__name__}")
    
        # Type check pages_total (expected int)
        if "pages_total" in props and props["pages_total"] is not None:
            if not isinstance(props["pages_total"], int):
                try:
                    # Attempt to convert
                    props["pages_total"] = int(props["pages_total"])
                except:
                    raise TypeError(f"Property pages_total must be of type int, got {type(props['pages_total']).__name__}")
    
        # Type check amendments (expected int)
        if "amendments" in props and props["amendments"] is not None:
            if not isinstance(props["amendments"], int):
                try:
                    # Attempt to convert
                    props["amendments"] = int(props["amendments"])
                except:
                    raise TypeError(f"Property amendments must be of type int, got {type(props['amendments']).__name__}")
    
        # Type check confidentiality_level (expected str)
        if "confidentiality_level" in props and props["confidentiality_level"] is not None:
            if not isinstance(props["confidentiality_level"], str):
                try:
                    # Attempt to convert
                    props["confidentiality_level"] = str(props["confidentiality_level"])
                except:
                    raise TypeError(f"Property confidentiality_level must be of type str, got {type(props['confidentiality_level']).__name__}")
    
        # Type check storage_location (expected str)
        if "storage_location" in props and props["storage_location"] is not None:
            if not isinstance(props["storage_location"], str):
                try:
                    # Attempt to convert
                    props["storage_location"] = str(props["storage_location"])
                except:
                    raise TypeError(f"Property storage_location must be of type str, got {type(props['storage_location']).__name__}")
    
        # Type check document_count (expected int)
        if "document_count" in props and props["document_count"] is not None:
            if not isinstance(props["document_count"], int):
                try:
                    # Attempt to convert
                    props["document_count"] = int(props["document_count"])
                except:
                    raise TypeError(f"Property document_count must be of type int, got {type(props['document_count']).__name__}")
    
        # Type check dispute_mechanisms (expected str)
        if "dispute_mechanisms" in props and props["dispute_mechanisms"] is not None:
            if not isinstance(props["dispute_mechanisms"], str):
                try:
                    # Attempt to convert
                    props["dispute_mechanisms"] = str(props["dispute_mechanisms"])
                except:
                    raise TypeError(f"Property dispute_mechanisms must be of type str, got {type(props['dispute_mechanisms']).__name__}")
    
        # Type check signatories (expected int)
        if "signatories" in props and props["signatories"] is not None:
            if not isinstance(props["signatories"], int):
                try:
                    # Attempt to convert
                    props["signatories"] = int(props["signatories"])
                except:
                    raise TypeError(f"Property signatories must be of type int, got {type(props['signatories']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="LegalDocument", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def productionlogistics(uuid=None, **props):
        """
        Find nodes with label ProductionLogistics matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check fleet_counts (expected object)
        if "fleet_counts" in props and props["fleet_counts"] is not None:
            if not isinstance(props["fleet_counts"], object):
                try:
                    # Attempt to convert
                    props["fleet_counts"] = object(props["fleet_counts"])
                except:
                    raise TypeError(f"Property fleet_counts must be of type object, got {type(props['fleet_counts']).__name__}")
    
        # Type check location_shooting_days (expected object)
        if "location_shooting_days" in props and props["location_shooting_days"] is not None:
            if not isinstance(props["location_shooting_days"], object):
                try:
                    # Attempt to convert
                    props["location_shooting_days"] = object(props["location_shooting_days"])
                except:
                    raise TypeError(f"Property location_shooting_days must be of type object, got {type(props['location_shooting_days']).__name__}")
    
        # Type check location_days (expected object)
        if "location_days" in props and props["location_days"] is not None:
            if not isinstance(props["location_days"], object):
                try:
                    # Attempt to convert
                    props["location_days"] = object(props["location_days"])
                except:
                    raise TypeError(f"Property location_days must be of type object, got {type(props['location_days']).__name__}")
    
        # Type check soundstages (expected int)
        if "soundstages" in props and props["soundstages"] is not None:
            if not isinstance(props["soundstages"], int):
                try:
                    # Attempt to convert
                    props["soundstages"] = int(props["soundstages"])
                except:
                    raise TypeError(f"Property soundstages must be of type int, got {type(props['soundstages']).__name__}")
    
        # Type check primary_locations (expected object)
        if "primary_locations" in props and props["primary_locations"] is not None:
            if not isinstance(props["primary_locations"], object):
                try:
                    # Attempt to convert
                    props["primary_locations"] = object(props["primary_locations"])
                except:
                    raise TypeError(f"Property primary_locations must be of type object, got {type(props['primary_locations']).__name__}")
    
        # Type check location_types (expected object)
        if "location_types" in props and props["location_types"] is not None:
            if not isinstance(props["location_types"], object):
                try:
                    # Attempt to convert
                    props["location_types"] = object(props["location_types"])
                except:
                    raise TypeError(f"Property location_types must be of type object, got {type(props['location_types']).__name__}")
    
        # Type check transportation_fleet (expected object)
        if "transportation_fleet" in props and props["transportation_fleet"] is not None:
            if not isinstance(props["transportation_fleet"], object):
                try:
                    # Attempt to convert
                    props["transportation_fleet"] = object(props["transportation_fleet"])
                except:
                    raise TypeError(f"Property transportation_fleet must be of type object, got {type(props['transportation_fleet']).__name__}")
    
        # Type check equipment_vendors (expected int)
        if "equipment_vendors" in props and props["equipment_vendors"] is not None:
            if not isinstance(props["equipment_vendors"], int):
                try:
                    # Attempt to convert
                    props["equipment_vendors"] = int(props["equipment_vendors"])
                except:
                    raise TypeError(f"Property equipment_vendors must be of type int, got {type(props['equipment_vendors']).__name__}")
    
        # Type check implemented (expected object)
        if "implemented" in props and props["implemented"] is not None:
            if not isinstance(props["implemented"], object):
                try:
                    # Attempt to convert
                    props["implemented"] = object(props["implemented"])
                except:
                    raise TypeError(f"Property implemented must be of type object, got {type(props['implemented']).__name__}")
    
        # Type check locations (expected int)
        if "locations" in props and props["locations"] is not None:
            if not isinstance(props["locations"], int):
                try:
                    # Attempt to convert
                    props["locations"] = int(props["locations"])
                except:
                    raise TypeError(f"Property locations must be of type int, got {type(props['locations']).__name__}")
    
        # Type check catering_services (expected int)
        if "catering_services" in props and props["catering_services"] is not None:
            if not isinstance(props["catering_services"], int):
                try:
                    # Attempt to convert
                    props["catering_services"] = int(props["catering_services"])
                except:
                    raise TypeError(f"Property catering_services must be of type int, got {type(props['catering_services']).__name__}")
    
        # Type check total_shooting_days (expected int)
        if "total_shooting_days" in props and props["total_shooting_days"] is not None:
            if not isinstance(props["total_shooting_days"], int):
                try:
                    # Attempt to convert
                    props["total_shooting_days"] = int(props["total_shooting_days"])
                except:
                    raise TypeError(f"Property total_shooting_days must be of type int, got {type(props['total_shooting_days']).__name__}")
    
        # Type check crew_size (expected int)
        if "crew_size" in props and props["crew_size"] is not None:
            if not isinstance(props["crew_size"], int):
                try:
                    # Attempt to convert
                    props["crew_size"] = int(props["crew_size"])
                except:
                    raise TypeError(f"Property crew_size must be of type int, got {type(props['crew_size']).__name__}")
    
        # Type check hotel_room_nights (expected int)
        if "hotel_room_nights" in props and props["hotel_room_nights"] is not None:
            if not isinstance(props["hotel_room_nights"], int):
                try:
                    # Attempt to convert
                    props["hotel_room_nights"] = int(props["hotel_room_nights"])
                except:
                    raise TypeError(f"Property hotel_room_nights must be of type int, got {type(props['hotel_room_nights']).__name__}")
    
        # Type check extras_total (expected int)
        if "extras_total" in props and props["extras_total"] is not None:
            if not isinstance(props["extras_total"], int):
                try:
                    # Attempt to convert
                    props["extras_total"] = int(props["extras_total"])
                except:
                    raise TypeError(f"Property extras_total must be of type int, got {type(props['extras_total']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check completed (expected object)
        if "completed" in props and props["completed"] is not None:
            if not isinstance(props["completed"], object):
                try:
                    # Attempt to convert
                    props["completed"] = object(props["completed"])
                except:
                    raise TypeError(f"Property completed must be of type object, got {type(props['completed']).__name__}")
    
        # Type check cast_members (expected int)
        if "cast_members" in props and props["cast_members"] is not None:
            if not isinstance(props["cast_members"], int):
                try:
                    # Attempt to convert
                    props["cast_members"] = int(props["cast_members"])
                except:
                    raise TypeError(f"Property cast_members must be of type int, got {type(props['cast_members']).__name__}")
    
        # Type check vehicles_used (expected int)
        if "vehicles_used" in props and props["vehicles_used"] is not None:
            if not isinstance(props["vehicles_used"], int):
                try:
                    # Attempt to convert
                    props["vehicles_used"] = int(props["vehicles_used"])
                except:
                    raise TypeError(f"Property vehicles_used must be of type int, got {type(props['vehicles_used']).__name__}")
    
        # Type check created (expected object)
        if "created" in props and props["created"] is not None:
            if not isinstance(props["created"], object):
                try:
                    # Attempt to convert
                    props["created"] = object(props["created"])
                except:
                    raise TypeError(f"Property created must be of type object, got {type(props['created']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="ProductionLogistics", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def distributionnetwork(uuid=None, **props):
        """
        Find nodes with label DistributionNetwork matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check release_dates (expected object)
        if "release_dates" in props and props["release_dates"] is not None:
            if not isinstance(props["release_dates"], object):
                try:
                    # Attempt to convert
                    props["release_dates"] = object(props["release_dates"])
                except:
                    raise TypeError(f"Property release_dates must be of type object, got {type(props['release_dates']).__name__}")
    
        # Type check censorship_issues (expected object)
        if "censorship_issues" in props and props["censorship_issues"] is not None:
            if not isinstance(props["censorship_issues"], object):
                try:
                    # Attempt to convert
                    props["censorship_issues"] = object(props["censorship_issues"])
                except:
                    raise TypeError(f"Property censorship_issues must be of type object, got {type(props['censorship_issues']).__name__}")
    
        # Type check distribution_partners (expected int)
        if "distribution_partners" in props and props["distribution_partners"] is not None:
            if not isinstance(props["distribution_partners"], int):
                try:
                    # Attempt to convert
                    props["distribution_partners"] = int(props["distribution_partners"])
                except:
                    raise TypeError(f"Property distribution_partners must be of type int, got {type(props['distribution_partners']).__name__}")
    
        # Type check established (expected object)
        if "established" in props and props["established"] is not None:
            if not isinstance(props["established"], object):
                try:
                    # Attempt to convert
                    props["established"] = object(props["established"])
                except:
                    raise TypeError(f"Property established must be of type object, got {type(props['established']).__name__}")
    
        # Type check international_awards (expected int)
        if "international_awards" in props and props["international_awards"] is not None:
            if not isinstance(props["international_awards"], int):
                try:
                    # Attempt to convert
                    props["international_awards"] = int(props["international_awards"])
                except:
                    raise TypeError(f"Property international_awards must be of type int, got {type(props['international_awards']).__name__}")
    
        # Type check language_versions (expected int)
        if "language_versions" in props and props["language_versions"] is not None:
            if not isinstance(props["language_versions"], int):
                try:
                    # Attempt to convert
                    props["language_versions"] = int(props["language_versions"])
                except:
                    raise TypeError(f"Property language_versions must be of type int, got {type(props['language_versions']).__name__}")
    
        # Type check territories (expected int)
        if "territories" in props and props["territories"] is not None:
            if not isinstance(props["territories"], int):
                try:
                    # Attempt to convert
                    props["territories"] = int(props["territories"])
                except:
                    raise TypeError(f"Property territories must be of type int, got {type(props['territories']).__name__}")
    
        # Type check key_markets (expected object)
        if "key_markets" in props and props["key_markets"] is not None:
            if not isinstance(props["key_markets"], object):
                try:
                    # Attempt to convert
                    props["key_markets"] = object(props["key_markets"])
                except:
                    raise TypeError(f"Property key_markets must be of type object, got {type(props['key_markets']).__name__}")
    
        # Type check subtitled_markets (expected int)
        if "subtitled_markets" in props and props["subtitled_markets"] is not None:
            if not isinstance(props["subtitled_markets"], int):
                try:
                    # Attempt to convert
                    props["subtitled_markets"] = int(props["subtitled_markets"])
                except:
                    raise TypeError(f"Property subtitled_markets must be of type int, got {type(props['subtitled_markets']).__name__}")
    
        # Type check activated (expected object)
        if "activated" in props and props["activated"] is not None:
            if not isinstance(props["activated"], object):
                try:
                    # Attempt to convert
                    props["activated"] = object(props["activated"])
                except:
                    raise TypeError(f"Property activated must be of type object, got {type(props['activated']).__name__}")
    
        # Type check market_distributors (expected object)
        if "market_distributors" in props and props["market_distributors"] is not None:
            if not isinstance(props["market_distributors"], object):
                try:
                    # Attempt to convert
                    props["market_distributors"] = object(props["market_distributors"])
                except:
                    raise TypeError(f"Property market_distributors must be of type object, got {type(props['market_distributors']).__name__}")
    
        # Type check censorship_countries (expected object)
        if "censorship_countries" in props and props["censorship_countries"] is not None:
            if not isinstance(props["censorship_countries"], object):
                try:
                    # Attempt to convert
                    props["censorship_countries"] = object(props["censorship_countries"])
                except:
                    raise TypeError(f"Property censorship_countries must be of type object, got {type(props['censorship_countries']).__name__}")
    
        # Type check marketing_localization (expected int)
        if "marketing_localization" in props and props["marketing_localization"] is not None:
            if not isinstance(props["marketing_localization"], int):
                try:
                    # Attempt to convert
                    props["marketing_localization"] = int(props["marketing_localization"])
                except:
                    raise TypeError(f"Property marketing_localization must be of type int, got {type(props['marketing_localization']).__name__}")
    
        # Type check box_office_reporting (expected str)
        if "box_office_reporting" in props and props["box_office_reporting"] is not None:
            if not isinstance(props["box_office_reporting"], str):
                try:
                    # Attempt to convert
                    props["box_office_reporting"] = str(props["box_office_reporting"])
                except:
                    raise TypeError(f"Property box_office_reporting must be of type str, got {type(props['box_office_reporting']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check material_delivery_date (expected object)
        if "material_delivery_date" in props and props["material_delivery_date"] is not None:
            if not isinstance(props["material_delivery_date"], object):
                try:
                    # Attempt to convert
                    props["material_delivery_date"] = object(props["material_delivery_date"])
                except:
                    raise TypeError(f"Property material_delivery_date must be of type object, got {type(props['material_delivery_date']).__name__}")
    
        # Type check censorship_challenges (expected int)
        if "censorship_challenges" in props and props["censorship_challenges"] is not None:
            if not isinstance(props["censorship_challenges"], int):
                try:
                    # Attempt to convert
                    props["censorship_challenges"] = int(props["censorship_challenges"])
                except:
                    raise TypeError(f"Property censorship_challenges must be of type int, got {type(props['censorship_challenges']).__name__}")
    
        # Type check international_prints (expected int)
        if "international_prints" in props and props["international_prints"] is not None:
            if not isinstance(props["international_prints"], int):
                try:
                    # Attempt to convert
                    props["international_prints"] = int(props["international_prints"])
                except:
                    raise TypeError(f"Property international_prints must be of type int, got {type(props['international_prints']).__name__}")
    
        # Type check dubbed_markets (expected int)
        if "dubbed_markets" in props and props["dubbed_markets"] is not None:
            if not isinstance(props["dubbed_markets"], int):
                try:
                    # Attempt to convert
                    props["dubbed_markets"] = int(props["dubbed_markets"])
                except:
                    raise TypeError(f"Property dubbed_markets must be of type int, got {type(props['dubbed_markets']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="DistributionNetwork", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def insurancepolicy(uuid=None, **props):
        """
        Find nodes with label InsurancePolicy matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check excluded_risks (expected object)
        if "excluded_risks" in props and props["excluded_risks"] is not None:
            if not isinstance(props["excluded_risks"], object):
                try:
                    # Attempt to convert
                    props["excluded_risks"] = object(props["excluded_risks"])
                except:
                    raise TypeError(f"Property excluded_risks must be of type object, got {type(props['excluded_risks']).__name__}")
    
        # Type check policy_extensions (expected int)
        if "policy_extensions" in props and props["policy_extensions"] is not None:
            if not isinstance(props["policy_extensions"], int):
                try:
                    # Attempt to convert
                    props["policy_extensions"] = int(props["policy_extensions"])
                except:
                    raise TypeError(f"Property policy_extensions must be of type int, got {type(props['policy_extensions']).__name__}")
    
        # Type check special_endorsements (expected object)
        if "special_endorsements" in props and props["special_endorsements"] is not None:
            if not isinstance(props["special_endorsements"], object):
                try:
                    # Attempt to convert
                    props["special_endorsements"] = object(props["special_endorsements"])
                except:
                    raise TypeError(f"Property special_endorsements must be of type object, got {type(props['special_endorsements']).__name__}")
    
        # Type check premium_allocations (expected object)
        if "premium_allocations" in props and props["premium_allocations"] is not None:
            if not isinstance(props["premium_allocations"], object):
                try:
                    # Attempt to convert
                    props["premium_allocations"] = object(props["premium_allocations"])
                except:
                    raise TypeError(f"Property premium_allocations must be of type object, got {type(props['premium_allocations']).__name__}")
    
        # Type check coverage_types (expected object)
        if "coverage_types" in props and props["coverage_types"] is not None:
            if not isinstance(props["coverage_types"], object):
                try:
                    # Attempt to convert
                    props["coverage_types"] = object(props["coverage_types"])
                except:
                    raise TypeError(f"Property coverage_types must be of type object, got {type(props['coverage_types']).__name__}")
    
        # Type check coverage_limits (expected object)
        if "coverage_limits" in props and props["coverage_limits"] is not None:
            if not isinstance(props["coverage_limits"], object):
                try:
                    # Attempt to convert
                    props["coverage_limits"] = object(props["coverage_limits"])
                except:
                    raise TypeError(f"Property coverage_limits must be of type object, got {type(props['coverage_limits']).__name__}")
    
        # Type check underwriter (expected str)
        if "underwriter" in props and props["underwriter"] is not None:
            if not isinstance(props["underwriter"], str):
                try:
                    # Attempt to convert
                    props["underwriter"] = str(props["underwriter"])
                except:
                    raise TypeError(f"Property underwriter must be of type str, got {type(props['underwriter']).__name__}")
    
        # Type check premium_total (expected int)
        if "premium_total" in props and props["premium_total"] is not None:
            if not isinstance(props["premium_total"], int):
                try:
                    # Attempt to convert
                    props["premium_total"] = int(props["premium_total"])
                except:
                    raise TypeError(f"Property premium_total must be of type int, got {type(props['premium_total']).__name__}")
    
        # Type check currency (expected str)
        if "currency" in props and props["currency"] is not None:
            if not isinstance(props["currency"], str):
                try:
                    # Attempt to convert
                    props["currency"] = str(props["currency"])
                except:
                    raise TypeError(f"Property currency must be of type str, got {type(props['currency']).__name__}")
    
        # Type check expiration (expected object)
        if "expiration" in props and props["expiration"] is not None:
            if not isinstance(props["expiration"], object):
                try:
                    # Attempt to convert
                    props["expiration"] = object(props["expiration"])
                except:
                    raise TypeError(f"Property expiration must be of type object, got {type(props['expiration']).__name__}")
    
        # Type check issued (expected object)
        if "issued" in props and props["issued"] is not None:
            if not isinstance(props["issued"], object):
                try:
                    # Attempt to convert
                    props["issued"] = object(props["issued"])
                except:
                    raise TypeError(f"Property issued must be of type object, got {type(props['issued']).__name__}")
    
        # Type check claims_paid (expected int)
        if "claims_paid" in props and props["claims_paid"] is not None:
            if not isinstance(props["claims_paid"], int):
                try:
                    # Attempt to convert
                    props["claims_paid"] = int(props["claims_paid"])
                except:
                    raise TypeError(f"Property claims_paid must be of type int, got {type(props['claims_paid']).__name__}")
    
        # Type check policy_number (expected str)
        if "policy_number" in props and props["policy_number"] is not None:
            if not isinstance(props["policy_number"], str):
                try:
                    # Attempt to convert
                    props["policy_number"] = str(props["policy_number"])
                except:
                    raise TypeError(f"Property policy_number must be of type str, got {type(props['policy_number']).__name__}")
    
        # Type check deductible (expected int)
        if "deductible" in props and props["deductible"] is not None:
            if not isinstance(props["deductible"], int):
                try:
                    # Attempt to convert
                    props["deductible"] = int(props["deductible"])
                except:
                    raise TypeError(f"Property deductible must be of type int, got {type(props['deductible']).__name__}")
    
        # Type check broker (expected str)
        if "broker" in props and props["broker"] is not None:
            if not isinstance(props["broker"], str):
                try:
                    # Attempt to convert
                    props["broker"] = str(props["broker"])
                except:
                    raise TypeError(f"Property broker must be of type str, got {type(props['broker']).__name__}")
    
        # Type check effective (expected object)
        if "effective" in props and props["effective"] is not None:
            if not isinstance(props["effective"], object):
                try:
                    # Attempt to convert
                    props["effective"] = object(props["effective"])
                except:
                    raise TypeError(f"Property effective must be of type object, got {type(props['effective']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check coverage_limit (expected int)
        if "coverage_limit" in props and props["coverage_limit"] is not None:
            if not isinstance(props["coverage_limit"], int):
                try:
                    # Attempt to convert
                    props["coverage_limit"] = int(props["coverage_limit"])
                except:
                    raise TypeError(f"Property coverage_limit must be of type int, got {type(props['coverage_limit']).__name__}")
    
        # Type check claims_filed (expected int)
        if "claims_filed" in props and props["claims_filed"] is not None:
            if not isinstance(props["claims_filed"], int):
                try:
                    # Attempt to convert
                    props["claims_filed"] = int(props["claims_filed"])
                except:
                    raise TypeError(f"Property claims_filed must be of type int, got {type(props['claims_filed']).__name__}")
    
        # Type check claims_total (expected int)
        if "claims_total" in props and props["claims_total"] is not None:
            if not isinstance(props["claims_total"], int):
                try:
                    # Attempt to convert
                    props["claims_total"] = int(props["claims_total"])
                except:
                    raise TypeError(f"Property claims_total must be of type int, got {type(props['claims_total']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="InsurancePolicy", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def archiverecord(uuid=None, **props):
        """
        Find nodes with label ArchiveRecord matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check access_requests_annual (expected int)
        if "access_requests_annual" in props and props["access_requests_annual"] is not None:
            if not isinstance(props["access_requests_annual"], int):
                try:
                    # Attempt to convert
                    props["access_requests_annual"] = int(props["access_requests_annual"])
                except:
                    raise TypeError(f"Property access_requests_annual must be of type int, got {type(props['access_requests_annual']).__name__}")
    
        # Type check established (expected object)
        if "established" in props and props["established"] is not None:
            if not isinstance(props["established"], object):
                try:
                    # Attempt to convert
                    props["established"] = object(props["established"])
                except:
                    raise TypeError(f"Property established must be of type object, got {type(props['established']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check storage_facilities (expected object)
        if "storage_facilities" in props and props["storage_facilities"] is not None:
            if not isinstance(props["storage_facilities"], object):
                try:
                    # Attempt to convert
                    props["storage_facilities"] = object(props["storage_facilities"])
                except:
                    raise TypeError(f"Property storage_facilities must be of type object, got {type(props['storage_facilities']).__name__}")
    
        # Type check restoration_years (expected object)
        if "restoration_years" in props and props["restoration_years"] is not None:
            if not isinstance(props["restoration_years"], object):
                try:
                    # Attempt to convert
                    props["restoration_years"] = object(props["restoration_years"])
                except:
                    raise TypeError(f"Property restoration_years must be of type object, got {type(props['restoration_years']).__name__}")
    
        # Type check restoration_technologies (expected object)
        if "restoration_technologies" in props and props["restoration_technologies"] is not None:
            if not isinstance(props["restoration_technologies"], object):
                try:
                    # Attempt to convert
                    props["restoration_technologies"] = object(props["restoration_technologies"])
                except:
                    raise TypeError(f"Property restoration_technologies must be of type object, got {type(props['restoration_technologies']).__name__}")
    
        # Type check physical_elements (expected int)
        if "physical_elements" in props and props["physical_elements"] is not None:
            if not isinstance(props["physical_elements"], int):
                try:
                    # Attempt to convert
                    props["physical_elements"] = int(props["physical_elements"])
                except:
                    raise TypeError(f"Property physical_elements must be of type int, got {type(props['physical_elements']).__name__}")
    
        # Type check material_types (expected object)
        if "material_types" in props and props["material_types"] is not None:
            if not isinstance(props["material_types"], object):
                try:
                    # Attempt to convert
                    props["material_types"] = object(props["material_types"])
                except:
                    raise TypeError(f"Property material_types must be of type object, got {type(props['material_types']).__name__}")
    
        # Type check material_counts (expected object)
        if "material_counts" in props and props["material_counts"] is not None:
            if not isinstance(props["material_counts"], object):
                try:
                    # Attempt to convert
                    props["material_counts"] = object(props["material_counts"])
                except:
                    raise TypeError(f"Property material_counts must be of type object, got {type(props['material_counts']).__name__}")
    
        # Type check storage_locations (expected int)
        if "storage_locations" in props and props["storage_locations"] is not None:
            if not isinstance(props["storage_locations"], int):
                try:
                    # Attempt to convert
                    props["storage_locations"] = int(props["storage_locations"])
                except:
                    raise TypeError(f"Property storage_locations must be of type int, got {type(props['storage_locations']).__name__}")
    
        # Type check historical_designation (expected str)
        if "historical_designation" in props and props["historical_designation"] is not None:
            if not isinstance(props["historical_designation"], str):
                try:
                    # Attempt to convert
                    props["historical_designation"] = str(props["historical_designation"])
                except:
                    raise TypeError(f"Property historical_designation must be of type str, got {type(props['historical_designation']).__name__}")
    
        # Type check scholarly_access (expected str)
        if "scholarly_access" in props and props["scholarly_access"] is not None:
            if not isinstance(props["scholarly_access"], str):
                try:
                    # Attempt to convert
                    props["scholarly_access"] = str(props["scholarly_access"])
                except:
                    raise TypeError(f"Property scholarly_access must be of type str, got {type(props['scholarly_access']).__name__}")
    
        # Type check access_level (expected str)
        if "access_level" in props and props["access_level"] is not None:
            if not isinstance(props["access_level"], str):
                try:
                    # Attempt to convert
                    props["access_level"] = str(props["access_level"])
                except:
                    raise TypeError(f"Property access_level must be of type str, got {type(props['access_level']).__name__}")
    
        # Type check digital_elements (expected int)
        if "digital_elements" in props and props["digital_elements"] is not None:
            if not isinstance(props["digital_elements"], int):
                try:
                    # Attempt to convert
                    props["digital_elements"] = int(props["digital_elements"])
                except:
                    raise TypeError(f"Property digital_elements must be of type int, got {type(props['digital_elements']).__name__}")
    
        # Type check preservation_budget (expected int)
        if "preservation_budget" in props and props["preservation_budget"] is not None:
            if not isinstance(props["preservation_budget"], int):
                try:
                    # Attempt to convert
                    props["preservation_budget"] = int(props["preservation_budget"])
                except:
                    raise TypeError(f"Property preservation_budget must be of type int, got {type(props['preservation_budget']).__name__}")
    
        # Type check climate_controlled (expected bool)
        if "climate_controlled" in props and props["climate_controlled"] is not None:
            if not isinstance(props["climate_controlled"], bool):
                try:
                    # Attempt to convert
                    props["climate_controlled"] = bool(props["climate_controlled"])
                except:
                    raise TypeError(f"Property climate_controlled must be of type bool, got {type(props['climate_controlled']).__name__}")
    
        # Type check public_exhibitions (expected int)
        if "public_exhibitions" in props and props["public_exhibitions"] is not None:
            if not isinstance(props["public_exhibitions"], int):
                try:
                    # Attempt to convert
                    props["public_exhibitions"] = int(props["public_exhibitions"])
                except:
                    raise TypeError(f"Property public_exhibitions must be of type int, got {type(props['public_exhibitions']).__name__}")
    
        # Type check updated (expected object)
        if "updated" in props and props["updated"] is not None:
            if not isinstance(props["updated"], object):
                try:
                    # Attempt to convert
                    props["updated"] = object(props["updated"])
                except:
                    raise TypeError(f"Property updated must be of type object, got {type(props['updated']).__name__}")
    
        # Type check restoration_projects (expected int)
        if "restoration_projects" in props and props["restoration_projects"] is not None:
            if not isinstance(props["restoration_projects"], int):
                try:
                    # Attempt to convert
                    props["restoration_projects"] = int(props["restoration_projects"])
                except:
                    raise TypeError(f"Property restoration_projects must be of type int, got {type(props['restoration_projects']).__name__}")
    
        # Type check disaster_recovery_plan (expected bool)
        if "disaster_recovery_plan" in props and props["disaster_recovery_plan"] is not None:
            if not isinstance(props["disaster_recovery_plan"], bool):
                try:
                    # Attempt to convert
                    props["disaster_recovery_plan"] = bool(props["disaster_recovery_plan"])
                except:
                    raise TypeError(f"Property disaster_recovery_plan must be of type bool, got {type(props['disaster_recovery_plan']).__name__}")
    
        # Type check materials_cataloged (expected int)
        if "materials_cataloged" in props and props["materials_cataloged"] is not None:
            if not isinstance(props["materials_cataloged"], int):
                try:
                    # Attempt to convert
                    props["materials_cataloged"] = int(props["materials_cataloged"])
                except:
                    raise TypeError(f"Property materials_cataloged must be of type int, got {type(props['materials_cataloged']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="ArchiveRecord", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def laboragreement(uuid=None, **props):
        """
        Find nodes with label LaborAgreement matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check payroll_totals (expected object)
        if "payroll_totals" in props and props["payroll_totals"] is not None:
            if not isinstance(props["payroll_totals"], object):
                try:
                    # Attempt to convert
                    props["payroll_totals"] = object(props["payroll_totals"])
                except:
                    raise TypeError(f"Property payroll_totals must be of type object, got {type(props['payroll_totals']).__name__}")
    
        # Type check agreement_variations (expected object)
        if "agreement_variations" in props and props["agreement_variations"] is not None:
            if not isinstance(props["agreement_variations"], object):
                try:
                    # Attempt to convert
                    props["agreement_variations"] = object(props["agreement_variations"])
                except:
                    raise TypeError(f"Property agreement_variations must be of type object, got {type(props['agreement_variations']).__name__}")
    
        # Type check payroll_categories (expected object)
        if "payroll_categories" in props and props["payroll_categories"] is not None:
            if not isinstance(props["payroll_categories"], object):
                try:
                    # Attempt to convert
                    props["payroll_categories"] = object(props["payroll_categories"])
                except:
                    raise TypeError(f"Property payroll_categories must be of type object, got {type(props['payroll_categories']).__name__}")
    
        # Type check overtime_hours (expected int)
        if "overtime_hours" in props and props["overtime_hours"] is not None:
            if not isinstance(props["overtime_hours"], int):
                try:
                    # Attempt to convert
                    props["overtime_hours"] = int(props["overtime_hours"])
                except:
                    raise TypeError(f"Property overtime_hours must be of type int, got {type(props['overtime_hours']).__name__}")
    
        # Type check contract_variations (expected int)
        if "contract_variations" in props and props["contract_variations"] is not None:
            if not isinstance(props["contract_variations"], int):
                try:
                    # Attempt to convert
                    props["contract_variations"] = int(props["contract_variations"])
                except:
                    raise TypeError(f"Property contract_variations must be of type int, got {type(props['contract_variations']).__name__}")
    
        # Type check work_stoppages (expected int)
        if "work_stoppages" in props and props["work_stoppages"] is not None:
            if not isinstance(props["work_stoppages"], int):
                try:
                    # Attempt to convert
                    props["work_stoppages"] = int(props["work_stoppages"])
                except:
                    raise TypeError(f"Property work_stoppages must be of type int, got {type(props['work_stoppages']).__name__}")
    
        # Type check total_union_members (expected int)
        if "total_union_members" in props and props["total_union_members"] is not None:
            if not isinstance(props["total_union_members"], int):
                try:
                    # Attempt to convert
                    props["total_union_members"] = int(props["total_union_members"])
                except:
                    raise TypeError(f"Property total_union_members must be of type int, got {type(props['total_union_members']).__name__}")
    
        # Type check union_agreements (expected object)
        if "union_agreements" in props and props["union_agreements"] is not None:
            if not isinstance(props["union_agreements"], object):
                try:
                    # Attempt to convert
                    props["union_agreements"] = object(props["union_agreements"])
                except:
                    raise TypeError(f"Property union_agreements must be of type object, got {type(props['union_agreements']).__name__}")
    
        # Type check compliance_audit (expected object)
        if "compliance_audit" in props and props["compliance_audit"] is not None:
            if not isinstance(props["compliance_audit"], object):
                try:
                    # Attempt to convert
                    props["compliance_audit"] = object(props["compliance_audit"])
                except:
                    raise TypeError(f"Property compliance_audit must be of type object, got {type(props['compliance_audit']).__name__}")
    
        # Type check grievances_filed (expected int)
        if "grievances_filed" in props and props["grievances_filed"] is not None:
            if not isinstance(props["grievances_filed"], int):
                try:
                    # Attempt to convert
                    props["grievances_filed"] = int(props["grievances_filed"])
                except:
                    raise TypeError(f"Property grievances_filed must be of type int, got {type(props['grievances_filed']).__name__}")
    
        # Type check payroll_service (expected str)
        if "payroll_service" in props and props["payroll_service"] is not None:
            if not isinstance(props["payroll_service"], str):
                try:
                    # Attempt to convert
                    props["payroll_service"] = str(props["payroll_service"])
                except:
                    raise TypeError(f"Property payroll_service must be of type str, got {type(props['payroll_service']).__name__}")
    
        # Type check negotiated (expected object)
        if "negotiated" in props and props["negotiated"] is not None:
            if not isinstance(props["negotiated"], object):
                try:
                    # Attempt to convert
                    props["negotiated"] = object(props["negotiated"])
                except:
                    raise TypeError(f"Property negotiated must be of type object, got {type(props['negotiated']).__name__}")
    
        # Type check pension_contributions (expected int)
        if "pension_contributions" in props and props["pension_contributions"] is not None:
            if not isinstance(props["pension_contributions"], int):
                try:
                    # Attempt to convert
                    props["pension_contributions"] = int(props["pension_contributions"])
                except:
                    raise TypeError(f"Property pension_contributions must be of type int, got {type(props['pension_contributions']).__name__}")
    
        # Type check signatory_unions (expected int)
        if "signatory_unions" in props and props["signatory_unions"] is not None:
            if not isinstance(props["signatory_unions"], int):
                try:
                    # Attempt to convert
                    props["signatory_unions"] = int(props["signatory_unions"])
                except:
                    raise TypeError(f"Property signatory_unions must be of type int, got {type(props['signatory_unions']).__name__}")
    
        # Type check grievances_resolved (expected int)
        if "grievances_resolved" in props and props["grievances_resolved"] is not None:
            if not isinstance(props["grievances_resolved"], int):
                try:
                    # Attempt to convert
                    props["grievances_resolved"] = int(props["grievances_resolved"])
                except:
                    raise TypeError(f"Property grievances_resolved must be of type int, got {type(props['grievances_resolved']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check meal_penalties (expected int)
        if "meal_penalties" in props and props["meal_penalties"] is not None:
            if not isinstance(props["meal_penalties"], int):
                try:
                    # Attempt to convert
                    props["meal_penalties"] = int(props["meal_penalties"])
                except:
                    raise TypeError(f"Property meal_penalties must be of type int, got {type(props['meal_penalties']).__name__}")
    
        # Type check effective (expected object)
        if "effective" in props and props["effective"] is not None:
            if not isinstance(props["effective"], object):
                try:
                    # Attempt to convert
                    props["effective"] = object(props["effective"])
                except:
                    raise TypeError(f"Property effective must be of type object, got {type(props['effective']).__name__}")
    
        # Type check expiration (expected object)
        if "expiration" in props and props["expiration"] is not None:
            if not isinstance(props["expiration"], object):
                try:
                    # Attempt to convert
                    props["expiration"] = object(props["expiration"])
                except:
                    raise TypeError(f"Property expiration must be of type object, got {type(props['expiration']).__name__}")
    
        # Type check health_contributions (expected int)
        if "health_contributions" in props and props["health_contributions"] is not None:
            if not isinstance(props["health_contributions"], int):
                try:
                    # Attempt to convert
                    props["health_contributions"] = int(props["health_contributions"])
                except:
                    raise TypeError(f"Property health_contributions must be of type int, got {type(props['health_contributions']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="LaborAgreement", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def licensingprogram(uuid=None, **props):
        """
        Find nodes with label LicensingProgram matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check design_guidelines (expected str)
        if "design_guidelines" in props and props["design_guidelines"] is not None:
            if not isinstance(props["design_guidelines"], str):
                try:
                    # Attempt to convert
                    props["design_guidelines"] = str(props["design_guidelines"])
                except:
                    raise TypeError(f"Property design_guidelines must be of type str, got {type(props['design_guidelines']).__name__}")
    
        # Type check logo_treatments (expected int)
        if "logo_treatments" in props and props["logo_treatments"] is not None:
            if not isinstance(props["logo_treatments"], int):
                try:
                    # Attempt to convert
                    props["logo_treatments"] = int(props["logo_treatments"])
                except:
                    raise TypeError(f"Property logo_treatments must be of type int, got {type(props['logo_treatments']).__name__}")
    
        # Type check territories (expected int)
        if "territories" in props and props["territories"] is not None:
            if not isinstance(props["territories"], int):
                try:
                    # Attempt to convert
                    props["territories"] = int(props["territories"])
                except:
                    raise TypeError(f"Property territories must be of type int, got {type(props['territories']).__name__}")
    
        # Type check established (expected object)
        if "established" in props and props["established"] is not None:
            if not isinstance(props["established"], object):
                try:
                    # Attempt to convert
                    props["established"] = object(props["established"])
                except:
                    raise TypeError(f"Property established must be of type object, got {type(props['established']).__name__}")
    
        # Type check licensee_advances (expected object)
        if "licensee_advances" in props and props["licensee_advances"] is not None:
            if not isinstance(props["licensee_advances"], object):
                try:
                    # Attempt to convert
                    props["licensee_advances"] = object(props["licensee_advances"])
                except:
                    raise TypeError(f"Property licensee_advances must be of type object, got {type(props['licensee_advances']).__name__}")
    
        # Type check activated (expected object)
        if "activated" in props and props["activated"] is not None:
            if not isinstance(props["activated"], object):
                try:
                    # Attempt to convert
                    props["activated"] = object(props["activated"])
                except:
                    raise TypeError(f"Property activated must be of type object, got {type(props['activated']).__name__}")
    
        # Type check quality_control (expected str)
        if "quality_control" in props and props["quality_control"] is not None:
            if not isinstance(props["quality_control"], str):
                try:
                    # Attempt to convert
                    props["quality_control"] = str(props["quality_control"])
                except:
                    raise TypeError(f"Property quality_control must be of type str, got {type(props['quality_control']).__name__}")
    
        # Type check license_term (expected object)
        if "license_term" in props and props["license_term"] is not None:
            if not isinstance(props["license_term"], object):
                try:
                    # Attempt to convert
                    props["license_term"] = object(props["license_term"])
                except:
                    raise TypeError(f"Property license_term must be of type object, got {type(props['license_term']).__name__}")
    
        # Type check approval_process (expected str)
        if "approval_process" in props and props["approval_process"] is not None:
            if not isinstance(props["approval_process"], str):
                try:
                    # Attempt to convert
                    props["approval_process"] = str(props["approval_process"])
                except:
                    raise TypeError(f"Property approval_process must be of type str, got {type(props['approval_process']).__name__}")
    
        # Type check royalty_rates (expected str)
        if "royalty_rates" in props and props["royalty_rates"] is not None:
            if not isinstance(props["royalty_rates"], str):
                try:
                    # Attempt to convert
                    props["royalty_rates"] = str(props["royalty_rates"])
                except:
                    raise TypeError(f"Property royalty_rates must be of type str, got {type(props['royalty_rates']).__name__}")
    
        # Type check product_categories (expected int)
        if "product_categories" in props and props["product_categories"] is not None:
            if not isinstance(props["product_categories"], int):
                try:
                    # Attempt to convert
                    props["product_categories"] = int(props["product_categories"])
                except:
                    raise TypeError(f"Property product_categories must be of type int, got {type(props['product_categories']).__name__}")
    
        # Type check product_lines (expected object)
        if "product_lines" in props and props["product_lines"] is not None:
            if not isinstance(props["product_lines"], object):
                try:
                    # Attempt to convert
                    props["product_lines"] = object(props["product_lines"])
                except:
                    raise TypeError(f"Property product_lines must be of type object, got {type(props['product_lines']).__name__}")
    
        # Type check marketing_support (expected str)
        if "marketing_support" in props and props["marketing_support"] is not None:
            if not isinstance(props["marketing_support"], str):
                try:
                    # Attempt to convert
                    props["marketing_support"] = str(props["marketing_support"])
                except:
                    raise TypeError(f"Property marketing_support must be of type str, got {type(props['marketing_support']).__name__}")
    
        # Type check program_manager (expected str)
        if "program_manager" in props and props["program_manager"] is not None:
            if not isinstance(props["program_manager"], str):
                try:
                    # Attempt to convert
                    props["program_manager"] = str(props["program_manager"])
                except:
                    raise TypeError(f"Property program_manager must be of type str, got {type(props['program_manager']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check minimum_guarantees (expected int)
        if "minimum_guarantees" in props and props["minimum_guarantees"] is not None:
            if not isinstance(props["minimum_guarantees"], int):
                try:
                    # Attempt to convert
                    props["minimum_guarantees"] = int(props["minimum_guarantees"])
                except:
                    raise TypeError(f"Property minimum_guarantees must be of type int, got {type(props['minimum_guarantees']).__name__}")
    
        # Type check renewal_options (expected int)
        if "renewal_options" in props and props["renewal_options"] is not None:
            if not isinstance(props["renewal_options"], int):
                try:
                    # Attempt to convert
                    props["renewal_options"] = int(props["renewal_options"])
                except:
                    raise TypeError(f"Property renewal_options must be of type int, got {type(props['renewal_options']).__name__}")
    
        # Type check licensees (expected int)
        if "licensees" in props and props["licensees"] is not None:
            if not isinstance(props["licensees"], int):
                try:
                    # Attempt to convert
                    props["licensees"] = int(props["licensees"])
                except:
                    raise TypeError(f"Property licensees must be of type int, got {type(props['licensees']).__name__}")
    
        # Type check top_markets (expected object)
        if "top_markets" in props and props["top_markets"] is not None:
            if not isinstance(props["top_markets"], object):
                try:
                    # Attempt to convert
                    props["top_markets"] = object(props["top_markets"])
                except:
                    raise TypeError(f"Property top_markets must be of type object, got {type(props['top_markets']).__name__}")
    
        # Type check market_revenues (expected object)
        if "market_revenues" in props and props["market_revenues"] is not None:
            if not isinstance(props["market_revenues"], object):
                try:
                    # Attempt to convert
                    props["market_revenues"] = object(props["market_revenues"])
                except:
                    raise TypeError(f"Property market_revenues must be of type object, got {type(props['market_revenues']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="LicensingProgram", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def commercialdeal(uuid=None, **props):
        """
        Find nodes with label CommercialDeal matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check compensation_values (expected object)
        if "compensation_values" in props and props["compensation_values"] is not None:
            if not isinstance(props["compensation_values"], object):
                try:
                    # Attempt to convert
                    props["compensation_values"] = object(props["compensation_values"])
                except:
                    raise TypeError(f"Property compensation_values must be of type object, got {type(props['compensation_values']).__name__}")
    
        # Type check contract_pages (expected int)
        if "contract_pages" in props and props["contract_pages"] is not None:
            if not isinstance(props["contract_pages"], int):
                try:
                    # Attempt to convert
                    props["contract_pages"] = int(props["contract_pages"])
                except:
                    raise TypeError(f"Property contract_pages must be of type int, got {type(props['contract_pages']).__name__}")
    
        # Type check brand_names (expected object)
        if "brand_names" in props and props["brand_names"] is not None:
            if not isinstance(props["brand_names"], object):
                try:
                    # Attempt to convert
                    props["brand_names"] = object(props["brand_names"])
                except:
                    raise TypeError(f"Property brand_names must be of type object, got {type(props['brand_names']).__name__}")
    
        # Type check compensation_types (expected object)
        if "compensation_types" in props and props["compensation_types"] is not None:
            if not isinstance(props["compensation_types"], object):
                try:
                    # Attempt to convert
                    props["compensation_types"] = object(props["compensation_types"])
                except:
                    raise TypeError(f"Property compensation_types must be of type object, got {type(props['compensation_types']).__name__}")
    
        # Type check screen_placements (expected object)
        if "screen_placements" in props and props["screen_placements"] is not None:
            if not isinstance(props["screen_placements"], object):
                try:
                    # Attempt to convert
                    props["screen_placements"] = object(props["screen_placements"])
                except:
                    raise TypeError(f"Property screen_placements must be of type object, got {type(props['screen_placements']).__name__}")
    
        # Type check screen_time_total (expected object)
        if "screen_time_total" in props and props["screen_time_total"] is not None:
            if not isinstance(props["screen_time_total"], object):
                try:
                    # Attempt to convert
                    props["screen_time_total"] = object(props["screen_time_total"])
                except:
                    raise TypeError(f"Property screen_time_total must be of type object, got {type(props['screen_time_total']).__name__}")
    
        # Type check cash_compensation (expected int)
        if "cash_compensation" in props and props["cash_compensation"] is not None:
            if not isinstance(props["cash_compensation"], int):
                try:
                    # Attempt to convert
                    props["cash_compensation"] = int(props["cash_compensation"])
                except:
                    raise TypeError(f"Property cash_compensation must be of type int, got {type(props['cash_compensation']).__name__}")
    
        # Type check in_kind_value (expected int)
        if "in_kind_value" in props and props["in_kind_value"] is not None:
            if not isinstance(props["in_kind_value"], int):
                try:
                    # Attempt to convert
                    props["in_kind_value"] = int(props["in_kind_value"])
                except:
                    raise TypeError(f"Property in_kind_value must be of type int, got {type(props['in_kind_value']).__name__}")
    
        # Type check negotiation_rounds (expected int)
        if "negotiation_rounds" in props and props["negotiation_rounds"] is not None:
            if not isinstance(props["negotiation_rounds"], int):
                try:
                    # Attempt to convert
                    props["negotiation_rounds"] = int(props["negotiation_rounds"])
                except:
                    raise TypeError(f"Property negotiation_rounds must be of type int, got {type(props['negotiation_rounds']).__name__}")
    
        # Type check legal_review_hours (expected int)
        if "legal_review_hours" in props and props["legal_review_hours"] is not None:
            if not isinstance(props["legal_review_hours"], int):
                try:
                    # Attempt to convert
                    props["legal_review_hours"] = int(props["legal_review_hours"])
                except:
                    raise TypeError(f"Property legal_review_hours must be of type int, got {type(props['legal_review_hours']).__name__}")
    
        # Type check director_approvals (expected str)
        if "director_approvals" in props and props["director_approvals"] is not None:
            if not isinstance(props["director_approvals"], str):
                try:
                    # Attempt to convert
                    props["director_approvals"] = str(props["director_approvals"])
                except:
                    raise TypeError(f"Property director_approvals must be of type str, got {type(props['director_approvals']).__name__}")
    
        # Type check brands_featured (expected int)
        if "brands_featured" in props and props["brands_featured"] is not None:
            if not isinstance(props["brands_featured"], int):
                try:
                    # Attempt to convert
                    props["brands_featured"] = int(props["brands_featured"])
                except:
                    raise TypeError(f"Property brands_featured must be of type int, got {type(props['brands_featured']).__name__}")
    
        # Type check authenticity_restrictions (expected str)
        if "authenticity_restrictions" in props and props["authenticity_restrictions"] is not None:
            if not isinstance(props["authenticity_restrictions"], str):
                try:
                    # Attempt to convert
                    props["authenticity_restrictions"] = str(props["authenticity_restrictions"])
                except:
                    raise TypeError(f"Property authenticity_restrictions must be of type str, got {type(props['authenticity_restrictions']).__name__}")
    
        # Type check negotiated (expected object)
        if "negotiated" in props and props["negotiated"] is not None:
            if not isinstance(props["negotiated"], object):
                try:
                    # Attempt to convert
                    props["negotiated"] = object(props["negotiated"])
                except:
                    raise TypeError(f"Property negotiated must be of type object, got {type(props['negotiated']).__name__}")
    
        # Type check anachronism_avoidance (expected str)
        if "anachronism_avoidance" in props and props["anachronism_avoidance"] is not None:
            if not isinstance(props["anachronism_avoidance"], str):
                try:
                    # Attempt to convert
                    props["anachronism_avoidance"] = str(props["anachronism_avoidance"])
                except:
                    raise TypeError(f"Property anachronism_avoidance must be of type str, got {type(props['anachronism_avoidance']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check placement_seconds (expected object)
        if "placement_seconds" in props and props["placement_seconds"] is not None:
            if not isinstance(props["placement_seconds"], object):
                try:
                    # Attempt to convert
                    props["placement_seconds"] = object(props["placement_seconds"])
                except:
                    raise TypeError(f"Property placement_seconds must be of type object, got {type(props['placement_seconds']).__name__}")
    
        # Type check product_categories (expected object)
        if "product_categories" in props and props["product_categories"] is not None:
            if not isinstance(props["product_categories"], object):
                try:
                    # Attempt to convert
                    props["product_categories"] = object(props["product_categories"])
                except:
                    raise TypeError(f"Property product_categories must be of type object, got {type(props['product_categories']).__name__}")
    
        # Type check executed (expected object)
        if "executed" in props and props["executed"] is not None:
            if not isinstance(props["executed"], object):
                try:
                    # Attempt to convert
                    props["executed"] = object(props["executed"])
                except:
                    raise TypeError(f"Property executed must be of type object, got {type(props['executed']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="CommercialDeal", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def postproductionfacility(uuid=None, **props):
        """
        Find nodes with label PostProductionFacility matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check facility_names (expected object)
        if "facility_names" in props and props["facility_names"] is not None:
            if not isinstance(props["facility_names"], object):
                try:
                    # Attempt to convert
                    props["facility_names"] = object(props["facility_names"])
                except:
                    raise TypeError(f"Property facility_names must be of type object, got {type(props['facility_names']).__name__}")
    
        # Type check service_durations_unit (expected str)
        if "service_durations_unit" in props and props["service_durations_unit"] is not None:
            if not isinstance(props["service_durations_unit"], str):
                try:
                    # Attempt to convert
                    props["service_durations_unit"] = str(props["service_durations_unit"])
                except:
                    raise TypeError(f"Property service_durations_unit must be of type str, got {type(props['service_durations_unit']).__name__}")
    
        # Type check technical_systems (expected object)
        if "technical_systems" in props and props["technical_systems"] is not None:
            if not isinstance(props["technical_systems"], object):
                try:
                    # Attempt to convert
                    props["technical_systems"] = object(props["technical_systems"])
                except:
                    raise TypeError(f"Property technical_systems must be of type object, got {type(props['technical_systems']).__name__}")
    
        # Type check deliverable_formats (expected object)
        if "deliverable_formats" in props and props["deliverable_formats"] is not None:
            if not isinstance(props["deliverable_formats"], object):
                try:
                    # Attempt to convert
                    props["deliverable_formats"] = object(props["deliverable_formats"])
                except:
                    raise TypeError(f"Property deliverable_formats must be of type object, got {type(props['deliverable_formats']).__name__}")
    
        # Type check editing_suites (expected int)
        if "editing_suites" in props and props["editing_suites"] is not None:
            if not isinstance(props["editing_suites"], int):
                try:
                    # Attempt to convert
                    props["editing_suites"] = int(props["editing_suites"])
                except:
                    raise TypeError(f"Property editing_suites must be of type int, got {type(props['editing_suites']).__name__}")
    
        # Type check service_categories (expected object)
        if "service_categories" in props and props["service_categories"] is not None:
            if not isinstance(props["service_categories"], object):
                try:
                    # Attempt to convert
                    props["service_categories"] = object(props["service_categories"])
                except:
                    raise TypeError(f"Property service_categories must be of type object, got {type(props['service_categories']).__name__}")
    
        # Type check service_durations (expected object)
        if "service_durations" in props and props["service_durations"] is not None:
            if not isinstance(props["service_durations"], object):
                try:
                    # Attempt to convert
                    props["service_durations"] = object(props["service_durations"])
                except:
                    raise TypeError(f"Property service_durations must be of type object, got {type(props['service_durations']).__name__}")
    
        # Type check facility_locations (expected int)
        if "facility_locations" in props and props["facility_locations"] is not None:
            if not isinstance(props["facility_locations"], int):
                try:
                    # Attempt to convert
                    props["facility_locations"] = int(props["facility_locations"])
                except:
                    raise TypeError(f"Property facility_locations must be of type int, got {type(props['facility_locations']).__name__}")
    
        # Type check mixing_rooms (expected int)
        if "mixing_rooms" in props and props["mixing_rooms"] is not None:
            if not isinstance(props["mixing_rooms"], int):
                try:
                    # Attempt to convert
                    props["mixing_rooms"] = int(props["mixing_rooms"])
                except:
                    raise TypeError(f"Property mixing_rooms must be of type int, got {type(props['mixing_rooms']).__name__}")
    
        # Type check screening_rooms (expected int)
        if "screening_rooms" in props and props["screening_rooms"] is not None:
            if not isinstance(props["screening_rooms"], int):
                try:
                    # Attempt to convert
                    props["screening_rooms"] = int(props["screening_rooms"])
                except:
                    raise TypeError(f"Property screening_rooms must be of type int, got {type(props['screening_rooms']).__name__}")
    
        # Type check dailies_processed (expected int)
        if "dailies_processed" in props and props["dailies_processed"] is not None:
            if not isinstance(props["dailies_processed"], int):
                try:
                    # Attempt to convert
                    props["dailies_processed"] = int(props["dailies_processed"])
                except:
                    raise TypeError(f"Property dailies_processed must be of type int, got {type(props['dailies_processed']).__name__}")
    
        # Type check dailies_unit (expected str)
        if "dailies_unit" in props and props["dailies_unit"] is not None:
            if not isinstance(props["dailies_unit"], str):
                try:
                    # Attempt to convert
                    props["dailies_unit"] = str(props["dailies_unit"])
                except:
                    raise TypeError(f"Property dailies_unit must be of type str, got {type(props['dailies_unit']).__name__}")
    
        # Type check technical_staff (expected int)
        if "technical_staff" in props and props["technical_staff"] is not None:
            if not isinstance(props["technical_staff"], int):
                try:
                    # Attempt to convert
                    props["technical_staff"] = int(props["technical_staff"])
                except:
                    raise TypeError(f"Property technical_staff must be of type int, got {type(props['technical_staff']).__name__}")
    
        # Type check sound_stages (expected int)
        if "sound_stages" in props and props["sound_stages"] is not None:
            if not isinstance(props["sound_stages"], int):
                try:
                    # Attempt to convert
                    props["sound_stages"] = int(props["sound_stages"])
                except:
                    raise TypeError(f"Property sound_stages must be of type int, got {type(props['sound_stages']).__name__}")
    
        # Type check creative_staff (expected int)
        if "creative_staff" in props and props["creative_staff"] is not None:
            if not isinstance(props["creative_staff"], int):
                try:
                    # Attempt to convert
                    props["creative_staff"] = int(props["creative_staff"])
                except:
                    raise TypeError(f"Property creative_staff must be of type int, got {type(props['creative_staff']).__name__}")
    
        # Type check final_runtime (expected object)
        if "final_runtime" in props and props["final_runtime"] is not None:
            if not isinstance(props["final_runtime"], object):
                try:
                    # Attempt to convert
                    props["final_runtime"] = object(props["final_runtime"])
                except:
                    raise TypeError(f"Property final_runtime must be of type object, got {type(props['final_runtime']).__name__}")
    
        # Type check completed (expected object)
        if "completed" in props and props["completed"] is not None:
            if not isinstance(props["completed"], object):
                try:
                    # Attempt to convert
                    props["completed"] = object(props["completed"])
                except:
                    raise TypeError(f"Property completed must be of type object, got {type(props['completed']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check engaged (expected object)
        if "engaged" in props and props["engaged"] is not None:
            if not isinstance(props["engaged"], object):
                try:
                    # Attempt to convert
                    props["engaged"] = object(props["engaged"])
                except:
                    raise TypeError(f"Property engaged must be of type object, got {type(props['engaged']).__name__}")
    
        # Type check equipment_value (expected int)
        if "equipment_value" in props and props["equipment_value"] is not None:
            if not isinstance(props["equipment_value"], int):
                try:
                    # Attempt to convert
                    props["equipment_value"] = int(props["equipment_value"])
                except:
                    raise TypeError(f"Property equipment_value must be of type int, got {type(props['equipment_value']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="PostProductionFacility", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def filmlaboratory(uuid=None, **props):
        """
        Find nodes with label FilmLaboratory matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check established (expected object)
        if "established" in props and props["established"] is not None:
            if not isinstance(props["established"], object):
                try:
                    # Attempt to convert
                    props["established"] = object(props["established"])
                except:
                    raise TypeError(f"Property established must be of type object, got {type(props['established']).__name__}")
    
        # Type check processing_capacity (expected int)
        if "processing_capacity" in props and props["processing_capacity"] is not None:
            if not isinstance(props["processing_capacity"], int):
                try:
                    # Attempt to convert
                    props["processing_capacity"] = int(props["processing_capacity"])
                except:
                    raise TypeError(f"Property processing_capacity must be of type int, got {type(props['processing_capacity']).__name__}")
    
        # Type check facility_size_unit (expected str)
        if "facility_size_unit" in props and props["facility_size_unit"] is not None:
            if not isinstance(props["facility_size_unit"], str):
                try:
                    # Attempt to convert
                    props["facility_size_unit"] = str(props["facility_size_unit"])
                except:
                    raise TypeError(f"Property facility_size_unit must be of type str, got {type(props['facility_size_unit']).__name__}")
    
        # Type check film_formats (expected str)
        if "film_formats" in props and props["film_formats"] is not None:
            if not isinstance(props["film_formats"], str):
                try:
                    # Attempt to convert
                    props["film_formats"] = str(props["film_formats"])
                except:
                    raise TypeError(f"Property film_formats must be of type str, got {type(props['film_formats']).__name__}")
    
        # Type check project_engaged (expected object)
        if "project_engaged" in props and props["project_engaged"] is not None:
            if not isinstance(props["project_engaged"], object):
                try:
                    # Attempt to convert
                    props["project_engaged"] = object(props["project_engaged"])
                except:
                    raise TypeError(f"Property project_engaged must be of type object, got {type(props['project_engaged']).__name__}")
    
        # Type check industry_leadership (expected str)
        if "industry_leadership" in props and props["industry_leadership"] is not None:
            if not isinstance(props["industry_leadership"], str):
                try:
                    # Attempt to convert
                    props["industry_leadership"] = str(props["industry_leadership"])
                except:
                    raise TypeError(f"Property industry_leadership must be of type str, got {type(props['industry_leadership']).__name__}")
    
        # Type check employees (expected int)
        if "employees" in props and props["employees"] is not None:
            if not isinstance(props["employees"], int):
                try:
                    # Attempt to convert
                    props["employees"] = int(props["employees"])
                except:
                    raise TypeError(f"Property employees must be of type int, got {type(props['employees']).__name__}")
    
        # Type check project_completed (expected object)
        if "project_completed" in props and props["project_completed"] is not None:
            if not isinstance(props["project_completed"], object):
                try:
                    # Attempt to convert
                    props["project_completed"] = object(props["project_completed"])
                except:
                    raise TypeError(f"Property project_completed must be of type object, got {type(props['project_completed']).__name__}")
    
        # Type check capacity_unit (expected str)
        if "capacity_unit" in props and props["capacity_unit"] is not None:
            if not isinstance(props["capacity_unit"], str):
                try:
                    # Attempt to convert
                    props["capacity_unit"] = str(props["capacity_unit"])
                except:
                    raise TypeError(f"Property capacity_unit must be of type str, got {type(props['capacity_unit']).__name__}")
    
        # Type check processing_standards (expected object)
        if "processing_standards" in props and props["processing_standards"] is not None:
            if not isinstance(props["processing_standards"], object):
                try:
                    # Attempt to convert
                    props["processing_standards"] = object(props["processing_standards"])
                except:
                    raise TypeError(f"Property processing_standards must be of type object, got {type(props['processing_standards']).__name__}")
    
        # Type check client_list (expected object)
        if "client_list" in props and props["client_list"] is not None:
            if not isinstance(props["client_list"], object):
                try:
                    # Attempt to convert
                    props["client_list"] = object(props["client_list"])
                except:
                    raise TypeError(f"Property client_list must be of type object, got {type(props['client_list']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check facility_size (expected int)
        if "facility_size" in props and props["facility_size"] is not None:
            if not isinstance(props["facility_size"], int):
                try:
                    # Attempt to convert
                    props["facility_size"] = int(props["facility_size"])
                except:
                    raise TypeError(f"Property facility_size must be of type int, got {type(props['facility_size']).__name__}")
    
        # Type check equipment_types (expected object)
        if "equipment_types" in props and props["equipment_types"] is not None:
            if not isinstance(props["equipment_types"], object):
                try:
                    # Attempt to convert
                    props["equipment_types"] = object(props["equipment_types"])
                except:
                    raise TypeError(f"Property equipment_types must be of type object, got {type(props['equipment_types']).__name__}")
    
        # Type check equipment_counts (expected object)
        if "equipment_counts" in props and props["equipment_counts"] is not None:
            if not isinstance(props["equipment_counts"], object):
                try:
                    # Attempt to convert
                    props["equipment_counts"] = object(props["equipment_counts"])
                except:
                    raise TypeError(f"Property equipment_counts must be of type object, got {type(props['equipment_counts']).__name__}")
    
        # Type check chemical_systems (expected object)
        if "chemical_systems" in props and props["chemical_systems"] is not None:
            if not isinstance(props["chemical_systems"], object):
                try:
                    # Attempt to convert
                    props["chemical_systems"] = object(props["chemical_systems"])
                except:
                    raise TypeError(f"Property chemical_systems must be of type object, got {type(props['chemical_systems']).__name__}")
    
        # Type check quality_control_points (expected int)
        if "quality_control_points" in props and props["quality_control_points"] is not None:
            if not isinstance(props["quality_control_points"], int):
                try:
                    # Attempt to convert
                    props["quality_control_points"] = int(props["quality_control_points"])
                except:
                    raise TypeError(f"Property quality_control_points must be of type int, got {type(props['quality_control_points']).__name__}")
    
        # Type check processing_systems (expected str)
        if "processing_systems" in props and props["processing_systems"] is not None:
            if not isinstance(props["processing_systems"], str):
                try:
                    # Attempt to convert
                    props["processing_systems"] = str(props["processing_systems"])
                except:
                    raise TypeError(f"Property processing_systems must be of type str, got {type(props['processing_systems']).__name__}")
    
        # Type check technical_certifications (expected int)
        if "technical_certifications" in props and props["technical_certifications"] is not None:
            if not isinstance(props["technical_certifications"], int):
                try:
                    # Attempt to convert
                    props["technical_certifications"] = int(props["technical_certifications"])
                except:
                    raise TypeError(f"Property technical_certifications must be of type int, got {type(props['technical_certifications']).__name__}")
    
        # Type check services_provided (expected object)
        if "services_provided" in props and props["services_provided"] is not None:
            if not isinstance(props["services_provided"], object):
                try:
                    # Attempt to convert
                    props["services_provided"] = object(props["services_provided"])
                except:
                    raise TypeError(f"Property services_provided must be of type object, got {type(props['services_provided']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="FilmLaboratory", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def manual(uuid=None, **props):
        """
        Find nodes with label Manual matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.node(label="Manual", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def part(uuid=None, **props):
        """
        Find nodes with label Part matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.node(label="Part", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def chapter(uuid=None, **props):
        """
        Find nodes with label Chapter matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.node(label="Chapter", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def message(uuid=None, **props):
        """
        Find nodes with label Message matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.node(label="Message", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def concept(uuid=None, **props):
        """
        Find nodes with label Concept matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.node(label="Concept", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def topic(uuid=None, **props):
        """
        Find nodes with label Topic matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.node(label="Topic", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def cognitivestate(uuid=None, **props):
        """
        Find nodes with label CognitiveState matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.node(label="CognitiveState", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def algorithm(uuid=None, **props):
        """
        Find nodes with label Algorithm matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.node(label="Algorithm", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def animationstudio(uuid=None, **props):
        """
        Find nodes with label AnimationStudio matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check yearlyProductions (expected float)
        if "yearlyProductions" in props and props["yearlyProductions"] is not None:
            if not isinstance(props["yearlyProductions"], float):
                try:
                    # Attempt to convert
                    props["yearlyProductions"] = float(props["yearlyProductions"])
                except:
                    raise TypeError(f"Property yearlyProductions must be of type float, got {type(props['yearlyProductions']).__name__}")
    
        # Type check specialization (expected str)
        if "specialization" in props and props["specialization"] is not None:
            if not isinstance(props["specialization"], str):
                try:
                    # Attempt to convert
                    props["specialization"] = str(props["specialization"])
                except:
                    raise TypeError(f"Property specialization must be of type str, got {type(props['specialization']).__name__}")
    
        # Type check awardWins (expected int)
        if "awardWins" in props and props["awardWins"] is not None:
            if not isinstance(props["awardWins"], int):
                try:
                    # Attempt to convert
                    props["awardWins"] = int(props["awardWins"])
                except:
                    raise TypeError(f"Property awardWins must be of type int, got {type(props['awardWins']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check employeeCount (expected int)
        if "employeeCount" in props and props["employeeCount"] is not None:
            if not isinstance(props["employeeCount"], int):
                try:
                    # Attempt to convert
                    props["employeeCount"] = int(props["employeeCount"])
                except:
                    raise TypeError(f"Property employeeCount must be of type int, got {type(props['employeeCount']).__name__}")
    
        # Type check headquartersLong (expected float)
        if "headquartersLong" in props and props["headquartersLong"] is not None:
            if not isinstance(props["headquartersLong"], float):
                try:
                    # Attempt to convert
                    props["headquartersLong"] = float(props["headquartersLong"])
                except:
                    raise TypeError(f"Property headquartersLong must be of type float, got {type(props['headquartersLong']).__name__}")
    
        # Type check headquartersLat (expected float)
        if "headquartersLat" in props and props["headquartersLat"] is not None:
            if not isinstance(props["headquartersLat"], float):
                try:
                    # Attempt to convert
                    props["headquartersLat"] = float(props["headquartersLat"])
                except:
                    raise TypeError(f"Property headquartersLat must be of type float, got {type(props['headquartersLat']).__name__}")
    
        # Type check animationStyle (expected str)
        if "animationStyle" in props and props["animationStyle"] is not None:
            if not isinstance(props["animationStyle"], str):
                try:
                    # Attempt to convert
                    props["animationStyle"] = str(props["animationStyle"])
                except:
                    raise TypeError(f"Property animationStyle must be of type str, got {type(props['animationStyle']).__name__}")
    
        # Type check technologyBudget (expected int)
        if "technologyBudget" in props and props["technologyBudget"] is not None:
            if not isinstance(props["technologyBudget"], int):
                try:
                    # Attempt to convert
                    props["technologyBudget"] = int(props["technologyBudget"])
                except:
                    raise TypeError(f"Property technologyBudget must be of type int, got {type(props['technologyBudget']).__name__}")
    
        # Type check founded (expected object)
        if "founded" in props and props["founded"] is not None:
            if not isinstance(props["founded"], object):
                try:
                    # Attempt to convert
                    props["founded"] = object(props["founded"])
                except:
                    raise TypeError(f"Property founded must be of type object, got {type(props['founded']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="AnimationStudio", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def technicalinnovation(uuid=None, **props):
        """
        Find nodes with label TechnicalInnovation matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Type check industryAwards (expected int)
        if "industryAwards" in props and props["industryAwards"] is not None:
            if not isinstance(props["industryAwards"], int):
                try:
                    # Attempt to convert
                    props["industryAwards"] = int(props["industryAwards"])
                except:
                    raise TypeError(f"Property industryAwards must be of type int, got {type(props['industryAwards']).__name__}")
    
        # Type check adoptionRate (expected float)
        if "adoptionRate" in props and props["adoptionRate"] is not None:
            if not isinstance(props["adoptionRate"], float):
                try:
                    # Attempt to convert
                    props["adoptionRate"] = float(props["adoptionRate"])
                except:
                    raise TypeError(f"Property adoptionRate must be of type float, got {type(props['adoptionRate']).__name__}")
    
        # Type check secondaryApplications (expected int)
        if "secondaryApplications" in props and props["secondaryApplications"] is not None:
            if not isinstance(props["secondaryApplications"], int):
                try:
                    # Attempt to convert
                    props["secondaryApplications"] = int(props["secondaryApplications"])
                except:
                    raise TypeError(f"Property secondaryApplications must be of type int, got {type(props['secondaryApplications']).__name__}")
    
        # Type check mainApplication (expected str)
        if "mainApplication" in props and props["mainApplication"] is not None:
            if not isinstance(props["mainApplication"], str):
                try:
                    # Attempt to convert
                    props["mainApplication"] = str(props["mainApplication"])
                except:
                    raise TypeError(f"Property mainApplication must be of type str, got {type(props['mainApplication']).__name__}")
    
        # Type check technicalPapersPublished (expected int)
        if "technicalPapersPublished" in props and props["technicalPapersPublished"] is not None:
            if not isinstance(props["technicalPapersPublished"], int):
                try:
                    # Attempt to convert
                    props["technicalPapersPublished"] = int(props["technicalPapersPublished"])
                except:
                    raise TypeError(f"Property technicalPapersPublished must be of type int, got {type(props['technicalPapersPublished']).__name__}")
    
        # Type check teamSize (expected int)
        if "teamSize" in props and props["teamSize"] is not None:
            if not isinstance(props["teamSize"], int):
                try:
                    # Attempt to convert
                    props["teamSize"] = int(props["teamSize"])
                except:
                    raise TypeError(f"Property teamSize must be of type int, got {type(props['teamSize']).__name__}")
    
        # Type check developmentCost (expected int)
        if "developmentCost" in props and props["developmentCost"] is not None:
            if not isinstance(props["developmentCost"], int):
                try:
                    # Attempt to convert
                    props["developmentCost"] = int(props["developmentCost"])
                except:
                    raise TypeError(f"Property developmentCost must be of type int, got {type(props['developmentCost']).__name__}")
    
        # Type check patented (expected object)
        if "patented" in props and props["patented"] is not None:
            if not isinstance(props["patented"], object):
                try:
                    # Attempt to convert
                    props["patented"] = object(props["patented"])
                except:
                    raise TypeError(f"Property patented must be of type object, got {type(props['patented']).__name__}")
    
        # Type check developedDate (expected object)
        if "developedDate" in props and props["developedDate"] is not None:
            if not isinstance(props["developedDate"], object):
                try:
                    # Attempt to convert
                    props["developedDate"] = object(props["developedDate"])
                except:
                    raise TypeError(f"Property developedDate must be of type object, got {type(props['developedDate']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="TechnicalInnovation", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]


    def financialservice(uuid=None, **props):
        """
        Find nodes with label FinancialService matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the node to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Dict]:
            A list of matching nodes as dictionaries with keys 'uuid', 'labels', and 'props'
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check report_recipients (expected object)
        if "report_recipients" in props and props["report_recipients"] is not None:
            if not isinstance(props["report_recipients"], object):
                try:
                    # Attempt to convert
                    props["report_recipients"] = object(props["report_recipients"])
                except:
                    raise TypeError(f"Property report_recipients must be of type object, got {type(props['report_recipients']).__name__}")
    
        # Type check compliance_frameworks (expected object)
        if "compliance_frameworks" in props and props["compliance_frameworks"] is not None:
            if not isinstance(props["compliance_frameworks"], object):
                try:
                    # Attempt to convert
                    props["compliance_frameworks"] = object(props["compliance_frameworks"])
                except:
                    raise TypeError(f"Property compliance_frameworks must be of type object, got {type(props['compliance_frameworks']).__name__}")
    
        # Type check record_retention (expected str)
        if "record_retention" in props and props["record_retention"] is not None:
            if not isinstance(props["record_retention"], str):
                try:
                    # Attempt to convert
                    props["record_retention"] = str(props["record_retention"])
                except:
                    raise TypeError(f"Property record_retention must be of type str, got {type(props['record_retention']).__name__}")
    
        # Type check chart_of_accounts (expected str)
        if "chart_of_accounts" in props and props["chart_of_accounts"] is not None:
            if not isinstance(props["chart_of_accounts"], str):
                try:
                    # Attempt to convert
                    props["chart_of_accounts"] = str(props["chart_of_accounts"])
                except:
                    raise TypeError(f"Property chart_of_accounts must be of type str, got {type(props['chart_of_accounts']).__name__}")
    
        # Type check accounting_system (expected str)
        if "accounting_system" in props and props["accounting_system"] is not None:
            if not isinstance(props["accounting_system"], str):
                try:
                    # Attempt to convert
                    props["accounting_system"] = str(props["accounting_system"])
                except:
                    raise TypeError(f"Property accounting_system must be of type str, got {type(props['accounting_system']).__name__}")
    
        # Type check fiscal_year (expected str)
        if "fiscal_year" in props and props["fiscal_year"] is not None:
            if not isinstance(props["fiscal_year"], str):
                try:
                    # Attempt to convert
                    props["fiscal_year"] = str(props["fiscal_year"])
                except:
                    raise TypeError(f"Property fiscal_year must be of type str, got {type(props['fiscal_year']).__name__}")
    
        # Type check invoices_processed (expected int)
        if "invoices_processed" in props and props["invoices_processed"] is not None:
            if not isinstance(props["invoices_processed"], int):
                try:
                    # Attempt to convert
                    props["invoices_processed"] = int(props["invoices_processed"])
                except:
                    raise TypeError(f"Property invoices_processed must be of type int, got {type(props['invoices_processed']).__name__}")
    
        # Type check report_types (expected object)
        if "report_types" in props and props["report_types"] is not None:
            if not isinstance(props["report_types"], object):
                try:
                    # Attempt to convert
                    props["report_types"] = object(props["report_types"])
                except:
                    raise TypeError(f"Property report_types must be of type object, got {type(props['report_types']).__name__}")
    
        # Type check audits_conducted (expected int)
        if "audits_conducted" in props and props["audits_conducted"] is not None:
            if not isinstance(props["audits_conducted"], int):
                try:
                    # Attempt to convert
                    props["audits_conducted"] = int(props["audits_conducted"])
                except:
                    raise TypeError(f"Property audits_conducted must be of type int, got {type(props['audits_conducted']).__name__}")
    
        # Type check financial_reports (expected int)
        if "financial_reports" in props and props["financial_reports"] is not None:
            if not isinstance(props["financial_reports"], int):
                try:
                    # Attempt to convert
                    props["financial_reports"] = int(props["financial_reports"])
                except:
                    raise TypeError(f"Property financial_reports must be of type int, got {type(props['financial_reports']).__name__}")
    
        # Type check transactions_processed (expected int)
        if "transactions_processed" in props and props["transactions_processed"] is not None:
            if not isinstance(props["transactions_processed"], int):
                try:
                    # Attempt to convert
                    props["transactions_processed"] = int(props["transactions_processed"])
                except:
                    raise TypeError(f"Property transactions_processed must be of type int, got {type(props['transactions_processed']).__name__}")
    
        # Type check accounting_staff (expected int)
        if "accounting_staff" in props and props["accounting_staff"] is not None:
            if not isinstance(props["accounting_staff"], int):
                try:
                    # Attempt to convert
                    props["accounting_staff"] = int(props["accounting_staff"])
                except:
                    raise TypeError(f"Property accounting_staff must be of type int, got {type(props['accounting_staff']).__name__}")
    
        # Type check engaged (expected object)
        if "engaged" in props and props["engaged"] is not None:
            if not isinstance(props["engaged"], object):
                try:
                    # Attempt to convert
                    props["engaged"] = object(props["engaged"])
                except:
                    raise TypeError(f"Property engaged must be of type object, got {type(props['engaged']).__name__}")
    
        # Type check service_categories (expected object)
        if "service_categories" in props and props["service_categories"] is not None:
            if not isinstance(props["service_categories"], object):
                try:
                    # Attempt to convert
                    props["service_categories"] = object(props["service_categories"])
                except:
                    raise TypeError(f"Property service_categories must be of type object, got {type(props['service_categories']).__name__}")
    
        # Type check payroll_transactions (expected int)
        if "payroll_transactions" in props and props["payroll_transactions"] is not None:
            if not isinstance(props["payroll_transactions"], int):
                try:
                    # Attempt to convert
                    props["payroll_transactions"] = int(props["payroll_transactions"])
                except:
                    raise TypeError(f"Property payroll_transactions must be of type int, got {type(props['payroll_transactions']).__name__}")
    
        # Type check tax_filings (expected int)
        if "tax_filings" in props and props["tax_filings"] is not None:
            if not isinstance(props["tax_filings"], int):
                try:
                    # Attempt to convert
                    props["tax_filings"] = int(props["tax_filings"])
                except:
                    raise TypeError(f"Property tax_filings must be of type int, got {type(props['tax_filings']).__name__}")
    
        # Type check software_systems (expected object)
        if "software_systems" in props and props["software_systems"] is not None:
            if not isinstance(props["software_systems"], object):
                try:
                    # Attempt to convert
                    props["software_systems"] = object(props["software_systems"])
                except:
                    raise TypeError(f"Property software_systems must be of type object, got {type(props['software_systems']).__name__}")
    
        # Type check completed (expected object)
        if "completed" in props and props["completed"] is not None:
            if not isinstance(props["completed"], object):
                try:
                    # Attempt to convert
                    props["completed"] = object(props["completed"])
                except:
                    raise TypeError(f"Property completed must be of type object, got {type(props['completed']).__name__}")
    
        # Type check banking_relationships (expected object)
        if "banking_relationships" in props and props["banking_relationships"] is not None:
            if not isinstance(props["banking_relationships"], object):
                try:
                    # Attempt to convert
                    props["banking_relationships"] = object(props["banking_relationships"])
                except:
                    raise TypeError(f"Property banking_relationships must be of type object, got {type(props['banking_relationships']).__name__}")
    
        # Type check name (expected str)
        if "name" in props and props["name"] is not None:
            if not isinstance(props["name"], str):
                try:
                    # Attempt to convert
                    props["name"] = str(props["name"])
                except:
                    raise TypeError(f"Property name must be of type str, got {type(props['name']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.node(label="FinancialService", **search_props)
        results = _query(query, params)
        return [_neo4j_node_to_dict(result['n']) for result in results]



class Edges:
    """
    Interface for working with relationships in the Neo4j graph.
    Each method corresponds to a relationship type in the graph.
    """

    def acted_in(uuid=None, **props):
        """
        Find relationships of type ACTED_IN matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check roles (expected object)
        if "roles" in props and props["roles"] is not None:
            if not isinstance(props["roles"], object):
                try:
                    # Attempt to convert
                    props["roles"] = object(props["roles"])
                except:
                    raise TypeError(f"Property roles must be of type object, got {type(props['roles']).__name__}")
    
        # Type check awardNominations (expected int)
        if "awardNominations" in props and props["awardNominations"] is not None:
            if not isinstance(props["awardNominations"], int):
                try:
                    # Attempt to convert
                    props["awardNominations"] = int(props["awardNominations"])
                except:
                    raise TypeError(f"Property awardNominations must be of type int, got {type(props['awardNominations']).__name__}")
    
        # Type check endDate (expected object)
        if "endDate" in props and props["endDate"] is not None:
            if not isinstance(props["endDate"], object):
                try:
                    # Attempt to convert
                    props["endDate"] = object(props["endDate"])
                except:
                    raise TypeError(f"Property endDate must be of type object, got {type(props['endDate']).__name__}")
    
        # Type check awardWins (expected int)
        if "awardWins" in props and props["awardWins"] is not None:
            if not isinstance(props["awardWins"], int):
                try:
                    # Attempt to convert
                    props["awardWins"] = int(props["awardWins"])
                except:
                    raise TypeError(f"Property awardWins must be of type int, got {type(props['awardWins']).__name__}")
    
        # Type check screenTimeMinutes (expected int)
        if "screenTimeMinutes" in props and props["screenTimeMinutes"] is not None:
            if not isinstance(props["screenTimeMinutes"], int):
                try:
                    # Attempt to convert
                    props["screenTimeMinutes"] = int(props["screenTimeMinutes"])
                except:
                    raise TypeError(f"Property screenTimeMinutes must be of type int, got {type(props['screenTimeMinutes']).__name__}")
    
        # Type check startDate (expected object)
        if "startDate" in props and props["startDate"] is not None:
            if not isinstance(props["startDate"], object):
                try:
                    # Attempt to convert
                    props["startDate"] = object(props["startDate"])
                except:
                    raise TypeError(f"Property startDate must be of type object, got {type(props['startDate']).__name__}")
    
        # Type check psychologicalPreparation (expected str)
        if "psychologicalPreparation" in props and props["psychologicalPreparation"] is not None:
            if not isinstance(props["psychologicalPreparation"], str):
                try:
                    # Attempt to convert
                    props["psychologicalPreparation"] = str(props["psychologicalPreparation"])
                except:
                    raise TypeError(f"Property psychologicalPreparation must be of type str, got {type(props['psychologicalPreparation']).__name__}")
    
        # Type check audienceScore (expected int)
        if "audienceScore" in props and props["audienceScore"] is not None:
            if not isinstance(props["audienceScore"], int):
                try:
                    # Attempt to convert
                    props["audienceScore"] = int(props["audienceScore"])
                except:
                    raise TypeError(f"Property audienceScore must be of type int, got {type(props['audienceScore']).__name__}")
    
        # Type check criticScore (expected int)
        if "criticScore" in props and props["criticScore"] is not None:
            if not isinstance(props["criticScore"], int):
                try:
                    # Attempt to convert
                    props["criticScore"] = int(props["criticScore"])
                except:
                    raise TypeError(f"Property criticScore must be of type int, got {type(props['criticScore']).__name__}")
    
        # Type check scheduleConflicts (expected bool)
        if "scheduleConflicts" in props and props["scheduleConflicts"] is not None:
            if not isinstance(props["scheduleConflicts"], bool):
                try:
                    # Attempt to convert
                    props["scheduleConflicts"] = bool(props["scheduleConflicts"])
                except:
                    raise TypeError(f"Property scheduleConflicts must be of type bool, got {type(props['scheduleConflicts']).__name__}")
    
        # Type check salary (expected int)
        if "salary" in props and props["salary"] is not None:
            if not isinstance(props["salary"], int):
                try:
                    # Attempt to convert
                    props["salary"] = int(props["salary"])
                except:
                    raise TypeError(f"Property salary must be of type int, got {type(props['salary']).__name__}")
    
        # Type check emotionalImpact (expected str)
        if "emotionalImpact" in props and props["emotionalImpact"] is not None:
            if not isinstance(props["emotionalImpact"], str):
                try:
                    # Attempt to convert
                    props["emotionalImpact"] = str(props["emotionalImpact"])
                except:
                    raise TypeError(f"Property emotionalImpact must be of type str, got {type(props['emotionalImpact']).__name__}")
    
        # Type check characterDepth (expected str)
        if "characterDepth" in props and props["characterDepth"] is not None:
            if not isinstance(props["characterDepth"], str):
                try:
                    # Attempt to convert
                    props["characterDepth"] = str(props["characterDepth"])
                except:
                    raise TypeError(f"Property characterDepth must be of type str, got {type(props['characterDepth']).__name__}")
    
        # Type check performanceRating (expected float)
        if "performanceRating" in props and props["performanceRating"] is not None:
            if not isinstance(props["performanceRating"], float):
                try:
                    # Attempt to convert
                    props["performanceRating"] = float(props["performanceRating"])
                except:
                    raise TypeError(f"Property performanceRating must be of type float, got {type(props['performanceRating']).__name__}")
    
        # Type check stuntPerformed (expected bool)
        if "stuntPerformed" in props and props["stuntPerformed"] is not None:
            if not isinstance(props["stuntPerformed"], bool):
                try:
                    # Attempt to convert
                    props["stuntPerformed"] = bool(props["stuntPerformed"])
                except:
                    raise TypeError(f"Property stuntPerformed must be of type bool, got {type(props['stuntPerformed']).__name__}")
    
        # Type check trainingPeriodWeeks (expected int)
        if "trainingPeriodWeeks" in props and props["trainingPeriodWeeks"] is not None:
            if not isinstance(props["trainingPeriodWeeks"], int):
                try:
                    # Attempt to convert
                    props["trainingPeriodWeeks"] = int(props["trainingPeriodWeeks"])
                except:
                    raise TypeError(f"Property trainingPeriodWeeks must be of type int, got {type(props['trainingPeriodWeeks']).__name__}")
    
        # Type check dualRoleComplexity (expected str)
        if "dualRoleComplexity" in props and props["dualRoleComplexity"] is not None:
            if not isinstance(props["dualRoleComplexity"], str):
                try:
                    # Attempt to convert
                    props["dualRoleComplexity"] = str(props["dualRoleComplexity"])
                except:
                    raise TypeError(f"Property dualRoleComplexity must be of type str, got {type(props['dualRoleComplexity']).__name__}")
    
        # Type check makeupHoursDaily (expected int)
        if "makeupHoursDaily" in props and props["makeupHoursDaily"] is not None:
            if not isinstance(props["makeupHoursDaily"], int):
                try:
                    # Attempt to convert
                    props["makeupHoursDaily"] = int(props["makeupHoursDaily"])
                except:
                    raise TypeError(f"Property makeupHoursDaily must be of type int, got {type(props['makeupHoursDaily']).__name__}")
    
        # Type check ageTransformationYears (expected int)
        if "ageTransformationYears" in props and props["ageTransformationYears"] is not None:
            if not isinstance(props["ageTransformationYears"], int):
                try:
                    # Attempt to convert
                    props["ageTransformationYears"] = int(props["ageTransformationYears"])
                except:
                    raise TypeError(f"Property ageTransformationYears must be of type int, got {type(props['ageTransformationYears']).__name__}")
    
        # Type check languagesSpoken (expected object)
        if "languagesSpoken" in props and props["languagesSpoken"] is not None:
            if not isinstance(props["languagesSpoken"], object):
                try:
                    # Attempt to convert
                    props["languagesSpoken"] = object(props["languagesSpoken"])
                except:
                    raise TypeError(f"Property languagesSpoken must be of type object, got {type(props['languagesSpoken']).__name__}")
    
        # Type check stuntPercentage (expected int)
        if "stuntPercentage" in props and props["stuntPercentage"] is not None:
            if not isinstance(props["stuntPercentage"], int):
                try:
                    # Attempt to convert
                    props["stuntPercentage"] = int(props["stuntPercentage"])
                except:
                    raise TypeError(f"Property stuntPercentage must be of type int, got {type(props['stuntPercentage']).__name__}")
    
        # Type check martialArtsPerformed (expected bool)
        if "martialArtsPerformed" in props and props["martialArtsPerformed"] is not None:
            if not isinstance(props["martialArtsPerformed"], bool):
                try:
                    # Attempt to convert
                    props["martialArtsPerformed"] = bool(props["martialArtsPerformed"])
                except:
                    raise TypeError(f"Property martialArtsPerformed must be of type bool, got {type(props['martialArtsPerformed']).__name__}")
    
        # Type check physicalDemands (expected str)
        if "physicalDemands" in props and props["physicalDemands"] is not None:
            if not isinstance(props["physicalDemands"], str):
                try:
                    # Attempt to convert
                    props["physicalDemands"] = str(props["physicalDemands"])
                except:
                    raise TypeError(f"Property physicalDemands must be of type str, got {type(props['physicalDemands']).__name__}")
    
        # Type check collaborationNumber (expected int)
        if "collaborationNumber" in props and props["collaborationNumber"] is not None:
            if not isinstance(props["collaborationNumber"], int):
                try:
                    # Attempt to convert
                    props["collaborationNumber"] = int(props["collaborationNumber"])
                except:
                    raise TypeError(f"Property collaborationNumber must be of type int, got {type(props['collaborationNumber']).__name__}")
    
        # Type check characterComplexity (expected str)
        if "characterComplexity" in props and props["characterComplexity"] is not None:
            if not isinstance(props["characterComplexity"], str):
                try:
                    # Attempt to convert
                    props["characterComplexity"] = str(props["characterComplexity"])
                except:
                    raise TypeError(f"Property characterComplexity must be of type str, got {type(props['characterComplexity']).__name__}")
    
        # Type check reunionWithDirector (expected bool)
        if "reunionWithDirector" in props and props["reunionWithDirector"] is not None:
            if not isinstance(props["reunionWithDirector"], bool):
                try:
                    # Attempt to convert
                    props["reunionWithDirector"] = bool(props["reunionWithDirector"])
                except:
                    raise TypeError(f"Property reunionWithDirector must be of type bool, got {type(props['reunionWithDirector']).__name__}")
    
        # Type check songsPerformed (expected int)
        if "songsPerformed" in props and props["songsPerformed"] is not None:
            if not isinstance(props["songsPerformed"], int):
                try:
                    # Attempt to convert
                    props["songsPerformed"] = int(props["songsPerformed"])
                except:
                    raise TypeError(f"Property songsPerformed must be of type int, got {type(props['songsPerformed']).__name__}")
    
        # Type check careerDefiningRole (expected bool)
        if "careerDefiningRole" in props and props["careerDefiningRole"] is not None:
            if not isinstance(props["careerDefiningRole"], bool):
                try:
                    # Attempt to convert
                    props["careerDefiningRole"] = bool(props["careerDefiningRole"])
                except:
                    raise TypeError(f"Property careerDefiningRole must be of type bool, got {type(props['careerDefiningRole']).__name__}")
    
        # Type check physicalTrainingMonths (expected int)
        if "physicalTrainingMonths" in props and props["physicalTrainingMonths"] is not None:
            if not isinstance(props["physicalTrainingMonths"], int):
                try:
                    # Attempt to convert
                    props["physicalTrainingMonths"] = int(props["physicalTrainingMonths"])
                except:
                    raise TypeError(f"Property physicalTrainingMonths must be of type int, got {type(props['physicalTrainingMonths']).__name__}")
    
        # Type check motionCaptureHours (expected int)
        if "motionCaptureHours" in props and props["motionCaptureHours"] is not None:
            if not isinstance(props["motionCaptureHours"], int):
                try:
                    # Attempt to convert
                    props["motionCaptureHours"] = int(props["motionCaptureHours"])
                except:
                    raise TypeError(f"Property motionCaptureHours must be of type int, got {type(props['motionCaptureHours']).__name__}")
    
        # Type check stuntTrainingHours (expected int)
        if "stuntTrainingHours" in props and props["stuntTrainingHours"] is not None:
            if not isinstance(props["stuntTrainingHours"], int):
                try:
                    # Attempt to convert
                    props["stuntTrainingHours"] = int(props["stuntTrainingHours"])
                except:
                    raise TypeError(f"Property stuntTrainingHours must be of type int, got {type(props['stuntTrainingHours']).__name__}")
    
        # Type check dialectCoaching (expected bool)
        if "dialectCoaching" in props and props["dialectCoaching"] is not None:
            if not isinstance(props["dialectCoaching"], bool):
                try:
                    # Attempt to convert
                    props["dialectCoaching"] = bool(props["dialectCoaching"])
                except:
                    raise TypeError(f"Property dialectCoaching must be of type bool, got {type(props['dialectCoaching']).__name__}")
    
        # Type check ageAtFilming (expected int)
        if "ageAtFilming" in props and props["ageAtFilming"] is not None:
            if not isinstance(props["ageAtFilming"], int):
                try:
                    # Attempt to convert
                    props["ageAtFilming"] = int(props["ageAtFilming"])
                except:
                    raise TypeError(f"Property ageAtFilming must be of type int, got {type(props['ageAtFilming']).__name__}")
    
        # Type check underwaterScenes (expected int)
        if "underwaterScenes" in props and props["underwaterScenes"] is not None:
            if not isinstance(props["underwaterScenes"], int):
                try:
                    # Attempt to convert
                    props["underwaterScenes"] = int(props["underwaterScenes"])
                except:
                    raise TypeError(f"Property underwaterScenes must be of type int, got {type(props['underwaterScenes']).__name__}")
    
        # Type check characterImmersion (expected str)
        if "characterImmersion" in props and props["characterImmersion"] is not None:
            if not isinstance(props["characterImmersion"], str):
                try:
                    # Attempt to convert
                    props["characterImmersion"] = str(props["characterImmersion"])
                except:
                    raise TypeError(f"Property characterImmersion must be of type str, got {type(props['characterImmersion']).__name__}")
    
        # Type check characterEvolution (expected str)
        if "characterEvolution" in props and props["characterEvolution"] is not None:
            if not isinstance(props["characterEvolution"], str):
                try:
                    # Attempt to convert
                    props["characterEvolution"] = str(props["characterEvolution"])
                except:
                    raise TypeError(f"Property characterEvolution must be of type str, got {type(props['characterEvolution']).__name__}")
    
        # Type check studioOpposition (expected bool)
        if "studioOpposition" in props and props["studioOpposition"] is not None:
            if not isinstance(props["studioOpposition"], bool):
                try:
                    # Attempt to convert
                    props["studioOpposition"] = bool(props["studioOpposition"])
                except:
                    raise TypeError(f"Property studioOpposition must be of type bool, got {type(props['studioOpposition']).__name__}")
    
        # Type check martialArtsTraining (expected str)
        if "martialArtsTraining" in props and props["martialArtsTraining"] is not None:
            if not isinstance(props["martialArtsTraining"], str):
                try:
                    # Attempt to convert
                    props["martialArtsTraining"] = str(props["martialArtsTraining"])
                except:
                    raise TypeError(f"Property martialArtsTraining must be of type str, got {type(props['martialArtsTraining']).__name__}")
    
        # Type check characterIconicity (expected str)
        if "characterIconicity" in props and props["characterIconicity"] is not None:
            if not isinstance(props["characterIconicity"], str):
                try:
                    # Attempt to convert
                    props["characterIconicity"] = str(props["characterIconicity"])
                except:
                    raise TypeError(f"Property characterIconicity must be of type str, got {type(props['characterIconicity']).__name__}")
    
        # Type check iconicScenes (expected object)
        if "iconicScenes" in props and props["iconicScenes"] is not None:
            if not isinstance(props["iconicScenes"], object):
                try:
                    # Attempt to convert
                    props["iconicScenes"] = object(props["iconicScenes"])
                except:
                    raise TypeError(f"Property iconicScenes must be of type object, got {type(props['iconicScenes']).__name__}")
    
        # Type check period_costume_discomfort (expected str)
        if "period_costume_discomfort" in props and props["period_costume_discomfort"] is not None:
            if not isinstance(props["period_costume_discomfort"], str):
                try:
                    # Attempt to convert
                    props["period_costume_discomfort"] = str(props["period_costume_discomfort"])
                except:
                    raise TypeError(f"Property period_costume_discomfort must be of type str, got {type(props['period_costume_discomfort']).__name__}")
    
        # Type check characterReversal (expected str)
        if "characterReversal" in props and props["characterReversal"] is not None:
            if not isinstance(props["characterReversal"], str):
                try:
                    # Attempt to convert
                    props["characterReversal"] = str(props["characterReversal"])
                except:
                    raise TypeError(f"Property characterReversal must be of type str, got {type(props['characterReversal']).__name__}")
    
        # Type check catchphraseIconicity (expected str)
        if "catchphraseIconicity" in props and props["catchphraseIconicity"] is not None:
            if not isinstance(props["catchphraseIconicity"], str):
                try:
                    # Attempt to convert
                    props["catchphraseIconicity"] = str(props["catchphraseIconicity"])
                except:
                    raise TypeError(f"Property catchphraseIconicity must be of type str, got {type(props['catchphraseIconicity']).__name__}")
    
        # Type check physicalTraining (expected str)
        if "physicalTraining" in props and props["physicalTraining"] is not None:
            if not isinstance(props["physicalTraining"], str):
                try:
                    # Attempt to convert
                    props["physicalTraining"] = str(props["physicalTraining"])
                except:
                    raise TypeError(f"Property physicalTraining must be of type str, got {type(props['physicalTraining']).__name__}")
    
        # Type check improvisationLevel (expected str)
        if "improvisationLevel" in props and props["improvisationLevel"] is not None:
            if not isinstance(props["improvisationLevel"], str):
                try:
                    # Attempt to convert
                    props["improvisationLevel"] = str(props["improvisationLevel"])
                except:
                    raise TypeError(f"Property improvisationLevel must be of type str, got {type(props['improvisationLevel']).__name__}")
    
        # Type check swordTraining (expected str)
        if "swordTraining" in props and props["swordTraining"] is not None:
            if not isinstance(props["swordTraining"], str):
                try:
                    # Attempt to convert
                    props["swordTraining"] = str(props["swordTraining"])
                except:
                    raise TypeError(f"Property swordTraining must be of type str, got {type(props['swordTraining']).__name__}")
    
        # Type check bonuses (expected str)
        if "bonuses" in props and props["bonuses"] is not None:
            if not isinstance(props["bonuses"], str):
                try:
                    # Attempt to convert
                    props["bonuses"] = str(props["bonuses"])
                except:
                    raise TypeError(f"Property bonuses must be of type str, got {type(props['bonuses']).__name__}")
    
        # Type check methodPreparation (expected str)
        if "methodPreparation" in props and props["methodPreparation"] is not None:
            if not isinstance(props["methodPreparation"], str):
                try:
                    # Attempt to convert
                    props["methodPreparation"] = str(props["methodPreparation"])
                except:
                    raise TypeError(f"Property methodPreparation must be of type str, got {type(props['methodPreparation']).__name__}")
    
        # Type check physicalPreparation (expected str)
        if "physicalPreparation" in props and props["physicalPreparation"] is not None:
            if not isinstance(props["physicalPreparation"], str):
                try:
                    # Attempt to convert
                    props["physicalPreparation"] = str(props["physicalPreparation"])
                except:
                    raise TypeError(f"Property physicalPreparation must be of type str, got {type(props['physicalPreparation']).__name__}")
    
        # Type check improvisation (expected str)
        if "improvisation" in props and props["improvisation"] is not None:
            if not isinstance(props["improvisation"], str):
                try:
                    # Attempt to convert
                    props["improvisation"] = str(props["improvisation"])
                except:
                    raise TypeError(f"Property improvisation must be of type str, got {type(props['improvisation']).__name__}")
    
        # Type check intensityLevel (expected str)
        if "intensityLevel" in props and props["intensityLevel"] is not None:
            if not isinstance(props["intensityLevel"], str):
                try:
                    # Attempt to convert
                    props["intensityLevel"] = str(props["intensityLevel"])
                except:
                    raise TypeError(f"Property intensityLevel must be of type str, got {type(props['intensityLevel']).__name__}")
    
        # Type check loyaltyPortrayal (expected str)
        if "loyaltyPortrayal" in props and props["loyaltyPortrayal"] is not None:
            if not isinstance(props["loyaltyPortrayal"], str):
                try:
                    # Attempt to convert
                    props["loyaltyPortrayal"] = str(props["loyaltyPortrayal"])
                except:
                    raise TypeError(f"Property loyaltyPortrayal must be of type str, got {type(props['loyaltyPortrayal']).__name__}")
    
        # Type check characterSubtlety (expected str)
        if "characterSubtlety" in props and props["characterSubtlety"] is not None:
            if not isinstance(props["characterSubtlety"], str):
                try:
                    # Attempt to convert
                    props["characterSubtlety"] = str(props["characterSubtlety"])
                except:
                    raise TypeError(f"Property characterSubtlety must be of type str, got {type(props['characterSubtlety']).__name__}")
    
        # Type check legalResearch (expected str)
        if "legalResearch" in props and props["legalResearch"] is not None:
            if not isinstance(props["legalResearch"], str):
                try:
                    # Attempt to convert
                    props["legalResearch"] = str(props["legalResearch"])
                except:
                    raise TypeError(f"Property legalResearch must be of type str, got {type(props['legalResearch']).__name__}")
    
        # Type check outsiderPerspective (expected str)
        if "outsiderPerspective" in props and props["outsiderPerspective"] is not None:
            if not isinstance(props["outsiderPerspective"], str):
                try:
                    # Attempt to convert
                    props["outsiderPerspective"] = str(props["outsiderPerspective"])
                except:
                    raise TypeError(f"Property outsiderPerspective must be of type str, got {type(props['outsiderPerspective']).__name__}")
    
        # Type check characterArc (expected str)
        if "characterArc" in props and props["characterArc"] is not None:
            if not isinstance(props["characterArc"], str):
                try:
                    # Attempt to convert
                    props["characterArc"] = str(props["characterArc"])
                except:
                    raise TypeError(f"Property characterArc must be of type str, got {type(props['characterArc']).__name__}")
    
        # Type check sequelDevelopment (expected str)
        if "sequelDevelopment" in props and props["sequelDevelopment"] is not None:
            if not isinstance(props["sequelDevelopment"], str):
                try:
                    # Attempt to convert
                    props["sequelDevelopment"] = str(props["sequelDevelopment"])
                except:
                    raise TypeError(f"Property sequelDevelopment must be of type str, got {type(props['sequelDevelopment']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="ACTED_IN", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def directed(uuid=None, **props):
        """
        Find relationships of type DIRECTED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check completionDate (expected object)
        if "completionDate" in props and props["completionDate"] is not None:
            if not isinstance(props["completionDate"], object):
                try:
                    # Attempt to convert
                    props["completionDate"] = object(props["completionDate"])
                except:
                    raise TypeError(f"Property completionDate must be of type object, got {type(props['completionDate']).__name__}")
    
        # Type check satisfaction (expected float)
        if "satisfaction" in props and props["satisfaction"] is not None:
            if not isinstance(props["satisfaction"], float):
                try:
                    # Attempt to convert
                    props["satisfaction"] = float(props["satisfaction"])
                except:
                    raise TypeError(f"Property satisfaction must be of type float, got {type(props['satisfaction']).__name__}")
    
        # Type check daysOnSet (expected int)
        if "daysOnSet" in props and props["daysOnSet"] is not None:
            if not isinstance(props["daysOnSet"], int):
                try:
                    # Attempt to convert
                    props["daysOnSet"] = int(props["daysOnSet"])
                except:
                    raise TypeError(f"Property daysOnSet must be of type int, got {type(props['daysOnSet']).__name__}")
    
        # Type check premiereEvent (expected object)
        if "premiereEvent" in props and props["premiereEvent"] is not None:
            if not isinstance(props["premiereEvent"], object):
                try:
                    # Attempt to convert
                    props["premiereEvent"] = object(props["premiereEvent"])
                except:
                    raise TypeError(f"Property premiereEvent must be of type object, got {type(props['premiereEvent']).__name__}")
    
        # Type check isFirstCollaboration (expected bool)
        if "isFirstCollaboration" in props and props["isFirstCollaboration"] is not None:
            if not isinstance(props["isFirstCollaboration"], bool):
                try:
                    # Attempt to convert
                    props["isFirstCollaboration"] = bool(props["isFirstCollaboration"])
                except:
                    raise TypeError(f"Property isFirstCollaboration must be of type bool, got {type(props['isFirstCollaboration']).__name__}")
    
        # Type check durationMonths (expected int)
        if "durationMonths" in props and props["durationMonths"] is not None:
            if not isinstance(props["durationMonths"], int):
                try:
                    # Attempt to convert
                    props["durationMonths"] = int(props["durationMonths"])
                except:
                    raise TypeError(f"Property durationMonths must be of type int, got {type(props['durationMonths']).__name__}")
    
        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Type check awardNominations (expected int)
        if "awardNominations" in props and props["awardNominations"] is not None:
            if not isinstance(props["awardNominations"], int):
                try:
                    # Attempt to convert
                    props["awardNominations"] = int(props["awardNominations"])
                except:
                    raise TypeError(f"Property awardNominations must be of type int, got {type(props['awardNominations']).__name__}")
    
        # Type check techChallengeRatings (expected object)
        if "techChallengeRatings" in props and props["techChallengeRatings"] is not None:
            if not isinstance(props["techChallengeRatings"], object):
                try:
                    # Attempt to convert
                    props["techChallengeRatings"] = object(props["techChallengeRatings"])
                except:
                    raise TypeError(f"Property techChallengeRatings must be of type object, got {type(props['techChallengeRatings']).__name__}")
    
        # Type check originalRuntime (expected object)
        if "originalRuntime" in props and props["originalRuntime"] is not None:
            if not isinstance(props["originalRuntime"], object):
                try:
                    # Attempt to convert
                    props["originalRuntime"] = object(props["originalRuntime"])
                except:
                    raise TypeError(f"Property originalRuntime must be of type object, got {type(props['originalRuntime']).__name__}")
    
        # Type check finalRuntime (expected object)
        if "finalRuntime" in props and props["finalRuntime"] is not None:
            if not isinstance(props["finalRuntime"], object):
                try:
                    # Attempt to convert
                    props["finalRuntime"] = object(props["finalRuntime"])
                except:
                    raise TypeError(f"Property finalRuntime must be of type object, got {type(props['finalRuntime']).__name__}")
    
        # Type check scriptChanges (expected int)
        if "scriptChanges" in props and props["scriptChanges"] is not None:
            if not isinstance(props["scriptChanges"], int):
                try:
                    # Attempt to convert
                    props["scriptChanges"] = int(props["scriptChanges"])
                except:
                    raise TypeError(f"Property scriptChanges must be of type int, got {type(props['scriptChanges']).__name__}")
    
        # Type check technicalChallenges (expected object)
        if "technicalChallenges" in props and props["technicalChallenges"] is not None:
            if not isinstance(props["technicalChallenges"], object):
                try:
                    # Attempt to convert
                    props["technicalChallenges"] = object(props["technicalChallenges"])
                except:
                    raise TypeError(f"Property technicalChallenges must be of type object, got {type(props['technicalChallenges']).__name__}")
    
        # Type check consultants (expected object)
        if "consultants" in props and props["consultants"] is not None:
            if not isinstance(props["consultants"], object):
                try:
                    # Attempt to convert
                    props["consultants"] = object(props["consultants"])
                except:
                    raise TypeError(f"Property consultants must be of type object, got {type(props['consultants']).__name__}")
    
        # Type check consultationHours (expected object)
        if "consultationHours" in props and props["consultationHours"] is not None:
            if not isinstance(props["consultationHours"], object):
                try:
                    # Attempt to convert
                    props["consultationHours"] = object(props["consultationHours"])
                except:
                    raise TypeError(f"Property consultationHours must be of type object, got {type(props['consultationHours']).__name__}")
    
        # Type check age (expected int)
        if "age" in props and props["age"] is not None:
            if not isinstance(props["age"], int):
                try:
                    # Attempt to convert
                    props["age"] = int(props["age"])
                except:
                    raise TypeError(f"Property age must be of type int, got {type(props['age']).__name__}")
    
        # Type check isFirstFeatureFilm (expected bool)
        if "isFirstFeatureFilm" in props and props["isFirstFeatureFilm"] is not None:
            if not isinstance(props["isFirstFeatureFilm"], bool):
                try:
                    # Attempt to convert
                    props["isFirstFeatureFilm"] = bool(props["isFirstFeatureFilm"])
                except:
                    raise TypeError(f"Property isFirstFeatureFilm must be of type bool, got {type(props['isFirstFeatureFilm']).__name__}")
    
        # Type check studioPressure (expected str)
        if "studioPressure" in props and props["studioPressure"] is not None:
            if not isinstance(props["studioPressure"], str):
                try:
                    # Attempt to convert
                    props["studioPressure"] = str(props["studioPressure"])
                except:
                    raise TypeError(f"Property studioPressure must be of type str, got {type(props['studioPressure']).__name__}")
    
        # Type check personalThemes (expected object)
        if "personalThemes" in props and props["personalThemes"] is not None:
            if not isinstance(props["personalThemes"], object):
                try:
                    # Attempt to convert
                    props["personalThemes"] = object(props["personalThemes"])
                except:
                    raise TypeError(f"Property personalThemes must be of type object, got {type(props['personalThemes']).__name__}")
    
        # Type check isFirstInternationalBreakout (expected bool)
        if "isFirstInternationalBreakout" in props and props["isFirstInternationalBreakout"] is not None:
            if not isinstance(props["isFirstInternationalBreakout"], bool):
                try:
                    # Attempt to convert
                    props["isFirstInternationalBreakout"] = bool(props["isFirstInternationalBreakout"])
                except:
                    raise TypeError(f"Property isFirstInternationalBreakout must be of type bool, got {type(props['isFirstInternationalBreakout']).__name__}")
    
        # Type check awardWins (expected int)
        if "awardWins" in props and props["awardWins"] is not None:
            if not isinstance(props["awardWins"], int):
                try:
                    # Attempt to convert
                    props["awardWins"] = int(props["awardWins"])
                except:
                    raise TypeError(f"Property awardWins must be of type int, got {type(props['awardWins']).__name__}")
    
        # Type check daysInAntarctica (expected int)
        if "daysInAntarctica" in props and props["daysInAntarctica"] is not None:
            if not isinstance(props["daysInAntarctica"], int):
                try:
                    # Attempt to convert
                    props["daysInAntarctica"] = int(props["daysInAntarctica"])
                except:
                    raise TypeError(f"Property daysInAntarctica must be of type int, got {type(props['daysInAntarctica']).__name__}")
    
        # Type check scientificConsultants (expected int)
        if "scientificConsultants" in props and props["scientificConsultants"] is not None:
            if not isinstance(props["scientificConsultants"], int):
                try:
                    # Attempt to convert
                    props["scientificConsultants"] = int(props["scientificConsultants"])
                except:
                    raise TypeError(f"Property scientificConsultants must be of type int, got {type(props['scientificConsultants']).__name__}")
    
        # Type check isFirstMajorDocumentary (expected bool)
        if "isFirstMajorDocumentary" in props and props["isFirstMajorDocumentary"] is not None:
            if not isinstance(props["isFirstMajorDocumentary"], bool):
                try:
                    # Attempt to convert
                    props["isFirstMajorDocumentary"] = bool(props["isFirstMajorDocumentary"])
                except:
                    raise TypeError(f"Property isFirstMajorDocumentary must be of type bool, got {type(props['isFirstMajorDocumentary']).__name__}")
    
        # Type check fieldworkPhases (expected int)
        if "fieldworkPhases" in props and props["fieldworkPhases"] is not None:
            if not isinstance(props["fieldworkPhases"], int):
                try:
                    # Attempt to convert
                    props["fieldworkPhases"] = int(props["fieldworkPhases"])
                except:
                    raise TypeError(f"Property fieldworkPhases must be of type int, got {type(props['fieldworkPhases']).__name__}")
    
        # Type check coDirector (expected str)
        if "coDirector" in props and props["coDirector"] is not None:
            if not isinstance(props["coDirector"], str):
                try:
                    # Attempt to convert
                    props["coDirector"] = str(props["coDirector"])
                except:
                    raise TypeError(f"Property coDirector must be of type str, got {type(props['coDirector']).__name__}")
    
        # Type check isLowBudget (expected bool)
        if "isLowBudget" in props and props["isLowBudget"] is not None:
            if not isinstance(props["isLowBudget"], bool):
                try:
                    # Attempt to convert
                    props["isLowBudget"] = bool(props["isLowBudget"])
                except:
                    raise TypeError(f"Property isLowBudget must be of type bool, got {type(props['isLowBudget']).__name__}")
    
        # Type check studioInterference (expected str)
        if "studioInterference" in props and props["studioInterference"] is not None:
            if not isinstance(props["studioInterference"], str):
                try:
                    # Attempt to convert
                    props["studioInterference"] = str(props["studioInterference"])
                except:
                    raise TypeError(f"Property studioInterference must be of type str, got {type(props['studioInterference']).__name__}")
    
        # Type check blackAndWhiteDecision (expected str)
        if "blackAndWhiteDecision" in props and props["blackAndWhiteDecision"] is not None:
            if not isinstance(props["blackAndWhiteDecision"], str):
                try:
                    # Attempt to convert
                    props["blackAndWhiteDecision"] = str(props["blackAndWhiteDecision"])
                except:
                    raise TypeError(f"Property blackAndWhiteDecision must be of type str, got {type(props['blackAndWhiteDecision']).__name__}")
    
        # Type check developmentYears (expected int)
        if "developmentYears" in props and props["developmentYears"] is not None:
            if not isinstance(props["developmentYears"], int):
                try:
                    # Attempt to convert
                    props["developmentYears"] = int(props["developmentYears"])
                except:
                    raise TypeError(f"Property developmentYears must be of type int, got {type(props['developmentYears']).__name__}")
    
        # Type check isTechnicalInnovation (expected bool)
        if "isTechnicalInnovation" in props and props["isTechnicalInnovation"] is not None:
            if not isinstance(props["isTechnicalInnovation"], bool):
                try:
                    # Attempt to convert
                    props["isTechnicalInnovation"] = bool(props["isTechnicalInnovation"])
                except:
                    raise TypeError(f"Property isTechnicalInnovation must be of type bool, got {type(props['isTechnicalInnovation']).__name__}")
    
        # Type check marvelInvolvement (expected str)
        if "marvelInvolvement" in props and props["marvelInvolvement"] is not None:
            if not isinstance(props["marvelInvolvement"], str):
                try:
                    # Attempt to convert
                    props["marvelInvolvement"] = str(props["marvelInvolvement"])
                except:
                    raise TypeError(f"Property marvelInvolvement must be of type str, got {type(props['marvelInvolvement']).__name__}")
    
        # Type check culturalConsultants (expected int)
        if "culturalConsultants" in props and props["culturalConsultants"] is not None:
            if not isinstance(props["culturalConsultants"], int):
                try:
                    # Attempt to convert
                    props["culturalConsultants"] = int(props["culturalConsultants"])
                except:
                    raise TypeError(f"Property culturalConsultants must be of type int, got {type(props['culturalConsultants']).__name__}")
    
        # Type check improvisation (expected str)
        if "improvisation" in props and props["improvisation"] is not None:
            if not isinstance(props["improvisation"], str):
                try:
                    # Attempt to convert
                    props["improvisation"] = str(props["improvisation"])
                except:
                    raise TypeError(f"Property improvisation must be of type str, got {type(props['improvisation']).__name__}")
    
        # Type check isPersonalStory (expected bool)
        if "isPersonalStory" in props and props["isPersonalStory"] is not None:
            if not isinstance(props["isPersonalStory"], bool):
                try:
                    # Attempt to convert
                    props["isPersonalStory"] = bool(props["isPersonalStory"])
                except:
                    raise TypeError(f"Property isPersonalStory must be of type bool, got {type(props['isPersonalStory']).__name__}")
    
        # Type check budgetOverruns (expected bool)
        if "budgetOverruns" in props and props["budgetOverruns"] is not None:
            if not isinstance(props["budgetOverruns"], bool):
                try:
                    # Attempt to convert
                    props["budgetOverruns"] = bool(props["budgetOverruns"])
                except:
                    raise TypeError(f"Property budgetOverruns must be of type bool, got {type(props['budgetOverruns']).__name__}")
    
        # Type check scheduleOverruns (expected bool)
        if "scheduleOverruns" in props and props["scheduleOverruns"] is not None:
            if not isinstance(props["scheduleOverruns"], bool):
                try:
                    # Attempt to convert
                    props["scheduleOverruns"] = bool(props["scheduleOverruns"])
                except:
                    raise TypeError(f"Property scheduleOverruns must be of type bool, got {type(props['scheduleOverruns']).__name__}")
    
        # Type check castingBattles (expected str)
        if "castingBattles" in props and props["castingBattles"] is not None:
            if not isinstance(props["castingBattles"], str):
                try:
                    # Attempt to convert
                    props["castingBattles"] = str(props["castingBattles"])
                except:
                    raise TypeError(f"Property castingBattles must be of type str, got {type(props['castingBattles']).__name__}")
    
        # Type check studioFights (expected bool)
        if "studioFights" in props and props["studioFights"] is not None:
            if not isinstance(props["studioFights"], bool):
                try:
                    # Attempt to convert
                    props["studioFights"] = bool(props["studioFights"])
                except:
                    raise TypeError(f"Property studioFights must be of type bool, got {type(props['studioFights']).__name__}")
    
        # Type check practicalEffectsPercentage (expected int)
        if "practicalEffectsPercentage" in props and props["practicalEffectsPercentage"] is not None:
            if not isinstance(props["practicalEffectsPercentage"], int):
                try:
                    # Attempt to convert
                    props["practicalEffectsPercentage"] = int(props["practicalEffectsPercentage"])
                except:
                    raise TypeError(f"Property practicalEffectsPercentage must be of type int, got {type(props['practicalEffectsPercentage']).__name__}")
    
        # Type check iMAXUsage (expected str)
        if "iMAXUsage" in props and props["iMAXUsage"] is not None:
            if not isinstance(props["iMAXUsage"], str):
                try:
                    # Attempt to convert
                    props["iMAXUsage"] = str(props["iMAXUsage"])
                except:
                    raise TypeError(f"Property iMAXUsage must be of type str, got {type(props['iMAXUsage']).__name__}")
    
        # Type check nonLinearExperiment (expected bool)
        if "nonLinearExperiment" in props and props["nonLinearExperiment"] is not None:
            if not isinstance(props["nonLinearExperiment"], bool):
                try:
                    # Attempt to convert
                    props["nonLinearExperiment"] = bool(props["nonLinearExperiment"])
                except:
                    raise TypeError(f"Property nonLinearExperiment must be of type bool, got {type(props['nonLinearExperiment']).__name__}")
    
        # Type check scriptToScreen (expected str)
        if "scriptToScreen" in props and props["scriptToScreen"] is not None:
            if not isinstance(props["scriptToScreen"], str):
                try:
                    # Attempt to convert
                    props["scriptToScreen"] = str(props["scriptToScreen"])
                except:
                    raise TypeError(f"Property scriptToScreen must be of type str, got {type(props['scriptToScreen']).__name__}")
    
        # Type check actionChoreography (expected str)
        if "actionChoreography" in props and props["actionChoreography"] is not None:
            if not isinstance(props["actionChoreography"], str):
                try:
                    # Attempt to convert
                    props["actionChoreography"] = str(props["actionChoreography"])
                except:
                    raise TypeError(f"Property actionChoreography must be of type str, got {type(props['actionChoreography']).__name__}")
    
        # Type check crossCulturalChallenges (expected bool)
        if "crossCulturalChallenges" in props and props["crossCulturalChallenges"] is not None:
            if not isinstance(props["crossCulturalChallenges"], bool):
                try:
                    # Attempt to convert
                    props["crossCulturalChallenges"] = bool(props["crossCulturalChallenges"])
                except:
                    raise TypeError(f"Property crossCulturalChallenges must be of type bool, got {type(props['crossCulturalChallenges']).__name__}")
    
        # Type check creativeControl (expected str)
        if "creativeControl" in props and props["creativeControl"] is not None:
            if not isinstance(props["creativeControl"], str):
                try:
                    # Attempt to convert
                    props["creativeControl"] = str(props["creativeControl"])
                except:
                    raise TypeError(f"Property creativeControl must be of type str, got {type(props['creativeControl']).__name__}")
    
        # Type check sequelPressure (expected str)
        if "sequelPressure" in props and props["sequelPressure"] is not None:
            if not isinstance(props["sequelPressure"], str):
                try:
                    # Attempt to convert
                    props["sequelPressure"] = str(props["sequelPressure"])
                except:
                    raise TypeError(f"Property sequelPressure must be of type str, got {type(props['sequelPressure']).__name__}")
    
        # Type check scriptDevelopmentYears (expected int)
        if "scriptDevelopmentYears" in props and props["scriptDevelopmentYears"] is not None:
            if not isinstance(props["scriptDevelopmentYears"], int):
                try:
                    # Attempt to convert
                    props["scriptDevelopmentYears"] = int(props["scriptDevelopmentYears"])
                except:
                    raise TypeError(f"Property scriptDevelopmentYears must be of type int, got {type(props['scriptDevelopmentYears']).__name__}")
    
        # Type check originalConcept (expected bool)
        if "originalConcept" in props and props["originalConcept"] is not None:
            if not isinstance(props["originalConcept"], bool):
                try:
                    # Attempt to convert
                    props["originalConcept"] = bool(props["originalConcept"])
                except:
                    raise TypeError(f"Property originalConcept must be of type bool, got {type(props['originalConcept']).__name__}")
    
        # Type check directorStyleForming (expected str)
        if "directorStyleForming" in props and props["directorStyleForming"] is not None:
            if not isinstance(props["directorStyleForming"], str):
                try:
                    # Attempt to convert
                    props["directorStyleForming"] = str(props["directorStyleForming"])
                except:
                    raise TypeError(f"Property directorStyleForming must be of type str, got {type(props['directorStyleForming']).__name__}")
    
        # Type check studioConflicts (expected bool)
        if "studioConflicts" in props and props["studioConflicts"] is not None:
            if not isinstance(props["studioConflicts"], bool):
                try:
                    # Attempt to convert
                    props["studioConflicts"] = bool(props["studioConflicts"])
                except:
                    raise TypeError(f"Property studioConflicts must be of type bool, got {type(props['studioConflicts']).__name__}")
    
        # Type check homageLevel (expected str)
        if "homageLevel" in props and props["homageLevel"] is not None:
            if not isinstance(props["homageLevel"], str):
                try:
                    # Attempt to convert
                    props["homageLevel"] = str(props["homageLevel"])
                except:
                    raise TypeError(f"Property homageLevel must be of type str, got {type(props['homageLevel']).__name__}")
    
        # Type check genreBlending (expected str)
        if "genreBlending" in props and props["genreBlending"] is not None:
            if not isinstance(props["genreBlending"], str):
                try:
                    # Attempt to convert
                    props["genreBlending"] = str(props["genreBlending"])
                except:
                    raise TypeError(f"Property genreBlending must be of type str, got {type(props['genreBlending']).__name__}")
    
        # Type check crossCulturalInsight (expected str)
        if "crossCulturalInsight" in props and props["crossCulturalInsight"] is not None:
            if not isinstance(props["crossCulturalInsight"], str):
                try:
                    # Attempt to convert
                    props["crossCulturalInsight"] = str(props["crossCulturalInsight"])
                except:
                    raise TypeError(f"Property crossCulturalInsight must be of type str, got {type(props['crossCulturalInsight']).__name__}")
    
        # Type check genreDeparture (expected bool)
        if "genreDeparture" in props and props["genreDeparture"] is not None:
            if not isinstance(props["genreDeparture"], bool):
                try:
                    # Attempt to convert
                    props["genreDeparture"] = bool(props["genreDeparture"])
                except:
                    raise TypeError(f"Property genreDeparture must be of type bool, got {type(props['genreDeparture']).__name__}")
    
        # Type check iMAXInnovation (expected str)
        if "iMAXInnovation" in props and props["iMAXInnovation"] is not None:
            if not isinstance(props["iMAXInnovation"], str):
                try:
                    # Attempt to convert
                    props["iMAXInnovation"] = str(props["iMAXInnovation"])
                except:
                    raise TypeError(f"Property iMAXInnovation must be of type str, got {type(props['iMAXInnovation']).__name__}")
    
        # Type check sequelVision (expected str)
        if "sequelVision" in props and props["sequelVision"] is not None:
            if not isinstance(props["sequelVision"], str):
                try:
                    # Attempt to convert
                    props["sequelVision"] = str(props["sequelVision"])
                except:
                    raise TypeError(f"Property sequelVision must be of type str, got {type(props['sequelVision']).__name__}")
    
        # Type check technicalInnovations (expected str)
        if "technicalInnovations" in props and props["technicalInnovations"] is not None:
            if not isinstance(props["technicalInnovations"], str):
                try:
                    # Attempt to convert
                    props["technicalInnovations"] = str(props["technicalInnovations"])
                except:
                    raise TypeError(f"Property technicalInnovations must be of type str, got {type(props['technicalInnovations']).__name__}")
    
        # Type check militaryPrecision (expected str)
        if "militaryPrecision" in props and props["militaryPrecision"] is not None:
            if not isinstance(props["militaryPrecision"], str):
                try:
                    # Attempt to convert
                    props["militaryPrecision"] = str(props["militaryPrecision"])
                except:
                    raise TypeError(f"Property militaryPrecision must be of type str, got {type(props['militaryPrecision']).__name__}")
    
        # Type check weatherChallenges (expected bool)
        if "weatherChallenges" in props and props["weatherChallenges"] is not None:
            if not isinstance(props["weatherChallenges"], bool):
                try:
                    # Attempt to convert
                    props["weatherChallenges"] = bool(props["weatherChallenges"])
                except:
                    raise TypeError(f"Property weatherChallenges must be of type bool, got {type(props['weatherChallenges']).__name__}")
    
        # Type check paintingStoryboards (expected bool)
        if "paintingStoryboards" in props and props["paintingStoryboards"] is not None:
            if not isinstance(props["paintingStoryboards"], bool):
                try:
                    # Attempt to convert
                    props["paintingStoryboards"] = bool(props["paintingStoryboards"])
                except:
                    raise TypeError(f"Property paintingStoryboards must be of type bool, got {type(props['paintingStoryboards']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="DIRECTED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def produced(uuid=None, **props):
        """
        Find relationships of type PRODUCED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check producerShare (expected float)
        if "producerShare" in props and props["producerShare"] is not None:
            if not isinstance(props["producerShare"], float):
                try:
                    # Attempt to convert
                    props["producerShare"] = float(props["producerShare"])
                except:
                    raise TypeError(f"Property producerShare must be of type float, got {type(props['producerShare']).__name__}")
    
        # Type check topCastShare (expected float)
        if "topCastShare" in props and props["topCastShare"] is not None:
            if not isinstance(props["topCastShare"], float):
                try:
                    # Attempt to convert
                    props["topCastShare"] = float(props["topCastShare"])
                except:
                    raise TypeError(f"Property topCastShare must be of type float, got {type(props['topCastShare']).__name__}")
    
        # Type check roi (expected float)
        if "roi" in props and props["roi"] is not None:
            if not isinstance(props["roi"], float):
                try:
                    # Attempt to convert
                    props["roi"] = float(props["roi"])
                except:
                    raise TypeError(f"Property roi must be of type float, got {type(props['roi']).__name__}")
    
        # Type check marketingStart (expected object)
        if "marketingStart" in props and props["marketingStart"] is not None:
            if not isinstance(props["marketingStart"], object):
                try:
                    # Attempt to convert
                    props["marketingStart"] = object(props["marketingStart"])
                except:
                    raise TypeError(f"Property marketingStart must be of type object, got {type(props['marketingStart']).__name__}")
    
        # Type check marketingBudget (expected int)
        if "marketingBudget" in props and props["marketingBudget"] is not None:
            if not isinstance(props["marketingBudget"], int):
                try:
                    # Attempt to convert
                    props["marketingBudget"] = int(props["marketingBudget"])
                except:
                    raise TypeError(f"Property marketingBudget must be of type int, got {type(props['marketingBudget']).__name__}")
    
        # Type check investment (expected int)
        if "investment" in props and props["investment"] is not None:
            if not isinstance(props["investment"], int):
                try:
                    # Attempt to convert
                    props["investment"] = int(props["investment"])
                except:
                    raise TypeError(f"Property investment must be of type int, got {type(props['investment']).__name__}")
    
        # Type check directorShare (expected float)
        if "directorShare" in props and props["directorShare"] is not None:
            if not isinstance(props["directorShare"], float):
                try:
                    # Attempt to convert
                    props["directorShare"] = float(props["directorShare"])
                except:
                    raise TypeError(f"Property directorShare must be of type float, got {type(props['directorShare']).__name__}")
    
        # Type check return (expected int)
        if "return" in props and props["return"] is not None:
            if not isinstance(props["return"], int):
                try:
                    # Attempt to convert
                    props["return"] = int(props["return"])
                except:
                    raise TypeError(f"Property return must be of type int, got {type(props['return']).__name__}")
    
        # Type check contractSigned (expected object)
        if "contractSigned" in props and props["contractSigned"] is not None:
            if not isinstance(props["contractSigned"], object):
                try:
                    # Attempt to convert
                    props["contractSigned"] = object(props["contractSigned"])
                except:
                    raise TypeError(f"Property contractSigned must be of type object, got {type(props['contractSigned']).__name__}")
    
        # Type check studioShare (expected float)
        if "studioShare" in props and props["studioShare"] is not None:
            if not isinstance(props["studioShare"], float):
                try:
                    # Attempt to convert
                    props["studioShare"] = float(props["studioShare"])
                except:
                    raise TypeError(f"Property studioShare must be of type float, got {type(props['studioShare']).__name__}")
    
        # Type check isProfitable (expected bool)
        if "isProfitable" in props and props["isProfitable"] is not None:
            if not isinstance(props["isProfitable"], bool):
                try:
                    # Attempt to convert
                    props["isProfitable"] = bool(props["isProfitable"])
                except:
                    raise TypeError(f"Property isProfitable must be of type bool, got {type(props['isProfitable']).__name__}")
    
        # Type check breakEvenDate (expected object)
        if "breakEvenDate" in props and props["breakEvenDate"] is not None:
            if not isinstance(props["breakEvenDate"], object):
                try:
                    # Attempt to convert
                    props["breakEvenDate"] = object(props["breakEvenDate"])
                except:
                    raise TypeError(f"Property breakEvenDate must be of type object, got {type(props['breakEvenDate']).__name__}")
    
        # Type check studioRisk (expected str)
        if "studioRisk" in props and props["studioRisk"] is not None:
            if not isinstance(props["studioRisk"], str):
                try:
                    # Attempt to convert
                    props["studioRisk"] = str(props["studioRisk"])
                except:
                    raise TypeError(f"Property studioRisk must be of type str, got {type(props['studioRisk']).__name__}")
    
        # Type check marketingStartDate (expected object)
        if "marketingStartDate" in props and props["marketingStartDate"] is not None:
            if not isinstance(props["marketingStartDate"], object):
                try:
                    # Attempt to convert
                    props["marketingStartDate"] = object(props["marketingStartDate"])
                except:
                    raise TypeError(f"Property marketingStartDate must be of type object, got {type(props['marketingStartDate']).__name__}")
    
        # Type check heartNegativePressureLevel (expected float)
        if "heartNegativePressureLevel" in props and props["heartNegativePressureLevel"] is not None:
            if not isinstance(props["heartNegativePressureLevel"], float):
                try:
                    # Attempt to convert
                    props["heartNegativePressureLevel"] = float(props["heartNegativePressureLevel"])
                except:
                    raise TypeError(f"Property heartNegativePressureLevel must be of type float, got {type(props['heartNegativePressureLevel']).__name__}")
    
        # Type check executiveSupport (expected str)
        if "executiveSupport" in props and props["executiveSupport"] is not None:
            if not isinstance(props["executiveSupport"], str):
                try:
                    # Attempt to convert
                    props["executiveSupport"] = str(props["executiveSupport"])
                except:
                    raise TypeError(f"Property executiveSupport must be of type str, got {type(props['executiveSupport']).__name__}")
    
        # Type check controversyHandling (expected str)
        if "controversyHandling" in props and props["controversyHandling"] is not None:
            if not isinstance(props["controversyHandling"], str):
                try:
                    # Attempt to convert
                    props["controversyHandling"] = str(props["controversyHandling"])
                except:
                    raise TypeError(f"Property controversyHandling must be of type str, got {type(props['controversyHandling']).__name__}")
    
        # Type check internationalMarketingBoost (expected object)
        if "internationalMarketingBoost" in props and props["internationalMarketingBoost"] is not None:
            if not isinstance(props["internationalMarketingBoost"], object):
                try:
                    # Attempt to convert
                    props["internationalMarketingBoost"] = object(props["internationalMarketingBoost"])
                except:
                    raise TypeError(f"Property internationalMarketingBoost must be of type object, got {type(props['internationalMarketingBoost']).__name__}")
    
        # Type check hitchcockDeal (expected str)
        if "hitchcockDeal" in props and props["hitchcockDeal"] is not None:
            if not isinstance(props["hitchcockDeal"], str):
                try:
                    # Attempt to convert
                    props["hitchcockDeal"] = str(props["hitchcockDeal"])
                except:
                    raise TypeError(f"Property hitchcockDeal must be of type str, got {type(props['hitchcockDeal']).__name__}")
    
        # Type check indieBreakoutStatus (expected bool)
        if "indieBreakoutStatus" in props and props["indieBreakoutStatus"] is not None:
            if not isinstance(props["indieBreakoutStatus"], bool):
                try:
                    # Attempt to convert
                    props["indieBreakoutStatus"] = bool(props["indieBreakoutStatus"])
                except:
                    raise TypeError(f"Property indieBreakoutStatus must be of type bool, got {type(props['indieBreakoutStatus']).__name__}")
    
        # Type check coProduction (expected str)
        if "coProduction" in props and props["coProduction"] is not None:
            if not isinstance(props["coProduction"], str):
                try:
                    # Attempt to convert
                    props["coProduction"] = str(props["coProduction"])
                except:
                    raise TypeError(f"Property coProduction must be of type str, got {type(props['coProduction']).__name__}")
    
        # Type check executiveOpposition (expected bool)
        if "executiveOpposition" in props and props["executiveOpposition"] is not None:
            if not isinstance(props["executiveOpposition"], bool):
                try:
                    # Attempt to convert
                    props["executiveOpposition"] = bool(props["executiveOpposition"])
                except:
                    raise TypeError(f"Property executiveOpposition must be of type bool, got {type(props['executiveOpposition']).__name__}")
    
        # Type check franchiseEntry (expected int)
        if "franchiseEntry" in props and props["franchiseEntry"] is not None:
            if not isinstance(props["franchiseEntry"], int):
                try:
                    # Attempt to convert
                    props["franchiseEntry"] = int(props["franchiseEntry"])
                except:
                    raise TypeError(f"Property franchiseEntry must be of type int, got {type(props['franchiseEntry']).__name__}")
    
        # Type check festivalStrategy (expected str)
        if "festivalStrategy" in props and props["festivalStrategy"] is not None:
            if not isinstance(props["festivalStrategy"], str):
                try:
                    # Attempt to convert
                    props["festivalStrategy"] = str(props["festivalStrategy"])
                except:
                    raise TypeError(f"Property festivalStrategy must be of type str, got {type(props['festivalStrategy']).__name__}")
    
        # Type check internationalFocus (expected bool)
        if "internationalFocus" in props and props["internationalFocus"] is not None:
            if not isinstance(props["internationalFocus"], bool):
                try:
                    # Attempt to convert
                    props["internationalFocus"] = bool(props["internationalFocus"])
                except:
                    raise TypeError(f"Property internationalFocus must be of type bool, got {type(props['internationalFocus']).__name__}")
    
        # Type check sequelStrategy (expected str)
        if "sequelStrategy" in props and props["sequelStrategy"] is not None:
            if not isinstance(props["sequelStrategy"], str):
                try:
                    # Attempt to convert
                    props["sequelStrategy"] = str(props["sequelStrategy"])
                except:
                    raise TypeError(f"Property sequelStrategy must be of type str, got {type(props['sequelStrategy']).__name__}")
    
        # Type check marketingInnovation (expected str)
        if "marketingInnovation" in props and props["marketingInnovation"] is not None:
            if not isinstance(props["marketingInnovation"], str):
                try:
                    # Attempt to convert
                    props["marketingInnovation"] = str(props["marketingInnovation"])
                except:
                    raise TypeError(f"Property marketingInnovation must be of type str, got {type(props['marketingInnovation']).__name__}")
    
        # Type check twoPartRelease (expected bool)
        if "twoPartRelease" in props and props["twoPartRelease"] is not None:
            if not isinstance(props["twoPartRelease"], bool):
                try:
                    # Attempt to convert
                    props["twoPartRelease"] = bool(props["twoPartRelease"])
                except:
                    raise TypeError(f"Property twoPartRelease must be of type bool, got {type(props['twoPartRelease']).__name__}")
    
        # Type check riskAssessment (expected str)
        if "riskAssessment" in props and props["riskAssessment"] is not None:
            if not isinstance(props["riskAssessment"], str):
                try:
                    # Attempt to convert
                    props["riskAssessment"] = str(props["riskAssessment"])
                except:
                    raise TypeError(f"Property riskAssessment must be of type str, got {type(props['riskAssessment']).__name__}")
    
        # Type check gamblePayoff (expected str)
        if "gamblePayoff" in props and props["gamblePayoff"] is not None:
            if not isinstance(props["gamblePayoff"], str):
                try:
                    # Attempt to convert
                    props["gamblePayoff"] = str(props["gamblePayoff"])
                except:
                    raise TypeError(f"Property gamblePayoff must be of type str, got {type(props['gamblePayoff']).__name__}")
    
        # Type check marketingApproach (expected str)
        if "marketingApproach" in props and props["marketingApproach"] is not None:
            if not isinstance(props["marketingApproach"], str):
                try:
                    # Attempt to convert
                    props["marketingApproach"] = str(props["marketingApproach"])
                except:
                    raise TypeError(f"Property marketingApproach must be of type str, got {type(props['marketingApproach']).__name__}")
    
        # Type check day_to_day_involvement (expected str)
        if "day_to_day_involvement" in props and props["day_to_day_involvement"] is not None:
            if not isinstance(props["day_to_day_involvement"], str):
                try:
                    # Attempt to convert
                    props["day_to_day_involvement"] = str(props["day_to_day_involvement"])
                except:
                    raise TypeError(f"Property day_to_day_involvement must be of type str, got {type(props['day_to_day_involvement']).__name__}")
    
        # Type check budget_secured (expected int)
        if "budget_secured" in props and props["budget_secured"] is not None:
            if not isinstance(props["budget_secured"], int):
                try:
                    # Attempt to convert
                    props["budget_secured"] = int(props["budget_secured"])
                except:
                    raise TypeError(f"Property budget_secured must be of type int, got {type(props['budget_secured']).__name__}")
    
        # Type check award_acceptance (expected str)
        if "award_acceptance" in props and props["award_acceptance"] is not None:
            if not isinstance(props["award_acceptance"], str):
                try:
                    # Attempt to convert
                    props["award_acceptance"] = str(props["award_acceptance"])
                except:
                    raise TypeError(f"Property award_acceptance must be of type str, got {type(props['award_acceptance']).__name__}")
    
        # Type check production_company (expected str)
        if "production_company" in props and props["production_company"] is not None:
            if not isinstance(props["production_company"], str):
                try:
                    # Attempt to convert
                    props["production_company"] = str(props["production_company"])
                except:
                    raise TypeError(f"Property production_company must be of type str, got {type(props['production_company']).__name__}")
    
        # Type check crisis_management (expected str)
        if "crisis_management" in props and props["crisis_management"] is not None:
            if not isinstance(props["crisis_management"], str):
                try:
                    # Attempt to convert
                    props["crisis_management"] = str(props["crisis_management"])
                except:
                    raise TypeError(f"Property crisis_management must be of type str, got {type(props['crisis_management']).__name__}")
    
        # Type check studio_relationship (expected str)
        if "studio_relationship" in props and props["studio_relationship"] is not None:
            if not isinstance(props["studio_relationship"], str):
                try:
                    # Attempt to convert
                    props["studio_relationship"] = str(props["studio_relationship"])
                except:
                    raise TypeError(f"Property studio_relationship must be of type str, got {type(props['studio_relationship']).__name__}")
    
        # Type check production_challenges (expected object)
        if "production_challenges" in props and props["production_challenges"] is not None:
            if not isinstance(props["production_challenges"], object):
                try:
                    # Attempt to convert
                    props["production_challenges"] = object(props["production_challenges"])
                except:
                    raise TypeError(f"Property production_challenges must be of type object, got {type(props['production_challenges']).__name__}")
    
        # Type check profit_percentage (expected float)
        if "profit_percentage" in props and props["profit_percentage"] is not None:
            if not isinstance(props["profit_percentage"], float):
                try:
                    # Attempt to convert
                    props["profit_percentage"] = float(props["profit_percentage"])
                except:
                    raise TypeError(f"Property profit_percentage must be of type float, got {type(props['profit_percentage']).__name__}")
    
        # Type check marketing_input (expected str)
        if "marketing_input" in props and props["marketing_input"] is not None:
            if not isinstance(props["marketing_input"], str):
                try:
                    # Attempt to convert
                    props["marketing_input"] = str(props["marketing_input"])
                except:
                    raise TypeError(f"Property marketing_input must be of type str, got {type(props['marketing_input']).__name__}")
    
        # Type check career_impact (expected str)
        if "career_impact" in props and props["career_impact"] is not None:
            if not isinstance(props["career_impact"], str):
                try:
                    # Attempt to convert
                    props["career_impact"] = str(props["career_impact"])
                except:
                    raise TypeError(f"Property career_impact must be of type str, got {type(props['career_impact']).__name__}")
    
        # Type check key_decisions (expected object)
        if "key_decisions" in props and props["key_decisions"] is not None:
            if not isinstance(props["key_decisions"], object):
                try:
                    # Attempt to convert
                    props["key_decisions"] = object(props["key_decisions"])
                except:
                    raise TypeError(f"Property key_decisions must be of type object, got {type(props['key_decisions']).__name__}")
    
        # Type check role (expected str)
        if "role" in props and props["role"] is not None:
            if not isinstance(props["role"], str):
                try:
                    # Attempt to convert
                    props["role"] = str(props["role"])
                except:
                    raise TypeError(f"Property role must be of type str, got {type(props['role']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="PRODUCED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def wrote(uuid=None, **props):
        """
        Find relationships of type WROTE matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check date (expected object)
        if "date" in props and props["date"] is not None:
            if not isinstance(props["date"], object):
                try:
                    # Attempt to convert
                    props["date"] = object(props["date"])
                except:
                    raise TypeError(f"Property date must be of type object, got {type(props['date']).__name__}")
    
        # Type check isVerified (expected bool)
        if "isVerified" in props and props["isVerified"] is not None:
            if not isinstance(props["isVerified"], bool):
                try:
                    # Attempt to convert
                    props["isVerified"] = bool(props["isVerified"])
                except:
                    raise TypeError(f"Property isVerified must be of type bool, got {type(props['isVerified']).__name__}")
    
        # Type check wordCount (expected int)
        if "wordCount" in props and props["wordCount"] is not None:
            if not isinstance(props["wordCount"], int):
                try:
                    # Attempt to convert
                    props["wordCount"] = int(props["wordCount"])
                except:
                    raise TypeError(f"Property wordCount must be of type int, got {type(props['wordCount']).__name__}")
    
        # Type check timeSpentMinutes (expected int)
        if "timeSpentMinutes" in props and props["timeSpentMinutes"] is not None:
            if not isinstance(props["timeSpentMinutes"], int):
                try:
                    # Attempt to convert
                    props["timeSpentMinutes"] = int(props["timeSpentMinutes"])
                except:
                    raise TypeError(f"Property timeSpentMinutes must be of type int, got {type(props['timeSpentMinutes']).__name__}")
    
        # Type check submissionTime (expected object)
        if "submissionTime" in props and props["submissionTime"] is not None:
            if not isinstance(props["submissionTime"], object):
                try:
                    # Attempt to convert
                    props["submissionTime"] = object(props["submissionTime"])
                except:
                    raise TypeError(f"Property submissionTime must be of type object, got {type(props['submissionTime']).__name__}")
    
        # Type check isRetroReview (expected bool)
        if "isRetroReview" in props and props["isRetroReview"] is not None:
            if not isinstance(props["isRetroReview"], bool):
                try:
                    # Attempt to convert
                    props["isRetroReview"] = bool(props["isRetroReview"])
                except:
                    raise TypeError(f"Property isRetroReview must be of type bool, got {type(props['isRetroReview']).__name__}")
    
        # Type check publicationName (expected str)
        if "publicationName" in props and props["publicationName"] is not None:
            if not isinstance(props["publicationName"], str):
                try:
                    # Attempt to convert
                    props["publicationName"] = str(props["publicationName"])
                except:
                    raise TypeError(f"Property publicationName must be of type str, got {type(props['publicationName']).__name__}")
    
        # Type check coWriter (expected str)
        if "coWriter" in props and props["coWriter"] is not None:
            if not isinstance(props["coWriter"], str):
                try:
                    # Attempt to convert
                    props["coWriter"] = str(props["coWriter"])
                except:
                    raise TypeError(f"Property coWriter must be of type str, got {type(props['coWriter']).__name__}")
    
        # Type check inspirationSources (expected object)
        if "inspirationSources" in props and props["inspirationSources"] is not None:
            if not isinstance(props["inspirationSources"], object):
                try:
                    # Attempt to convert
                    props["inspirationSources"] = object(props["inspirationSources"])
                except:
                    raise TypeError(f"Property inspirationSources must be of type object, got {type(props['inspirationSources']).__name__}")
    
        # Type check writingCompletionDate (expected object)
        if "writingCompletionDate" in props and props["writingCompletionDate"] is not None:
            if not isinstance(props["writingCompletionDate"], object):
                try:
                    # Attempt to convert
                    props["writingCompletionDate"] = object(props["writingCompletionDate"])
                except:
                    raise TypeError(f"Property writingCompletionDate must be of type object, got {type(props['writingCompletionDate']).__name__}")
    
        # Type check scriptNominations (expected int)
        if "scriptNominations" in props and props["scriptNominations"] is not None:
            if not isinstance(props["scriptNominations"], int):
                try:
                    # Attempt to convert
                    props["scriptNominations"] = int(props["scriptNominations"])
                except:
                    raise TypeError(f"Property scriptNominations must be of type int, got {type(props['scriptNominations']).__name__}")
    
        # Type check scriptWins (expected int)
        if "scriptWins" in props and props["scriptWins"] is not None:
            if not isinstance(props["scriptWins"], int):
                try:
                    # Attempt to convert
                    props["scriptWins"] = int(props["scriptWins"])
                except:
                    raise TypeError(f"Property scriptWins must be of type int, got {type(props['scriptWins']).__name__}")
    
        # Type check finalPageCount (expected int)
        if "finalPageCount" in props and props["finalPageCount"] is not None:
            if not isinstance(props["finalPageCount"], int):
                try:
                    # Attempt to convert
                    props["finalPageCount"] = int(props["finalPageCount"])
                except:
                    raise TypeError(f"Property finalPageCount must be of type int, got {type(props['finalPageCount']).__name__}")
    
        # Type check draftCount (expected int)
        if "draftCount" in props and props["draftCount"] is not None:
            if not isinstance(props["draftCount"], int):
                try:
                    # Attempt to convert
                    props["draftCount"] = int(props["draftCount"])
                except:
                    raise TypeError(f"Property draftCount must be of type int, got {type(props['draftCount']).__name__}")
    
        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Type check controversyLevel (expected str)
        if "controversyLevel" in props and props["controversyLevel"] is not None:
            if not isinstance(props["controversyLevel"], str):
                try:
                    # Attempt to convert
                    props["controversyLevel"] = str(props["controversyLevel"])
                except:
                    raise TypeError(f"Property controversyLevel must be of type str, got {type(props['controversyLevel']).__name__}")
    
        # Type check writingStartDate (expected object)
        if "writingStartDate" in props and props["writingStartDate"] is not None:
            if not isinstance(props["writingStartDate"], object):
                try:
                    # Attempt to convert
                    props["writingStartDate"] = object(props["writingStartDate"])
                except:
                    raise TypeError(f"Property writingStartDate must be of type object, got {type(props['writingStartDate']).__name__}")
    
        # Type check thematicElements (expected object)
        if "thematicElements" in props and props["thematicElements"] is not None:
            if not isinstance(props["thematicElements"], object):
                try:
                    # Attempt to convert
                    props["thematicElements"] = object(props["thematicElements"])
                except:
                    raise TypeError(f"Property thematicElements must be of type object, got {type(props['thematicElements']).__name__}")
    
        # Type check awardNominations (expected int)
        if "awardNominations" in props and props["awardNominations"] is not None:
            if not isinstance(props["awardNominations"], int):
                try:
                    # Attempt to convert
                    props["awardNominations"] = int(props["awardNominations"])
                except:
                    raise TypeError(f"Property awardNominations must be of type int, got {type(props['awardNominations']).__name__}")
    
        # Type check awardWins (expected int)
        if "awardWins" in props and props["awardWins"] is not None:
            if not isinstance(props["awardWins"], int):
                try:
                    # Attempt to convert
                    props["awardWins"] = int(props["awardWins"])
                except:
                    raise TypeError(f"Property awardWins must be of type int, got {type(props['awardWins']).__name__}")
    
        # Type check adaptationYears (expected int)
        if "adaptationYears" in props and props["adaptationYears"] is not None:
            if not isinstance(props["adaptationYears"], int):
                try:
                    # Attempt to convert
                    props["adaptationYears"] = int(props["adaptationYears"])
                except:
                    raise TypeError(f"Property adaptationYears must be of type int, got {type(props['adaptationYears']).__name__}")
    
        # Type check diaryKept (expected bool)
        if "diaryKept" in props and props["diaryKept"] is not None:
            if not isinstance(props["diaryKept"], bool):
                try:
                    # Attempt to convert
                    props["diaryKept"] = bool(props["diaryKept"])
                except:
                    raise TypeError(f"Property diaryKept must be of type bool, got {type(props['diaryKept']).__name__}")
    
        # Type check fidelityBalance (expected str)
        if "fidelityBalance" in props and props["fidelityBalance"] is not None:
            if not isinstance(props["fidelityBalance"], str):
                try:
                    # Attempt to convert
                    props["fidelityBalance"] = str(props["fidelityBalance"])
                except:
                    raise TypeError(f"Property fidelityBalance must be of type str, got {type(props['fidelityBalance']).__name__}")
    
        # Type check adaptationSource (expected str)
        if "adaptationSource" in props and props["adaptationSource"] is not None:
            if not isinstance(props["adaptationSource"], str):
                try:
                    # Attempt to convert
                    props["adaptationSource"] = str(props["adaptationSource"])
                except:
                    raise TypeError(f"Property adaptationSource must be of type str, got {type(props['adaptationSource']).__name__}")
    
        # Type check studioNotes (expected str)
        if "studioNotes" in props and props["studioNotes"] is not None:
            if not isinstance(props["studioNotes"], str):
                try:
                    # Attempt to convert
                    props["studioNotes"] = str(props["studioNotes"])
                except:
                    raise TypeError(f"Property studioNotes must be of type str, got {type(props['studioNotes']).__name__}")
    
        # Type check keyContributions (expected object)
        if "keyContributions" in props and props["keyContributions"] is not None:
            if not isinstance(props["keyContributions"], object):
                try:
                    # Attempt to convert
                    props["keyContributions"] = object(props["keyContributions"])
                except:
                    raise TypeError(f"Property keyContributions must be of type object, got {type(props['keyContributions']).__name__}")
    
        # Type check scriptChanges (expected str)
        if "scriptChanges" in props and props["scriptChanges"] is not None:
            if not isinstance(props["scriptChanges"], str):
                try:
                    # Attempt to convert
                    props["scriptChanges"] = str(props["scriptChanges"])
                except:
                    raise TypeError(f"Property scriptChanges must be of type str, got {type(props['scriptChanges']).__name__}")
    
        # Type check perspectiveApplied (expected str)
        if "perspectiveApplied" in props and props["perspectiveApplied"] is not None:
            if not isinstance(props["perspectiveApplied"], str):
                try:
                    # Attempt to convert
                    props["perspectiveApplied"] = str(props["perspectiveApplied"])
                except:
                    raise TypeError(f"Property perspectiveApplied must be of type str, got {type(props['perspectiveApplied']).__name__}")
    
        # Type check researchConducted (expected str)
        if "researchConducted" in props and props["researchConducted"] is not None:
            if not isinstance(props["researchConducted"], str):
                try:
                    # Attempt to convert
                    props["researchConducted"] = str(props["researchConducted"])
                except:
                    raise TypeError(f"Property researchConducted must be of type str, got {type(props['researchConducted']).__name__}")
    
        # Type check recognitionReceived (expected str)
        if "recognitionReceived" in props and props["recognitionReceived"] is not None:
            if not isinstance(props["recognitionReceived"], str):
                try:
                    # Attempt to convert
                    props["recognitionReceived"] = str(props["recognitionReceived"])
                except:
                    raise TypeError(f"Property recognitionReceived must be of type str, got {type(props['recognitionReceived']).__name__}")
    
        # Type check editorialChanges (expected str)
        if "editorialChanges" in props and props["editorialChanges"] is not None:
            if not isinstance(props["editorialChanges"], str):
                try:
                    # Attempt to convert
                    props["editorialChanges"] = str(props["editorialChanges"])
                except:
                    raise TypeError(f"Property editorialChanges must be of type str, got {type(props['editorialChanges']).__name__}")
    
        # Type check paymentReceived (expected int)
        if "paymentReceived" in props and props["paymentReceived"] is not None:
            if not isinstance(props["paymentReceived"], int):
                try:
                    # Attempt to convert
                    props["paymentReceived"] = int(props["paymentReceived"])
                except:
                    raise TypeError(f"Property paymentReceived must be of type int, got {type(props['paymentReceived']).__name__}")
    
        # Type check timeSpentWriting (expected object)
        if "timeSpentWriting" in props and props["timeSpentWriting"] is not None:
            if not isinstance(props["timeSpentWriting"], object):
                try:
                    # Attempt to convert
                    props["timeSpentWriting"] = object(props["timeSpentWriting"])
                except:
                    raise TypeError(f"Property timeSpentWriting must be of type object, got {type(props['timeSpentWriting']).__name__}")
    
        # Type check laterReassessments (expected str)
        if "laterReassessments" in props and props["laterReassessments"] is not None:
            if not isinstance(props["laterReassessments"], str):
                try:
                    # Attempt to convert
                    props["laterReassessments"] = str(props["laterReassessments"])
                except:
                    raise TypeError(f"Property laterReassessments must be of type str, got {type(props['laterReassessments']).__name__}")
    
        # Type check influenceLevel (expected str)
        if "influenceLevel" in props and props["influenceLevel"] is not None:
            if not isinstance(props["influenceLevel"], str):
                try:
                    # Attempt to convert
                    props["influenceLevel"] = str(props["influenceLevel"])
                except:
                    raise TypeError(f"Property influenceLevel must be of type str, got {type(props['influenceLevel']).__name__}")
    
        # Type check originalMaterial (expected str)
        if "originalMaterial" in props and props["originalMaterial"] is not None:
            if not isinstance(props["originalMaterial"], str):
                try:
                    # Attempt to convert
                    props["originalMaterial"] = str(props["originalMaterial"])
                except:
                    raise TypeError(f"Property originalMaterial must be of type str, got {type(props['originalMaterial']).__name__}")
    
        # Type check sequelChallenges (expected object)
        if "sequelChallenges" in props and props["sequelChallenges"] is not None:
            if not isinstance(props["sequelChallenges"], object):
                try:
                    # Attempt to convert
                    props["sequelChallenges"] = object(props["sequelChallenges"])
                except:
                    raise TypeError(f"Property sequelChallenges must be of type object, got {type(props['sequelChallenges']).__name__}")
    
        # Type check narrativeInnovations (expected object)
        if "narrativeInnovations" in props and props["narrativeInnovations"] is not None:
            if not isinstance(props["narrativeInnovations"], object):
                try:
                    # Attempt to convert
                    props["narrativeInnovations"] = object(props["narrativeInnovations"])
                except:
                    raise TypeError(f"Property narrativeInnovations must be of type object, got {type(props['narrativeInnovations']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="WROTE", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def follows(uuid=None, **props):
        """
        Find relationships of type FOLLOWS matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Construct and execute the query
        query, params = Queries.edge(type="FOLLOWS", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def reviewed(uuid=None, **props):
        """
        Find relationships of type REVIEWED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check summary (expected str)
        if "summary" in props and props["summary"] is not None:
            if not isinstance(props["summary"], str):
                try:
                    # Attempt to convert
                    props["summary"] = str(props["summary"])
                except:
                    raise TypeError(f"Property summary must be of type str, got {type(props['summary']).__name__}")
    
        # Type check rating (expected int)
        if "rating" in props and props["rating"] is not None:
            if not isinstance(props["rating"], int):
                try:
                    # Attempt to convert
                    props["rating"] = int(props["rating"])
                except:
                    raise TypeError(f"Property rating must be of type int, got {type(props['rating']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="REVIEWED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def part_of(uuid=None, **props):
        """
        Find relationships of type PART_OF matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check shooting_location (expected str)
        if "shooting_location" in props and props["shooting_location"] is not None:
            if not isinstance(props["shooting_location"], str):
                try:
                    # Attempt to convert
                    props["shooting_location"] = str(props["shooting_location"])
                except:
                    raise TypeError(f"Property shooting_location must be of type str, got {type(props['shooting_location']).__name__}")
    
        # Type check viewer_reaction (expected str)
        if "viewer_reaction" in props and props["viewer_reaction"] is not None:
            if not isinstance(props["viewer_reaction"], str):
                try:
                    # Attempt to convert
                    props["viewer_reaction"] = str(props["viewer_reaction"])
                except:
                    raise TypeError(f"Property viewer_reaction must be of type str, got {type(props['viewer_reaction']).__name__}")
    
        # Type check filmingChallenges (expected object)
        if "filmingChallenges" in props and props["filmingChallenges"] is not None:
            if not isinstance(props["filmingChallenges"], object):
                try:
                    # Attempt to convert
                    props["filmingChallenges"] = object(props["filmingChallenges"])
                except:
                    raise TypeError(f"Property filmingChallenges must be of type object, got {type(props['filmingChallenges']).__name__}")
    
        # Type check controversies (expected str)
        if "controversies" in props and props["controversies"] is not None:
            if not isinstance(props["controversies"], str):
                try:
                    # Attempt to convert
                    props["controversies"] = str(props["controversies"])
                except:
                    raise TypeError(f"Property controversies must be of type str, got {type(props['controversies']).__name__}")
    
        # Type check story_significance (expected str)
        if "story_significance" in props and props["story_significance"] is not None:
            if not isinstance(props["story_significance"], str):
                try:
                    # Attempt to convert
                    props["story_significance"] = str(props["story_significance"])
                except:
                    raise TypeError(f"Property story_significance must be of type str, got {type(props['story_significance']).__name__}")
    
        # Type check runningOrder (expected int)
        if "runningOrder" in props and props["runningOrder"] is not None:
            if not isinstance(props["runningOrder"], int):
                try:
                    # Attempt to convert
                    props["runningOrder"] = int(props["runningOrder"])
                except:
                    raise TypeError(f"Property runningOrder must be of type int, got {type(props['runningOrder']).__name__}")
    
        # Type check filmingDays (expected int)
        if "filmingDays" in props and props["filmingDays"] is not None:
            if not isinstance(props["filmingDays"], int):
                try:
                    # Attempt to convert
                    props["filmingDays"] = int(props["filmingDays"])
                except:
                    raise TypeError(f"Property filmingDays must be of type int, got {type(props['filmingDays']).__name__}")
    
        # Type check production_cost (expected int)
        if "production_cost" in props and props["production_cost"] is not None:
            if not isinstance(props["production_cost"], int):
                try:
                    # Attempt to convert
                    props["production_cost"] = int(props["production_cost"])
                except:
                    raise TypeError(f"Property production_cost must be of type int, got {type(props['production_cost']).__name__}")
    
        # Type check trivia (expected str)
        if "trivia" in props and props["trivia"] is not None:
            if not isinstance(props["trivia"], str):
                try:
                    # Attempt to convert
                    props["trivia"] = str(props["trivia"])
                except:
                    raise TypeError(f"Property trivia must be of type str, got {type(props['trivia']).__name__}")
    
        # Type check character_development (expected str)
        if "character_development" in props and props["character_development"] is not None:
            if not isinstance(props["character_development"], str):
                try:
                    # Attempt to convert
                    props["character_development"] = str(props["character_development"])
                except:
                    raise TypeError(f"Property character_development must be of type str, got {type(props['character_development']).__name__}")
    
        # Type check cultural_impact (expected str)
        if "cultural_impact" in props and props["cultural_impact"] is not None:
            if not isinstance(props["cultural_impact"], str):
                try:
                    # Attempt to convert
                    props["cultural_impact"] = str(props["cultural_impact"])
                except:
                    raise TypeError(f"Property cultural_impact must be of type str, got {type(props['cultural_impact']).__name__}")
    
        # Type check timeIndex (expected object)
        if "timeIndex" in props and props["timeIndex"] is not None:
            if not isinstance(props["timeIndex"], object):
                try:
                    # Attempt to convert
                    props["timeIndex"] = object(props["timeIndex"])
                except:
                    raise TypeError(f"Property timeIndex must be of type object, got {type(props['timeIndex']).__name__}")
    
        # Type check symbolic_meaning (expected str)
        if "symbolic_meaning" in props and props["symbolic_meaning"] is not None:
            if not isinstance(props["symbolic_meaning"], str):
                try:
                    # Attempt to convert
                    props["symbolic_meaning"] = str(props["symbolic_meaning"])
                except:
                    raise TypeError(f"Property symbolic_meaning must be of type str, got {type(props['symbolic_meaning']).__name__}")
    
        # Type check technical_specifications (expected object)
        if "technical_specifications" in props and props["technical_specifications"] is not None:
            if not isinstance(props["technical_specifications"], object):
                try:
                    # Attempt to convert
                    props["technical_specifications"] = object(props["technical_specifications"])
                except:
                    raise TypeError(f"Property technical_specifications must be of type object, got {type(props['technical_specifications']).__name__}")
    
        # Type check exposition_method (expected str)
        if "exposition_method" in props and props["exposition_method"] is not None:
            if not isinstance(props["exposition_method"], str):
                try:
                    # Attempt to convert
                    props["exposition_method"] = str(props["exposition_method"])
                except:
                    raise TypeError(f"Property exposition_method must be of type str, got {type(props['exposition_method']).__name__}")
    
        # Type check directing_technique (expected str)
        if "directing_technique" in props and props["directing_technique"] is not None:
            if not isinstance(props["directing_technique"], str):
                try:
                    # Attempt to convert
                    props["directing_technique"] = str(props["directing_technique"])
                except:
                    raise TypeError(f"Property directing_technique must be of type str, got {type(props['directing_technique']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="PART_OF", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def financed(uuid=None, **props):
        """
        Find relationships of type FINANCED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check paymentDate3 (expected object)
        if "paymentDate3" in props and props["paymentDate3"] is not None:
            if not isinstance(props["paymentDate3"], object):
                try:
                    # Attempt to convert
                    props["paymentDate3"] = object(props["paymentDate3"])
                except:
                    raise TypeError(f"Property paymentDate3 must be of type object, got {type(props['paymentDate3']).__name__}")
    
        # Type check paymentAmount3 (expected int)
        if "paymentAmount3" in props and props["paymentAmount3"] is not None:
            if not isinstance(props["paymentAmount3"], int):
                try:
                    # Attempt to convert
                    props["paymentAmount3"] = int(props["paymentAmount3"])
                except:
                    raise TypeError(f"Property paymentAmount3 must be of type int, got {type(props['paymentAmount3']).__name__}")
    
        # Type check transferTime3 (expected object)
        if "transferTime3" in props and props["transferTime3"] is not None:
            if not isinstance(props["transferTime3"], object):
                try:
                    # Attempt to convert
                    props["transferTime3"] = object(props["transferTime3"])
                except:
                    raise TypeError(f"Property transferTime3 must be of type object, got {type(props['transferTime3']).__name__}")
    
        # Type check paymentAmount2 (expected int)
        if "paymentAmount2" in props and props["paymentAmount2"] is not None:
            if not isinstance(props["paymentAmount2"], int):
                try:
                    # Attempt to convert
                    props["paymentAmount2"] = int(props["paymentAmount2"])
                except:
                    raise TypeError(f"Property paymentAmount2 must be of type int, got {type(props['paymentAmount2']).__name__}")
    
        # Type check transferTime2 (expected object)
        if "transferTime2" in props and props["transferTime2"] is not None:
            if not isinstance(props["transferTime2"], object):
                try:
                    # Attempt to convert
                    props["transferTime2"] = object(props["transferTime2"])
                except:
                    raise TypeError(f"Property transferTime2 must be of type object, got {type(props['transferTime2']).__name__}")
    
        # Type check paymentDate2 (expected object)
        if "paymentDate2" in props and props["paymentDate2"] is not None:
            if not isinstance(props["paymentDate2"], object):
                try:
                    # Attempt to convert
                    props["paymentDate2"] = object(props["paymentDate2"])
                except:
                    raise TypeError(f"Property paymentDate2 must be of type object, got {type(props['paymentDate2']).__name__}")
    
        # Type check transferTime1 (expected object)
        if "transferTime1" in props and props["transferTime1"] is not None:
            if not isinstance(props["transferTime1"], object):
                try:
                    # Attempt to convert
                    props["transferTime1"] = object(props["transferTime1"])
                except:
                    raise TypeError(f"Property transferTime1 must be of type object, got {type(props['transferTime1']).__name__}")
    
        # Type check paymentAmount1 (expected int)
        if "paymentAmount1" in props and props["paymentAmount1"] is not None:
            if not isinstance(props["paymentAmount1"], int):
                try:
                    # Attempt to convert
                    props["paymentAmount1"] = int(props["paymentAmount1"])
                except:
                    raise TypeError(f"Property paymentAmount1 must be of type int, got {type(props['paymentAmount1']).__name__}")
    
        # Type check contractDate (expected object)
        if "contractDate" in props and props["contractDate"] is not None:
            if not isinstance(props["contractDate"], object):
                try:
                    # Attempt to convert
                    props["contractDate"] = object(props["contractDate"])
                except:
                    raise TypeError(f"Property contractDate must be of type object, got {type(props['contractDate']).__name__}")
    
        # Type check amount (expected int)
        if "amount" in props and props["amount"] is not None:
            if not isinstance(props["amount"], int):
                try:
                    # Attempt to convert
                    props["amount"] = int(props["amount"])
                except:
                    raise TypeError(f"Property amount must be of type int, got {type(props['amount']).__name__}")
    
        # Type check isFullyPaid (expected bool)
        if "isFullyPaid" in props and props["isFullyPaid"] is not None:
            if not isinstance(props["isFullyPaid"], bool):
                try:
                    # Attempt to convert
                    props["isFullyPaid"] = bool(props["isFullyPaid"])
                except:
                    raise TypeError(f"Property isFullyPaid must be of type bool, got {type(props['isFullyPaid']).__name__}")
    
        # Type check paymentDate1 (expected object)
        if "paymentDate1" in props and props["paymentDate1"] is not None:
            if not isinstance(props["paymentDate1"], object):
                try:
                    # Attempt to convert
                    props["paymentDate1"] = object(props["paymentDate1"])
                except:
                    raise TypeError(f"Property paymentDate1 must be of type object, got {type(props['paymentDate1']).__name__}")
    
        # Type check transferTime4 (expected object)
        if "transferTime4" in props and props["transferTime4"] is not None:
            if not isinstance(props["transferTime4"], object):
                try:
                    # Attempt to convert
                    props["transferTime4"] = object(props["transferTime4"])
                except:
                    raise TypeError(f"Property transferTime4 must be of type object, got {type(props['transferTime4']).__name__}")
    
        # Type check paymentDate4 (expected object)
        if "paymentDate4" in props and props["paymentDate4"] is not None:
            if not isinstance(props["paymentDate4"], object):
                try:
                    # Attempt to convert
                    props["paymentDate4"] = object(props["paymentDate4"])
                except:
                    raise TypeError(f"Property paymentDate4 must be of type object, got {type(props['paymentDate4']).__name__}")
    
        # Type check paymentAmount4 (expected int)
        if "paymentAmount4" in props and props["paymentAmount4"] is not None:
            if not isinstance(props["paymentAmount4"], int):
                try:
                    # Attempt to convert
                    props["paymentAmount4"] = int(props["paymentAmount4"])
                except:
                    raise TypeError(f"Property paymentAmount4 must be of type int, got {type(props['paymentAmount4']).__name__}")
    
        # Type check executiveOversight (expected str)
        if "executiveOversight" in props and props["executiveOversight"] is not None:
            if not isinstance(props["executiveOversight"], str):
                try:
                    # Attempt to convert
                    props["executiveOversight"] = str(props["executiveOversight"])
                except:
                    raise TypeError(f"Property executiveOversight must be of type str, got {type(props['executiveOversight']).__name__}")
    
        # Type check hitchcockOwnPercentage (expected int)
        if "hitchcockOwnPercentage" in props and props["hitchcockOwnPercentage"] is not None:
            if not isinstance(props["hitchcockOwnPercentage"], int):
                try:
                    # Attempt to convert
                    props["hitchcockOwnPercentage"] = int(props["hitchcockOwnPercentage"])
                except:
                    raise TypeError(f"Property hitchcockOwnPercentage must be of type int, got {type(props['hitchcockOwnPercentage']).__name__}")
    
        # Type check unusualDeal (expected bool)
        if "unusualDeal" in props and props["unusualDeal"] is not None:
            if not isinstance(props["unusualDeal"], bool):
                try:
                    # Attempt to convert
                    props["unusualDeal"] = bool(props["unusualDeal"])
                except:
                    raise TypeError(f"Property unusualDeal must be of type bool, got {type(props['unusualDeal']).__name__}")
    
        # Type check costOverrunConcerns (expected str)
        if "costOverrunConcerns" in props and props["costOverrunConcerns"] is not None:
            if not isinstance(props["costOverrunConcerns"], str):
                try:
                    # Attempt to convert
                    props["costOverrunConcerns"] = str(props["costOverrunConcerns"])
                except:
                    raise TypeError(f"Property costOverrunConcerns must be of type str, got {type(props['costOverrunConcerns']).__name__}")
    
        # Type check budgetControl (expected str)
        if "budgetControl" in props and props["budgetControl"] is not None:
            if not isinstance(props["budgetControl"], str):
                try:
                    # Attempt to convert
                    props["budgetControl"] = str(props["budgetControl"])
                except:
                    raise TypeError(f"Property budgetControl must be of type str, got {type(props['budgetControl']).__name__}")
    
        # Type check producerOversight (expected str)
        if "producerOversight" in props and props["producerOversight"] is not None:
            if not isinstance(props["producerOversight"], str):
                try:
                    # Attempt to convert
                    props["producerOversight"] = str(props["producerOversight"])
                except:
                    raise TypeError(f"Property producerOversight must be of type str, got {type(props['producerOversight']).__name__}")
    
        # Type check tentpoleStatus (expected bool)
        if "tentpoleStatus" in props and props["tentpoleStatus"] is not None:
            if not isinstance(props["tentpoleStatus"], bool):
                try:
                    # Attempt to convert
                    props["tentpoleStatus"] = bool(props["tentpoleStatus"])
                except:
                    raise TypeError(f"Property tentpoleStatus must be of type bool, got {type(props['tentpoleStatus']).__name__}")
    
        # Type check tightControls (expected bool)
        if "tightControls" in props and props["tightControls"] is not None:
            if not isinstance(props["tightControls"], bool):
                try:
                    # Attempt to convert
                    props["tightControls"] = bool(props["tightControls"])
                except:
                    raise TypeError(f"Property tightControls must be of type bool, got {type(props['tightControls']).__name__}")
    
        # Type check independentBudgeting (expected bool)
        if "independentBudgeting" in props and props["independentBudgeting"] is not None:
            if not isinstance(props["independentBudgeting"], bool):
                try:
                    # Attempt to convert
                    props["independentBudgeting"] = bool(props["independentBudgeting"])
                except:
                    raise TypeError(f"Property independentBudgeting must be of type bool, got {type(props['independentBudgeting']).__name__}")
    
        # Type check completion_guarantee (expected str)
        if "completion_guarantee" in props and props["completion_guarantee"] is not None:
            if not isinstance(props["completion_guarantee"], str):
                try:
                    # Attempt to convert
                    props["completion_guarantee"] = str(props["completion_guarantee"])
                except:
                    raise TypeError(f"Property completion_guarantee must be of type str, got {type(props['completion_guarantee']).__name__}")
    
        # Type check payment_schedule (expected str)
        if "payment_schedule" in props and props["payment_schedule"] is not None:
            if not isinstance(props["payment_schedule"], str):
                try:
                    # Attempt to convert
                    props["payment_schedule"] = str(props["payment_schedule"])
                except:
                    raise TypeError(f"Property payment_schedule must be of type str, got {type(props['payment_schedule']).__name__}")
    
        # Type check audit_rights (expected str)
        if "audit_rights" in props and props["audit_rights"] is not None:
            if not isinstance(props["audit_rights"], str):
                try:
                    # Attempt to convert
                    props["audit_rights"] = str(props["audit_rights"])
                except:
                    raise TypeError(f"Property audit_rights must be of type str, got {type(props['audit_rights']).__name__}")
    
        # Type check banking_relationships (expected str)
        if "banking_relationships" in props and props["banking_relationships"] is not None:
            if not isinstance(props["banking_relationships"], str):
                try:
                    # Attempt to convert
                    props["banking_relationships"] = str(props["banking_relationships"])
                except:
                    raise TypeError(f"Property banking_relationships must be of type str, got {type(props['banking_relationships']).__name__}")
    
        # Type check financial_close_process (expected str)
        if "financial_close_process" in props and props["financial_close_process"] is not None:
            if not isinstance(props["financial_close_process"], str):
                try:
                    # Attempt to convert
                    props["financial_close_process"] = str(props["financial_close_process"])
                except:
                    raise TypeError(f"Property financial_close_process must be of type str, got {type(props['financial_close_process']).__name__}")
    
        # Type check funding_approvals (expected str)
        if "funding_approvals" in props and props["funding_approvals"] is not None:
            if not isinstance(props["funding_approvals"], str):
                try:
                    # Attempt to convert
                    props["funding_approvals"] = str(props["funding_approvals"])
                except:
                    raise TypeError(f"Property funding_approvals must be of type str, got {type(props['funding_approvals']).__name__}")
    
        # Type check cash_flow_management (expected str)
        if "cash_flow_management" in props and props["cash_flow_management"] is not None:
            if not isinstance(props["cash_flow_management"], str):
                try:
                    # Attempt to convert
                    props["cash_flow_management"] = str(props["cash_flow_management"])
                except:
                    raise TypeError(f"Property cash_flow_management must be of type str, got {type(props['cash_flow_management']).__name__}")
    
        # Type check financial_reporting_requirements (expected str)
        if "financial_reporting_requirements" in props and props["financial_reporting_requirements"] is not None:
            if not isinstance(props["financial_reporting_requirements"], str):
                try:
                    # Attempt to convert
                    props["financial_reporting_requirements"] = str(props["financial_reporting_requirements"])
                except:
                    raise TypeError(f"Property financial_reporting_requirements must be of type str, got {type(props['financial_reporting_requirements']).__name__}")
    
        # Type check financing_method (expected str)
        if "financing_method" in props and props["financing_method"] is not None:
            if not isinstance(props["financing_method"], str):
                try:
                    # Attempt to convert
                    props["financing_method"] = str(props["financing_method"])
                except:
                    raise TypeError(f"Property financing_method must be of type str, got {type(props['financing_method']).__name__}")
    
        # Type check financial_controls (expected str)
        if "financial_controls" in props and props["financial_controls"] is not None:
            if not isinstance(props["financial_controls"], str):
                try:
                    # Attempt to convert
                    props["financial_controls"] = str(props["financial_controls"])
                except:
                    raise TypeError(f"Property financial_controls must be of type str, got {type(props['financial_controls']).__name__}")
    
        # Type check profit_definition (expected str)
        if "profit_definition" in props and props["profit_definition"] is not None:
            if not isinstance(props["profit_definition"], str):
                try:
                    # Attempt to convert
                    props["profit_definition"] = str(props["profit_definition"])
                except:
                    raise TypeError(f"Property profit_definition must be of type str, got {type(props['profit_definition']).__name__}")
    
        # Type check insurance_coverage (expected str)
        if "insurance_coverage" in props and props["insurance_coverage"] is not None:
            if not isinstance(props["insurance_coverage"], str):
                try:
                    # Attempt to convert
                    props["insurance_coverage"] = str(props["insurance_coverage"])
                except:
                    raise TypeError(f"Property insurance_coverage must be of type str, got {type(props['insurance_coverage']).__name__}")
    
        # Type check tax_considerations (expected str)
        if "tax_considerations" in props and props["tax_considerations"] is not None:
            if not isinstance(props["tax_considerations"], str):
                try:
                    # Attempt to convert
                    props["tax_considerations"] = str(props["tax_considerations"])
                except:
                    raise TypeError(f"Property tax_considerations must be of type str, got {type(props['tax_considerations']).__name__}")
    
        # Type check deal_structure (expected str)
        if "deal_structure" in props and props["deal_structure"] is not None:
            if not isinstance(props["deal_structure"], str):
                try:
                    # Attempt to convert
                    props["deal_structure"] = str(props["deal_structure"])
                except:
                    raise TypeError(f"Property deal_structure must be of type str, got {type(props['deal_structure']).__name__}")
    
        # Type check currency_hedging (expected str)
        if "currency_hedging" in props and props["currency_hedging"] is not None:
            if not isinstance(props["currency_hedging"], str):
                try:
                    # Attempt to convert
                    props["currency_hedging"] = str(props["currency_hedging"])
                except:
                    raise TypeError(f"Property currency_hedging must be of type str, got {type(props['currency_hedging']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="FINANCED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def for_movie(uuid=None, **props):
        """
        Find relationships of type FOR_MOVIE matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check durationDays (expected int)
        if "durationDays" in props and props["durationDays"] is not None:
            if not isinstance(props["durationDays"], int):
                try:
                    # Attempt to convert
                    props["durationDays"] = int(props["durationDays"])
                except:
                    raise TypeError(f"Property durationDays must be of type int, got {type(props['durationDays']).__name__}")
    
        # Type check durationMonths (expected int)
        if "durationMonths" in props and props["durationMonths"] is not None:
            if not isinstance(props["durationMonths"], int):
                try:
                    # Attempt to convert
                    props["durationMonths"] = int(props["durationMonths"])
                except:
                    raise TypeError(f"Property durationMonths must be of type int, got {type(props['durationMonths']).__name__}")
    
        # Type check locationCount (expected int)
        if "locationCount" in props and props["locationCount"] is not None:
            if not isinstance(props["locationCount"], int):
                try:
                    # Attempt to convert
                    props["locationCount"] = int(props["locationCount"])
                except:
                    raise TypeError(f"Property locationCount must be of type int, got {type(props['locationCount']).__name__}")
    
        # Type check scheduleAdherence (expected float)
        if "scheduleAdherence" in props and props["scheduleAdherence"] is not None:
            if not isinstance(props["scheduleAdherence"], float):
                try:
                    # Attempt to convert
                    props["scheduleAdherence"] = float(props["scheduleAdherence"])
                except:
                    raise TypeError(f"Property scheduleAdherence must be of type float, got {type(props['scheduleAdherence']).__name__}")
    
        # Type check isCompleted (expected bool)
        if "isCompleted" in props and props["isCompleted"] is not None:
            if not isinstance(props["isCompleted"], bool):
                try:
                    # Attempt to convert
                    props["isCompleted"] = bool(props["isCompleted"])
                except:
                    raise TypeError(f"Property isCompleted must be of type bool, got {type(props['isCompleted']).__name__}")
    
        # Type check weatherDelaysDays (expected int)
        if "weatherDelaysDays" in props and props["weatherDelaysDays"] is not None:
            if not isinstance(props["weatherDelaysDays"], int):
                try:
                    # Attempt to convert
                    props["weatherDelaysDays"] = int(props["weatherDelaysDays"])
                except:
                    raise TypeError(f"Property weatherDelaysDays must be of type int, got {type(props['weatherDelaysDays']).__name__}")
    
        # Type check dailyAverageCost (expected int)
        if "dailyAverageCost" in props and props["dailyAverageCost"] is not None:
            if not isinstance(props["dailyAverageCost"], int):
                try:
                    # Attempt to convert
                    props["dailyAverageCost"] = int(props["dailyAverageCost"])
                except:
                    raise TypeError(f"Property dailyAverageCost must be of type int, got {type(props['dailyAverageCost']).__name__}")
    
        # Type check originalScheduledEnd (expected object)
        if "originalScheduledEnd" in props and props["originalScheduledEnd"] is not None:
            if not isinstance(props["originalScheduledEnd"], object):
                try:
                    # Attempt to convert
                    props["originalScheduledEnd"] = object(props["originalScheduledEnd"])
                except:
                    raise TypeError(f"Property originalScheduledEnd must be of type object, got {type(props['originalScheduledEnd']).__name__}")
    
        # Type check publicationDateTime (expected object)
        if "publicationDateTime" in props and props["publicationDateTime"] is not None:
            if not isinstance(props["publicationDateTime"], object):
                try:
                    # Attempt to convert
                    props["publicationDateTime"] = object(props["publicationDateTime"])
                except:
                    raise TypeError(f"Property publicationDateTime must be of type object, got {type(props['publicationDateTime']).__name__}")
    
        # Type check isPublished (expected bool)
        if "isPublished" in props and props["isPublished"] is not None:
            if not isinstance(props["isPublished"], bool):
                try:
                    # Attempt to convert
                    props["isPublished"] = bool(props["isPublished"])
                except:
                    raise TypeError(f"Property isPublished must be of type bool, got {type(props['isPublished']).__name__}")
    
        # Type check views (expected str)
        if "views" in props and props["views"] is not None:
            if not isinstance(props["views"], str):
                try:
                    # Attempt to convert
                    props["views"] = str(props["views"])
                except:
                    raise TypeError(f"Property views must be of type str, got {type(props['views']).__name__}")
    
        # Type check featuredDurationDays (expected int)
        if "featuredDurationDays" in props and props["featuredDurationDays"] is not None:
            if not isinstance(props["featuredDurationDays"], int):
                try:
                    # Attempt to convert
                    props["featuredDurationDays"] = int(props["featuredDurationDays"])
                except:
                    raise TypeError(f"Property featuredDurationDays must be of type int, got {type(props['featuredDurationDays']).__name__}")
    
        # Type check shares (expected int)
        if "shares" in props and props["shares"] is not None:
            if not isinstance(props["shares"], int):
                try:
                    # Attempt to convert
                    props["shares"] = int(props["shares"])
                except:
                    raise TypeError(f"Property shares must be of type int, got {type(props['shares']).__name__}")
    
        # Type check comments (expected int)
        if "comments" in props and props["comments"] is not None:
            if not isinstance(props["comments"], int):
                try:
                    # Attempt to convert
                    props["comments"] = int(props["comments"])
                except:
                    raise TypeError(f"Property comments must be of type int, got {type(props['comments']).__name__}")
    
        # Type check technologyDelaysDays (expected int)
        if "technologyDelaysDays" in props and props["technologyDelaysDays"] is not None:
            if not isinstance(props["technologyDelaysDays"], int):
                try:
                    # Attempt to convert
                    props["technologyDelaysDays"] = int(props["technologyDelaysDays"])
                except:
                    raise TypeError(f"Property technologyDelaysDays must be of type int, got {type(props['technologyDelaysDays']).__name__}")
    
        # Type check renderingHours (expected int)
        if "renderingHours" in props and props["renderingHours"] is not None:
            if not isinstance(props["renderingHours"], int):
                try:
                    # Attempt to convert
                    props["renderingHours"] = int(props["renderingHours"])
                except:
                    raise TypeError(f"Property renderingHours must be of type int, got {type(props['renderingHours']).__name__}")
    
        # Type check animationFrames (expected int)
        if "animationFrames" in props and props["animationFrames"] is not None:
            if not isinstance(props["animationFrames"], int):
                try:
                    # Attempt to convert
                    props["animationFrames"] = int(props["animationFrames"])
                except:
                    raise TypeError(f"Property animationFrames must be of type int, got {type(props['animationFrames']).__name__}")
    
        # Type check animationStudios (expected int)
        if "animationStudios" in props and props["animationStudios"] is not None:
            if not isinstance(props["animationStudios"], int):
                try:
                    # Attempt to convert
                    props["animationStudios"] = int(props["animationStudios"])
                except:
                    raise TypeError(f"Property animationStudios must be of type int, got {type(props['animationStudios']).__name__}")
    
        # Type check digitalArchiveDate (expected object)
        if "digitalArchiveDate" in props and props["digitalArchiveDate"] is not None:
            if not isinstance(props["digitalArchiveDate"], object):
                try:
                    # Attempt to convert
                    props["digitalArchiveDate"] = object(props["digitalArchiveDate"])
                except:
                    raise TypeError(f"Property digitalArchiveDate must be of type object, got {type(props['digitalArchiveDate']).__name__}")
    
        # Type check reprintCount (expected int)
        if "reprintCount" in props and props["reprintCount"] is not None:
            if not isinstance(props["reprintCount"], int):
                try:
                    # Attempt to convert
                    props["reprintCount"] = int(props["reprintCount"])
                except:
                    raise TypeError(f"Property reprintCount must be of type int, got {type(props['reprintCount']).__name__}")
    
        # Type check soundstageCount (expected int)
        if "soundstageCount" in props and props["soundstageCount"] is not None:
            if not isinstance(props["soundstageCount"], int):
                try:
                    # Attempt to convert
                    props["soundstageCount"] = int(props["soundstageCount"])
                except:
                    raise TypeError(f"Property soundstageCount must be of type int, got {type(props['soundstageCount']).__name__}")
    
        # Type check setCount (expected int)
        if "setCount" in props and props["setCount"] is not None:
            if not isinstance(props["setCount"], int):
                try:
                    # Attempt to convert
                    props["setCount"] = int(props["setCount"])
                except:
                    raise TypeError(f"Property setCount must be of type int, got {type(props['setCount']).__name__}")
    
        # Type check technicalChallengesOvercome (expected int)
        if "technicalChallengesOvercome" in props and props["technicalChallengesOvercome"] is not None:
            if not isinstance(props["technicalChallengesOvercome"], int):
                try:
                    # Attempt to convert
                    props["technicalChallengesOvercome"] = int(props["technicalChallengesOvercome"])
                except:
                    raise TypeError(f"Property technicalChallengesOvercome must be of type int, got {type(props['technicalChallengesOvercome']).__name__}")
    
        # Type check innovationSuccessRate (expected float)
        if "innovationSuccessRate" in props and props["innovationSuccessRate"] is not None:
            if not isinstance(props["innovationSuccessRate"], float):
                try:
                    # Attempt to convert
                    props["innovationSuccessRate"] = float(props["innovationSuccessRate"])
                except:
                    raise TypeError(f"Property innovationSuccessRate must be of type float, got {type(props['innovationSuccessRate']).__name__}")
    
        # Type check customSetsBudget (expected int)
        if "customSetsBudget" in props and props["customSetsBudget"] is not None:
            if not isinstance(props["customSetsBudget"], int):
                try:
                    # Attempt to convert
                    props["customSetsBudget"] = int(props["customSetsBudget"])
                except:
                    raise TypeError(f"Property customSetsBudget must be of type int, got {type(props['customSetsBudget']).__name__}")
    
        # Type check perfectShotTakes (expected int)
        if "perfectShotTakes" in props and props["perfectShotTakes"] is not None:
            if not isinstance(props["perfectShotTakes"], int):
                try:
                    # Attempt to convert
                    props["perfectShotTakes"] = int(props["perfectShotTakes"])
                except:
                    raise TypeError(f"Property perfectShotTakes must be of type int, got {type(props['perfectShotTakes']).__name__}")
    
        # Type check totalTakes (expected int)
        if "totalTakes" in props and props["totalTakes"] is not None:
            if not isinstance(props["totalTakes"], int):
                try:
                    # Attempt to convert
                    props["totalTakes"] = int(props["totalTakes"])
                except:
                    raise TypeError(f"Property totalTakes must be of type int, got {type(props['totalTakes']).__name__}")
    
        # Type check scientificValueRating (expected float)
        if "scientificValueRating" in props and props["scientificValueRating"] is not None:
            if not isinstance(props["scientificValueRating"], float):
                try:
                    # Attempt to convert
                    props["scientificValueRating"] = float(props["scientificValueRating"])
                except:
                    raise TypeError(f"Property scientificValueRating must be of type float, got {type(props['scientificValueRating']).__name__}")
    
        # Type check footageUnit (expected str)
        if "footageUnit" in props and props["footageUnit"] is not None:
            if not isinstance(props["footageUnit"], str):
                try:
                    # Attempt to convert
                    props["footageUnit"] = str(props["footageUnit"])
                except:
                    raise TypeError(f"Property footageUnit must be of type str, got {type(props['footageUnit']).__name__}")
    
        # Type check equipmentMalfunctions (expected int)
        if "equipmentMalfunctions" in props and props["equipmentMalfunctions"] is not None:
            if not isinstance(props["equipmentMalfunctions"], int):
                try:
                    # Attempt to convert
                    props["equipmentMalfunctions"] = int(props["equipmentMalfunctions"])
                except:
                    raise TypeError(f"Property equipmentMalfunctions must be of type int, got {type(props['equipmentMalfunctions']).__name__}")
    
        # Type check scheduleExtensions (expected int)
        if "scheduleExtensions" in props and props["scheduleExtensions"] is not None:
            if not isinstance(props["scheduleExtensions"], int):
                try:
                    # Attempt to convert
                    props["scheduleExtensions"] = int(props["scheduleExtensions"])
                except:
                    raise TypeError(f"Property scheduleExtensions must be of type int, got {type(props['scheduleExtensions']).__name__}")
    
        # Type check extremeConditionDays (expected int)
        if "extremeConditionDays" in props and props["extremeConditionDays"] is not None:
            if not isinstance(props["extremeConditionDays"], int):
                try:
                    # Attempt to convert
                    props["extremeConditionDays"] = int(props["extremeConditionDays"])
                except:
                    raise TypeError(f"Property extremeConditionDays must be of type int, got {type(props['extremeConditionDays']).__name__}")
    
        # Type check totalFootage (expected int)
        if "totalFootage" in props and props["totalFootage"] is not None:
            if not isinstance(props["totalFootage"], int):
                try:
                    # Attempt to convert
                    props["totalFootage"] = int(props["totalFootage"])
                except:
                    raise TypeError(f"Property totalFootage must be of type int, got {type(props['totalFootage']).__name__}")
    
        # Type check locationFilmingPercentage (expected int)
        if "locationFilmingPercentage" in props and props["locationFilmingPercentage"] is not None:
            if not isinstance(props["locationFilmingPercentage"], int):
                try:
                    # Attempt to convert
                    props["locationFilmingPercentage"] = int(props["locationFilmingPercentage"])
                except:
                    raise TypeError(f"Property locationFilmingPercentage must be of type int, got {type(props['locationFilmingPercentage']).__name__}")
    
        # Type check musicalNumbersFilmed (expected int)
        if "musicalNumbersFilmed" in props and props["musicalNumbersFilmed"] is not None:
            if not isinstance(props["musicalNumbersFilmed"], int):
                try:
                    # Attempt to convert
                    props["musicalNumbersFilmed"] = int(props["musicalNumbersFilmed"])
                except:
                    raise TypeError(f"Property musicalNumbersFilmed must be of type int, got {type(props['musicalNumbersFilmed']).__name__}")
    
        # Type check crewSize (expected int)
        if "crewSize" in props and props["crewSize"] is not None:
            if not isinstance(props["crewSize"], int):
                try:
                    # Attempt to convert
                    props["crewSize"] = int(props["crewSize"])
                except:
                    raise TypeError(f"Property crewSize must be of type int, got {type(props['crewSize']).__name__}")
    
        # Type check studioFilmingPercentage (expected int)
        if "studioFilmingPercentage" in props and props["studioFilmingPercentage"] is not None:
            if not isinstance(props["studioFilmingPercentage"], int):
                try:
                    # Attempt to convert
                    props["studioFilmingPercentage"] = int(props["studioFilmingPercentage"])
                except:
                    raise TypeError(f"Property studioFilmingPercentage must be of type int, got {type(props['studioFilmingPercentage']).__name__}")
    
        # Type check secrecyLevel (expected str)
        if "secrecyLevel" in props and props["secrecyLevel"] is not None:
            if not isinstance(props["secrecyLevel"], str):
                try:
                    # Attempt to convert
                    props["secrecyLevel"] = str(props["secrecyLevel"])
                except:
                    raise TypeError(f"Property secrecyLevel must be of type str, got {type(props['secrecyLevel']).__name__}")
    
        # Type check blackAndWhiteFormat (expected bool)
        if "blackAndWhiteFormat" in props and props["blackAndWhiteFormat"] is not None:
            if not isinstance(props["blackAndWhiteFormat"], bool):
                try:
                    # Attempt to convert
                    props["blackAndWhiteFormat"] = bool(props["blackAndWhiteFormat"])
                except:
                    raise TypeError(f"Property blackAndWhiteFormat must be of type bool, got {type(props['blackAndWhiteFormat']).__name__}")
    
        # Type check scheduleOverrun (expected float)
        if "scheduleOverrun" in props and props["scheduleOverrun"] is not None:
            if not isinstance(props["scheduleOverrun"], float):
                try:
                    # Attempt to convert
                    props["scheduleOverrun"] = float(props["scheduleOverrun"])
                except:
                    raise TypeError(f"Property scheduleOverrun must be of type float, got {type(props['scheduleOverrun']).__name__}")
    
        # Type check budgetOverrun (expected float)
        if "budgetOverrun" in props and props["budgetOverrun"] is not None:
            if not isinstance(props["budgetOverrun"], float):
                try:
                    # Attempt to convert
                    props["budgetOverrun"] = float(props["budgetOverrun"])
                except:
                    raise TypeError(f"Property budgetOverrun must be of type float, got {type(props['budgetOverrun']).__name__}")
    
        # Type check studioInterference (expected str)
        if "studioInterference" in props and props["studioInterference"] is not None:
            if not isinstance(props["studioInterference"], str):
                try:
                    # Attempt to convert
                    props["studioInterference"] = str(props["studioInterference"])
                except:
                    raise TypeError(f"Property studioInterference must be of type str, got {type(props['studioInterference']).__name__}")
    
        # Type check castingDisputes (expected str)
        if "castingDisputes" in props and props["castingDisputes"] is not None:
            if not isinstance(props["castingDisputes"], str):
                try:
                    # Attempt to convert
                    props["castingDisputes"] = str(props["castingDisputes"])
                except:
                    raise TypeError(f"Property castingDisputes must be of type str, got {type(props['castingDisputes']).__name__}")
    
        # Type check iMAXPercentage (expected int)
        if "iMAXPercentage" in props and props["iMAXPercentage"] is not None:
            if not isinstance(props["iMAXPercentage"], int):
                try:
                    # Attempt to convert
                    props["iMAXPercentage"] = int(props["iMAXPercentage"])
                except:
                    raise TypeError(f"Property iMAXPercentage must be of type int, got {type(props['iMAXPercentage']).__name__}")
    
        # Type check practicalEffects (expected str)
        if "practicalEffects" in props and props["practicalEffects"] is not None:
            if not isinstance(props["practicalEffects"], str):
                try:
                    # Attempt to convert
                    props["practicalEffects"] = str(props["practicalEffects"])
                except:
                    raise TypeError(f"Property practicalEffects must be of type str, got {type(props['practicalEffects']).__name__}")
    
        # Type check improvisationLevel (expected str)
        if "improvisationLevel" in props and props["improvisationLevel"] is not None:
            if not isinstance(props["improvisationLevel"], str):
                try:
                    # Attempt to convert
                    props["improvisationLevel"] = str(props["improvisationLevel"])
                except:
                    raise TypeError(f"Property improvisationLevel must be of type str, got {type(props['improvisationLevel']).__name__}")
    
        # Type check castChemistry (expected str)
        if "castChemistry" in props and props["castChemistry"] is not None:
            if not isinstance(props["castChemistry"], str):
                try:
                    # Attempt to convert
                    props["castChemistry"] = str(props["castChemistry"])
                except:
                    raise TypeError(f"Property castChemistry must be of type str, got {type(props['castChemistry']).__name__}")
    
        # Type check culturalContext (expected str)
        if "culturalContext" in props and props["culturalContext"] is not None:
            if not isinstance(props["culturalContext"], str):
                try:
                    # Attempt to convert
                    props["culturalContext"] = str(props["culturalContext"])
                except:
                    raise TypeError(f"Property culturalContext must be of type str, got {type(props['culturalContext']).__name__}")
    
        # Type check criticalImpact (expected str)
        if "criticalImpact" in props and props["criticalImpact"] is not None:
            if not isinstance(props["criticalImpact"], str):
                try:
                    # Attempt to convert
                    props["criticalImpact"] = str(props["criticalImpact"])
                except:
                    raise TypeError(f"Property criticalImpact must be of type str, got {type(props['criticalImpact']).__name__}")
    
        # Type check historicalValue (expected str)
        if "historicalValue" in props and props["historicalValue"] is not None:
            if not isinstance(props["historicalValue"], str):
                try:
                    # Attempt to convert
                    props["historicalValue"] = str(props["historicalValue"])
                except:
                    raise TypeError(f"Property historicalValue must be of type str, got {type(props['historicalValue']).__name__}")
    
        # Type check criticPerspective (expected str)
        if "criticPerspective" in props and props["criticPerspective"] is not None:
            if not isinstance(props["criticPerspective"], str):
                try:
                    # Attempt to convert
                    props["criticPerspective"] = str(props["criticPerspective"])
                except:
                    raise TypeError(f"Property criticPerspective must be of type str, got {type(props['criticPerspective']).__name__}")
    
        # Type check industryInfluence (expected str)
        if "industryInfluence" in props and props["industryInfluence"] is not None:
            if not isinstance(props["industryInfluence"], str):
                try:
                    # Attempt to convert
                    props["industryInfluence"] = str(props["industryInfluence"])
                except:
                    raise TypeError(f"Property industryInfluence must be of type str, got {type(props['industryInfluence']).__name__}")
    
        # Type check anthologized (expected bool)
        if "anthologized" in props and props["anthologized"] is not None:
            if not isinstance(props["anthologized"], bool):
                try:
                    # Attempt to convert
                    props["anthologized"] = bool(props["anthologized"])
                except:
                    raise TypeError(f"Property anthologized must be of type bool, got {type(props['anthologized']).__name__}")
    
        # Type check publicationPage (expected str)
        if "publicationPage" in props and props["publicationPage"] is not None:
            if not isinstance(props["publicationPage"], str):
                try:
                    # Attempt to convert
                    props["publicationPage"] = str(props["publicationPage"])
                except:
                    raise TypeError(f"Property publicationPage must be of type str, got {type(props['publicationPage']).__name__}")
    
        # Type check academicCitations (expected int)
        if "academicCitations" in props and props["academicCitations"] is not None:
            if not isinstance(props["academicCitations"], int):
                try:
                    # Attempt to convert
                    props["academicCitations"] = int(props["academicCitations"])
                except:
                    raise TypeError(f"Property academicCitations must be of type int, got {type(props['academicCitations']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="FOR_MOVIE", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def nominated_for(uuid=None, **props):
        """
        Find relationships of type NOMINATED_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check presenter2 (expected str)
        if "presenter2" in props and props["presenter2"] is not None:
            if not isinstance(props["presenter2"], str):
                try:
                    # Attempt to convert
                    props["presenter2"] = str(props["presenter2"])
                except:
                    raise TypeError(f"Property presenter2 must be of type str, got {type(props['presenter2']).__name__}")
    
        # Type check announcementTime (expected object)
        if "announcementTime" in props and props["announcementTime"] is not None:
            if not isinstance(props["announcementTime"], object):
                try:
                    # Attempt to convert
                    props["announcementTime"] = object(props["announcementTime"])
                except:
                    raise TypeError(f"Property announcementTime must be of type object, got {type(props['announcementTime']).__name__}")
    
        # Type check presenter1 (expected str)
        if "presenter1" in props and props["presenter1"] is not None:
            if not isinstance(props["presenter1"], str):
                try:
                    # Attempt to convert
                    props["presenter1"] = str(props["presenter1"])
                except:
                    raise TypeError(f"Property presenter1 must be of type str, got {type(props['presenter1']).__name__}")
    
        # Type check ceremony (expected int)
        if "ceremony" in props and props["ceremony"] is not None:
            if not isinstance(props["ceremony"], int):
                try:
                    # Attempt to convert
                    props["ceremony"] = int(props["ceremony"])
                except:
                    raise TypeError(f"Property ceremony must be of type int, got {type(props['ceremony']).__name__}")
    
        # Type check category (expected str)
        if "category" in props and props["category"] is not None:
            if not isinstance(props["category"], str):
                try:
                    # Attempt to convert
                    props["category"] = str(props["category"])
                except:
                    raise TypeError(f"Property category must be of type str, got {type(props['category']).__name__}")
    
        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Type check isWinner (expected bool)
        if "isWinner" in props and props["isWinner"] is not None:
            if not isinstance(props["isWinner"], bool):
                try:
                    # Attempt to convert
                    props["isWinner"] = bool(props["isWinner"])
                except:
                    raise TypeError(f"Property isWinner must be of type bool, got {type(props['isWinner']).__name__}")
    
        # Type check votesAgainst (expected int)
        if "votesAgainst" in props and props["votesAgainst"] is not None:
            if not isinstance(props["votesAgainst"], int):
                try:
                    # Attempt to convert
                    props["votesAgainst"] = int(props["votesAgainst"])
                except:
                    raise TypeError(f"Property votesAgainst must be of type int, got {type(props['votesAgainst']).__name__}")
    
        # Type check ceremonyDate (expected object)
        if "ceremonyDate" in props and props["ceremonyDate"] is not None:
            if not isinstance(props["ceremonyDate"], object):
                try:
                    # Attempt to convert
                    props["ceremonyDate"] = object(props["ceremonyDate"])
                except:
                    raise TypeError(f"Property ceremonyDate must be of type object, got {type(props['ceremonyDate']).__name__}")
    
        # Type check votesFor (expected int)
        if "votesFor" in props and props["votesFor"] is not None:
            if not isinstance(props["votesFor"], int):
                try:
                    # Attempt to convert
                    props["votesFor"] = int(props["votesFor"])
                except:
                    raise TypeError(f"Property votesFor must be of type int, got {type(props['votesFor']).__name__}")
    
        # Type check speechDuration (expected object)
        if "speechDuration" in props and props["speechDuration"] is not None:
            if not isinstance(props["speechDuration"], object):
                try:
                    # Attempt to convert
                    props["speechDuration"] = object(props["speechDuration"])
                except:
                    raise TypeError(f"Property speechDuration must be of type object, got {type(props['speechDuration']).__name__}")
    
        # Type check wins (expected int)
        if "wins" in props and props["wins"] is not None:
            if not isinstance(props["wins"], int):
                try:
                    # Attempt to convert
                    props["wins"] = int(props["wins"])
                except:
                    raise TypeError(f"Property wins must be of type int, got {type(props['wins']).__name__}")
    
        # Type check categories (expected int)
        if "categories" in props and props["categories"] is not None:
            if not isinstance(props["categories"], int):
                try:
                    # Attempt to convert
                    props["categories"] = int(props["categories"])
                except:
                    raise TypeError(f"Property categories must be of type int, got {type(props['categories']).__name__}")
    
        # Type check controversyLevel (expected str)
        if "controversyLevel" in props and props["controversyLevel"] is not None:
            if not isinstance(props["controversyLevel"], str):
                try:
                    # Attempt to convert
                    props["controversyLevel"] = str(props["controversyLevel"])
                except:
                    raise TypeError(f"Property controversyLevel must be of type str, got {type(props['controversyLevel']).__name__}")
    
        # Type check historicalReassessment (expected str)
        if "historicalReassessment" in props and props["historicalReassessment"] is not None:
            if not isinstance(props["historicalReassessment"], str):
                try:
                    # Attempt to convert
                    props["historicalReassessment"] = str(props["historicalReassessment"])
                except:
                    raise TypeError(f"Property historicalReassessment must be of type str, got {type(props['historicalReassessment']).__name__}")
    
        # Type check reasonForAbsence (expected str)
        if "reasonForAbsence" in props and props["reasonForAbsence"] is not None:
            if not isinstance(props["reasonForAbsence"], str):
                try:
                    # Attempt to convert
                    props["reasonForAbsence"] = str(props["reasonForAbsence"])
                except:
                    raise TypeError(f"Property reasonForAbsence must be of type str, got {type(props['reasonForAbsence']).__name__}")
    
        # Type check coRecipient (expected str)
        if "coRecipient" in props and props["coRecipient"] is not None:
            if not isinstance(props["coRecipient"], str):
                try:
                    # Attempt to convert
                    props["coRecipient"] = str(props["coRecipient"])
                except:
                    raise TypeError(f"Property coRecipient must be of type str, got {type(props['coRecipient']).__name__}")
    
        # Type check historicalSignificance (expected str)
        if "historicalSignificance" in props and props["historicalSignificance"] is not None:
            if not isinstance(props["historicalSignificance"], str):
                try:
                    # Attempt to convert
                    props["historicalSignificance"] = str(props["historicalSignificance"])
                except:
                    raise TypeError(f"Property historicalSignificance must be of type str, got {type(props['historicalSignificance']).__name__}")
    
        # Type check attendance (expected bool)
        if "attendance" in props and props["attendance"] is not None:
            if not isinstance(props["attendance"], bool):
                try:
                    # Attempt to convert
                    props["attendance"] = bool(props["attendance"])
                except:
                    raise TypeError(f"Property attendance must be of type bool, got {type(props['attendance']).__name__}")
    
        # Type check audienceReaction (expected str)
        if "audienceReaction" in props and props["audienceReaction"] is not None:
            if not isinstance(props["audienceReaction"], str):
                try:
                    # Attempt to convert
                    props["audienceReaction"] = str(props["audienceReaction"])
                except:
                    raise TypeError(f"Property audienceReaction must be of type str, got {type(props['audienceReaction']).__name__}")
    
        # Type check ovationLength (expected object)
        if "ovationLength" in props and props["ovationLength"] is not None:
            if not isinstance(props["ovationLength"], object):
                try:
                    # Attempt to convert
                    props["ovationLength"] = object(props["ovationLength"])
                except:
                    raise TypeError(f"Property ovationLength must be of type object, got {type(props['ovationLength']).__name__}")
    
        # Type check memorableQuote (expected str)
        if "memorableQuote" in props and props["memorableQuote"] is not None:
            if not isinstance(props["memorableQuote"], str):
                try:
                    # Attempt to convert
                    props["memorableQuote"] = str(props["memorableQuote"])
                except:
                    raise TypeError(f"Property memorableQuote must be of type str, got {type(props['memorableQuote']).__name__}")
    
        # Type check translatorUsed (expected bool)
        if "translatorUsed" in props and props["translatorUsed"] is not None:
            if not isinstance(props["translatorUsed"], bool):
                try:
                    # Attempt to convert
                    props["translatorUsed"] = bool(props["translatorUsed"])
                except:
                    raise TypeError(f"Property translatorUsed must be of type bool, got {type(props['translatorUsed']).__name__}")
    
        # Type check audienceShareDuringAnnouncement (expected float)
        if "audienceShareDuringAnnouncement" in props and props["audienceShareDuringAnnouncement"] is not None:
            if not isinstance(props["audienceShareDuringAnnouncement"], float):
                try:
                    # Attempt to convert
                    props["audienceShareDuringAnnouncement"] = float(props["audienceShareDuringAnnouncement"])
                except:
                    raise TypeError(f"Property audienceShareDuringAnnouncement must be of type float, got {type(props['audienceShareDuringAnnouncement']).__name__}")
    
        # Type check significanceRating (expected str)
        if "significanceRating" in props and props["significanceRating"] is not None:
            if not isinstance(props["significanceRating"], str):
                try:
                    # Attempt to convert
                    props["significanceRating"] = str(props["significanceRating"])
                except:
                    raise TypeError(f"Property significanceRating must be of type str, got {type(props['significanceRating']).__name__}")
    
        # Type check reactionDuration (expected object)
        if "reactionDuration" in props and props["reactionDuration"] is not None:
            if not isinstance(props["reactionDuration"], object):
                try:
                    # Attempt to convert
                    props["reactionDuration"] = object(props["reactionDuration"])
                except:
                    raise TypeError(f"Property reactionDuration must be of type object, got {type(props['reactionDuration']).__name__}")
    
        # Type check screeningVenue (expected str)
        if "screeningVenue" in props and props["screeningVenue"] is not None:
            if not isinstance(props["screeningVenue"], str):
                try:
                    # Attempt to convert
                    props["screeningVenue"] = str(props["screeningVenue"])
                except:
                    raise TypeError(f"Property screeningVenue must be of type str, got {type(props['screeningVenue']).__name__}")
    
        # Type check screeningTime (expected object)
        if "screeningTime" in props and props["screeningTime"] is not None:
            if not isinstance(props["screeningTime"], object):
                try:
                    # Attempt to convert
                    props["screeningTime"] = object(props["screeningTime"])
                except:
                    raise TypeError(f"Property screeningTime must be of type object, got {type(props['screeningTime']).__name__}")
    
        # Type check screeningDate (expected object)
        if "screeningDate" in props and props["screeningDate"] is not None:
            if not isinstance(props["screeningDate"], object):
                try:
                    # Attempt to convert
                    props["screeningDate"] = object(props["screeningDate"])
                except:
                    raise TypeError(f"Property screeningDate must be of type object, got {type(props['screeningDate']).__name__}")
    
        # Type check culturalImpact (expected str)
        if "culturalImpact" in props and props["culturalImpact"] is not None:
            if not isinstance(props["culturalImpact"], str):
                try:
                    # Attempt to convert
                    props["culturalImpact"] = str(props["culturalImpact"])
                except:
                    raise TypeError(f"Property culturalImpact must be of type str, got {type(props['culturalImpact']).__name__}")
    
        # Type check producerAccepting (expected str)
        if "producerAccepting" in props and props["producerAccepting"] is not None:
            if not isinstance(props["producerAccepting"], str):
                try:
                    # Attempt to convert
                    props["producerAccepting"] = str(props["producerAccepting"])
                except:
                    raise TypeError(f"Property producerAccepting must be of type str, got {type(props['producerAccepting']).__name__}")
    
        # Type check previousWinYear (expected int)
        if "previousWinYear" in props and props["previousWinYear"] is not None:
            if not isinstance(props["previousWinYear"], int):
                try:
                    # Attempt to convert
                    props["previousWinYear"] = int(props["previousWinYear"])
                except:
                    raise TypeError(f"Property previousWinYear must be of type int, got {type(props['previousWinYear']).__name__}")
    
        # Type check previousWin (expected bool)
        if "previousWin" in props and props["previousWin"] is not None:
            if not isinstance(props["previousWin"], bool):
                try:
                    # Attempt to convert
                    props["previousWin"] = bool(props["previousWin"])
                except:
                    raise TypeError(f"Property previousWin must be of type bool, got {type(props['previousWin']).__name__}")
    
        # Type check competitionWinner (expected str)
        if "competitionWinner" in props and props["competitionWinner"] is not None:
            if not isinstance(props["competitionWinner"], str):
                try:
                    # Attempt to convert
                    props["competitionWinner"] = str(props["competitionWinner"])
                except:
                    raise TypeError(f"Property competitionWinner must be of type str, got {type(props['competitionWinner']).__name__}")
    
        # Type check techAwards (expected int)
        if "techAwards" in props and props["techAwards"] is not None:
            if not isinstance(props["techAwards"], int):
                try:
                    # Attempt to convert
                    props["techAwards"] = int(props["techAwards"])
                except:
                    raise TypeError(f"Property techAwards must be of type int, got {type(props['techAwards']).__name__}")
    
        # Type check culturalMilestone (expected bool)
        if "culturalMilestone" in props and props["culturalMilestone"] is not None:
            if not isinstance(props["culturalMilestone"], bool):
                try:
                    # Attempt to convert
                    props["culturalMilestone"] = bool(props["culturalMilestone"])
                except:
                    raise TypeError(f"Property culturalMilestone must be of type bool, got {type(props['culturalMilestone']).__name__}")
    
        # Type check secondGenerationWinner (expected bool)
        if "secondGenerationWinner" in props and props["secondGenerationWinner"] is not None:
            if not isinstance(props["secondGenerationWinner"], bool):
                try:
                    # Attempt to convert
                    props["secondGenerationWinner"] = bool(props["secondGenerationWinner"])
                except:
                    raise TypeError(f"Property secondGenerationWinner must be of type bool, got {type(props['secondGenerationWinner']).__name__}")
    
        # Type check totalOscars (expected int)
        if "totalOscars" in props and props["totalOscars"] is not None:
            if not isinstance(props["totalOscars"], int):
                try:
                    # Attempt to convert
                    props["totalOscars"] = int(props["totalOscars"])
                except:
                    raise TypeError(f"Property totalOscars must be of type int, got {type(props['totalOscars']).__name__}")
    
        # Type check recordTying (expected bool)
        if "recordTying" in props and props["recordTying"] is not None:
            if not isinstance(props["recordTying"], bool):
                try:
                    # Attempt to convert
                    props["recordTying"] = bool(props["recordTying"])
                except:
                    raise TypeError(f"Property recordTying must be of type bool, got {type(props['recordTying']).__name__}")
    
        # Type check quotedLine (expected str)
        if "quotedLine" in props and props["quotedLine"] is not None:
            if not isinstance(props["quotedLine"], str):
                try:
                    # Attempt to convert
                    props["quotedLine"] = str(props["quotedLine"])
                except:
                    raise TypeError(f"Property quotedLine must be of type str, got {type(props['quotedLine']).__name__}")
    
        # Type check speechMemorable (expected bool)
        if "speechMemorable" in props and props["speechMemorable"] is not None:
            if not isinstance(props["speechMemorable"], bool):
                try:
                    # Attempt to convert
                    props["speechMemorable"] = bool(props["speechMemorable"])
                except:
                    raise TypeError(f"Property speechMemorable must be of type bool, got {type(props['speechMemorable']).__name__}")
    
        # Type check controversies (expected str)
        if "controversies" in props and props["controversies"] is not None:
            if not isinstance(props["controversies"], str):
                try:
                    # Attempt to convert
                    props["controversies"] = str(props["controversies"])
                except:
                    raise TypeError(f"Property controversies must be of type str, got {type(props['controversies']).__name__}")
    
        # Type check emotionalImpact (expected str)
        if "emotionalImpact" in props and props["emotionalImpact"] is not None:
            if not isinstance(props["emotionalImpact"], str):
                try:
                    # Attempt to convert
                    props["emotionalImpact"] = str(props["emotionalImpact"])
                except:
                    raise TypeError(f"Property emotionalImpact must be of type str, got {type(props['emotionalImpact']).__name__}")
    
        # Type check acceptedBy (expected str)
        if "acceptedBy" in props and props["acceptedBy"] is not None:
            if not isinstance(props["acceptedBy"], str):
                try:
                    # Attempt to convert
                    props["acceptedBy"] = str(props["acceptedBy"])
                except:
                    raise TypeError(f"Property acceptedBy must be of type str, got {type(props['acceptedBy']).__name__}")
    
        # Type check posthumousAward (expected bool)
        if "posthumousAward" in props and props["posthumousAward"] is not None:
            if not isinstance(props["posthumousAward"], bool):
                try:
                    # Attempt to convert
                    props["posthumousAward"] = bool(props["posthumousAward"])
                except:
                    raise TypeError(f"Property posthumousAward must be of type bool, got {type(props['posthumousAward']).__name__}")
    
        # Type check indieBreakthrough (expected bool)
        if "indieBreakthrough" in props and props["indieBreakthrough"] is not None:
            if not isinstance(props["indieBreakthrough"], bool):
                try:
                    # Attempt to convert
                    props["indieBreakthrough"] = bool(props["indieBreakthrough"])
                except:
                    raise TypeError(f"Property indieBreakthrough must be of type bool, got {type(props['indieBreakthrough']).__name__}")
    
        # Type check independentCelebration (expected bool)
        if "independentCelebration" in props and props["independentCelebration"] is not None:
            if not isinstance(props["independentCelebration"], bool):
                try:
                    # Attempt to convert
                    props["independentCelebration"] = bool(props["independentCelebration"])
                except:
                    raise TypeError(f"Property independentCelebration must be of type bool, got {type(props['independentCelebration']).__name__}")
    
        # Type check additionalNominations (expected int)
        if "additionalNominations" in props and props["additionalNominations"] is not None:
            if not isinstance(props["additionalNominations"], int):
                try:
                    # Attempt to convert
                    props["additionalNominations"] = int(props["additionalNominations"])
                except:
                    raise TypeError(f"Property additionalNominations must be of type int, got {type(props['additionalNominations']).__name__}")
    
        # Type check broadestRecognition (expected str)
        if "broadestRecognition" in props and props["broadestRecognition"] is not None:
            if not isinstance(props["broadestRecognition"], str):
                try:
                    # Attempt to convert
                    props["broadestRecognition"] = str(props["broadestRecognition"])
                except:
                    raise TypeError(f"Property broadestRecognition must be of type str, got {type(props['broadestRecognition']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="NOMINATED_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def knows(uuid=None, **props):
        """
        Find relationships of type KNOWS matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check lastContact (expected object)
        if "lastContact" in props and props["lastContact"] is not None:
            if not isinstance(props["lastContact"], object):
                try:
                    # Attempt to convert
                    props["lastContact"] = object(props["lastContact"])
                except:
                    raise TypeError(f"Property lastContact must be of type object, got {type(props['lastContact']).__name__}")
    
        # Type check relationship (expected str)
        if "relationship" in props and props["relationship"] is not None:
            if not isinstance(props["relationship"], str):
                try:
                    # Attempt to convert
                    props["relationship"] = str(props["relationship"])
                except:
                    raise TypeError(f"Property relationship must be of type str, got {type(props['relationship']).__name__}")
    
        # Type check since (expected object)
        if "since" in props and props["since"] is not None:
            if not isinstance(props["since"], object):
                try:
                    # Attempt to convert
                    props["since"] = object(props["since"])
                except:
                    raise TypeError(f"Property since must be of type object, got {type(props['since']).__name__}")
    
        # Type check nextMeeting (expected object)
        if "nextMeeting" in props and props["nextMeeting"] is not None:
            if not isinstance(props["nextMeeting"], object):
                try:
                    # Attempt to convert
                    props["nextMeeting"] = object(props["nextMeeting"])
                except:
                    raise TypeError(f"Property nextMeeting must be of type object, got {type(props['nextMeeting']).__name__}")
    
        # Type check projects (expected int)
        if "projects" in props and props["projects"] is not None:
            if not isinstance(props["projects"], int):
                try:
                    # Attempt to convert
                    props["projects"] = int(props["projects"])
                except:
                    raise TypeError(f"Property projects must be of type int, got {type(props['projects']).__name__}")
    
        # Type check project1 (expected str)
        if "project1" in props and props["project1"] is not None:
            if not isinstance(props["project1"], str):
                try:
                    # Attempt to convert
                    props["project1"] = str(props["project1"])
                except:
                    raise TypeError(f"Property project1 must be of type str, got {type(props['project1']).__name__}")
    
        # Type check year1 (expected int)
        if "year1" in props and props["year1"] is not None:
            if not isinstance(props["year1"], int):
                try:
                    # Attempt to convert
                    props["year1"] = int(props["year1"])
                except:
                    raise TypeError(f"Property year1 must be of type int, got {type(props['year1']).__name__}")
    
        # Type check year2 (expected int)
        if "year2" in props and props["year2"] is not None:
            if not isinstance(props["year2"], int):
                try:
                    # Attempt to convert
                    props["year2"] = int(props["year2"])
                except:
                    raise TypeError(f"Property year2 must be of type int, got {type(props['year2']).__name__}")
    
        # Type check project2 (expected str)
        if "project2" in props and props["project2"] is not None:
            if not isinstance(props["project2"], str):
                try:
                    # Attempt to convert
                    props["project2"] = str(props["project2"])
                except:
                    raise TypeError(f"Property project2 must be of type str, got {type(props['project2']).__name__}")
    
        # Type check durationYears (expected int)
        if "durationYears" in props and props["durationYears"] is not None:
            if not isinstance(props["durationYears"], int):
                try:
                    # Attempt to convert
                    props["durationYears"] = int(props["durationYears"])
                except:
                    raise TypeError(f"Property durationYears must be of type int, got {type(props['durationYears']).__name__}")
    
        # Type check lastCollaboration (expected object)
        if "lastCollaboration" in props and props["lastCollaboration"] is not None:
            if not isinstance(props["lastCollaboration"], object):
                try:
                    # Attempt to convert
                    props["lastCollaboration"] = object(props["lastCollaboration"])
                except:
                    raise TypeError(f"Property lastCollaboration must be of type object, got {type(props['lastCollaboration']).__name__}")
    
        # Type check lastMeeting (expected object)
        if "lastMeeting" in props and props["lastMeeting"] is not None:
            if not isinstance(props["lastMeeting"], object):
                try:
                    # Attempt to convert
                    props["lastMeeting"] = object(props["lastMeeting"])
                except:
                    raise TypeError(f"Property lastMeeting must be of type object, got {type(props['lastMeeting']).__name__}")
    
        # Type check commonFriends (expected int)
        if "commonFriends" in props and props["commonFriends"] is not None:
            if not isinstance(props["commonFriends"], int):
                try:
                    # Attempt to convert
                    props["commonFriends"] = int(props["commonFriends"])
                except:
                    raise TypeError(f"Property commonFriends must be of type int, got {type(props['commonFriends']).__name__}")
    
        # Type check commonProjects (expected int)
        if "commonProjects" in props and props["commonProjects"] is not None:
            if not isinstance(props["commonProjects"], int):
                try:
                    # Attempt to convert
                    props["commonProjects"] = int(props["commonProjects"])
                except:
                    raise TypeError(f"Property commonProjects must be of type int, got {type(props['commonProjects']).__name__}")
    
        # Type check commonGenres (expected object)
        if "commonGenres" in props and props["commonGenres"] is not None:
            if not isinstance(props["commonGenres"], object):
                try:
                    # Attempt to convert
                    props["commonGenres"] = object(props["commonGenres"])
                except:
                    raise TypeError(f"Property commonGenres must be of type object, got {type(props['commonGenres']).__name__}")
    
        # Type check commonAwards (expected int)
        if "commonAwards" in props and props["commonAwards"] is not None:
            if not isinstance(props["commonAwards"], int):
                try:
                    # Attempt to convert
                    props["commonAwards"] = int(props["commonAwards"])
                except:
                    raise TypeError(f"Property commonAwards must be of type int, got {type(props['commonAwards']).__name__}")
    
        # Type check commonEvents (expected int)
        if "commonEvents" in props and props["commonEvents"] is not None:
            if not isinstance(props["commonEvents"], int):
                try:
                    # Attempt to convert
                    props["commonEvents"] = int(props["commonEvents"])
                except:
                    raise TypeError(f"Property commonEvents must be of type int, got {type(props['commonEvents']).__name__}")
    
        # Type check industryEvents (expected int)
        if "industryEvents" in props and props["industryEvents"] is not None:
            if not isinstance(props["industryEvents"], int):
                try:
                    # Attempt to convert
                    props["industryEvents"] = int(props["industryEvents"])
                except:
                    raise TypeError(f"Property industryEvents must be of type int, got {type(props['industryEvents']).__name__}")
    
        # Type check mutualRespectLevel (expected str)
        if "mutualRespectLevel" in props and props["mutualRespectLevel"] is not None:
            if not isinstance(props["mutualRespectLevel"], str):
                try:
                    # Attempt to convert
                    props["mutualRespectLevel"] = str(props["mutualRespectLevel"])
                except:
                    raise TypeError(f"Property mutualRespectLevel must be of type str, got {type(props['mutualRespectLevel']).__name__}")
    
        # Type check technicalExchanges (expected int)
        if "technicalExchanges" in props and props["technicalExchanges"] is not None:
            if not isinstance(props["technicalExchanges"], int):
                try:
                    # Attempt to convert
                    props["technicalExchanges"] = int(props["technicalExchanges"])
                except:
                    raise TypeError(f"Property technicalExchanges must be of type int, got {type(props['technicalExchanges']).__name__}")
    
        # Type check mutualAdmiration (expected bool)
        if "mutualAdmiration" in props and props["mutualAdmiration"] is not None:
            if not isinstance(props["mutualAdmiration"], bool):
                try:
                    # Attempt to convert
                    props["mutualAdmiration"] = bool(props["mutualAdmiration"])
                except:
                    raise TypeError(f"Property mutualAdmiration must be of type bool, got {type(props['mutualAdmiration']).__name__}")
    
        # Type check festivalEncounters (expected int)
        if "festivalEncounters" in props and props["festivalEncounters"] is not None:
            if not isinstance(props["festivalEncounters"], int):
                try:
                    # Attempt to convert
                    props["festivalEncounters"] = int(props["festivalEncounters"])
                except:
                    raise TypeError(f"Property festivalEncounters must be of type int, got {type(props['festivalEncounters']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="KNOWS", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def worked_with(uuid=None, **props):
        """
        Find relationships of type WORKED_WITH matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check firstProject (expected str)
        if "firstProject" in props and props["firstProject"] is not None:
            if not isinstance(props["firstProject"], str):
                try:
                    # Attempt to convert
                    props["firstProject"] = str(props["firstProject"])
                except:
                    raise TypeError(f"Property firstProject must be of type str, got {type(props['firstProject']).__name__}")
    
        # Type check firstYear (expected int)
        if "firstYear" in props and props["firstYear"] is not None:
            if not isinstance(props["firstYear"], int):
                try:
                    # Attempt to convert
                    props["firstYear"] = int(props["firstYear"])
                except:
                    raise TypeError(f"Property firstYear must be of type int, got {type(props['firstYear']).__name__}")
    
        # Type check relationship (expected str)
        if "relationship" in props and props["relationship"] is not None:
            if not isinstance(props["relationship"], str):
                try:
                    # Attempt to convert
                    props["relationship"] = str(props["relationship"])
                except:
                    raise TypeError(f"Property relationship must be of type str, got {type(props['relationship']).__name__}")
    
        # Type check chemistry (expected float)
        if "chemistry" in props and props["chemistry"] is not None:
            if not isinstance(props["chemistry"], float):
                try:
                    # Attempt to convert
                    props["chemistry"] = float(props["chemistry"])
                except:
                    raise TypeError(f"Property chemistry must be of type float, got {type(props['chemistry']).__name__}")
    
        # Type check jointSceneMinutes (expected int)
        if "jointSceneMinutes" in props and props["jointSceneMinutes"] is not None:
            if not isinstance(props["jointSceneMinutes"], int):
                try:
                    # Attempt to convert
                    props["jointSceneMinutes"] = int(props["jointSceneMinutes"])
                except:
                    raise TypeError(f"Property jointSceneMinutes must be of type int, got {type(props['jointSceneMinutes']).__name__}")
    
        # Type check interviews (expected int)
        if "interviews" in props and props["interviews"] is not None:
            if not isinstance(props["interviews"], int):
                try:
                    # Attempt to convert
                    props["interviews"] = int(props["interviews"])
                except:
                    raise TypeError(f"Property interviews must be of type int, got {type(props['interviews']).__name__}")
    
        # Type check nextProjectPlanned (expected object)
        if "nextProjectPlanned" in props and props["nextProjectPlanned"] is not None:
            if not isinstance(props["nextProjectPlanned"], object):
                try:
                    # Attempt to convert
                    props["nextProjectPlanned"] = object(props["nextProjectPlanned"])
                except:
                    raise TypeError(f"Property nextProjectPlanned must be of type object, got {type(props['nextProjectPlanned']).__name__}")
    
        # Type check projects (expected int)
        if "projects" in props and props["projects"] is not None:
            if not isinstance(props["projects"], int):
                try:
                    # Attempt to convert
                    props["projects"] = int(props["projects"])
                except:
                    raise TypeError(f"Property projects must be of type int, got {type(props['projects']).__name__}")
    
        # Type check reunionAttempts (expected int)
        if "reunionAttempts" in props and props["reunionAttempts"] is not None:
            if not isinstance(props["reunionAttempts"], int):
                try:
                    # Attempt to convert
                    props["reunionAttempts"] = int(props["reunionAttempts"])
                except:
                    raise TypeError(f"Property reunionAttempts must be of type int, got {type(props['reunionAttempts']).__name__}")
    
        # Type check awards (expected object)
        if "awards" in props and props["awards"] is not None:
            if not isinstance(props["awards"], object):
                try:
                    # Attempt to convert
                    props["awards"] = object(props["awards"])
                except:
                    raise TypeError(f"Property awards must be of type object, got {type(props['awards']).__name__}")
    
        # Type check filmedDays (expected int)
        if "filmedDays" in props and props["filmedDays"] is not None:
            if not isinstance(props["filmedDays"], int):
                try:
                    # Attempt to convert
                    props["filmedDays"] = int(props["filmedDays"])
                except:
                    raise TypeError(f"Property filmedDays must be of type int, got {type(props['filmedDays']).__name__}")
    
        # Type check awardsCelebrated (expected int)
        if "awardsCelebrated" in props and props["awardsCelebrated"] is not None:
            if not isinstance(props["awardsCelebrated"], int):
                try:
                    # Attempt to convert
                    props["awardsCelebrated"] = int(props["awardsCelebrated"])
                except:
                    raise TypeError(f"Property awardsCelebrated must be of type int, got {type(props['awardsCelebrated']).__name__}")
    
        # Type check reunionDiscussions (expected int)
        if "reunionDiscussions" in props and props["reunionDiscussions"] is not None:
            if not isinstance(props["reunionDiscussions"], int):
                try:
                    # Attempt to convert
                    props["reunionDiscussions"] = int(props["reunionDiscussions"])
                except:
                    raise TypeError(f"Property reunionDiscussions must be of type int, got {type(props['reunionDiscussions']).__name__}")
    
        # Type check iconic_confrontations (expected str)
        if "iconic_confrontations" in props and props["iconic_confrontations"] is not None:
            if not isinstance(props["iconic_confrontations"], str):
                try:
                    # Attempt to convert
                    props["iconic_confrontations"] = str(props["iconic_confrontations"])
                except:
                    raise TypeError(f"Property iconic_confrontations must be of type str, got {type(props['iconic_confrontations']).__name__}")
    
        # Type check screen_fights (expected int)
        if "screen_fights" in props and props["screen_fights"] is not None:
            if not isinstance(props["screen_fights"], int):
                try:
                    # Attempt to convert
                    props["screen_fights"] = int(props["screen_fights"])
                except:
                    raise TypeError(f"Property screen_fights must be of type int, got {type(props['screen_fights']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="WORKED_WITH", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def admires(uuid=None, **props):
        """
        Find relationships of type ADMIRES matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check relationship (expected str)
        if "relationship" in props and props["relationship"] is not None:
            if not isinstance(props["relationship"], str):
                try:
                    # Attempt to convert
                    props["relationship"] = str(props["relationship"])
                except:
                    raise TypeError(f"Property relationship must be of type str, got {type(props['relationship']).__name__}")
    
        # Type check since (expected object)
        if "since" in props and props["since"] is not None:
            if not isinstance(props["since"], object):
                try:
                    # Attempt to convert
                    props["since"] = object(props["since"])
                except:
                    raise TypeError(f"Property since must be of type object, got {type(props['since']).__name__}")
    
        # Type check projects (expected int)
        if "projects" in props and props["projects"] is not None:
            if not isinstance(props["projects"], int):
                try:
                    # Attempt to convert
                    props["projects"] = int(props["projects"])
                except:
                    raise TypeError(f"Property projects must be of type int, got {type(props['projects']).__name__}")
    
        # Type check influencedWorks (expected object)
        if "influencedWorks" in props and props["influencedWorks"] is not None:
            if not isinstance(props["influencedWorks"], object):
                try:
                    # Attempt to convert
                    props["influencedWorks"] = object(props["influencedWorks"])
                except:
                    raise TypeError(f"Property influencedWorks must be of type object, got {type(props['influencedWorks']).__name__}")
    
        # Type check inspirationLevel (expected float)
        if "inspirationLevel" in props and props["inspirationLevel"] is not None:
            if not isinstance(props["inspirationLevel"], float):
                try:
                    # Attempt to convert
                    props["inspirationLevel"] = float(props["inspirationLevel"])
                except:
                    raise TypeError(f"Property inspirationLevel must be of type float, got {type(props['inspirationLevel']).__name__}")
    
        # Type check lastContact (expected object)
        if "lastContact" in props and props["lastContact"] is not None:
            if not isinstance(props["lastContact"], object):
                try:
                    # Attempt to convert
                    props["lastContact"] = object(props["lastContact"])
                except:
                    raise TypeError(f"Property lastContact must be of type object, got {type(props['lastContact']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="ADMIRES", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def inspired_by(uuid=None, **props):
        """
        Find relationships of type INSPIRED_BY matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check favouriteFilm (expected str)
        if "favouriteFilm" in props and props["favouriteFilm"] is not None:
            if not isinstance(props["favouriteFilm"], str):
                try:
                    # Attempt to convert
                    props["favouriteFilm"] = str(props["favouriteFilm"])
                except:
                    raise TypeError(f"Property favouriteFilm must be of type str, got {type(props['favouriteFilm']).__name__}")
    
        # Type check since (expected object)
        if "since" in props and props["since"] is not None:
            if not isinstance(props["since"], object):
                try:
                    # Attempt to convert
                    props["since"] = object(props["since"])
                except:
                    raise TypeError(f"Property since must be of type object, got {type(props['since']).__name__}")
    
        # Type check influencedWorks (expected object)
        if "influencedWorks" in props and props["influencedWorks"] is not None:
            if not isinstance(props["influencedWorks"], object):
                try:
                    # Attempt to convert
                    props["influencedWorks"] = object(props["influencedWorks"])
                except:
                    raise TypeError(f"Property influencedWorks must be of type object, got {type(props['influencedWorks']).__name__}")
    
        # Type check impactLevel (expected float)
        if "impactLevel" in props and props["impactLevel"] is not None:
            if not isinstance(props["impactLevel"], float):
                try:
                    # Attempt to convert
                    props["impactLevel"] = float(props["impactLevel"])
                except:
                    raise TypeError(f"Property impactLevel must be of type float, got {type(props['impactLevel']).__name__}")
    
        # Type check mentionedInInterviews (expected int)
        if "mentionedInInterviews" in props and props["mentionedInInterviews"] is not None:
            if not isinstance(props["mentionedInInterviews"], int):
                try:
                    # Attempt to convert
                    props["mentionedInInterviews"] = int(props["mentionedInInterviews"])
                except:
                    raise TypeError(f"Property mentionedInInterviews must be of type int, got {type(props['mentionedInInterviews']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="INSPIRED_BY", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def featured_in(uuid=None, **props):
        """
        Find relationships of type FEATURED_IN matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check contractDate (expected object)
        if "contractDate" in props and props["contractDate"] is not None:
            if not isinstance(props["contractDate"], object):
                try:
                    # Attempt to convert
                    props["contractDate"] = object(props["contractDate"])
                except:
                    raise TypeError(f"Property contractDate must be of type object, got {type(props['contractDate']).__name__}")
    
        # Type check screenTimeSeconds (expected int)
        if "screenTimeSeconds" in props and props["screenTimeSeconds"] is not None:
            if not isinstance(props["screenTimeSeconds"], int):
                try:
                    # Attempt to convert
                    props["screenTimeSeconds"] = int(props["screenTimeSeconds"])
                except:
                    raise TypeError(f"Property screenTimeSeconds must be of type int, got {type(props['screenTimeSeconds']).__name__}")
    
        # Type check firstAppearance (expected object)
        if "firstAppearance" in props and props["firstAppearance"] is not None:
            if not isinstance(props["firstAppearance"], object):
                try:
                    # Attempt to convert
                    props["firstAppearance"] = object(props["firstAppearance"])
                except:
                    raise TypeError(f"Property firstAppearance must be of type object, got {type(props['firstAppearance']).__name__}")
    
        # Type check isProminentPlacement (expected bool)
        if "isProminentPlacement" in props and props["isProminentPlacement"] is not None:
            if not isinstance(props["isProminentPlacement"], bool):
                try:
                    # Attempt to convert
                    props["isProminentPlacement"] = bool(props["isProminentPlacement"])
                except:
                    raise TypeError(f"Property isProminentPlacement must be of type bool, got {type(props['isProminentPlacement']).__name__}")
    
        # Type check lastAppearance (expected object)
        if "lastAppearance" in props and props["lastAppearance"] is not None:
            if not isinstance(props["lastAppearance"], object):
                try:
                    # Attempt to convert
                    props["lastAppearance"] = object(props["lastAppearance"])
                except:
                    raise TypeError(f"Property lastAppearance must be of type object, got {type(props['lastAppearance']).__name__}")
    
        # Type check sceneCount (expected int)
        if "sceneCount" in props and props["sceneCount"] is not None:
            if not isinstance(props["sceneCount"], int):
                try:
                    # Attempt to convert
                    props["sceneCount"] = int(props["sceneCount"])
                except:
                    raise TypeError(f"Property sceneCount must be of type int, got {type(props['sceneCount']).__name__}")
    
        # Type check characterCount (expected int)
        if "characterCount" in props and props["characterCount"] is not None:
            if not isinstance(props["characterCount"], int):
                try:
                    # Attempt to convert
                    props["characterCount"] = int(props["characterCount"])
                except:
                    raise TypeError(f"Property characterCount must be of type int, got {type(props['characterCount']).__name__}")
    
        # Type check designAwards (expected int)
        if "designAwards" in props and props["designAwards"] is not None:
            if not isinstance(props["designAwards"], int):
                try:
                    # Attempt to convert
                    props["designAwards"] = int(props["designAwards"])
                except:
                    raise TypeError(f"Property designAwards must be of type int, got {type(props['designAwards']).__name__}")
    
        # Type check symbolicElements (expected object)
        if "symbolicElements" in props and props["symbolicElements"] is not None:
            if not isinstance(props["symbolicElements"], object):
                try:
                    # Attempt to convert
                    props["symbolicElements"] = object(props["symbolicElements"])
                except:
                    raise TypeError(f"Property symbolicElements must be of type object, got {type(props['symbolicElements']).__name__}")
    
        # Type check characterClassIndication (expected object)
        if "characterClassIndication" in props and props["characterClassIndication"] is not None:
            if not isinstance(props["characterClassIndication"], object):
                try:
                    # Attempt to convert
                    props["characterClassIndication"] = object(props["characterClassIndication"])
                except:
                    raise TypeError(f"Property characterClassIndication must be of type object, got {type(props['characterClassIndication']).__name__}")
    
        # Type check costumesPerCharacter (expected object)
        if "costumesPerCharacter" in props and props["costumesPerCharacter"] is not None:
            if not isinstance(props["costumesPerCharacter"], object):
                try:
                    # Attempt to convert
                    props["costumesPerCharacter"] = object(props["costumesPerCharacter"])
                except:
                    raise TypeError(f"Property costumesPerCharacter must be of type object, got {type(props['costumesPerCharacter']).__name__}")
    
        # Type check elementPurpose (expected object)
        if "elementPurpose" in props and props["elementPurpose"] is not None:
            if not isinstance(props["elementPurpose"], object):
                try:
                    # Attempt to convert
                    props["elementPurpose"] = object(props["elementPurpose"])
                except:
                    raise TypeError(f"Property elementPurpose must be of type object, got {type(props['elementPurpose']).__name__}")
    
        # Type check original_cost (expected int)
        if "original_cost" in props and props["original_cost"] is not None:
            if not isinstance(props["original_cost"], int):
                try:
                    # Attempt to convert
                    props["original_cost"] = int(props["original_cost"])
                except:
                    raise TypeError(f"Property original_cost must be of type int, got {type(props['original_cost']).__name__}")
    
        # Type check hammer_price (expected int)
        if "hammer_price" in props and props["hammer_price"] is not None:
            if not isinstance(props["hammer_price"], int):
                try:
                    # Attempt to convert
                    props["hammer_price"] = int(props["hammer_price"])
                except:
                    raise TypeError(f"Property hammer_price must be of type int, got {type(props['hammer_price']).__name__}")
    
        # Type check auction_date (expected object)
        if "auction_date" in props and props["auction_date"] is not None:
            if not isinstance(props["auction_date"], object):
                try:
                    # Attempt to convert
                    props["auction_date"] = object(props["auction_date"])
                except:
                    raise TypeError(f"Property auction_date must be of type object, got {type(props['auction_date']).__name__}")
    
        # Type check exhibition_history (expected object)
        if "exhibition_history" in props and props["exhibition_history"] is not None:
            if not isinstance(props["exhibition_history"], object):
                try:
                    # Attempt to convert
                    props["exhibition_history"] = object(props["exhibition_history"])
                except:
                    raise TypeError(f"Property exhibition_history must be of type object, got {type(props['exhibition_history']).__name__}")
    
        # Type check competing_bidders (expected int)
        if "competing_bidders" in props and props["competing_bidders"] is not None:
            if not isinstance(props["competing_bidders"], int):
                try:
                    # Attempt to convert
                    props["competing_bidders"] = int(props["competing_bidders"])
                except:
                    raise TypeError(f"Property competing_bidders must be of type int, got {type(props['competing_bidders']).__name__}")
    
        # Type check restoration (expected str)
        if "restoration" in props and props["restoration"] is not None:
            if not isinstance(props["restoration"], str):
                try:
                    # Attempt to convert
                    props["restoration"] = str(props["restoration"])
                except:
                    raise TypeError(f"Property restoration must be of type str, got {type(props['restoration']).__name__}")
    
        # Type check significance (expected str)
        if "significance" in props and props["significance"] is not None:
            if not isinstance(props["significance"], str):
                try:
                    # Attempt to convert
                    props["significance"] = str(props["significance"])
                except:
                    raise TypeError(f"Property significance must be of type str, got {type(props['significance']).__name__}")
    
        # Type check total_price (expected int)
        if "total_price" in props and props["total_price"] is not None:
            if not isinstance(props["total_price"], int):
                try:
                    # Attempt to convert
                    props["total_price"] = int(props["total_price"])
                except:
                    raise TypeError(f"Property total_price must be of type int, got {type(props['total_price']).__name__}")
    
        # Type check auction_house (expected str)
        if "auction_house" in props and props["auction_house"] is not None:
            if not isinstance(props["auction_house"], str):
                try:
                    # Attempt to convert
                    props["auction_house"] = str(props["auction_house"])
                except:
                    raise TypeError(f"Property auction_house must be of type str, got {type(props['auction_house']).__name__}")
    
        # Type check scenes (expected object)
        if "scenes" in props and props["scenes"] is not None:
            if not isinstance(props["scenes"], object):
                try:
                    # Attempt to convert
                    props["scenes"] = object(props["scenes"])
                except:
                    raise TypeError(f"Property scenes must be of type object, got {type(props['scenes']).__name__}")
    
        # Type check screen_minutes (expected int)
        if "screen_minutes" in props and props["screen_minutes"] is not None:
            if not isinstance(props["screen_minutes"], int):
                try:
                    # Attempt to convert
                    props["screen_minutes"] = int(props["screen_minutes"])
                except:
                    raise TypeError(f"Property screen_minutes must be of type int, got {type(props['screen_minutes']).__name__}")
    
        # Type check cultural_significance (expected str)
        if "cultural_significance" in props and props["cultural_significance"] is not None:
            if not isinstance(props["cultural_significance"], str):
                try:
                    # Attempt to convert
                    props["cultural_significance"] = str(props["cultural_significance"])
                except:
                    raise TypeError(f"Property cultural_significance must be of type str, got {type(props['cultural_significance']).__name__}")
    
        # Type check buyer_premium (expected int)
        if "buyer_premium" in props and props["buyer_premium"] is not None:
            if not isinstance(props["buyer_premium"], int):
                try:
                    # Attempt to convert
                    props["buyer_premium"] = int(props["buyer_premium"])
                except:
                    raise TypeError(f"Property buyer_premium must be of type int, got {type(props['buyer_premium']).__name__}")
    
        # Type check provenance (expected str)
        if "provenance" in props and props["provenance"] is not None:
            if not isinstance(props["provenance"], str):
                try:
                    # Attempt to convert
                    props["provenance"] = str(props["provenance"])
                except:
                    raise TypeError(f"Property provenance must be of type str, got {type(props['provenance']).__name__}")
    
        # Type check exhibition_dates (expected list)
        if "exhibition_dates" in props and props["exhibition_dates"] is not None:
            if not isinstance(props["exhibition_dates"], list):
                try:
                    # Attempt to convert
                    props["exhibition_dates"] = list(props["exhibition_dates"])
                except:
                    raise TypeError(f"Property exhibition_dates must be of type list, got {type(props['exhibition_dates']).__name__}")
    
        # Type check auction_lot (expected int)
        if "auction_lot" in props and props["auction_lot"] is not None:
            if not isinstance(props["auction_lot"], int):
                try:
                    # Attempt to convert
                    props["auction_lot"] = int(props["auction_lot"])
                except:
                    raise TypeError(f"Property auction_lot must be of type int, got {type(props['auction_lot']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="FEATURED_IN", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def used_in(uuid=None, **props):
        """
        Find relationships of type USED_IN matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check firstAppearance (expected object)
        if "firstAppearance" in props and props["firstAppearance"] is not None:
            if not isinstance(props["firstAppearance"], object):
                try:
                    # Attempt to convert
                    props["firstAppearance"] = object(props["firstAppearance"])
                except:
                    raise TypeError(f"Property firstAppearance must be of type object, got {type(props['firstAppearance']).__name__}")
    
        # Type check significance (expected str)
        if "significance" in props and props["significance"] is not None:
            if not isinstance(props["significance"], str):
                try:
                    # Attempt to convert
                    props["significance"] = str(props["significance"])
                except:
                    raise TypeError(f"Property significance must be of type str, got {type(props['significance']).__name__}")
    
        # Type check isCloseup (expected bool)
        if "isCloseup" in props and props["isCloseup"] is not None:
            if not isinstance(props["isCloseup"], bool):
                try:
                    # Attempt to convert
                    props["isCloseup"] = bool(props["isCloseup"])
                except:
                    raise TypeError(f"Property isCloseup must be of type bool, got {type(props['isCloseup']).__name__}")
    
        # Type check lastAppearance (expected object)
        if "lastAppearance" in props and props["lastAppearance"] is not None:
            if not isinstance(props["lastAppearance"], object):
                try:
                    # Attempt to convert
                    props["lastAppearance"] = object(props["lastAppearance"])
                except:
                    raise TypeError(f"Property lastAppearance must be of type object, got {type(props['lastAppearance']).__name__}")
    
        # Type check sceneCount (expected int)
        if "sceneCount" in props and props["sceneCount"] is not None:
            if not isinstance(props["sceneCount"], int):
                try:
                    # Attempt to convert
                    props["sceneCount"] = int(props["sceneCount"])
                except:
                    raise TypeError(f"Property sceneCount must be of type int, got {type(props['sceneCount']).__name__}")
    
        # Type check scenes (expected object)
        if "scenes" in props and props["scenes"] is not None:
            if not isinstance(props["scenes"], object):
                try:
                    # Attempt to convert
                    props["scenes"] = object(props["scenes"])
                except:
                    raise TypeError(f"Property scenes must be of type object, got {type(props['scenes']).__name__}")
    
        # Type check successScore (expected float)
        if "successScore" in props and props["successScore"] is not None:
            if not isinstance(props["successScore"], float):
                try:
                    # Attempt to convert
                    props["successScore"] = float(props["successScore"])
                except:
                    raise TypeError(f"Property successScore must be of type float, got {type(props['successScore']).__name__}")
    
        # Type check industryInfluence (expected str)
        if "industryInfluence" in props and props["industryInfluence"] is not None:
            if not isinstance(props["industryInfluence"], str):
                try:
                    # Attempt to convert
                    props["industryInfluence"] = str(props["industryInfluence"])
                except:
                    raise TypeError(f"Property industryInfluence must be of type str, got {type(props['industryInfluence']).__name__}")
    
        # Type check fullIntegrationDate (expected object)
        if "fullIntegrationDate" in props and props["fullIntegrationDate"] is not None:
            if not isinstance(props["fullIntegrationDate"], object):
                try:
                    # Attempt to convert
                    props["fullIntegrationDate"] = object(props["fullIntegrationDate"])
                except:
                    raise TypeError(f"Property fullIntegrationDate must be of type object, got {type(props['fullIntegrationDate']).__name__}")
    
        # Type check developmentPhases (expected int)
        if "developmentPhases" in props and props["developmentPhases"] is not None:
            if not isinstance(props["developmentPhases"], int):
                try:
                    # Attempt to convert
                    props["developmentPhases"] = int(props["developmentPhases"])
                except:
                    raise TypeError(f"Property developmentPhases must be of type int, got {type(props['developmentPhases']).__name__}")
    
        # Type check testingIterations (expected int)
        if "testingIterations" in props and props["testingIterations"] is not None:
            if not isinstance(props["testingIterations"], int):
                try:
                    # Attempt to convert
                    props["testingIterations"] = int(props["testingIterations"])
                except:
                    raise TypeError(f"Property testingIterations must be of type int, got {type(props['testingIterations']).__name__}")
    
        # Type check subsequentAdopters (expected int)
        if "subsequentAdopters" in props and props["subsequentAdopters"] is not None:
            if not isinstance(props["subsequentAdopters"], int):
                try:
                    # Attempt to convert
                    props["subsequentAdopters"] = int(props["subsequentAdopters"])
                except:
                    raise TypeError(f"Property subsequentAdopters must be of type int, got {type(props['subsequentAdopters']).__name__}")
    
        # Type check successMetric (expected str)
        if "successMetric" in props and props["successMetric"] is not None:
            if not isinstance(props["successMetric"], str):
                try:
                    # Attempt to convert
                    props["successMetric"] = str(props["successMetric"])
                except:
                    raise TypeError(f"Property successMetric must be of type str, got {type(props['successMetric']).__name__}")
    
        # Type check implementationDate (expected object)
        if "implementationDate" in props and props["implementationDate"] is not None:
            if not isinstance(props["implementationDate"], object):
                try:
                    # Attempt to convert
                    props["implementationDate"] = object(props["implementationDate"])
                except:
                    raise TypeError(f"Property implementationDate must be of type object, got {type(props['implementationDate']).__name__}")
    
        # Type check operator (expected str)
        if "operator" in props and props["operator"] is not None:
            if not isinstance(props["operator"], str):
                try:
                    # Attempt to convert
                    props["operator"] = str(props["operator"])
                except:
                    raise TypeError(f"Property operator must be of type str, got {type(props['operator']).__name__}")
    
        # Type check techniqueInfluence (expected float)
        if "techniqueInfluence" in props and props["techniqueInfluence"] is not None:
            if not isinstance(props["techniqueInfluence"], float):
                try:
                    # Attempt to convert
                    props["techniqueInfluence"] = float(props["techniqueInfluence"])
                except:
                    raise TypeError(f"Property techniqueInfluence must be of type float, got {type(props['techniqueInfluence']).__name__}")
    
        # Type check setupTime (expected object)
        if "setupTime" in props and props["setupTime"] is not None:
            if not isinstance(props["setupTime"], object):
                try:
                    # Attempt to convert
                    props["setupTime"] = object(props["setupTime"])
                except:
                    raise TypeError(f"Property setupTime must be of type object, got {type(props['setupTime']).__name__}")
    
        # Type check innovationSuccess (expected object)
        if "innovationSuccess" in props and props["innovationSuccess"] is not None:
            if not isinstance(props["innovationSuccess"], object):
                try:
                    # Attempt to convert
                    props["innovationSuccess"] = object(props["innovationSuccess"])
                except:
                    raise TypeError(f"Property innovationSuccess must be of type object, got {type(props['innovationSuccess']).__name__}")
    
        # Type check signatureShots (expected object)
        if "signatureShots" in props and props["signatureShots"] is not None:
            if not isinstance(props["signatureShots"], object):
                try:
                    # Attempt to convert
                    props["signatureShots"] = object(props["signatureShots"])
                except:
                    raise TypeError(f"Property signatureShots must be of type object, got {type(props['signatureShots']).__name__}")
    
        # Type check technicalInnovations (expected object)
        if "technicalInnovations" in props and props["technicalInnovations"] is not None:
            if not isinstance(props["technicalInnovations"], object):
                try:
                    # Attempt to convert
                    props["technicalInnovations"] = object(props["technicalInnovations"])
                except:
                    raise TypeError(f"Property technicalInnovations must be of type object, got {type(props['technicalInnovations']).__name__}")
    
        # Type check maintenanceEvents (expected int)
        if "maintenanceEvents" in props and props["maintenanceEvents"] is not None:
            if not isinstance(props["maintenanceEvents"], int):
                try:
                    # Attempt to convert
                    props["maintenanceEvents"] = int(props["maintenanceEvents"])
                except:
                    raise TypeError(f"Property maintenanceEvents must be of type int, got {type(props['maintenanceEvents']).__name__}")
    
        # Type check unitCount (expected int)
        if "unitCount" in props and props["unitCount"] is not None:
            if not isinstance(props["unitCount"], int):
                try:
                    # Attempt to convert
                    props["unitCount"] = int(props["unitCount"])
                except:
                    raise TypeError(f"Property unitCount must be of type int, got {type(props['unitCount']).__name__}")
    
        # Type check operationalDays (expected int)
        if "operationalDays" in props and props["operationalDays"] is not None:
            if not isinstance(props["operationalDays"], int):
                try:
                    # Attempt to convert
                    props["operationalDays"] = int(props["operationalDays"])
                except:
                    raise TypeError(f"Property operationalDays must be of type int, got {type(props['operationalDays']).__name__}")
    
        # Type check historicalAccuracy (expected str)
        if "historicalAccuracy" in props and props["historicalAccuracy"] is not None:
            if not isinstance(props["historicalAccuracy"], str):
                try:
                    # Attempt to convert
                    props["historicalAccuracy"] = str(props["historicalAccuracy"])
                except:
                    raise TypeError(f"Property historicalAccuracy must be of type str, got {type(props['historicalAccuracy']).__name__}")
    
        # Type check propOrigin (expected str)
        if "propOrigin" in props and props["propOrigin"] is not None:
            if not isinstance(props["propOrigin"], str):
                try:
                    # Attempt to convert
                    props["propOrigin"] = str(props["propOrigin"])
                except:
                    raise TypeError(f"Property propOrigin must be of type str, got {type(props['propOrigin']).__name__}")
    
        # Type check culturalImpact (expected str)
        if "culturalImpact" in props and props["culturalImpact"] is not None:
            if not isinstance(props["culturalImpact"], str):
                try:
                    # Attempt to convert
                    props["culturalImpact"] = str(props["culturalImpact"])
                except:
                    raise TypeError(f"Property culturalImpact must be of type str, got {type(props['culturalImpact']).__name__}")
    
        # Type check isImprovisedElement (expected bool)
        if "isImprovisedElement" in props and props["isImprovisedElement"] is not None:
            if not isinstance(props["isImprovisedElement"], bool):
                try:
                    # Attempt to convert
                    props["isImprovisedElement"] = bool(props["isImprovisedElement"])
                except:
                    raise TypeError(f"Property isImprovisedElement must be of type bool, got {type(props['isImprovisedElement']).__name__}")
    
        # Type check directorNote (expected str)
        if "directorNote" in props and props["directorNote"] is not None:
            if not isinstance(props["directorNote"], str):
                try:
                    # Attempt to convert
                    props["directorNote"] = str(props["directorNote"])
                except:
                    raise TypeError(f"Property directorNote must be of type str, got {type(props['directorNote']).__name__}")
    
        # Type check symbolism (expected str)
        if "symbolism" in props and props["symbolism"] is not None:
            if not isinstance(props["symbolism"], str):
                try:
                    # Attempt to convert
                    props["symbolism"] = str(props["symbolism"])
                except:
                    raise TypeError(f"Property symbolism must be of type str, got {type(props['symbolism']).__name__}")
    
        # Type check merchandisingValue (expected str)
        if "merchandisingValue" in props and props["merchandisingValue"] is not None:
            if not isinstance(props["merchandisingValue"], str):
                try:
                    # Attempt to convert
                    props["merchandisingValue"] = str(props["merchandisingValue"])
                except:
                    raise TypeError(f"Property merchandisingValue must be of type str, got {type(props['merchandisingValue']).__name__}")
    
        # Type check propContinuity (expected str)
        if "propContinuity" in props and props["propContinuity"] is not None:
            if not isinstance(props["propContinuity"], str):
                try:
                    # Attempt to convert
                    props["propContinuity"] = str(props["propContinuity"])
                except:
                    raise TypeError(f"Property propContinuity must be of type str, got {type(props['propContinuity']).__name__}")
    
        # Type check quotableConnection (expected str)
        if "quotableConnection" in props and props["quotableConnection"] is not None:
            if not isinstance(props["quotableConnection"], str):
                try:
                    # Attempt to convert
                    props["quotableConnection"] = str(props["quotableConnection"])
                except:
                    raise TypeError(f"Property quotableConnection must be of type str, got {type(props['quotableConnection']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="USED_IN", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def composed_for(uuid=None, **props):
        """
        Find relationships of type COMPOSED_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check wonAwards (expected object)
        if "wonAwards" in props and props["wonAwards"] is not None:
            if not isinstance(props["wonAwards"], object):
                try:
                    # Attempt to convert
                    props["wonAwards"] = object(props["wonAwards"])
                except:
                    raise TypeError(f"Property wonAwards must be of type object, got {type(props['wonAwards']).__name__}")
    
        # Type check youtubeViews (expected int)
        if "youtubeViews" in props and props["youtubeViews"] is not None:
            if not isinstance(props["youtubeViews"], int):
                try:
                    # Attempt to convert
                    props["youtubeViews"] = int(props["youtubeViews"])
                except:
                    raise TypeError(f"Property youtubeViews must be of type int, got {type(props['youtubeViews']).__name__}")
    
        # Type check contractDate (expected object)
        if "contractDate" in props and props["contractDate"] is not None:
            if not isinstance(props["contractDate"], object):
                try:
                    # Attempt to convert
                    props["contractDate"] = object(props["contractDate"])
                except:
                    raise TypeError(f"Property contractDate must be of type object, got {type(props['contractDate']).__name__}")
    
        # Type check completion (expected object)
        if "completion" in props and props["completion"] is not None:
            if not isinstance(props["completion"], object):
                try:
                    # Attempt to convert
                    props["completion"] = object(props["completion"])
                except:
                    raise TypeError(f"Property completion must be of type object, got {type(props['completion']).__name__}")
    
        # Type check spotifyStreams (expected int)
        if "spotifyStreams" in props and props["spotifyStreams"] is not None:
            if not isinstance(props["spotifyStreams"], int):
                try:
                    # Attempt to convert
                    props["spotifyStreams"] = int(props["spotifyStreams"])
                except:
                    raise TypeError(f"Property spotifyStreams must be of type int, got {type(props['spotifyStreams']).__name__}")
    
        # Type check nominatedAwards (expected object)
        if "nominatedAwards" in props and props["nominatedAwards"] is not None:
            if not isinstance(props["nominatedAwards"], object):
                try:
                    # Attempt to convert
                    props["nominatedAwards"] = object(props["nominatedAwards"])
                except:
                    raise TypeError(f"Property nominatedAwards must be of type object, got {type(props['nominatedAwards']).__name__}")
    
        # Type check iconicSongs (expected object)
        if "iconicSongs" in props and props["iconicSongs"] is not None:
            if not isinstance(props["iconicSongs"], object):
                try:
                    # Attempt to convert
                    props["iconicSongs"] = object(props["iconicSongs"])
                except:
                    raise TypeError(f"Property iconicSongs must be of type object, got {type(props['iconicSongs']).__name__}")
    
        # Type check platinumRecords (expected int)
        if "platinumRecords" in props and props["platinumRecords"] is not None:
            if not isinstance(props["platinumRecords"], int):
                try:
                    # Attempt to convert
                    props["platinumRecords"] = int(props["platinumRecords"])
                except:
                    raise TypeError(f"Property platinumRecords must be of type int, got {type(props['platinumRecords']).__name__}")
    
        # Type check goldRecords (expected int)
        if "goldRecords" in props and props["goldRecords"] is not None:
            if not isinstance(props["goldRecords"], int):
                try:
                    # Attempt to convert
                    props["goldRecords"] = int(props["goldRecords"])
                except:
                    raise TypeError(f"Property goldRecords must be of type int, got {type(props['goldRecords']).__name__}")
    
        # Type check recordingDays (expected int)
        if "recordingDays" in props and props["recordingDays"] is not None:
            if not isinstance(props["recordingDays"], int):
                try:
                    # Attempt to convert
                    props["recordingDays"] = int(props["recordingDays"])
                except:
                    raise TypeError(f"Property recordingDays must be of type int, got {type(props['recordingDays']).__name__}")
    
        # Type check culturalInfluence (expected str)
        if "culturalInfluence" in props and props["culturalInfluence"] is not None:
            if not isinstance(props["culturalInfluence"], str):
                try:
                    # Attempt to convert
                    props["culturalInfluence"] = str(props["culturalInfluence"])
                except:
                    raise TypeError(f"Property culturalInfluence must be of type str, got {type(props['culturalInfluence']).__name__}")
    
        # Type check iconicTracks (expected object)
        if "iconicTracks" in props and props["iconicTracks"] is not None:
            if not isinstance(props["iconicTracks"], object):
                try:
                    # Attempt to convert
                    props["iconicTracks"] = object(props["iconicTracks"])
                except:
                    raise TypeError(f"Property iconicTracks must be of type object, got {type(props['iconicTracks']).__name__}")
    
        # Type check stringInstrumentCount (expected int)
        if "stringInstrumentCount" in props and props["stringInstrumentCount"] is not None:
            if not isinstance(props["stringInstrumentCount"], int):
                try:
                    # Attempt to convert
                    props["stringInstrumentCount"] = int(props["stringInstrumentCount"])
                except:
                    raise TypeError(f"Property stringInstrumentCount must be of type int, got {type(props['stringInstrumentCount']).__name__}")
    
        # Type check vocalistFeatured (expected str)
        if "vocalistFeatured" in props and props["vocalistFeatured"] is not None:
            if not isinstance(props["vocalistFeatured"], str):
                try:
                    # Attempt to convert
                    props["vocalistFeatured"] = str(props["vocalistFeatured"])
                except:
                    raise TypeError(f"Property vocalistFeatured must be of type str, got {type(props['vocalistFeatured']).__name__}")
    
        # Type check diamondCertification (expected bool)
        if "diamondCertification" in props and props["diamondCertification"] is not None:
            if not isinstance(props["diamondCertification"], bool):
                try:
                    # Attempt to convert
                    props["diamondCertification"] = bool(props["diamondCertification"])
                except:
                    raise TypeError(f"Property diamondCertification must be of type bool, got {type(props['diamondCertification']).__name__}")
    
        # Type check orchestraSize (expected int)
        if "orchestraSize" in props and props["orchestraSize"] is not None:
            if not isinstance(props["orchestraSize"], int):
                try:
                    # Attempt to convert
                    props["orchestraSize"] = int(props["orchestraSize"])
                except:
                    raise TypeError(f"Property orchestraSize must be of type int, got {type(props['orchestraSize']).__name__}")
    
        # Type check culturalResonance (expected str)
        if "culturalResonance" in props and props["culturalResonance"] is not None:
            if not isinstance(props["culturalResonance"], str):
                try:
                    # Attempt to convert
                    props["culturalResonance"] = str(props["culturalResonance"])
                except:
                    raise TypeError(f"Property culturalResonance must be of type str, got {type(props['culturalResonance']).__name__}")
    
        # Type check disqualificationReason (expected str)
        if "disqualificationReason" in props and props["disqualificationReason"] is not None:
            if not isinstance(props["disqualificationReason"], str):
                try:
                    # Attempt to convert
                    props["disqualificationReason"] = str(props["disqualificationReason"])
                except:
                    raise TypeError(f"Property disqualificationReason must be of type str, got {type(props['disqualificationReason']).__name__}")
    
        # Type check iconicThemes (expected object)
        if "iconicThemes" in props and props["iconicThemes"] is not None:
            if not isinstance(props["iconicThemes"], object):
                try:
                    # Attempt to convert
                    props["iconicThemes"] = object(props["iconicThemes"])
                except:
                    raise TypeError(f"Property iconicThemes must be of type object, got {type(props['iconicThemes']).__name__}")
    
        # Type check ethnicInfluences (expected str)
        if "ethnicInfluences" in props and props["ethnicInfluences"] is not None:
            if not isinstance(props["ethnicInfluences"], str):
                try:
                    # Attempt to convert
                    props["ethnicInfluences"] = str(props["ethnicInfluences"])
                except:
                    raise TypeError(f"Property ethnicInfluences must be of type str, got {type(props['ethnicInfluences']).__name__}")
    
        # Type check emotionalImpact (expected float)
        if "emotionalImpact" in props and props["emotionalImpact"] is not None:
            if not isinstance(props["emotionalImpact"], float):
                try:
                    # Attempt to convert
                    props["emotionalImpact"] = float(props["emotionalImpact"])
                except:
                    raise TypeError(f"Property emotionalImpact must be of type float, got {type(props['emotionalImpact']).__name__}")
    
        # Type check directorCollaboration (expected str)
        if "directorCollaboration" in props and props["directorCollaboration"] is not None:
            if not isinstance(props["directorCollaboration"], str):
                try:
                    # Attempt to convert
                    props["directorCollaboration"] = str(props["directorCollaboration"])
                except:
                    raise TypeError(f"Property directorCollaboration must be of type str, got {type(props['directorCollaboration']).__name__}")
    
        # Type check recordingSessions (expected int)
        if "recordingSessions" in props and props["recordingSessions"] is not None:
            if not isinstance(props["recordingSessions"], int):
                try:
                    # Attempt to convert
                    props["recordingSessions"] = int(props["recordingSessions"])
                except:
                    raise TypeError(f"Property recordingSessions must be of type int, got {type(props['recordingSessions']).__name__}")
    
        # Type check thematicElements (expected object)
        if "thematicElements" in props and props["thematicElements"] is not None:
            if not isinstance(props["thematicElements"], object):
                try:
                    # Attempt to convert
                    props["thematicElements"] = object(props["thematicElements"])
                except:
                    raise TypeError(f"Property thematicElements must be of type object, got {type(props['thematicElements']).__name__}")
    
        # Type check mainInstrumentation (expected object)
        if "mainInstrumentation" in props and props["mainInstrumentation"] is not None:
            if not isinstance(props["mainInstrumentation"], object):
                try:
                    # Attempt to convert
                    props["mainInstrumentation"] = object(props["mainInstrumentation"])
                except:
                    raise TypeError(f"Property mainInstrumentation must be of type object, got {type(props['mainInstrumentation']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="COMPOSED_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def filmed_at(uuid=None, **props):
        """
        Find relationships of type FILMED_AT matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check characterPresent (expected object)
        if "characterPresent" in props and props["characterPresent"] is not None:
            if not isinstance(props["characterPresent"], object):
                try:
                    # Attempt to convert
                    props["characterPresent"] = object(props["characterPresent"])
                except:
                    raise TypeError(f"Property characterPresent must be of type object, got {type(props['characterPresent']).__name__}")
    
        # Type check totalDays (expected int)
        if "totalDays" in props and props["totalDays"] is not None:
            if not isinstance(props["totalDays"], int):
                try:
                    # Attempt to convert
                    props["totalDays"] = int(props["totalDays"])
                except:
                    raise TypeError(f"Property totalDays must be of type int, got {type(props['totalDays']).__name__}")
    
        # Type check logisticsCost (expected int)
        if "logisticsCost" in props and props["logisticsCost"] is not None:
            if not isinstance(props["logisticsCost"], int):
                try:
                    # Attempt to convert
                    props["logisticsCost"] = int(props["logisticsCost"])
                except:
                    raise TypeError(f"Property logisticsCost must be of type int, got {type(props['logisticsCost']).__name__}")
    
        # Type check crewSize (expected int)
        if "crewSize" in props and props["crewSize"] is not None:
            if not isinstance(props["crewSize"], int):
                try:
                    # Attempt to convert
                    props["crewSize"] = int(props["crewSize"])
                except:
                    raise TypeError(f"Property crewSize must be of type int, got {type(props['crewSize']).__name__}")
    
        # Type check endDate (expected object)
        if "endDate" in props and props["endDate"] is not None:
            if not isinstance(props["endDate"], object):
                try:
                    # Attempt to convert
                    props["endDate"] = object(props["endDate"])
                except:
                    raise TypeError(f"Property endDate must be of type object, got {type(props['endDate']).__name__}")
    
        # Type check startDate (expected object)
        if "startDate" in props and props["startDate"] is not None:
            if not isinstance(props["startDate"], object):
                try:
                    # Attempt to convert
                    props["startDate"] = object(props["startDate"])
                except:
                    raise TypeError(f"Property startDate must be of type object, got {type(props['startDate']).__name__}")
    
        # Type check sceneCount (expected int)
        if "sceneCount" in props and props["sceneCount"] is not None:
            if not isinstance(props["sceneCount"], int):
                try:
                    # Attempt to convert
                    props["sceneCount"] = int(props["sceneCount"])
                except:
                    raise TypeError(f"Property sceneCount must be of type int, got {type(props['sceneCount']).__name__}")
    
        # Type check weatherDelayDays (expected int)
        if "weatherDelayDays" in props and props["weatherDelayDays"] is not None:
            if not isinstance(props["weatherDelayDays"], int):
                try:
                    # Attempt to convert
                    props["weatherDelayDays"] = int(props["weatherDelayDays"])
                except:
                    raise TypeError(f"Property weatherDelayDays must be of type int, got {type(props['weatherDelayDays']).__name__}")
    
        # Type check accommodationCost (expected int)
        if "accommodationCost" in props and props["accommodationCost"] is not None:
            if not isinstance(props["accommodationCost"], int):
                try:
                    # Attempt to convert
                    props["accommodationCost"] = int(props["accommodationCost"])
                except:
                    raise TypeError(f"Property accommodationCost must be of type int, got {type(props['accommodationCost']).__name__}")
    
        # Type check touristSiteToday (expected bool)
        if "touristSiteToday" in props and props["touristSiteToday"] is not None:
            if not isinstance(props["touristSiteToday"], bool):
                try:
                    # Attempt to convert
                    props["touristSiteToday"] = bool(props["touristSiteToday"])
                except:
                    raise TypeError(f"Property touristSiteToday must be of type bool, got {type(props['touristSiteToday']).__name__}")
    
        # Type check setsBulit (expected int)
        if "setsBulit" in props and props["setsBulit"] is not None:
            if not isinstance(props["setsBulit"], int):
                try:
                    # Attempt to convert
                    props["setsBulit"] = int(props["setsBulit"])
                except:
                    raise TypeError(f"Property setsBulit must be of type int, got {type(props['setsBulit']).__name__}")
    
        # Type check setPreservationStatus (expected str)
        if "setPreservationStatus" in props and props["setPreservationStatus"] is not None:
            if not isinstance(props["setPreservationStatus"], str):
                try:
                    # Attempt to convert
                    props["setPreservationStatus"] = str(props["setPreservationStatus"])
                except:
                    raise TypeError(f"Property setPreservationStatus must be of type str, got {type(props['setPreservationStatus']).__name__}")
    
        # Type check touristVisitsAnnually (expected int)
        if "touristVisitsAnnually" in props and props["touristVisitsAnnually"] is not None:
            if not isinstance(props["touristVisitsAnnually"], int):
                try:
                    # Attempt to convert
                    props["touristVisitsAnnually"] = int(props["touristVisitsAnnually"])
                except:
                    raise TypeError(f"Property touristVisitsAnnually must be of type int, got {type(props['touristVisitsAnnually']).__name__}")
    
        # Type check iconicSet (expected str)
        if "iconicSet" in props and props["iconicSet"] is not None:
            if not isinstance(props["iconicSet"], str):
                try:
                    # Attempt to convert
                    props["iconicSet"] = str(props["iconicSet"])
                except:
                    raise TypeError(f"Property iconicSet must be of type str, got {type(props['iconicSet']).__name__}")
    
        # Type check specialRequirements (expected str)
        if "specialRequirements" in props and props["specialRequirements"] is not None:
            if not isinstance(props["specialRequirements"], str):
                try:
                    # Attempt to convert
                    props["specialRequirements"] = str(props["specialRequirements"])
                except:
                    raise TypeError(f"Property specialRequirements must be of type str, got {type(props['specialRequirements']).__name__}")
    
        # Type check setConstruction (expected str)
        if "setConstruction" in props and props["setConstruction"] is not None:
            if not isinstance(props["setConstruction"], str):
                try:
                    # Attempt to convert
                    props["setConstruction"] = str(props["setConstruction"])
                except:
                    raise TypeError(f"Property setConstruction must be of type str, got {type(props['setConstruction']).__name__}")
    
        # Type check waterTankGallons (expected int)
        if "waterTankGallons" in props and props["waterTankGallons"] is not None:
            if not isinstance(props["waterTankGallons"], int):
                try:
                    # Attempt to convert
                    props["waterTankGallons"] = int(props["waterTankGallons"])
                except:
                    raise TypeError(f"Property waterTankGallons must be of type int, got {type(props['waterTankGallons']).__name__}")
    
        # Type check buildingsUsed (expected object)
        if "buildingsUsed" in props and props["buildingsUsed"] is not None:
            if not isinstance(props["buildingsUsed"], object):
                try:
                    # Attempt to convert
                    props["buildingsUsed"] = object(props["buildingsUsed"])
                except:
                    raise TypeError(f"Property buildingsUsed must be of type object, got {type(props['buildingsUsed']).__name__}")
    
        # Type check helicopterShots (expected int)
        if "helicopterShots" in props and props["helicopterShots"] is not None:
            if not isinstance(props["helicopterShots"], int):
                try:
                    # Attempt to convert
                    props["helicopterShots"] = int(props["helicopterShots"])
                except:
                    raise TypeError(f"Property helicopterShots must be of type int, got {type(props['helicopterShots']).__name__}")
    
        # Type check streetClosures (expected int)
        if "streetClosures" in props and props["streetClosures"] is not None:
            if not isinstance(props["streetClosures"], int):
                try:
                    # Attempt to convert
                    props["streetClosures"] = int(props["streetClosures"])
                except:
                    raise TypeError(f"Property streetClosures must be of type int, got {type(props['streetClosures']).__name__}")
    
        # Type check permitDifficulties (expected str)
        if "permitDifficulties" in props and props["permitDifficulties"] is not None:
            if not isinstance(props["permitDifficulties"], str):
                try:
                    # Attempt to convert
                    props["permitDifficulties"] = str(props["permitDifficulties"])
                except:
                    raise TypeError(f"Property permitDifficulties must be of type str, got {type(props['permitDifficulties']).__name__}")
    
        # Type check localReaction (expected str)
        if "localReaction" in props and props["localReaction"] is not None:
            if not isinstance(props["localReaction"], str):
                try:
                    # Attempt to convert
                    props["localReaction"] = str(props["localReaction"])
                except:
                    raise TypeError(f"Property localReaction must be of type str, got {type(props['localReaction']).__name__}")
    
        # Type check securityChallenges (expected bool)
        if "securityChallenges" in props and props["securityChallenges"] is not None:
            if not isinstance(props["securityChallenges"], bool):
                try:
                    # Attempt to convert
                    props["securityChallenges"] = bool(props["securityChallenges"])
                except:
                    raise TypeError(f"Property securityChallenges must be of type bool, got {type(props['securityChallenges']).__name__}")
    
        # Type check scenesFilmed (expected object)
        if "scenesFilmed" in props and props["scenesFilmed"] is not None:
            if not isinstance(props["scenesFilmed"], object):
                try:
                    # Attempt to convert
                    props["scenesFilmed"] = object(props["scenesFilmed"])
                except:
                    raise TypeError(f"Property scenesFilmed must be of type object, got {type(props['scenesFilmed']).__name__}")
    
        # Type check locationAccuracy (expected str)
        if "locationAccuracy" in props and props["locationAccuracy"] is not None:
            if not isinstance(props["locationAccuracy"], str):
                try:
                    # Attempt to convert
                    props["locationAccuracy"] = str(props["locationAccuracy"])
                except:
                    raise TypeError(f"Property locationAccuracy must be of type str, got {type(props['locationAccuracy']).__name__}")
    
        # Type check logisticalChallenges (expected str)
        if "logisticalChallenges" in props and props["logisticalChallenges"] is not None:
            if not isinstance(props["logisticalChallenges"], str):
                try:
                    # Attempt to convert
                    props["logisticalChallenges"] = str(props["logisticalChallenges"])
                except:
                    raise TypeError(f"Property logisticalChallenges must be of type str, got {type(props['logisticalChallenges']).__name__}")
    
        # Type check authenticDialect (expected bool)
        if "authenticDialect" in props and props["authenticDialect"] is not None:
            if not isinstance(props["authenticDialect"], bool):
                try:
                    # Attempt to convert
                    props["authenticDialect"] = bool(props["authenticDialect"])
                except:
                    raise TypeError(f"Property authenticDialect must be of type bool, got {type(props['authenticDialect']).__name__}")
    
        # Type check localParticipation (expected bool)
        if "localParticipation" in props and props["localParticipation"] is not None:
            if not isinstance(props["localParticipation"], bool):
                try:
                    # Attempt to convert
                    props["localParticipation"] = bool(props["localParticipation"])
                except:
                    raise TypeError(f"Property localParticipation must be of type bool, got {type(props['localParticipation']).__name__}")
    
        # Type check visualAuthenticity (expected str)
        if "visualAuthenticity" in props and props["visualAuthenticity"] is not None:
            if not isinstance(props["visualAuthenticity"], str):
                try:
                    # Attempt to convert
                    props["visualAuthenticity"] = str(props["visualAuthenticity"])
                except:
                    raise TypeError(f"Property visualAuthenticity must be of type str, got {type(props['visualAuthenticity']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="FILMED_AT", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def cinematography_for(uuid=None, **props):
        """
        Find relationships of type CINEMATOGRAPHY_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check awardWins (expected int)
        if "awardWins" in props and props["awardWins"] is not None:
            if not isinstance(props["awardWins"], int):
                try:
                    # Attempt to convert
                    props["awardWins"] = int(props["awardWins"])
                except:
                    raise TypeError(f"Property awardWins must be of type int, got {type(props['awardWins']).__name__}")
    
        # Type check signature_shots (expected object)
        if "signature_shots" in props and props["signature_shots"] is not None:
            if not isinstance(props["signature_shots"], object):
                try:
                    # Attempt to convert
                    props["signature_shots"] = object(props["signature_shots"])
                except:
                    raise TypeError(f"Property signature_shots must be of type object, got {type(props['signature_shots']).__name__}")
    
        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Type check awardNominations (expected int)
        if "awardNominations" in props and props["awardNominations"] is not None:
            if not isinstance(props["awardNominations"], int):
                try:
                    # Attempt to convert
                    props["awardNominations"] = int(props["awardNominations"])
                except:
                    raise TypeError(f"Property awardNominations must be of type int, got {type(props['awardNominations']).__name__}")
    
        # Type check completionDate (expected object)
        if "completionDate" in props and props["completionDate"] is not None:
            if not isinstance(props["completionDate"], object):
                try:
                    # Attempt to convert
                    props["completionDate"] = object(props["completionDate"])
                except:
                    raise TypeError(f"Property completionDate must be of type object, got {type(props['completionDate']).__name__}")
    
        # Type check startDate (expected object)
        if "startDate" in props and props["startDate"] is not None:
            if not isinstance(props["startDate"], object):
                try:
                    # Attempt to convert
                    props["startDate"] = object(props["startDate"])
                except:
                    raise TypeError(f"Property startDate must be of type object, got {type(props['startDate']).__name__}")
    
        # Type check cameras (expected object)
        if "cameras" in props and props["cameras"] is not None:
            if not isinstance(props["cameras"], object):
                try:
                    # Attempt to convert
                    props["cameras"] = object(props["cameras"])
                except:
                    raise TypeError(f"Property cameras must be of type object, got {type(props['cameras']).__name__}")
    
        # Type check lenses (expected object)
        if "lenses" in props and props["lenses"] is not None:
            if not isinstance(props["lenses"], object):
                try:
                    # Attempt to convert
                    props["lenses"] = object(props["lenses"])
                except:
                    raise TypeError(f"Property lenses must be of type object, got {type(props['lenses']).__name__}")
    
        # Type check lighting_setups (expected int)
        if "lighting_setups" in props and props["lighting_setups"] is not None:
            if not isinstance(props["lighting_setups"], int):
                try:
                    # Attempt to convert
                    props["lighting_setups"] = int(props["lighting_setups"])
                except:
                    raise TypeError(f"Property lighting_setups must be of type int, got {type(props['lighting_setups']).__name__}")
    
        # Type check technicalChallengesOvercome (expected int)
        if "technicalChallengesOvercome" in props and props["technicalChallengesOvercome"] is not None:
            if not isinstance(props["technicalChallengesOvercome"], int):
                try:
                    # Attempt to convert
                    props["technicalChallengesOvercome"] = int(props["technicalChallengesOvercome"])
                except:
                    raise TypeError(f"Property technicalChallengesOvercome must be of type int, got {type(props['technicalChallengesOvercome']).__name__}")
    
        # Type check innovationsTested (expected object)
        if "innovationsTested" in props and props["innovationsTested"] is not None:
            if not isinstance(props["innovationsTested"], object):
                try:
                    # Attempt to convert
                    props["innovationsTested"] = object(props["innovationsTested"])
                except:
                    raise TypeError(f"Property innovationsTested must be of type object, got {type(props['innovationsTested']).__name__}")
    
        # Type check signatureTechniques (expected object)
        if "signatureTechniques" in props and props["signatureTechniques"] is not None:
            if not isinstance(props["signatureTechniques"], object):
                try:
                    # Attempt to convert
                    props["signatureTechniques"] = object(props["signatureTechniques"])
                except:
                    raise TypeError(f"Property signatureTechniques must be of type object, got {type(props['signatureTechniques']).__name__}")
    
        # Type check innovationsSuccessRate (expected object)
        if "innovationsSuccessRate" in props and props["innovationsSuccessRate"] is not None:
            if not isinstance(props["innovationsSuccessRate"], object):
                try:
                    # Attempt to convert
                    props["innovationsSuccessRate"] = object(props["innovationsSuccessRate"])
                except:
                    raise TypeError(f"Property innovationsSuccessRate must be of type object, got {type(props['innovationsSuccessRate']).__name__}")
    
        # Type check filmedOnLocation (expected bool)
        if "filmedOnLocation" in props and props["filmedOnLocation"] is not None:
            if not isinstance(props["filmedOnLocation"], bool):
                try:
                    # Attempt to convert
                    props["filmedOnLocation"] = bool(props["filmedOnLocation"])
                except:
                    raise TypeError(f"Property filmedOnLocation must be of type bool, got {type(props['filmedOnLocation']).__name__}")
    
        # Type check aspectRatio (expected str)
        if "aspectRatio" in props and props["aspectRatio"] is not None:
            if not isinstance(props["aspectRatio"], str):
                try:
                    # Attempt to convert
                    props["aspectRatio"] = str(props["aspectRatio"])
                except:
                    raise TypeError(f"Property aspectRatio must be of type str, got {type(props['aspectRatio']).__name__}")
    
        # Type check colorProcess (expected str)
        if "colorProcess" in props and props["colorProcess"] is not None:
            if not isinstance(props["colorProcess"], str):
                try:
                    # Attempt to convert
                    props["colorProcess"] = str(props["colorProcess"])
                except:
                    raise TypeError(f"Property colorProcess must be of type str, got {type(props['colorProcess']).__name__}")
    
        # Type check televisionExperience (expected bool)
        if "televisionExperience" in props and props["televisionExperience"] is not None:
            if not isinstance(props["televisionExperience"], bool):
                try:
                    # Attempt to convert
                    props["televisionExperience"] = bool(props["televisionExperience"])
                except:
                    raise TypeError(f"Property televisionExperience must be of type bool, got {type(props['televisionExperience']).__name__}")
    
        # Type check blackAndWhiteFilmStock (expected str)
        if "blackAndWhiteFilmStock" in props and props["blackAndWhiteFilmStock"] is not None:
            if not isinstance(props["blackAndWhiteFilmStock"], str):
                try:
                    # Attempt to convert
                    props["blackAndWhiteFilmStock"] = str(props["blackAndWhiteFilmStock"])
                except:
                    raise TypeError(f"Property blackAndWhiteFilmStock must be of type str, got {type(props['blackAndWhiteFilmStock']).__name__}")
    
        # Type check underwaterChallenges (expected bool)
        if "underwaterChallenges" in props and props["underwaterChallenges"] is not None:
            if not isinstance(props["underwaterChallenges"], bool):
                try:
                    # Attempt to convert
                    props["underwaterChallenges"] = bool(props["underwaterChallenges"])
                except:
                    raise TypeError(f"Property underwaterChallenges must be of type bool, got {type(props['underwaterChallenges']).__name__}")
    
        # Type check epochalCinematography (expected bool)
        if "epochalCinematography" in props and props["epochalCinematography"] is not None:
            if not isinstance(props["epochalCinematography"], bool):
                try:
                    # Attempt to convert
                    props["epochalCinematography"] = bool(props["epochalCinematography"])
                except:
                    raise TypeError(f"Property epochalCinematography must be of type bool, got {type(props['epochalCinematography']).__name__}")
    
        # Type check academicStudies (expected int)
        if "academicStudies" in props and props["academicStudies"] is not None:
            if not isinstance(props["academicStudies"], int):
                try:
                    # Attempt to convert
                    props["academicStudies"] = int(props["academicStudies"])
                except:
                    raise TypeError(f"Property academicStudies must be of type int, got {type(props['academicStudies']).__name__}")
    
        # Type check colorScheme (expected str)
        if "colorScheme" in props and props["colorScheme"] is not None:
            if not isinstance(props["colorScheme"], str):
                try:
                    # Attempt to convert
                    props["colorScheme"] = str(props["colorScheme"])
                except:
                    raise TypeError(f"Property colorScheme must be of type str, got {type(props['colorScheme']).__name__}")
    
        # Type check innovationLevel (expected str)
        if "innovationLevel" in props and props["innovationLevel"] is not None:
            if not isinstance(props["innovationLevel"], str):
                try:
                    # Attempt to convert
                    props["innovationLevel"] = str(props["innovationLevel"])
                except:
                    raise TypeError(f"Property innovationLevel must be of type str, got {type(props['innovationLevel']).__name__}")
    
        # Type check cinematographic_influence (expected str)
        if "cinematographic_influence" in props and props["cinematographic_influence"] is not None:
            if not isinstance(props["cinematographic_influence"], str):
                try:
                    # Attempt to convert
                    props["cinematographic_influence"] = str(props["cinematographic_influence"])
                except:
                    raise TypeError(f"Property cinematographic_influence must be of type str, got {type(props['cinematographic_influence']).__name__}")
    
        # Type check challenges_overcome (expected object)
        if "challenges_overcome" in props and props["challenges_overcome"] is not None:
            if not isinstance(props["challenges_overcome"], object):
                try:
                    # Attempt to convert
                    props["challenges_overcome"] = object(props["challenges_overcome"])
                except:
                    raise TypeError(f"Property challenges_overcome must be of type object, got {type(props['challenges_overcome']).__name__}")
    
        # Type check technical_innovations (expected object)
        if "technical_innovations" in props and props["technical_innovations"] is not None:
            if not isinstance(props["technical_innovations"], object):
                try:
                    # Attempt to convert
                    props["technical_innovations"] = object(props["technical_innovations"])
                except:
                    raise TypeError(f"Property technical_innovations must be of type object, got {type(props['technical_innovations']).__name__}")
    
        # Type check studio_conflicts (expected str)
        if "studio_conflicts" in props and props["studio_conflicts"] is not None:
            if not isinstance(props["studio_conflicts"], str):
                try:
                    # Attempt to convert
                    props["studio_conflicts"] = str(props["studio_conflicts"])
                except:
                    raise TypeError(f"Property studio_conflicts must be of type str, got {type(props['studio_conflicts']).__name__}")
    
        # Type check filmStock (expected str)
        if "filmStock" in props and props["filmStock"] is not None:
            if not isinstance(props["filmStock"], str):
                try:
                    # Attempt to convert
                    props["filmStock"] = str(props["filmStock"])
                except:
                    raise TypeError(f"Property filmStock must be of type str, got {type(props['filmStock']).__name__}")
    
        # Type check signature_techniques (expected object)
        if "signature_techniques" in props and props["signature_techniques"] is not None:
            if not isinstance(props["signature_techniques"], object):
                try:
                    # Attempt to convert
                    props["signature_techniques"] = object(props["signature_techniques"])
                except:
                    raise TypeError(f"Property signature_techniques must be of type object, got {type(props['signature_techniques']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="CINEMATOGRAPHY_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def narrated(uuid=None, **props):
        """
        Find relationships of type NARRATED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check recordingCompletionDate (expected object)
        if "recordingCompletionDate" in props and props["recordingCompletionDate"] is not None:
            if not isinstance(props["recordingCompletionDate"], object):
                try:
                    # Attempt to convert
                    props["recordingCompletionDate"] = object(props["recordingCompletionDate"])
                except:
                    raise TypeError(f"Property recordingCompletionDate must be of type object, got {type(props['recordingCompletionDate']).__name__}")
    
        # Type check rerecordingRequired (expected bool)
        if "rerecordingRequired" in props and props["rerecordingRequired"] is not None:
            if not isinstance(props["rerecordingRequired"], bool):
                try:
                    # Attempt to convert
                    props["rerecordingRequired"] = bool(props["rerecordingRequired"])
                except:
                    raise TypeError(f"Property rerecordingRequired must be of type bool, got {type(props['rerecordingRequired']).__name__}")
    
        # Type check recordingDays (expected int)
        if "recordingDays" in props and props["recordingDays"] is not None:
            if not isinstance(props["recordingDays"], int):
                try:
                    # Attempt to convert
                    props["recordingDays"] = int(props["recordingDays"])
                except:
                    raise TypeError(f"Property recordingDays must be of type int, got {type(props['recordingDays']).__name__}")
    
        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Type check language (expected str)
        if "language" in props and props["language"] is not None:
            if not isinstance(props["language"], str):
                try:
                    # Attempt to convert
                    props["language"] = str(props["language"])
                except:
                    raise TypeError(f"Property language must be of type str, got {type(props['language']).__name__}")
    
        # Type check audienceImpactRating (expected float)
        if "audienceImpactRating" in props and props["audienceImpactRating"] is not None:
            if not isinstance(props["audienceImpactRating"], float):
                try:
                    # Attempt to convert
                    props["audienceImpactRating"] = float(props["audienceImpactRating"])
                except:
                    raise TypeError(f"Property audienceImpactRating must be of type float, got {type(props['audienceImpactRating']).__name__}")
    
        # Type check scriptPages (expected int)
        if "scriptPages" in props and props["scriptPages"] is not None:
            if not isinstance(props["scriptPages"], int):
                try:
                    # Attempt to convert
                    props["scriptPages"] = int(props["scriptPages"])
                except:
                    raise TypeError(f"Property scriptPages must be of type int, got {type(props['scriptPages']).__name__}")
    
        # Type check recordingSessionHours (expected int)
        if "recordingSessionHours" in props and props["recordingSessionHours"] is not None:
            if not isinstance(props["recordingSessionHours"], int):
                try:
                    # Attempt to convert
                    props["recordingSessionHours"] = int(props["recordingSessionHours"])
                except:
                    raise TypeError(f"Property recordingSessionHours must be of type int, got {type(props['recordingSessionHours']).__name__}")
    
        # Type check studioLocation (expected str)
        if "studioLocation" in props and props["studioLocation"] is not None:
            if not isinstance(props["studioLocation"], str):
                try:
                    # Attempt to convert
                    props["studioLocation"] = str(props["studioLocation"])
                except:
                    raise TypeError(f"Property studioLocation must be of type str, got {type(props['studioLocation']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="NARRATED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def distributed(uuid=None, **props):
        """
        Find relationships of type DISTRIBUTED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check returnOnInvestment (expected float)
        if "returnOnInvestment" in props and props["returnOnInvestment"] is not None:
            if not isinstance(props["returnOnInvestment"], float):
                try:
                    # Attempt to convert
                    props["returnOnInvestment"] = float(props["returnOnInvestment"])
                except:
                    raise TypeError(f"Property returnOnInvestment must be of type float, got {type(props['returnOnInvestment']).__name__}")
    
        # Type check marketingStart (expected object)
        if "marketingStart" in props and props["marketingStart"] is not None:
            if not isinstance(props["marketingStart"], object):
                try:
                    # Attempt to convert
                    props["marketingStart"] = object(props["marketingStart"])
                except:
                    raise TypeError(f"Property marketingStart must be of type object, got {type(props['marketingStart']).__name__}")
    
        # Type check marketingBudget (expected int)
        if "marketingBudget" in props and props["marketingBudget"] is not None:
            if not isinstance(props["marketingBudget"], int):
                try:
                    # Attempt to convert
                    props["marketingBudget"] = int(props["marketingBudget"])
                except:
                    raise TypeError(f"Property marketingBudget must be of type int, got {type(props['marketingBudget']).__name__}")
    
        # Type check acquisitionDate (expected object)
        if "acquisitionDate" in props and props["acquisitionDate"] is not None:
            if not isinstance(props["acquisitionDate"], object):
                try:
                    # Attempt to convert
                    props["acquisitionDate"] = object(props["acquisitionDate"])
                except:
                    raise TypeError(f"Property acquisitionDate must be of type object, got {type(props['acquisitionDate']).__name__}")
    
        # Type check territories (expected object)
        if "territories" in props and props["territories"] is not None:
            if not isinstance(props["territories"], object):
                try:
                    # Attempt to convert
                    props["territories"] = object(props["territories"])
                except:
                    raise TypeError(f"Property territories must be of type object, got {type(props['territories']).__name__}")
    
        # Type check conservationDonation (expected int)
        if "conservationDonation" in props and props["conservationDonation"] is not None:
            if not isinstance(props["conservationDonation"], int):
                try:
                    # Attempt to convert
                    props["conservationDonation"] = int(props["conservationDonation"])
                except:
                    raise TypeError(f"Property conservationDonation must be of type int, got {type(props['conservationDonation']).__name__}")
    
        # Type check educationalProgramCreated (expected bool)
        if "educationalProgramCreated" in props and props["educationalProgramCreated"] is not None:
            if not isinstance(props["educationalProgramCreated"], bool):
                try:
                    # Attempt to convert
                    props["educationalProgramCreated"] = bool(props["educationalProgramCreated"])
                except:
                    raise TypeError(f"Property educationalProgramCreated must be of type bool, got {type(props['educationalProgramCreated']).__name__}")
    
        # Type check acquisitionCost (expected int)
        if "acquisitionCost" in props and props["acquisitionCost"] is not None:
            if not isinstance(props["acquisitionCost"], int):
                try:
                    # Attempt to convert
                    props["acquisitionCost"] = int(props["acquisitionCost"])
                except:
                    raise TypeError(f"Property acquisitionCost must be of type int, got {type(props['acquisitionCost']).__name__}")
    
        # Type check isProfitable (expected bool)
        if "isProfitable" in props and props["isProfitable"] is not None:
            if not isinstance(props["isProfitable"], bool):
                try:
                    # Attempt to convert
                    props["isProfitable"] = bool(props["isProfitable"])
                except:
                    raise TypeError(f"Property isProfitable must be of type bool, got {type(props['isProfitable']).__name__}")
    
        # Type check familyMarketingFocus (expected float)
        if "familyMarketingFocus" in props and props["familyMarketingFocus"] is not None:
            if not isinstance(props["familyMarketingFocus"], float):
                try:
                    # Attempt to convert
                    props["familyMarketingFocus"] = float(props["familyMarketingFocus"])
                except:
                    raise TypeError(f"Property familyMarketingFocus must be of type float, got {type(props['familyMarketingFocus']).__name__}")
    
        # Type check international_critical_reception (expected str)
        if "international_critical_reception" in props and props["international_critical_reception"] is not None:
            if not isinstance(props["international_critical_reception"], str):
                try:
                    # Attempt to convert
                    props["international_critical_reception"] = str(props["international_critical_reception"])
                except:
                    raise TypeError(f"Property international_critical_reception must be of type str, got {type(props['international_critical_reception']).__name__}")
    
        # Type check revenue_split_structure (expected str)
        if "revenue_split_structure" in props and props["revenue_split_structure"] is not None:
            if not isinstance(props["revenue_split_structure"], str):
                try:
                    # Attempt to convert
                    props["revenue_split_structure"] = str(props["revenue_split_structure"])
                except:
                    raise TypeError(f"Property revenue_split_structure must be of type str, got {type(props['revenue_split_structure']).__name__}")
    
        # Type check cultural_impact_variance (expected str)
        if "cultural_impact_variance" in props and props["cultural_impact_variance"] is not None:
            if not isinstance(props["cultural_impact_variance"], str):
                try:
                    # Attempt to convert
                    props["cultural_impact_variance"] = str(props["cultural_impact_variance"])
                except:
                    raise TypeError(f"Property cultural_impact_variance must be of type str, got {type(props['cultural_impact_variance']).__name__}")
    
        # Type check distribution_head (expected str)
        if "distribution_head" in props and props["distribution_head"] is not None:
            if not isinstance(props["distribution_head"], str):
                try:
                    # Attempt to convert
                    props["distribution_head"] = str(props["distribution_head"])
                except:
                    raise TypeError(f"Property distribution_head must be of type str, got {type(props['distribution_head']).__name__}")
    
        # Type check latin_american_coordination (expected str)
        if "latin_american_coordination" in props and props["latin_american_coordination"] is not None:
            if not isinstance(props["latin_american_coordination"], str):
                try:
                    # Attempt to convert
                    props["latin_american_coordination"] = str(props["latin_american_coordination"])
                except:
                    raise TypeError(f"Property latin_american_coordination must be of type str, got {type(props['latin_american_coordination']).__name__}")
    
        # Type check piracy_protection_measures (expected str)
        if "piracy_protection_measures" in props and props["piracy_protection_measures"] is not None:
            if not isinstance(props["piracy_protection_measures"], str):
                try:
                    # Attempt to convert
                    props["piracy_protection_measures"] = str(props["piracy_protection_measures"])
                except:
                    raise TypeError(f"Property piracy_protection_measures must be of type str, got {type(props['piracy_protection_measures']).__name__}")
    
        # Type check european_distribution_headquarters (expected str)
        if "european_distribution_headquarters" in props and props["european_distribution_headquarters"] is not None:
            if not isinstance(props["european_distribution_headquarters"], str):
                try:
                    # Attempt to convert
                    props["european_distribution_headquarters"] = str(props["european_distribution_headquarters"])
                except:
                    raise TypeError(f"Property european_distribution_headquarters must be of type str, got {type(props['european_distribution_headquarters']).__name__}")
    
        # Type check subtitle_quality_control (expected str)
        if "subtitle_quality_control" in props and props["subtitle_quality_control"] is not None:
            if not isinstance(props["subtitle_quality_control"], str):
                try:
                    # Attempt to convert
                    props["subtitle_quality_control"] = str(props["subtitle_quality_control"])
                except:
                    raise TypeError(f"Property subtitle_quality_control must be of type str, got {type(props['subtitle_quality_control']).__name__}")
    
        # Type check box_office_collection_methods (expected str)
        if "box_office_collection_methods" in props and props["box_office_collection_methods"] is not None:
            if not isinstance(props["box_office_collection_methods"], str):
                try:
                    # Attempt to convert
                    props["box_office_collection_methods"] = str(props["box_office_collection_methods"])
                except:
                    raise TypeError(f"Property box_office_collection_methods must be of type str, got {type(props['box_office_collection_methods']).__name__}")
    
        # Type check global_strategy (expected str)
        if "global_strategy" in props and props["global_strategy"] is not None:
            if not isinstance(props["global_strategy"], str):
                try:
                    # Attempt to convert
                    props["global_strategy"] = str(props["global_strategy"])
                except:
                    raise TypeError(f"Property global_strategy must be of type str, got {type(props['global_strategy']).__name__}")
    
        # Type check dubbing_supervision (expected str)
        if "dubbing_supervision" in props and props["dubbing_supervision"] is not None:
            if not isinstance(props["dubbing_supervision"], str):
                try:
                    # Attempt to convert
                    props["dubbing_supervision"] = str(props["dubbing_supervision"])
                except:
                    raise TypeError(f"Property dubbing_supervision must be of type str, got {type(props['dubbing_supervision']).__name__}")
    
        # Type check international_premiere_approach (expected str)
        if "international_premiere_approach" in props and props["international_premiere_approach"] is not None:
            if not isinstance(props["international_premiere_approach"], str):
                try:
                    # Attempt to convert
                    props["international_premiere_approach"] = str(props["international_premiere_approach"])
                except:
                    raise TypeError(f"Property international_premiere_approach must be of type str, got {type(props['international_premiere_approach']).__name__}")
    
        # Type check distribution_model (expected str)
        if "distribution_model" in props and props["distribution_model"] is not None:
            if not isinstance(props["distribution_model"], str):
                try:
                    # Attempt to convert
                    props["distribution_model"] = str(props["distribution_model"])
                except:
                    raise TypeError(f"Property distribution_model must be of type str, got {type(props['distribution_model']).__name__}")
    
        # Type check materials_provided (expected object)
        if "materials_provided" in props and props["materials_provided"] is not None:
            if not isinstance(props["materials_provided"], object):
                try:
                    # Attempt to convert
                    props["materials_provided"] = object(props["materials_provided"])
                except:
                    raise TypeError(f"Property materials_provided must be of type object, got {type(props['materials_provided']).__name__}")
    
        # Type check asian_distribution_headquarters (expected str)
        if "asian_distribution_headquarters" in props and props["asian_distribution_headquarters"] is not None:
            if not isinstance(props["asian_distribution_headquarters"], str):
                try:
                    # Attempt to convert
                    props["asian_distribution_headquarters"] = str(props["asian_distribution_headquarters"])
                except:
                    raise TypeError(f"Property asian_distribution_headquarters must be of type str, got {type(props['asian_distribution_headquarters']).__name__}")
    
        # Type check censorship_negotiation_strategy (expected str)
        if "censorship_negotiation_strategy" in props and props["censorship_negotiation_strategy"] is not None:
            if not isinstance(props["censorship_negotiation_strategy"], str):
                try:
                    # Attempt to convert
                    props["censorship_negotiation_strategy"] = str(props["censorship_negotiation_strategy"])
                except:
                    raise TypeError(f"Property censorship_negotiation_strategy must be of type str, got {type(props['censorship_negotiation_strategy']).__name__}")
    
        # Type check currency_repatriation_challenges (expected str)
        if "currency_repatriation_challenges" in props and props["currency_repatriation_challenges"] is not None:
            if not isinstance(props["currency_repatriation_challenges"], str):
                try:
                    # Attempt to convert
                    props["currency_repatriation_challenges"] = str(props["currency_repatriation_challenges"])
                except:
                    raise TypeError(f"Property currency_repatriation_challenges must be of type str, got {type(props['currency_repatriation_challenges']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="DISTRIBUTED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def preserved_by(uuid=None, **props):
        """
        Find relationships of type PRESERVED_BY matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Type check preservationDate (expected object)
        if "preservationDate" in props and props["preservationDate"] is not None:
            if not isinstance(props["preservationDate"], object):
                try:
                    # Attempt to convert
                    props["preservationDate"] = object(props["preservationDate"])
                except:
                    raise TypeError(f"Property preservationDate must be of type object, got {type(props['preservationDate']).__name__}")
    
        # Type check preservationMedium (expected object)
        if "preservationMedium" in props and props["preservationMedium"] is not None:
            if not isinstance(props["preservationMedium"], object):
                try:
                    # Attempt to convert
                    props["preservationMedium"] = object(props["preservationMedium"])
                except:
                    raise TypeError(f"Property preservationMedium must be of type object, got {type(props['preservationMedium']).__name__}")
    
        # Type check digitalFormat (expected str)
        if "digitalFormat" in props and props["digitalFormat"] is not None:
            if not isinstance(props["digitalFormat"], str):
                try:
                    # Attempt to convert
                    props["digitalFormat"] = str(props["digitalFormat"])
                except:
                    raise TypeError(f"Property digitalFormat must be of type str, got {type(props['digitalFormat']).__name__}")
    
        # Type check restorationDate (expected object)
        if "restorationDate" in props and props["restorationDate"] is not None:
            if not isinstance(props["restorationDate"], object):
                try:
                    # Attempt to convert
                    props["restorationDate"] = object(props["restorationDate"])
                except:
                    raise TypeError(f"Property restorationDate must be of type object, got {type(props['restorationDate']).__name__}")
    
        # Type check restoration (expected bool)
        if "restoration" in props and props["restoration"] is not None:
            if not isinstance(props["restoration"], bool):
                try:
                    # Attempt to convert
                    props["restoration"] = bool(props["restoration"])
                except:
                    raise TypeError(f"Property restoration must be of type bool, got {type(props['restoration']).__name__}")
    
        # Type check preservationRound (expected int)
        if "preservationRound" in props and props["preservationRound"] is not None:
            if not isinstance(props["preservationRound"], int):
                try:
                    # Attempt to convert
                    props["preservationRound"] = int(props["preservationRound"])
                except:
                    raise TypeError(f"Property preservationRound must be of type int, got {type(props['preservationRound']).__name__}")
    
        # Type check restorationCost (expected int)
        if "restorationCost" in props and props["restorationCost"] is not None:
            if not isinstance(props["restorationCost"], int):
                try:
                    # Attempt to convert
                    props["restorationCost"] = int(props["restorationCost"])
                except:
                    raise TypeError(f"Property restorationCost must be of type int, got {type(props['restorationCost']).__name__}")
    
        # Type check selectionCriteria (expected object)
        if "selectionCriteria" in props and props["selectionCriteria"] is not None:
            if not isinstance(props["selectionCriteria"], object):
                try:
                    # Attempt to convert
                    props["selectionCriteria"] = object(props["selectionCriteria"])
                except:
                    raise TypeError(f"Property selectionCriteria must be of type object, got {type(props['selectionCriteria']).__name__}")
    
        # Type check criteriaScore (expected object)
        if "criteriaScore" in props and props["criteriaScore"] is not None:
            if not isinstance(props["criteriaScore"], object):
                try:
                    # Attempt to convert
                    props["criteriaScore"] = object(props["criteriaScore"])
                except:
                    raise TypeError(f"Property criteriaScore must be of type object, got {type(props['criteriaScore']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="PRESERVED_BY", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def teaches_with(uuid=None, **props):
        """
        Find relationships of type TEACHES_WITH matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check coursesUsedIn (expected int)
        if "coursesUsedIn" in props and props["coursesUsedIn"] is not None:
            if not isinstance(props["coursesUsedIn"], int):
                try:
                    # Attempt to convert
                    props["coursesUsedIn"] = int(props["coursesUsedIn"])
                except:
                    raise TypeError(f"Property coursesUsedIn must be of type int, got {type(props['coursesUsedIn']).__name__}")
    
        # Type check yearAdded (expected int)
        if "yearAdded" in props and props["yearAdded"] is not None:
            if not isinstance(props["yearAdded"], int):
                try:
                    # Attempt to convert
                    props["yearAdded"] = int(props["yearAdded"])
                except:
                    raise TypeError(f"Property yearAdded must be of type int, got {type(props['yearAdded']).__name__}")
    
        # Type check studentPapersCount (expected int)
        if "studentPapersCount" in props and props["studentPapersCount"] is not None:
            if not isinstance(props["studentPapersCount"], int):
                try:
                    # Attempt to convert
                    props["studentPapersCount"] = int(props["studentPapersCount"])
                except:
                    raise TypeError(f"Property studentPapersCount must be of type int, got {type(props['studentPapersCount']).__name__}")
    
        # Type check primaryFocus (expected object)
        if "primaryFocus" in props and props["primaryFocus"] is not None:
            if not isinstance(props["primaryFocus"], object):
                try:
                    # Attempt to convert
                    props["primaryFocus"] = object(props["primaryFocus"])
                except:
                    raise TypeError(f"Property primaryFocus must be of type object, got {type(props['primaryFocus']).__name__}")
    
        # Type check requiredForDegrees (expected object)
        if "requiredForDegrees" in props and props["requiredForDegrees"] is not None:
            if not isinstance(props["requiredForDegrees"], object):
                try:
                    # Attempt to convert
                    props["requiredForDegrees"] = object(props["requiredForDegrees"])
                except:
                    raise TypeError(f"Property requiredForDegrees must be of type object, got {type(props['requiredForDegrees']).__name__}")
    
        # Type check teachingHoursAnnually (expected int)
        if "teachingHoursAnnually" in props and props["teachingHoursAnnually"] is not None:
            if not isinstance(props["teachingHoursAnnually"], int):
                try:
                    # Attempt to convert
                    props["teachingHoursAnnually"] = int(props["teachingHoursAnnually"])
                except:
                    raise TypeError(f"Property teachingHoursAnnually must be of type int, got {type(props['teachingHoursAnnually']).__name__}")
    
        # Type check mostCommonAnalysisTopics (expected object)
        if "mostCommonAnalysisTopics" in props and props["mostCommonAnalysisTopics"] is not None:
            if not isinstance(props["mostCommonAnalysisTopics"], object):
                try:
                    # Attempt to convert
                    props["mostCommonAnalysisTopics"] = object(props["mostCommonAnalysisTopics"])
                except:
                    raise TypeError(f"Property mostCommonAnalysisTopics must be of type object, got {type(props['mostCommonAnalysisTopics']).__name__}")
    
        # Type check teachingValue (expected float)
        if "teachingValue" in props and props["teachingValue"] is not None:
            if not isinstance(props["teachingValue"], float):
                try:
                    # Attempt to convert
                    props["teachingValue"] = float(props["teachingValue"])
                except:
                    raise TypeError(f"Property teachingValue must be of type float, got {type(props['teachingValue']).__name__}")
    
        # Type check restorationPartnership (expected bool)
        if "restorationPartnership" in props and props["restorationPartnership"] is not None:
            if not isinstance(props["restorationPartnership"], bool):
                try:
                    # Attempt to convert
                    props["restorationPartnership"] = bool(props["restorationPartnership"])
                except:
                    raise TypeError(f"Property restorationPartnership must be of type bool, got {type(props['restorationPartnership']).__name__}")
    
        # Type check preservationEfforts (expected str)
        if "preservationEfforts" in props and props["preservationEfforts"] is not None:
            if not isinstance(props["preservationEfforts"], str):
                try:
                    # Attempt to convert
                    props["preservationEfforts"] = str(props["preservationEfforts"])
                except:
                    raise TypeError(f"Property preservationEfforts must be of type str, got {type(props['preservationEfforts']).__name__}")
    
        # Type check originalMaterialsAccess (expected str)
        if "originalMaterialsAccess" in props and props["originalMaterialsAccess"] is not None:
            if not isinstance(props["originalMaterialsAccess"], str):
                try:
                    # Attempt to convert
                    props["originalMaterialsAccess"] = str(props["originalMaterialsAccess"])
                except:
                    raise TypeError(f"Property originalMaterialsAccess must be of type str, got {type(props['originalMaterialsAccess']).__name__}")
    
        # Type check technicalDeconstruction (expected object)
        if "technicalDeconstruction" in props and props["technicalDeconstruction"] is not None:
            if not isinstance(props["technicalDeconstruction"], object):
                try:
                    # Attempt to convert
                    props["technicalDeconstruction"] = object(props["technicalDeconstruction"])
                except:
                    raise TypeError(f"Property technicalDeconstruction must be of type object, got {type(props['technicalDeconstruction']).__name__}")
    
        # Type check alumniConnections (expected str)
        if "alumniConnections" in props and props["alumniConnections"] is not None:
            if not isinstance(props["alumniConnections"], str):
                try:
                    # Attempt to convert
                    props["alumniConnections"] = str(props["alumniConnections"])
                except:
                    raise TypeError(f"Property alumniConnections must be of type str, got {type(props['alumniConnections']).__name__}")
    
        # Type check preservationPartnership (expected bool)
        if "preservationPartnership" in props and props["preservationPartnership"] is not None:
            if not isinstance(props["preservationPartnership"], bool):
                try:
                    # Attempt to convert
                    props["preservationPartnership"] = bool(props["preservationPartnership"])
                except:
                    raise TypeError(f"Property preservationPartnership must be of type bool, got {type(props['preservationPartnership']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="TEACHES_WITH", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def impacted(uuid=None, **props):
        """
        Find relationships of type IMPACTED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check adaptationSuccessRates (expected object)
        if "adaptationSuccessRates" in props and props["adaptationSuccessRates"] is not None:
            if not isinstance(props["adaptationSuccessRates"], object):
                try:
                    # Attempt to convert
                    props["adaptationSuccessRates"] = object(props["adaptationSuccessRates"])
                except:
                    raise TypeError(f"Property adaptationSuccessRates must be of type object, got {type(props['adaptationSuccessRates']).__name__}")
    
        # Type check daysExperienced (expected int)
        if "daysExperienced" in props and props["daysExperienced"] is not None:
            if not isinstance(props["daysExperienced"], int):
                try:
                    # Attempt to convert
                    props["daysExperienced"] = int(props["daysExperienced"])
                except:
                    raise TypeError(f"Property daysExperienced must be of type int, got {type(props['daysExperienced']).__name__}")
    
        # Type check humanEnduranceLimit (expected object)
        if "humanEnduranceLimit" in props and props["humanEnduranceLimit"] is not None:
            if not isinstance(props["humanEnduranceLimit"], object):
                try:
                    # Attempt to convert
                    props["humanEnduranceLimit"] = object(props["humanEnduranceLimit"])
                except:
                    raise TypeError(f"Property humanEnduranceLimit must be of type object, got {type(props['humanEnduranceLimit']).__name__}")
    
        # Type check documentaryValueAdded (expected float)
        if "documentaryValueAdded" in props and props["documentaryValueAdded"] is not None:
            if not isinstance(props["documentaryValueAdded"], float):
                try:
                    # Attempt to convert
                    props["documentaryValueAdded"] = float(props["documentaryValueAdded"])
                except:
                    raise TypeError(f"Property documentaryValueAdded must be of type float, got {type(props['documentaryValueAdded']).__name__}")
    
        # Type check equipmentFailureRate (expected float)
        if "equipmentFailureRate" in props and props["equipmentFailureRate"] is not None:
            if not isinstance(props["equipmentFailureRate"], float):
                try:
                    # Attempt to convert
                    props["equipmentFailureRate"] = float(props["equipmentFailureRate"])
                except:
                    raise TypeError(f"Property equipmentFailureRate must be of type float, got {type(props['equipmentFailureRate']).__name__}")
    
        # Type check rotationalSchedule (expected str)
        if "rotationalSchedule" in props and props["rotationalSchedule"] is not None:
            if not isinstance(props["rotationalSchedule"], str):
                try:
                    # Attempt to convert
                    props["rotationalSchedule"] = str(props["rotationalSchedule"])
                except:
                    raise TypeError(f"Property rotationalSchedule must be of type str, got {type(props['rotationalSchedule']).__name__}")
    
        # Type check equipmentAdaptations (expected object)
        if "equipmentAdaptations" in props and props["equipmentAdaptations"] is not None:
            if not isinstance(props["equipmentAdaptations"], object):
                try:
                    # Attempt to convert
                    props["equipmentAdaptations"] = object(props["equipmentAdaptations"])
                except:
                    raise TypeError(f"Property equipmentAdaptations must be of type object, got {type(props['equipmentAdaptations']).__name__}")
    
        # Type check footageLostToCold (expected str)
        if "footageLostToCold" in props and props["footageLostToCold"] is not None:
            if not isinstance(props["footageLostToCold"], str):
                try:
                    # Attempt to convert
                    props["footageLostToCold"] = str(props["footageLostToCold"])
                except:
                    raise TypeError(f"Property footageLostToCold must be of type str, got {type(props['footageLostToCold']).__name__}")
    
        # Type check crewmedicalIncidents (expected int)
        if "crewmedicalIncidents" in props and props["crewmedicalIncidents"] is not None:
            if not isinstance(props["crewmedicalIncidents"], int):
                try:
                    # Attempt to convert
                    props["crewmedicalIncidents"] = int(props["crewmedicalIncidents"])
                except:
                    raise TypeError(f"Property crewmedicalIncidents must be of type int, got {type(props['crewmedicalIncidents']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="IMPACTED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def influenced_by(uuid=None, **props):
        """
        Find relationships of type INFLUENCED_BY matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check criticalTheoriesGenerated (expected object)
        if "criticalTheoriesGenerated" in props and props["criticalTheoriesGenerated"] is not None:
            if not isinstance(props["criticalTheoriesGenerated"], object):
                try:
                    # Attempt to convert
                    props["criticalTheoriesGenerated"] = object(props["criticalTheoriesGenerated"])
                except:
                    raise TypeError(f"Property criticalTheoriesGenerated must be of type object, got {type(props['criticalTheoriesGenerated']).__name__}")
    
        # Type check canonicalSurveys (expected int)
        if "canonicalSurveys" in props and props["canonicalSurveys"] is not None:
            if not isinstance(props["canonicalSurveys"], int):
                try:
                    # Attempt to convert
                    props["canonicalSurveys"] = int(props["canonicalSurveys"])
                except:
                    raise TypeError(f"Property canonicalSurveys must be of type int, got {type(props['canonicalSurveys']).__name__}")
    
        # Type check theoryInfluence (expected object)
        if "theoryInfluence" in props and props["theoryInfluence"] is not None:
            if not isinstance(props["theoryInfluence"], object):
                try:
                    # Attempt to convert
                    props["theoryInfluence"] = object(props["theoryInfluence"])
                except:
                    raise TypeError(f"Property theoryInfluence must be of type object, got {type(props['theoryInfluence']).__name__}")
    
        # Type check yearFirstStudied (expected int)
        if "yearFirstStudied" in props and props["yearFirstStudied"] is not None:
            if not isinstance(props["yearFirstStudied"], int):
                try:
                    # Attempt to convert
                    props["yearFirstStudied"] = int(props["yearFirstStudied"])
                except:
                    raise TypeError(f"Property yearFirstStudied must be of type int, got {type(props['yearFirstStudied']).__name__}")
    
        # Type check surveyYears (expected object)
        if "surveyYears" in props and props["surveyYears"] is not None:
            if not isinstance(props["surveyYears"], object):
                try:
                    # Attempt to convert
                    props["surveyYears"] = object(props["surveyYears"])
                except:
                    raise TypeError(f"Property surveyYears must be of type object, got {type(props['surveyYears']).__name__}")
    
        # Type check academicPapersCount (expected int)
        if "academicPapersCount" in props and props["academicPapersCount"] is not None:
            if not isinstance(props["academicPapersCount"], int):
                try:
                    # Attempt to convert
                    props["academicPapersCount"] = int(props["academicPapersCount"])
                except:
                    raise TypeError(f"Property academicPapersCount must be of type int, got {type(props['academicPapersCount']).__name__}")
    
        # Type check canonicalPosition (expected int)
        if "canonicalPosition" in props and props["canonicalPosition"] is not None:
            if not isinstance(props["canonicalPosition"], int):
                try:
                    # Attempt to convert
                    props["canonicalPosition"] = int(props["canonicalPosition"])
                except:
                    raise TypeError(f"Property canonicalPosition must be of type int, got {type(props['canonicalPosition']).__name__}")
    
        # Type check textbookReferences (expected int)
        if "textbookReferences" in props and props["textbookReferences"] is not None:
            if not isinstance(props["textbookReferences"], int):
                try:
                    # Attempt to convert
                    props["textbookReferences"] = int(props["textbookReferences"])
                except:
                    raise TypeError(f"Property textbookReferences must be of type int, got {type(props['textbookReferences']).__name__}")
    
        # Type check percentageCoursesTeaching (expected int)
        if "percentageCoursesTeaching" in props and props["percentageCoursesTeaching"] is not None:
            if not isinstance(props["percentageCoursesTeaching"], int):
                try:
                    # Attempt to convert
                    props["percentageCoursesTeaching"] = int(props["percentageCoursesTeaching"])
                except:
                    raise TypeError(f"Property percentageCoursesTeaching must be of type int, got {type(props['percentageCoursesTeaching']).__name__}")
    
        # Type check mediaCoverage (expected str)
        if "mediaCoverage" in props and props["mediaCoverage"] is not None:
            if not isinstance(props["mediaCoverage"], str):
                try:
                    # Attempt to convert
                    props["mediaCoverage"] = str(props["mediaCoverage"])
                except:
                    raise TypeError(f"Property mediaCoverage must be of type str, got {type(props['mediaCoverage']).__name__}")
    
        # Type check culturalImpact (expected str)
        if "culturalImpact" in props and props["culturalImpact"] is not None:
            if not isinstance(props["culturalImpact"], str):
                try:
                    # Attempt to convert
                    props["culturalImpact"] = str(props["culturalImpact"])
                except:
                    raise TypeError(f"Property culturalImpact must be of type str, got {type(props['culturalImpact']).__name__}")
    
        # Type check culturalShift (expected str)
        if "culturalShift" in props and props["culturalShift"] is not None:
            if not isinstance(props["culturalShift"], str):
                try:
                    # Attempt to convert
                    props["culturalShift"] = str(props["culturalShift"])
                except:
                    raise TypeError(f"Property culturalShift must be of type str, got {type(props['culturalShift']).__name__}")
    
        # Type check subsequentPortrayals (expected str)
        if "subsequentPortrayals" in props and props["subsequentPortrayals"] is not None:
            if not isinstance(props["subsequentPortrayals"], str):
                try:
                    # Attempt to convert
                    props["subsequentPortrayals"] = str(props["subsequentPortrayals"])
                except:
                    raise TypeError(f"Property subsequentPortrayals must be of type str, got {type(props['subsequentPortrayals']).__name__}")
    
        # Type check significanceRating (expected float)
        if "significanceRating" in props and props["significanceRating"] is not None:
            if not isinstance(props["significanceRating"], float):
                try:
                    # Attempt to convert
                    props["significanceRating"] = float(props["significanceRating"])
                except:
                    raise TypeError(f"Property significanceRating must be of type float, got {type(props['significanceRating']).__name__}")
    
        # Type check languageContributions (expected object)
        if "languageContributions" in props and props["languageContributions"] is not None:
            if not isinstance(props["languageContributions"], object):
                try:
                    # Attempt to convert
                    props["languageContributions"] = object(props["languageContributions"])
                except:
                    raise TypeError(f"Property languageContributions must be of type object, got {type(props['languageContributions']).__name__}")
    
        # Type check controversyLevel (expected str)
        if "controversyLevel" in props and props["controversyLevel"] is not None:
            if not isinstance(props["controversyLevel"], str):
                try:
                    # Attempt to convert
                    props["controversyLevel"] = str(props["controversyLevel"])
                except:
                    raise TypeError(f"Property controversyLevel must be of type str, got {type(props['controversyLevel']).__name__}")
    
        # Type check identityEffects (expected object)
        if "identityEffects" in props and props["identityEffects"] is not None:
            if not isinstance(props["identityEffects"], object):
                try:
                    # Attempt to convert
                    props["identityEffects"] = object(props["identityEffects"])
                except:
                    raise TypeError(f"Property identityEffects must be of type object, got {type(props['identityEffects']).__name__}")
    
        # Type check communityReactions (expected object)
        if "communityReactions" in props and props["communityReactions"] is not None:
            if not isinstance(props["communityReactions"], object):
                try:
                    # Attempt to convert
                    props["communityReactions"] = object(props["communityReactions"])
                except:
                    raise TypeError(f"Property communityReactions must be of type object, got {type(props['communityReactions']).__name__}")
    
        # Type check authenticityClaims (expected str)
        if "authenticityClaims" in props and props["authenticityClaims"] is not None:
            if not isinstance(props["authenticityClaims"], str):
                try:
                    # Attempt to convert
                    props["authenticityClaims"] = str(props["authenticityClaims"])
                except:
                    raise TypeError(f"Property authenticityClaims must be of type str, got {type(props['authenticityClaims']).__name__}")
    
        # Type check academicAnalyses (expected int)
        if "academicAnalyses" in props and props["academicAnalyses"] is not None:
            if not isinstance(props["academicAnalyses"], int):
                try:
                    # Attempt to convert
                    props["academicAnalyses"] = int(props["academicAnalyses"])
                except:
                    raise TypeError(f"Property academicAnalyses must be of type int, got {type(props['academicAnalyses']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="INFLUENCED_BY", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def culminated_with(uuid=None, **props):
        """
        Find relationships of type CULMINATED_WITH matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check boxOfficeMultiplierEffect (expected float)
        if "boxOfficeMultiplierEffect" in props and props["boxOfficeMultiplierEffect"] is not None:
            if not isinstance(props["boxOfficeMultiplierEffect"], float):
                try:
                    # Attempt to convert
                    props["boxOfficeMultiplierEffect"] = float(props["boxOfficeMultiplierEffect"])
                except:
                    raise TypeError(f"Property boxOfficeMultiplierEffect must be of type float, got {type(props['boxOfficeMultiplierEffect']).__name__}")
    
        # Type check subtitleAcceptanceIncrease (expected float)
        if "subtitleAcceptanceIncrease" in props and props["subtitleAcceptanceIncrease"] is not None:
            if not isinstance(props["subtitleAcceptanceIncrease"], float):
                try:
                    # Attempt to convert
                    props["subtitleAcceptanceIncrease"] = float(props["subtitleAcceptanceIncrease"])
                except:
                    raise TypeError(f"Property subtitleAcceptanceIncrease must be of type float, got {type(props['subtitleAcceptanceIncrease']).__name__}")
    
        # Type check filmSchoolAdoption (expected str)
        if "filmSchoolAdoption" in props and props["filmSchoolAdoption"] is not None:
            if not isinstance(props["filmSchoolAdoption"], str):
                try:
                    # Attempt to convert
                    props["filmSchoolAdoption"] = str(props["filmSchoolAdoption"])
                except:
                    raise TypeError(f"Property filmSchoolAdoption must be of type str, got {type(props['filmSchoolAdoption']).__name__}")
    
        # Type check subsequentDistributionDeals (expected int)
        if "subsequentDistributionDeals" in props and props["subsequentDistributionDeals"] is not None:
            if not isinstance(props["subsequentDistributionDeals"], int):
                try:
                    # Attempt to convert
                    props["subsequentDistributionDeals"] = int(props["subsequentDistributionDeals"])
                except:
                    raise TypeError(f"Property subsequentDistributionDeals must be of type int, got {type(props['subsequentDistributionDeals']).__name__}")
    
        # Type check newFilmmakersInspired (expected str)
        if "newFilmmakersInspired" in props and props["newFilmmakersInspired"] is not None:
            if not isinstance(props["newFilmmakersInspired"], str):
                try:
                    # Attempt to convert
                    props["newFilmmakersInspired"] = str(props["newFilmmakersInspired"])
                except:
                    raise TypeError(f"Property newFilmmakersInspired must be of type str, got {type(props['newFilmmakersInspired']).__name__}")
    
        # Type check academicAnalyses (expected int)
        if "academicAnalyses" in props and props["academicAnalyses"] is not None:
            if not isinstance(props["academicAnalyses"], int):
                try:
                    # Attempt to convert
                    props["academicAnalyses"] = int(props["academicAnalyses"])
                except:
                    raise TypeError(f"Property academicAnalyses must be of type int, got {type(props['academicAnalyses']).__name__}")
    
        # Type check globalImpact (expected str)
        if "globalImpact" in props and props["globalImpact"] is not None:
            if not isinstance(props["globalImpact"], str):
                try:
                    # Attempt to convert
                    props["globalImpact"] = str(props["globalImpact"])
                except:
                    raise TypeError(f"Property globalImpact must be of type str, got {type(props['globalImpact']).__name__}")
    
        # Type check koreanFilmExportsIncrease (expected float)
        if "koreanFilmExportsIncrease" in props and props["koreanFilmExportsIncrease"] is not None:
            if not isinstance(props["koreanFilmExportsIncrease"], float):
                try:
                    # Attempt to convert
                    props["koreanFilmExportsIncrease"] = float(props["koreanFilmExportsIncrease"])
                except:
                    raise TypeError(f"Property koreanFilmExportsIncrease must be of type float, got {type(props['koreanFilmExportsIncrease']).__name__}")
    
        # Type check significanceRating (expected float)
        if "significanceRating" in props and props["significanceRating"] is not None:
            if not isinstance(props["significanceRating"], float):
                try:
                    # Attempt to convert
                    props["significanceRating"] = float(props["significanceRating"])
                except:
                    raise TypeError(f"Property significanceRating must be of type float, got {type(props['significanceRating']).__name__}")
    
        # Type check culturalBarrierReduction (expected str)
        if "culturalBarrierReduction" in props and props["culturalBarrierReduction"] is not None:
            if not isinstance(props["culturalBarrierReduction"], str):
                try:
                    # Attempt to convert
                    props["culturalBarrierReduction"] = str(props["culturalBarrierReduction"])
                except:
                    raise TypeError(f"Property culturalBarrierReduction must be of type str, got {type(props['culturalBarrierReduction']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="CULMINATED_WITH", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def provided_services_for(uuid=None, **props):
        """
        Find relationships of type PROVIDED_SERVICES_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check transformationQuality (expected float)
        if "transformationQuality" in props and props["transformationQuality"] is not None:
            if not isinstance(props["transformationQuality"], float):
                try:
                    # Attempt to convert
                    props["transformationQuality"] = float(props["transformationQuality"])
                except:
                    raise TypeError(f"Property transformationQuality must be of type float, got {type(props['transformationQuality']).__name__}")
    
        # Type check visualizationAccuracy (expected str)
        if "visualizationAccuracy" in props and props["visualizationAccuracy"] is not None:
            if not isinstance(props["visualizationAccuracy"], str):
                try:
                    # Attempt to convert
                    props["visualizationAccuracy"] = str(props["visualizationAccuracy"])
                except:
                    raise TypeError(f"Property visualizationAccuracy must be of type str, got {type(props['visualizationAccuracy']).__name__}")
    
        # Type check footageProcessed (expected int)
        if "footageProcessed" in props and props["footageProcessed"] is not None:
            if not isinstance(props["footageProcessed"], int):
                try:
                    # Attempt to convert
                    props["footageProcessed"] = int(props["footageProcessed"])
                except:
                    raise TypeError(f"Property footageProcessed must be of type int, got {type(props['footageProcessed']).__name__}")
    
        # Type check footageUnit (expected str)
        if "footageUnit" in props and props["footageUnit"] is not None:
            if not isinstance(props["footageUnit"], str):
                try:
                    # Attempt to convert
                    props["footageUnit"] = str(props["footageUnit"])
                except:
                    raise TypeError(f"Property footageUnit must be of type str, got {type(props['footageUnit']).__name__}")
    
        # Type check serviceType (expected object)
        if "serviceType" in props and props["serviceType"] is not None:
            if not isinstance(props["serviceType"], object):
                try:
                    # Attempt to convert
                    props["serviceType"] = object(props["serviceType"])
                except:
                    raise TypeError(f"Property serviceType must be of type object, got {type(props['serviceType']).__name__}")
    
        # Type check contractValue (expected int)
        if "contractValue" in props and props["contractValue"] is not None:
            if not isinstance(props["contractValue"], int):
                try:
                    # Attempt to convert
                    props["contractValue"] = int(props["contractValue"])
                except:
                    raise TypeError(f"Property contractValue must be of type int, got {type(props['contractValue']).__name__}")
    
        # Type check workDuration (expected object)
        if "workDuration" in props and props["workDuration"] is not None:
            if not isinstance(props["workDuration"], object):
                try:
                    # Attempt to convert
                    props["workDuration"] = object(props["workDuration"])
                except:
                    raise TypeError(f"Property workDuration must be of type object, got {type(props['workDuration']).__name__}")
    
        # Type check teamSize (expected int)
        if "teamSize" in props and props["teamSize"] is not None:
            if not isinstance(props["teamSize"], int):
                try:
                    # Attempt to convert
                    props["teamSize"] = int(props["teamSize"])
                except:
                    raise TypeError(f"Property teamSize must be of type int, got {type(props['teamSize']).__name__}")
    
        # Type check temperatureExtremesVisualized (expected bool)
        if "temperatureExtremesVisualized" in props and props["temperatureExtremesVisualized"] is not None:
            if not isinstance(props["temperatureExtremesVisualized"], bool):
                try:
                    # Attempt to convert
                    props["temperatureExtremesVisualized"] = bool(props["temperatureExtremesVisualized"])
                except:
                    raise TypeError(f"Property temperatureExtremesVisualized must be of type bool, got {type(props['temperatureExtremesVisualized']).__name__}")
    
        # Type check proprietaryTechniquesUsed (expected int)
        if "proprietaryTechniquesUsed" in props and props["proprietaryTechniquesUsed"] is not None:
            if not isinstance(props["proprietaryTechniquesUsed"], int):
                try:
                    # Attempt to convert
                    props["proprietaryTechniquesUsed"] = int(props["proprietaryTechniquesUsed"])
                except:
                    raise TypeError(f"Property proprietaryTechniquesUsed must be of type int, got {type(props['proprietaryTechniquesUsed']).__name__}")
    
        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="PROVIDED_SERVICES_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def based_on(uuid=None, **props):
        """
        Find relationships of type BASED_ON matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check filmHistoryContextualization (expected str)
        if "filmHistoryContextualization" in props and props["filmHistoryContextualization"] is not None:
            if not isinstance(props["filmHistoryContextualization"], str):
                try:
                    # Attempt to convert
                    props["filmHistoryContextualization"] = str(props["filmHistoryContextualization"])
                except:
                    raise TypeError(f"Property filmHistoryContextualization must be of type str, got {type(props['filmHistoryContextualization']).__name__}")
    
        # Type check entertainmentFocus (expected float)
        if "entertainmentFocus" in props and props["entertainmentFocus"] is not None:
            if not isinstance(props["entertainmentFocus"], float):
                try:
                    # Attempt to convert
                    props["entertainmentFocus"] = float(props["entertainmentFocus"])
                except:
                    raise TypeError(f"Property entertainmentFocus must be of type float, got {type(props['entertainmentFocus']).__name__}")
    
        # Type check educationalFocus (expected float)
        if "educationalFocus" in props and props["educationalFocus"] is not None:
            if not isinstance(props["educationalFocus"], float):
                try:
                    # Attempt to convert
                    props["educationalFocus"] = float(props["educationalFocus"])
                except:
                    raise TypeError(f"Property educationalFocus must be of type float, got {type(props['educationalFocus']).__name__}")
    
        # Type check audienceRating (expected float)
        if "audienceRating" in props and props["audienceRating"] is not None:
            if not isinstance(props["audienceRating"], float):
                try:
                    # Attempt to convert
                    props["audienceRating"] = float(props["audienceRating"])
                except:
                    raise TypeError(f"Property audienceRating must be of type float, got {type(props['audienceRating']).__name__}")
    
        # Type check filmElementsFeatured (expected object)
        if "filmElementsFeatured" in props and props["filmElementsFeatured"] is not None:
            if not isinstance(props["filmElementsFeatured"], object):
                try:
                    # Attempt to convert
                    props["filmElementsFeatured"] = object(props["filmElementsFeatured"])
                except:
                    raise TypeError(f"Property filmElementsFeatured must be of type object, got {type(props['filmElementsFeatured']).__name__}")
    
        # Type check originalPropsCurated (expected int)
        if "originalPropsCurated" in props and props["originalPropsCurated"] is not None:
            if not isinstance(props["originalPropsCurated"], int):
                try:
                    # Attempt to convert
                    props["originalPropsCurated"] = int(props["originalPropsCurated"])
                except:
                    raise TypeError(f"Property originalPropsCurated must be of type int, got {type(props['originalPropsCurated']).__name__}")
    
        # Type check filmingTechniqueDemonstrations (expected int)
        if "filmingTechniqueDemonstrations" in props and props["filmingTechniqueDemonstrations"] is not None:
            if not isinstance(props["filmingTechniqueDemonstrations"], int):
                try:
                    # Attempt to convert
                    props["filmingTechniqueDemonstrations"] = int(props["filmingTechniqueDemonstrations"])
                except:
                    raise TypeError(f"Property filmingTechniqueDemonstrations must be of type int, got {type(props['filmingTechniqueDemonstrations']).__name__}")
    
        # Type check culturalImpactMetrics (expected object)
        if "culturalImpactMetrics" in props and props["culturalImpactMetrics"] is not None:
            if not isinstance(props["culturalImpactMetrics"], object):
                try:
                    # Attempt to convert
                    props["culturalImpactMetrics"] = object(props["culturalImpactMetrics"])
                except:
                    raise TypeError(f"Property culturalImpactMetrics must be of type object, got {type(props['culturalImpactMetrics']).__name__}")
    
        # Type check reproductionProps (expected int)
        if "reproductionProps" in props and props["reproductionProps"] is not None:
            if not isinstance(props["reproductionProps"], int):
                try:
                    # Attempt to convert
                    props["reproductionProps"] = int(props["reproductionProps"])
                except:
                    raise TypeError(f"Property reproductionProps must be of type int, got {type(props['reproductionProps']).__name__}")
    
        # Type check rosebudSymbolismExhibits (expected int)
        if "rosebudSymbolismExhibits" in props and props["rosebudSymbolismExhibits"] is not None:
            if not isinstance(props["rosebudSymbolismExhibits"], int):
                try:
                    # Attempt to convert
                    props["rosebudSymbolismExhibits"] = int(props["rosebudSymbolismExhibits"])
                except:
                    raise TypeError(f"Property rosebudSymbolismExhibits must be of type int, got {type(props['rosebudSymbolismExhibits']).__name__}")
    
        # Type check historicalContextualization (expected str)
        if "historicalContextualization" in props and props["historicalContextualization"] is not None:
            if not isinstance(props["historicalContextualization"], str):
                try:
                    # Attempt to convert
                    props["historicalContextualization"] = str(props["historicalContextualization"])
                except:
                    raise TypeError(f"Property historicalContextualization must be of type str, got {type(props['historicalContextualization']).__name__}")
    
        # Type check songPerformanceLocations (expected int)
        if "songPerformanceLocations" in props and props["songPerformanceLocations"] is not None:
            if not isinstance(props["songPerformanceLocations"], int):
                try:
                    # Attempt to convert
                    props["songPerformanceLocations"] = int(props["songPerformanceLocations"])
                except:
                    raise TypeError(f"Property songPerformanceLocations must be of type int, got {type(props['songPerformanceLocations']).__name__}")
    
        # Type check economicContribution (expected int)
        if "economicContribution" in props and props["economicContribution"] is not None:
            if not isinstance(props["economicContribution"], int):
                try:
                    # Attempt to convert
                    props["economicContribution"] = int(props["economicContribution"])
                except:
                    raise TypeError(f"Property economicContribution must be of type int, got {type(props['economicContribution']).__name__}")
    
        # Type check filmingLocationAccuracy (expected str)
        if "filmingLocationAccuracy" in props and props["filmingLocationAccuracy"] is not None:
            if not isinstance(props["filmingLocationAccuracy"], str):
                try:
                    # Attempt to convert
                    props["filmingLocationAccuracy"] = str(props["filmingLocationAccuracy"])
                except:
                    raise TypeError(f"Property filmingLocationAccuracy must be of type str, got {type(props['filmingLocationAccuracy']).__name__}")
    
        # Type check originalSitesCurated (expected int)
        if "originalSitesCurated" in props and props["originalSitesCurated"] is not None:
            if not isinstance(props["originalSitesCurated"], int):
                try:
                    # Attempt to convert
                    props["originalSitesCurated"] = int(props["originalSitesCurated"])
                except:
                    raise TypeError(f"Property originalSitesCurated must be of type int, got {type(props['originalSitesCurated']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="BASED_ON", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def derived_from(uuid=None, **props):
        """
        Find relationships of type DERIVED_FROM matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check educationalImpact (expected str)
        if "educationalImpact" in props and props["educationalImpact"] is not None:
            if not isinstance(props["educationalImpact"], str):
                try:
                    # Attempt to convert
                    props["educationalImpact"] = str(props["educationalImpact"])
                except:
                    raise TypeError(f"Property educationalImpact must be of type str, got {type(props['educationalImpact']).__name__}")
    
        # Type check licensingDeal (expected object)
        if "licensingDeal" in props and props["licensingDeal"] is not None:
            if not isinstance(props["licensingDeal"], object):
                try:
                    # Attempt to convert
                    props["licensingDeal"] = object(props["licensingDeal"])
                except:
                    raise TypeError(f"Property licensingDeal must be of type object, got {type(props['licensingDeal']).__name__}")
    
        # Type check unitsSold (expected int)
        if "unitsSold" in props and props["unitsSold"] is not None:
            if not isinstance(props["unitsSold"], int):
                try:
                    # Attempt to convert
                    props["unitsSold"] = int(props["unitsSold"])
                except:
                    raise TypeError(f"Property unitsSold must be of type int, got {type(props['unitsSold']).__name__}")
    
        # Type check retailersCarrying (expected int)
        if "retailersCarrying" in props and props["retailersCarrying"] is not None:
            if not isinstance(props["retailersCarrying"], int):
                try:
                    # Attempt to convert
                    props["retailersCarrying"] = int(props["retailersCarrying"])
                except:
                    raise TypeError(f"Property retailersCarrying must be of type int, got {type(props['retailersCarrying']).__name__}")
    
        # Type check merchandisingLongevity (expected str)
        if "merchandisingLongevity" in props and props["merchandisingLongevity"] is not None:
            if not isinstance(props["merchandisingLongevity"], str):
                try:
                    # Attempt to convert
                    props["merchandisingLongevity"] = str(props["merchandisingLongevity"])
                except:
                    raise TypeError(f"Property merchandisingLongevity must be of type str, got {type(props['merchandisingLongevity']).__name__}")
    
        # Type check sequelMerchandisingEffect (expected str)
        if "sequelMerchandisingEffect" in props and props["sequelMerchandisingEffect"] is not None:
            if not isinstance(props["sequelMerchandisingEffect"], str):
                try:
                    # Attempt to convert
                    props["sequelMerchandisingEffect"] = str(props["sequelMerchandisingEffect"])
                except:
                    raise TypeError(f"Property sequelMerchandisingEffect must be of type str, got {type(props['sequelMerchandisingEffect']).__name__}")
    
        # Type check geographicalDistribution (expected object)
        if "geographicalDistribution" in props and props["geographicalDistribution"] is not None:
            if not isinstance(props["geographicalDistribution"], object):
                try:
                    # Attempt to convert
                    props["geographicalDistribution"] = object(props["geographicalDistribution"])
                except:
                    raise TypeError(f"Property geographicalDistribution must be of type object, got {type(props['geographicalDistribution']).__name__}")
    
        # Type check brandRecognition (expected float)
        if "brandRecognition" in props and props["brandRecognition"] is not None:
            if not isinstance(props["brandRecognition"], float):
                try:
                    # Attempt to convert
                    props["brandRecognition"] = float(props["brandRecognition"])
                except:
                    raise TypeError(f"Property brandRecognition must be of type float, got {type(props['brandRecognition']).__name__}")
    
        # Type check conservationFundsRaised (expected int)
        if "conservationFundsRaised" in props and props["conservationFundsRaised"] is not None:
            if not isinstance(props["conservationFundsRaised"], int):
                try:
                    # Attempt to convert
                    props["conservationFundsRaised"] = int(props["conservationFundsRaised"])
                except:
                    raise TypeError(f"Property conservationFundsRaised must be of type int, got {type(props['conservationFundsRaised']).__name__}")
    
        # Type check salesDistribution (expected object)
        if "salesDistribution" in props and props["salesDistribution"] is not None:
            if not isinstance(props["salesDistribution"], object):
                try:
                    # Attempt to convert
                    props["salesDistribution"] = object(props["salesDistribution"])
                except:
                    raise TypeError(f"Property salesDistribution must be of type object, got {type(props['salesDistribution']).__name__}")
    
        # Type check digitalCodeInclusion (expected bool)
        if "digitalCodeInclusion" in props and props["digitalCodeInclusion"] is not None:
            if not isinstance(props["digitalCodeInclusion"], bool):
                try:
                    # Attempt to convert
                    props["digitalCodeInclusion"] = bool(props["digitalCodeInclusion"])
                except:
                    raise TypeError(f"Property digitalCodeInclusion must be of type bool, got {type(props['digitalCodeInclusion']).__name__}")
    
        # Type check specialContentHours (expected float)
        if "specialContentHours" in props and props["specialContentHours"] is not None:
            if not isinstance(props["specialContentHours"], float):
                try:
                    # Attempt to convert
                    props["specialContentHours"] = float(props["specialContentHours"])
                except:
                    raise TypeError(f"Property specialContentHours must be of type float, got {type(props['specialContentHours']).__name__}")
    
        # Type check collectibleResaleValue (expected int)
        if "collectibleResaleValue" in props and props["collectibleResaleValue"] is not None:
            if not isinstance(props["collectibleResaleValue"], int):
                try:
                    # Attempt to convert
                    props["collectibleResaleValue"] = int(props["collectibleResaleValue"])
                except:
                    raise TypeError(f"Property collectibleResaleValue must be of type int, got {type(props['collectibleResaleValue']).__name__}")
    
        # Type check reissueVersions (expected int)
        if "reissueVersions" in props and props["reissueVersions"] is not None:
            if not isinstance(props["reissueVersions"], int):
                try:
                    # Attempt to convert
                    props["reissueVersions"] = int(props["reissueVersions"])
                except:
                    raise TypeError(f"Property reissueVersions must be of type int, got {type(props['reissueVersions']).__name__}")
    
        # Type check anniversarySalesBumps (expected int)
        if "anniversarySalesBumps" in props and props["anniversarySalesBumps"] is not None:
            if not isinstance(props["anniversarySalesBumps"], int):
                try:
                    # Attempt to convert
                    props["anniversarySalesBumps"] = int(props["anniversarySalesBumps"])
                except:
                    raise TypeError(f"Property anniversarySalesBumps must be of type int, got {type(props['anniversarySalesBumps']).__name__}")
    
        # Type check collectibleStatus (expected str)
        if "collectibleStatus" in props and props["collectibleStatus"] is not None:
            if not isinstance(props["collectibleStatus"], str):
                try:
                    # Attempt to convert
                    props["collectibleStatus"] = str(props["collectibleStatus"])
                except:
                    raise TypeError(f"Property collectibleStatus must be of type str, got {type(props['collectibleStatus']).__name__}")
    
        # Type check valentinesPeaks (expected int)
        if "valentinesPeaks" in props and props["valentinesPeaks"] is not None:
            if not isinstance(props["valentinesPeaks"], int):
                try:
                    # Attempt to convert
                    props["valentinesPeaks"] = int(props["valentinesPeaks"])
                except:
                    raise TypeError(f"Property valentinesPeaks must be of type int, got {type(props['valentinesPeaks']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="DERIVED_FROM", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def analyzes(uuid=None, **props):
        """
        Find relationships of type ANALYZES matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check culturalComprehensionExpansion (expected str)
        if "culturalComprehensionExpansion" in props and props["culturalComprehensionExpansion"] is not None:
            if not isinstance(props["culturalComprehensionExpansion"], str):
                try:
                    # Attempt to convert
                    props["culturalComprehensionExpansion"] = str(props["culturalComprehensionExpansion"])
                except:
                    raise TypeError(f"Property culturalComprehensionExpansion must be of type str, got {type(props['culturalComprehensionExpansion']).__name__}")
    
        # Type check focusAreas (expected object)
        if "focusAreas" in props and props["focusAreas"] is not None:
            if not isinstance(props["focusAreas"], object):
                try:
                    # Attempt to convert
                    props["focusAreas"] = object(props["focusAreas"])
                except:
                    raise TypeError(f"Property focusAreas must be of type object, got {type(props['focusAreas']).__name__}")
    
        # Type check filmmakingTechniquesExamined (expected int)
        if "filmmakingTechniquesExamined" in props and props["filmmakingTechniquesExamined"] is not None:
            if not isinstance(props["filmmakingTechniquesExamined"], int):
                try:
                    # Attempt to convert
                    props["filmmakingTechniquesExamined"] = int(props["filmmakingTechniquesExamined"])
                except:
                    raise TypeError(f"Property filmmakingTechniquesExamined must be of type int, got {type(props['filmmakingTechniquesExamined']).__name__}")
    
        # Type check criticalThinkingDevelopment (expected str)
        if "criticalThinkingDevelopment" in props and props["criticalThinkingDevelopment"] is not None:
            if not isinstance(props["criticalThinkingDevelopment"], str):
                try:
                    # Attempt to convert
                    props["criticalThinkingDevelopment"] = str(props["criticalThinkingDevelopment"])
                except:
                    raise TypeError(f"Property criticalThinkingDevelopment must be of type str, got {type(props['criticalThinkingDevelopment']).__name__}")
    
        # Type check studentFeedbackScore (expected float)
        if "studentFeedbackScore" in props and props["studentFeedbackScore"] is not None:
            if not isinstance(props["studentFeedbackScore"], float):
                try:
                    # Attempt to convert
                    props["studentFeedbackScore"] = float(props["studentFeedbackScore"])
                except:
                    raise TypeError(f"Property studentFeedbackScore must be of type float, got {type(props['studentFeedbackScore']).__name__}")
    
        # Type check globalAdoption (expected str)
        if "globalAdoption" in props and props["globalAdoption"] is not None:
            if not isinstance(props["globalAdoption"], str):
                try:
                    # Attempt to convert
                    props["globalAdoption"] = str(props["globalAdoption"])
                except:
                    raise TypeError(f"Property globalAdoption must be of type str, got {type(props['globalAdoption']).__name__}")
    
        # Type check analyticalApproaches (expected object)
        if "analyticalApproaches" in props and props["analyticalApproaches"] is not None:
            if not isinstance(props["analyticalApproaches"], object):
                try:
                    # Attempt to convert
                    props["analyticalApproaches"] = object(props["analyticalApproaches"])
                except:
                    raise TypeError(f"Property analyticalApproaches must be of type object, got {type(props['analyticalApproaches']).__name__}")
    
        # Type check academicPaperGeneration (expected int)
        if "academicPaperGeneration" in props and props["academicPaperGeneration"] is not None:
            if not isinstance(props["academicPaperGeneration"], int):
                try:
                    # Attempt to convert
                    props["academicPaperGeneration"] = int(props["academicPaperGeneration"])
                except:
                    raise TypeError(f"Property academicPaperGeneration must be of type int, got {type(props['academicPaperGeneration']).__name__}")
    
        # Type check crossCulturalDialoguePromotion (expected str)
        if "crossCulturalDialoguePromotion" in props and props["crossCulturalDialoguePromotion"] is not None:
            if not isinstance(props["crossCulturalDialoguePromotion"], str):
                try:
                    # Attempt to convert
                    props["crossCulturalDialoguePromotion"] = str(props["crossCulturalDialoguePromotion"])
                except:
                    raise TypeError(f"Property crossCulturalDialoguePromotion must be of type str, got {type(props['crossCulturalDialoguePromotion']).__name__}")
    
        # Type check focusDistribution (expected object)
        if "focusDistribution" in props and props["focusDistribution"] is not None:
            if not isinstance(props["focusDistribution"], object):
                try:
                    # Attempt to convert
                    props["focusDistribution"] = object(props["focusDistribution"])
                except:
                    raise TypeError(f"Property focusDistribution must be of type object, got {type(props['focusDistribution']).__name__}")
    
        # Type check filmTechniqueRecognition (expected str)
        if "filmTechniqueRecognition" in props and props["filmTechniqueRecognition"] is not None:
            if not isinstance(props["filmTechniqueRecognition"], str):
                try:
                    # Attempt to convert
                    props["filmTechniqueRecognition"] = str(props["filmTechniqueRecognition"])
                except:
                    raise TypeError(f"Property filmTechniqueRecognition must be of type str, got {type(props['filmTechniqueRecognition']).__name__}")
    
        # Type check filmStudiesImpact (expected str)
        if "filmStudiesImpact" in props and props["filmStudiesImpact"] is not None:
            if not isinstance(props["filmStudiesImpact"], str):
                try:
                    # Attempt to convert
                    props["filmStudiesImpact"] = str(props["filmStudiesImpact"])
                except:
                    raise TypeError(f"Property filmStudiesImpact must be of type str, got {type(props['filmStudiesImpact']).__name__}")
    
        # Type check shotByShot (expected bool)
        if "shotByShot" in props and props["shotByShot"] is not None:
            if not isinstance(props["shotByShot"], bool):
                try:
                    # Attempt to convert
                    props["shotByShot"] = bool(props["shotByShot"])
                except:
                    raise TypeError(f"Property shotByShot must be of type bool, got {type(props['shotByShot']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="ANALYZES", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def preserved(uuid=None, **props):
        """
        Find relationships of type PRESERVED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check historicalConsultants (expected int)
        if "historicalConsultants" in props and props["historicalConsultants"] is not None:
            if not isinstance(props["historicalConsultants"], int):
                try:
                    # Attempt to convert
                    props["historicalConsultants"] = int(props["historicalConsultants"])
                except:
                    raise TypeError(f"Property historicalConsultants must be of type int, got {type(props['historicalConsultants']).__name__}")
    
        # Type check frameCorrectionCount (expected int)
        if "frameCorrectionCount" in props and props["frameCorrectionCount"] is not None:
            if not isinstance(props["frameCorrectionCount"], int):
                try:
                    # Attempt to convert
                    props["frameCorrectionCount"] = int(props["frameCorrectionCount"])
                except:
                    raise TypeError(f"Property frameCorrectionCount must be of type int, got {type(props['frameCorrectionCount']).__name__}")
    
        # Type check audioSamplingUnit (expected str)
        if "audioSamplingUnit" in props and props["audioSamplingUnit"] is not None:
            if not isinstance(props["audioSamplingUnit"], str):
                try:
                    # Attempt to convert
                    props["audioSamplingUnit"] = str(props["audioSamplingUnit"])
                except:
                    raise TypeError(f"Property audioSamplingUnit must be of type str, got {type(props['audioSamplingUnit']).__name__}")
    
        # Type check audioSamplingRate (expected int)
        if "audioSamplingRate" in props and props["audioSamplingRate"] is not None:
            if not isinstance(props["audioSamplingRate"], int):
                try:
                    # Attempt to convert
                    props["audioSamplingRate"] = int(props["audioSamplingRate"])
                except:
                    raise TypeError(f"Property audioSamplingRate must be of type int, got {type(props['audioSamplingRate']).__name__}")
    
        # Type check challengeComplexity (expected object)
        if "challengeComplexity" in props and props["challengeComplexity"] is not None:
            if not isinstance(props["challengeComplexity"], object):
                try:
                    # Attempt to convert
                    props["challengeComplexity"] = object(props["challengeComplexity"])
                except:
                    raise TypeError(f"Property challengeComplexity must be of type object, got {type(props['challengeComplexity']).__name__}")
    
        # Type check frameTotalCount (expected int)
        if "frameTotalCount" in props and props["frameTotalCount"] is not None:
            if not isinstance(props["frameTotalCount"], int):
                try:
                    # Attempt to convert
                    props["frameTotalCount"] = int(props["frameTotalCount"])
                except:
                    raise TypeError(f"Property frameTotalCount must be of type int, got {type(props['frameTotalCount']).__name__}")
    
        # Type check preservationStandard (expected str)
        if "preservationStandard" in props and props["preservationStandard"] is not None:
            if not isinstance(props["preservationStandard"], str):
                try:
                    # Attempt to convert
                    props["preservationStandard"] = str(props["preservationStandard"])
                except:
                    raise TypeError(f"Property preservationStandard must be of type str, got {type(props['preservationStandard']).__name__}")
    
        # Type check originalDamagePercentage (expected float)
        if "originalDamagePercentage" in props and props["originalDamagePercentage"] is not None:
            if not isinstance(props["originalDamagePercentage"], float):
                try:
                    # Attempt to convert
                    props["originalDamagePercentage"] = float(props["originalDamagePercentage"])
                except:
                    raise TypeError(f"Property originalDamagePercentage must be of type float, got {type(props['originalDamagePercentage']).__name__}")
    
        # Type check restorationFidelity (expected float)
        if "restorationFidelity" in props and props["restorationFidelity"] is not None:
            if not isinstance(props["restorationFidelity"], float):
                try:
                    # Attempt to convert
                    props["restorationFidelity"] = float(props["restorationFidelity"])
                except:
                    raise TypeError(f"Property restorationFidelity must be of type float, got {type(props['restorationFidelity']).__name__}")
    
        # Type check audioChannelsPreserved (expected int)
        if "audioChannelsPreserved" in props and props["audioChannelsPreserved"] is not None:
            if not isinstance(props["audioChannelsPreserved"], int):
                try:
                    # Attempt to convert
                    props["audioChannelsPreserved"] = int(props["audioChannelsPreserved"])
                except:
                    raise TypeError(f"Property audioChannelsPreserved must be of type int, got {type(props['audioChannelsPreserved']).__name__}")
    
        # Type check primaryRestorationChallenges (expected object)
        if "primaryRestorationChallenges" in props and props["primaryRestorationChallenges"] is not None:
            if not isinstance(props["primaryRestorationChallenges"], object):
                try:
                    # Attempt to convert
                    props["primaryRestorationChallenges"] = object(props["primaryRestorationChallenges"])
                except:
                    raise TypeError(f"Property primaryRestorationChallenges must be of type object, got {type(props['primaryRestorationChallenges']).__name__}")
    
        # Type check academicValidation (expected str)
        if "academicValidation" in props and props["academicValidation"] is not None:
            if not isinstance(props["academicValidation"], str):
                try:
                    # Attempt to convert
                    props["academicValidation"] = str(props["academicValidation"])
                except:
                    raise TypeError(f"Property academicValidation must be of type str, got {type(props['academicValidation']).__name__}")
    
        # Type check technologiesUsed (expected object)
        if "technologiesUsed" in props and props["technologiesUsed"] is not None:
            if not isinstance(props["technologiesUsed"], object):
                try:
                    # Attempt to convert
                    props["technologiesUsed"] = object(props["technologiesUsed"])
                except:
                    raise TypeError(f"Property technologiesUsed must be of type object, got {type(props['technologiesUsed']).__name__}")
    
        # Type check archivalStorageLocations (expected object)
        if "archivalStorageLocations" in props and props["archivalStorageLocations"] is not None:
            if not isinstance(props["archivalStorageLocations"], object):
                try:
                    # Attempt to convert
                    props["archivalStorageLocations"] = object(props["archivalStorageLocations"])
                except:
                    raise TypeError(f"Property archivalStorageLocations must be of type object, got {type(props['archivalStorageLocations']).__name__}")
    
        # Type check directorInvolvement (expected str)
        if "directorInvolvement" in props and props["directorInvolvement"] is not None:
            if not isinstance(props["directorInvolvement"], str):
                try:
                    # Attempt to convert
                    props["directorInvolvement"] = str(props["directorInvolvement"])
                except:
                    raise TypeError(f"Property directorInvolvement must be of type str, got {type(props['directorInvolvement']).__name__}")
    
        # Type check physicalPreservationCopies (expected int)
        if "physicalPreservationCopies" in props and props["physicalPreservationCopies"] is not None:
            if not isinstance(props["physicalPreservationCopies"], int):
                try:
                    # Attempt to convert
                    props["physicalPreservationCopies"] = int(props["physicalPreservationCopies"])
                except:
                    raise TypeError(f"Property physicalPreservationCopies must be of type int, got {type(props['physicalPreservationCopies']).__name__}")
    
        # Type check publicReception (expected str)
        if "publicReception" in props and props["publicReception"] is not None:
            if not isinstance(props["publicReception"], str):
                try:
                    # Attempt to convert
                    props["publicReception"] = str(props["publicReception"])
                except:
                    raise TypeError(f"Property publicReception must be of type str, got {type(props['publicReception']).__name__}")
    
        # Type check cinematographerConsultation (expected str)
        if "cinematographerConsultation" in props and props["cinematographerConsultation"] is not None:
            if not isinstance(props["cinematographerConsultation"], str):
                try:
                    # Attempt to convert
                    props["cinematographerConsultation"] = str(props["cinematographerConsultation"])
                except:
                    raise TypeError(f"Property cinematographerConsultation must be of type str, got {type(props['cinematographerConsultation']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="PRESERVED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def engaged_with(uuid=None, **props):
        """
        Find relationships of type ENGAGED_WITH matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check reissuesCampaigns (expected int)
        if "reissuesCampaigns" in props and props["reissuesCampaigns"] is not None:
            if not isinstance(props["reissuesCampaigns"], int):
                try:
                    # Attempt to convert
                    props["reissuesCampaigns"] = int(props["reissuesCampaigns"])
                except:
                    raise TypeError(f"Property reissuesCampaigns must be of type int, got {type(props['reissuesCampaigns']).__name__}")
    
        # Type check reviewsSubmitted (expected int)
        if "reviewsSubmitted" in props and props["reviewsSubmitted"] is not None:
            if not isinstance(props["reviewsSubmitted"], int):
                try:
                    # Attempt to convert
                    props["reviewsSubmitted"] = int(props["reviewsSubmitted"])
                except:
                    raise TypeError(f"Property reviewsSubmitted must be of type int, got {type(props['reviewsSubmitted']).__name__}")
    
        # Type check preReleaseEvents (expected int)
        if "preReleaseEvents" in props and props["preReleaseEvents"] is not None:
            if not isinstance(props["preReleaseEvents"], int):
                try:
                    # Attempt to convert
                    props["preReleaseEvents"] = int(props["preReleaseEvents"])
                except:
                    raise TypeError(f"Property preReleaseEvents must be of type int, got {type(props['preReleaseEvents']).__name__}")
    
        # Type check anticipationScore (expected float)
        if "anticipationScore" in props and props["anticipationScore"] is not None:
            if not isinstance(props["anticipationScore"], float):
                try:
                    # Attempt to convert
                    props["anticipationScore"] = float(props["anticipationScore"])
                except:
                    raise TypeError(f"Property anticipationScore must be of type float, got {type(props['anticipationScore']).__name__}")
    
        # Type check postReleaseEvents (expected int)
        if "postReleaseEvents" in props and props["postReleaseEvents"] is not None:
            if not isinstance(props["postReleaseEvents"], int):
                try:
                    # Attempt to convert
                    props["postReleaseEvents"] = int(props["postReleaseEvents"])
                except:
                    raise TypeError(f"Property postReleaseEvents must be of type int, got {type(props['postReleaseEvents']).__name__}")
    
        # Type check theoriesGenerated (expected int)
        if "theoriesGenerated" in props and props["theoriesGenerated"] is not None:
            if not isinstance(props["theoriesGenerated"], int):
                try:
                    # Attempt to convert
                    props["theoriesGenerated"] = int(props["theoriesGenerated"])
                except:
                    raise TypeError(f"Property theoriesGenerated must be of type int, got {type(props['theoriesGenerated']).__name__}")
    
        # Type check merchandiseSales (expected int)
        if "merchandiseSales" in props and props["merchandiseSales"] is not None:
            if not isinstance(props["merchandiseSales"], int):
                try:
                    # Attempt to convert
                    props["merchandiseSales"] = int(props["merchandiseSales"])
                except:
                    raise TypeError(f"Property merchandiseSales must be of type int, got {type(props['merchandiseSales']).__name__}")
    
        # Type check onlineDiscussions (expected int)
        if "onlineDiscussions" in props and props["onlineDiscussions"] is not None:
            if not isinstance(props["onlineDiscussions"], int):
                try:
                    # Attempt to convert
                    props["onlineDiscussions"] = int(props["onlineDiscussions"])
                except:
                    raise TypeError(f"Property onlineDiscussions must be of type int, got {type(props['onlineDiscussions']).__name__}")
    
        # Type check averageRating (expected float)
        if "averageRating" in props and props["averageRating"] is not None:
            if not isinstance(props["averageRating"], float):
                try:
                    # Attempt to convert
                    props["averageRating"] = float(props["averageRating"])
                except:
                    raise TypeError(f"Property averageRating must be of type float, got {type(props['averageRating']).__name__}")
    
        # Type check sequelAnticipation (expected float)
        if "sequelAnticipation" in props and props["sequelAnticipation"] is not None:
            if not isinstance(props["sequelAnticipation"], float):
                try:
                    # Attempt to convert
                    props["sequelAnticipation"] = float(props["sequelAnticipation"])
                except:
                    raise TypeError(f"Property sequelAnticipation must be of type float, got {type(props['sequelAnticipation']).__name__}")
    
        # Type check commemorationEvents (expected object)
        if "commemorationEvents" in props and props["commemorationEvents"] is not None:
            if not isinstance(props["commemorationEvents"], object):
                try:
                    # Attempt to convert
                    props["commemorationEvents"] = object(props["commemorationEvents"])
                except:
                    raise TypeError(f"Property commemorationEvents must be of type object, got {type(props['commemorationEvents']).__name__}")
    
        # Type check digitalPlatformRevival (expected str)
        if "digitalPlatformRevival" in props and props["digitalPlatformRevival"] is not None:
            if not isinstance(props["digitalPlatformRevival"], str):
                try:
                    # Attempt to convert
                    props["digitalPlatformRevival"] = str(props["digitalPlatformRevival"])
                except:
                    raise TypeError(f"Property digitalPlatformRevival must be of type str, got {type(props['digitalPlatformRevival']).__name__}")
    
        # Type check debateTopics (expected object)
        if "debateTopics" in props and props["debateTopics"] is not None:
            if not isinstance(props["debateTopics"], object):
                try:
                    # Attempt to convert
                    props["debateTopics"] = object(props["debateTopics"])
                except:
                    raise TypeError(f"Property debateTopics must be of type object, got {type(props['debateTopics']).__name__}")
    
        # Type check museumExhibits (expected int)
        if "museumExhibits" in props and props["museumExhibits"] is not None:
            if not isinstance(props["museumExhibits"], int):
                try:
                    # Attempt to convert
                    props["museumExhibits"] = int(props["museumExhibits"])
                except:
                    raise TypeError(f"Property museumExhibits must be of type int, got {type(props['museumExhibits']).__name__}")
    
        # Type check fanTheories (expected int)
        if "fanTheories" in props and props["fanTheories"] is not None:
            if not isinstance(props["fanTheories"], int):
                try:
                    # Attempt to convert
                    props["fanTheories"] = int(props["fanTheories"])
                except:
                    raise TypeError(f"Property fanTheories must be of type int, got {type(props['fanTheories']).__name__}")
    
        # Type check shipwreckExpeditions (expected int)
        if "shipwreckExpeditions" in props and props["shipwreckExpeditions"] is not None:
            if not isinstance(props["shipwreckExpeditions"], int):
                try:
                    # Attempt to convert
                    props["shipwreckExpeditions"] = int(props["shipwreckExpeditions"])
                except:
                    raise TypeError(f"Property shipwreckExpeditions must be of type int, got {type(props['shipwreckExpeditions']).__name__}")
    
        # Type check romanticFocus (expected float)
        if "romanticFocus" in props and props["romanticFocus"] is not None:
            if not isinstance(props["romanticFocus"], float):
                try:
                    # Attempt to convert
                    props["romanticFocus"] = float(props["romanticFocus"])
                except:
                    raise TypeError(f"Property romanticFocus must be of type float, got {type(props['romanticFocus']).__name__}")
    
        # Type check historicalFocus (expected float)
        if "historicalFocus" in props and props["historicalFocus"] is not None:
            if not isinstance(props["historicalFocus"], float):
                try:
                    # Attempt to convert
                    props["historicalFocus"] = float(props["historicalFocus"])
                except:
                    raise TypeError(f"Property historicalFocus must be of type float, got {type(props['historicalFocus']).__name__}")
    
        # Type check anniversaryCelebrations (expected int)
        if "anniversaryCelebrations" in props and props["anniversaryCelebrations"] is not None:
            if not isinstance(props["anniversaryCelebrations"], int):
                try:
                    # Attempt to convert
                    props["anniversaryCelebrations"] = int(props["anniversaryCelebrations"])
                except:
                    raise TypeError(f"Property anniversaryCelebrations must be of type int, got {type(props['anniversaryCelebrations']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="ENGAGED_WITH", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def designed_costumes_for(uuid=None, **props):
        """
        Find relationships of type DESIGNED_COSTUMES_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check awardWins (expected int)
        if "awardWins" in props and props["awardWins"] is not None:
            if not isinstance(props["awardWins"], int):
                try:
                    # Attempt to convert
                    props["awardWins"] = int(props["awardWins"])
                except:
                    raise TypeError(f"Property awardWins must be of type int, got {type(props['awardWins']).__name__}")
    
        # Type check costumesCreated (expected int)
        if "costumesCreated" in props and props["costumesCreated"] is not None:
            if not isinstance(props["costumesCreated"], int):
                try:
                    # Attempt to convert
                    props["costumesCreated"] = int(props["costumesCreated"])
                except:
                    raise TypeError(f"Property costumesCreated must be of type int, got {type(props['costumesCreated']).__name__}")
    
        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Type check awardNominations (expected int)
        if "awardNominations" in props and props["awardNominations"] is not None:
            if not isinstance(props["awardNominations"], int):
                try:
                    # Attempt to convert
                    props["awardNominations"] = int(props["awardNominations"])
                except:
                    raise TypeError(f"Property awardNominations must be of type int, got {type(props['awardNominations']).__name__}")
    
        # Type check completionDate (expected object)
        if "completionDate" in props and props["completionDate"] is not None:
            if not isinstance(props["completionDate"], object):
                try:
                    # Attempt to convert
                    props["completionDate"] = object(props["completionDate"])
                except:
                    raise TypeError(f"Property completionDate must be of type object, got {type(props['completionDate']).__name__}")
    
        # Type check startDate (expected object)
        if "startDate" in props and props["startDate"] is not None:
            if not isinstance(props["startDate"], object):
                try:
                    # Attempt to convert
                    props["startDate"] = object(props["startDate"])
                except:
                    raise TypeError(f"Property startDate must be of type object, got {type(props['startDate']).__name__}")
    
        # Type check budget (expected int)
        if "budget" in props and props["budget"] is not None:
            if not isinstance(props["budget"], int):
                try:
                    # Attempt to convert
                    props["budget"] = int(props["budget"])
                except:
                    raise TypeError(f"Property budget must be of type int, got {type(props['budget']).__name__}")
    
        # Type check researchHours (expected int)
        if "researchHours" in props and props["researchHours"] is not None:
            if not isinstance(props["researchHours"], int):
                try:
                    # Attempt to convert
                    props["researchHours"] = int(props["researchHours"])
                except:
                    raise TypeError(f"Property researchHours must be of type int, got {type(props['researchHours']).__name__}")
    
        # Type check specialCostumes (expected object)
        if "specialCostumes" in props and props["specialCostumes"] is not None:
            if not isinstance(props["specialCostumes"], object):
                try:
                    # Attempt to convert
                    props["specialCostumes"] = object(props["specialCostumes"])
                except:
                    raise TypeError(f"Property specialCostumes must be of type object, got {type(props['specialCostumes']).__name__}")
    
        # Type check conceptualDesigns (expected int)
        if "conceptualDesigns" in props and props["conceptualDesigns"] is not None:
            if not isinstance(props["conceptualDesigns"], int):
                try:
                    # Attempt to convert
                    props["conceptualDesigns"] = int(props["conceptualDesigns"])
                except:
                    raise TypeError(f"Property conceptualDesigns must be of type int, got {type(props['conceptualDesigns']).__name__}")
    
        # Type check historicalAccuracy (expected str)
        if "historicalAccuracy" in props and props["historicalAccuracy"] is not None:
            if not isinstance(props["historicalAccuracy"], str):
                try:
                    # Attempt to convert
                    props["historicalAccuracy"] = str(props["historicalAccuracy"])
                except:
                    raise TypeError(f"Property historicalAccuracy must be of type str, got {type(props['historicalAccuracy']).__name__}")
    
        # Type check fabricsUsed (expected int)
        if "fabricsUsed" in props and props["fabricsUsed"] is not None:
            if not isinstance(props["fabricsUsed"], int):
                try:
                    # Attempt to convert
                    props["fabricsUsed"] = int(props["fabricsUsed"])
                except:
                    raise TypeError(f"Property fabricsUsed must be of type int, got {type(props['fabricsUsed']).__name__}")
    
        # Type check blackAndWhiteConsiderations (expected bool)
        if "blackAndWhiteConsiderations" in props and props["blackAndWhiteConsiderations"] is not None:
            if not isinstance(props["blackAndWhiteConsiderations"], bool):
                try:
                    # Attempt to convert
                    props["blackAndWhiteConsiderations"] = bool(props["blackAndWhiteConsiderations"])
                except:
                    raise TypeError(f"Property blackAndWhiteConsiderations must be of type bool, got {type(props['blackAndWhiteConsiderations']).__name__}")
    
        # Type check psychologicalSignificance (expected str)
        if "psychologicalSignificance" in props and props["psychologicalSignificance"] is not None:
            if not isinstance(props["psychologicalSignificance"], str):
                try:
                    # Attempt to convert
                    props["psychologicalSignificance"] = str(props["psychologicalSignificance"])
                except:
                    raise TypeError(f"Property psychologicalSignificance must be of type str, got {type(props['psychologicalSignificance']).__name__}")
    
        # Type check costumesSubmerged (expected int)
        if "costumesSubmerged" in props and props["costumesSubmerged"] is not None:
            if not isinstance(props["costumesSubmerged"], int):
                try:
                    # Attempt to convert
                    props["costumesSubmerged"] = int(props["costumesSubmerged"])
                except:
                    raise TypeError(f"Property costumesSubmerged must be of type int, got {type(props['costumesSubmerged']).__name__}")
    
        # Type check functionalDesign (expected bool)
        if "functionalDesign" in props and props["functionalDesign"] is not None:
            if not isinstance(props["functionalDesign"], bool):
                try:
                    # Attempt to convert
                    props["functionalDesign"] = bool(props["functionalDesign"])
                except:
                    raise TypeError(f"Property functionalDesign must be of type bool, got {type(props['functionalDesign']).__name__}")
    
        # Type check characterEmphasis (expected str)
        if "characterEmphasis" in props and props["characterEmphasis"] is not None:
            if not isinstance(props["characterEmphasis"], str):
                try:
                    # Attempt to convert
                    props["characterEmphasis"] = str(props["characterEmphasis"])
                except:
                    raise TypeError(f"Property characterEmphasis must be of type str, got {type(props['characterEmphasis']).__name__}")
    
        # Type check batSuitIterations (expected int)
        if "batSuitIterations" in props and props["batSuitIterations"] is not None:
            if not isinstance(props["batSuitIterations"], int):
                try:
                    # Attempt to convert
                    props["batSuitIterations"] = int(props["batSuitIterations"])
                except:
                    raise TypeError(f"Property batSuitIterations must be of type int, got {type(props['batSuitIterations']).__name__}")
    
        # Type check colorSymbolism (expected str)
        if "colorSymbolism" in props and props["colorSymbolism"] is not None:
            if not isinstance(props["colorSymbolism"], str):
                try:
                    # Attempt to convert
                    props["colorSymbolism"] = str(props["colorSymbolism"])
                except:
                    raise TypeError(f"Property colorSymbolism must be of type str, got {type(props['colorSymbolism']).__name__}")
    
        # Type check specificChallenges (expected object)
        if "specificChallenges" in props and props["specificChallenges"] is not None:
            if not isinstance(props["specificChallenges"], object):
                try:
                    # Attempt to convert
                    props["specificChallenges"] = object(props["specificChallenges"])
                except:
                    raise TypeError(f"Property specificChallenges must be of type object, got {type(props['specificChallenges']).__name__}")
    
        # Type check characterProgression (expected str)
        if "characterProgression" in props and props["characterProgression"] is not None:
            if not isinstance(props["characterProgression"], str):
                try:
                    # Attempt to convert
                    props["characterProgression"] = str(props["characterProgression"])
                except:
                    raise TypeError(f"Property characterProgression must be of type str, got {type(props['characterProgression']).__name__}")
    
        # Type check fabricsSourced (expected object)
        if "fabricsSourced" in props and props["fabricsSourced"] is not None:
            if not isinstance(props["fabricsSourced"], object):
                try:
                    # Attempt to convert
                    props["fabricsSourced"] = object(props["fabricsSourced"])
                except:
                    raise TypeError(f"Property fabricsSourced must be of type object, got {type(props['fabricsSourced']).__name__}")
    
        # Type check fabricCost (expected int)
        if "fabricCost" in props and props["fabricCost"] is not None:
            if not isinstance(props["fabricCost"], int):
                try:
                    # Attempt to convert
                    props["fabricCost"] = int(props["fabricCost"])
                except:
                    raise TypeError(f"Property fabricCost must be of type int, got {type(props['fabricCost']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="DESIGNED_COSTUMES_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def influenced(uuid=None, **props):
        """
        Find relationships of type INFLUENCED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check influenceStrength (expected str)
        if "influenceStrength" in props and props["influenceStrength"] is not None:
            if not isinstance(props["influenceStrength"], str):
                try:
                    # Attempt to convert
                    props["influenceStrength"] = str(props["influenceStrength"])
                except:
                    raise TypeError(f"Property influenceStrength must be of type str, got {type(props['influenceStrength']).__name__}")
    
        # Type check directInfluence (expected bool)
        if "directInfluence" in props and props["directInfluence"] is not None:
            if not isinstance(props["directInfluence"], bool):
                try:
                    # Attempt to convert
                    props["directInfluence"] = bool(props["directInfluence"])
                except:
                    raise TypeError(f"Property directInfluence must be of type bool, got {type(props['directInfluence']).__name__}")
    
        # Type check cinematicTechniques (expected object)
        if "cinematicTechniques" in props and props["cinematicTechniques"] is not None:
            if not isinstance(props["cinematicTechniques"], object):
                try:
                    # Attempt to convert
                    props["cinematicTechniques"] = object(props["cinematicTechniques"])
                except:
                    raise TypeError(f"Property cinematicTechniques must be of type object, got {type(props['cinematicTechniques']).__name__}")
    
        # Type check mentionedInInterviews (expected int)
        if "mentionedInInterviews" in props and props["mentionedInInterviews"] is not None:
            if not isinstance(props["mentionedInInterviews"], int):
                try:
                    # Attempt to convert
                    props["mentionedInInterviews"] = int(props["mentionedInInterviews"])
                except:
                    raise TypeError(f"Property mentionedInInterviews must be of type int, got {type(props['mentionedInInterviews']).__name__}")
    
        # Type check startYear (expected int)
        if "startYear" in props and props["startYear"] is not None:
            if not isinstance(props["startYear"], int):
                try:
                    # Attempt to convert
                    props["startYear"] = int(props["startYear"])
                except:
                    raise TypeError(f"Property startYear must be of type int, got {type(props['startYear']).__name__}")
    
        # Type check culturalConnection (expected str)
        if "culturalConnection" in props and props["culturalConnection"] is not None:
            if not isinstance(props["culturalConnection"], str):
                try:
                    # Attempt to convert
                    props["culturalConnection"] = str(props["culturalConnection"])
                except:
                    raise TypeError(f"Property culturalConnection must be of type str, got {type(props['culturalConnection']).__name__}")
    
        # Type check technicalInfluence (expected str)
        if "technicalInfluence" in props and props["technicalInfluence"] is not None:
            if not isinstance(props["technicalInfluence"], str):
                try:
                    # Attempt to convert
                    props["technicalInfluence"] = str(props["technicalInfluence"])
                except:
                    raise TypeError(f"Property technicalInfluence must be of type str, got {type(props['technicalInfluence']).__name__}")
    
        # Type check academicRecognition (expected str)
        if "academicRecognition" in props and props["academicRecognition"] is not None:
            if not isinstance(props["academicRecognition"], str):
                try:
                    # Attempt to convert
                    props["academicRecognition"] = str(props["academicRecognition"])
                except:
                    raise TypeError(f"Property academicRecognition must be of type str, got {type(props['academicRecognition']).__name__}")
    
        # Type check industryImpact (expected str)
        if "industryImpact" in props and props["industryImpact"] is not None:
            if not isinstance(props["industryImpact"], str):
                try:
                    # Attempt to convert
                    props["industryImpact"] = str(props["industryImpact"])
                except:
                    raise TypeError(f"Property industryImpact must be of type str, got {type(props['industryImpact']).__name__}")
    
        # Type check styleContinuity (expected str)
        if "styleContinuity" in props and props["styleContinuity"] is not None:
            if not isinstance(props["styleContinuity"], str):
                try:
                    # Attempt to convert
                    props["styleContinuity"] = str(props["styleContinuity"])
                except:
                    raise TypeError(f"Property styleContinuity must be of type str, got {type(props['styleContinuity']).__name__}")
    
        # Type check aspectsInfluenced (expected object)
        if "aspectsInfluenced" in props and props["aspectsInfluenced"] is not None:
            if not isinstance(props["aspectsInfluenced"], object):
                try:
                    # Attempt to convert
                    props["aspectsInfluenced"] = object(props["aspectsInfluenced"])
                except:
                    raise TypeError(f"Property aspectsInfluenced must be of type object, got {type(props['aspectsInfluenced']).__name__}")
    
        # Type check directorsAcknowledged (expected bool)
        if "directorsAcknowledged" in props and props["directorsAcknowledged"] is not None:
            if not isinstance(props["directorsAcknowledged"], bool):
                try:
                    # Attempt to convert
                    props["directorsAcknowledged"] = bool(props["directorsAcknowledged"])
                except:
                    raise TypeError(f"Property directorsAcknowledged must be of type bool, got {type(props['directorsAcknowledged']).__name__}")
    
        # Type check eastAsianCinemaLegacy (expected str)
        if "eastAsianCinemaLegacy" in props and props["eastAsianCinemaLegacy"] is not None:
            if not isinstance(props["eastAsianCinemaLegacy"], str):
                try:
                    # Attempt to convert
                    props["eastAsianCinemaLegacy"] = str(props["eastAsianCinemaLegacy"])
                except:
                    raise TypeError(f"Property eastAsianCinemaLegacy must be of type str, got {type(props['eastAsianCinemaLegacy']).__name__}")
    
        # Type check crossCulturalImpact (expected str)
        if "crossCulturalImpact" in props and props["crossCulturalImpact"] is not None:
            if not isinstance(props["crossCulturalImpact"], str):
                try:
                    # Attempt to convert
                    props["crossCulturalImpact"] = str(props["crossCulturalImpact"])
                except:
                    raise TypeError(f"Property crossCulturalImpact must be of type str, got {type(props['crossCulturalImpact']).__name__}")
    
        # Type check mutualRespect (expected str)
        if "mutualRespect" in props and props["mutualRespect"] is not None:
            if not isinstance(props["mutualRespect"], str):
                try:
                    # Attempt to convert
                    props["mutualRespect"] = str(props["mutualRespect"])
                except:
                    raise TypeError(f"Property mutualRespect must be of type str, got {type(props['mutualRespect']).__name__}")
    
        # Type check cinematic_techniques (expected object)
        if "cinematic_techniques" in props and props["cinematic_techniques"] is not None:
            if not isinstance(props["cinematic_techniques"], object):
                try:
                    # Attempt to convert
                    props["cinematic_techniques"] = object(props["cinematic_techniques"])
                except:
                    raise TypeError(f"Property cinematic_techniques must be of type object, got {type(props['cinematic_techniques']).__name__}")
    
        # Type check laterSupport (expected str)
        if "laterSupport" in props and props["laterSupport"] is not None:
            if not isinstance(props["laterSupport"], str):
                try:
                    # Attempt to convert
                    props["laterSupport"] = str(props["laterSupport"])
                except:
                    raise TypeError(f"Property laterSupport must be of type str, got {type(props['laterSupport']).__name__}")
    
        # Type check publicAcknowledgement (expected bool)
        if "publicAcknowledgement" in props and props["publicAcknowledgement"] is not None:
            if not isinstance(props["publicAcknowledgement"], bool):
                try:
                    # Attempt to convert
                    props["publicAcknowledgement"] = bool(props["publicAcknowledgement"])
                except:
                    raise TypeError(f"Property publicAcknowledgement must be of type bool, got {type(props['publicAcknowledgement']).__name__}")
    
        # Type check narrativeApproaches (expected object)
        if "narrativeApproaches" in props and props["narrativeApproaches"] is not None:
            if not isinstance(props["narrativeApproaches"], object):
                try:
                    # Attempt to convert
                    props["narrativeApproaches"] = object(props["narrativeApproaches"])
                except:
                    raise TypeError(f"Property narrativeApproaches must be of type object, got {type(props['narrativeApproaches']).__name__}")
    
        # Type check narrativeConnection (expected str)
        if "narrativeConnection" in props and props["narrativeConnection"] is not None:
            if not isinstance(props["narrativeConnection"], str):
                try:
                    # Attempt to convert
                    props["narrativeConnection"] = str(props["narrativeConnection"])
                except:
                    raise TypeError(f"Property narrativeConnection must be of type str, got {type(props['narrativeConnection']).__name__}")
    
        # Type check creativeTeamOverlap (expected float)
        if "creativeTeamOverlap" in props and props["creativeTeamOverlap"] is not None:
            if not isinstance(props["creativeTeamOverlap"], float):
                try:
                    # Attempt to convert
                    props["creativeTeamOverlap"] = float(props["creativeTeamOverlap"])
                except:
                    raise TypeError(f"Property creativeTeamOverlap must be of type float, got {type(props['creativeTeamOverlap']).__name__}")
    
        # Type check expandedThemes (expected object)
        if "expandedThemes" in props and props["expandedThemes"] is not None:
            if not isinstance(props["expandedThemes"], object):
                try:
                    # Attempt to convert
                    props["expandedThemes"] = object(props["expandedThemes"])
                except:
                    raise TypeError(f"Property expandedThemes must be of type object, got {type(props['expandedThemes']).__name__}")
    
        # Type check academicAnalysis (expected str)
        if "academicAnalysis" in props and props["academicAnalysis"] is not None:
            if not isinstance(props["academicAnalysis"], str):
                try:
                    # Attempt to convert
                    props["academicAnalysis"] = str(props["academicAnalysis"])
                except:
                    raise TypeError(f"Property academicAnalysis must be of type str, got {type(props['academicAnalysis']).__name__}")
    
        # Type check continuityElements (expected object)
        if "continuityElements" in props and props["continuityElements"] is not None:
            if not isinstance(props["continuityElements"], object):
                try:
                    # Attempt to convert
                    props["continuityElements"] = object(props["continuityElements"])
                except:
                    raise TypeError(f"Property continuityElements must be of type object, got {type(props['continuityElements']).__name__}")
    
        # Type check criticComparison (expected str)
        if "criticComparison" in props and props["criticComparison"] is not None:
            if not isinstance(props["criticComparison"], str):
                try:
                    # Attempt to convert
                    props["criticComparison"] = str(props["criticComparison"])
                except:
                    raise TypeError(f"Property criticComparison must be of type str, got {type(props['criticComparison']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="INFLUENCED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def admired(uuid=None, **props):
        """
        Find relationships of type ADMIRED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check commonTechniques (expected object)
        if "commonTechniques" in props and props["commonTechniques"] is not None:
            if not isinstance(props["commonTechniques"], object):
                try:
                    # Attempt to convert
                    props["commonTechniques"] = object(props["commonTechniques"])
                except:
                    raise TypeError(f"Property commonTechniques must be of type object, got {type(props['commonTechniques']).__name__}")
    
        # Type check since (expected object)
        if "since" in props and props["since"] is not None:
            if not isinstance(props["since"], object):
                try:
                    # Attempt to convert
                    props["since"] = object(props["since"])
                except:
                    raise TypeError(f"Property since must be of type object, got {type(props['since']).__name__}")
    
        # Type check techniqueOverlap (expected object)
        if "techniqueOverlap" in props and props["techniqueOverlap"] is not None:
            if not isinstance(props["techniqueOverlap"], object):
                try:
                    # Attempt to convert
                    props["techniqueOverlap"] = object(props["techniqueOverlap"])
                except:
                    raise TypeError(f"Property techniqueOverlap must be of type object, got {type(props['techniqueOverlap']).__name__}")
    
        # Type check cinematicInfluence (expected str)
        if "cinematicInfluence" in props and props["cinematicInfluence"] is not None:
            if not isinstance(props["cinematicInfluence"], str):
                try:
                    # Attempt to convert
                    props["cinematicInfluence"] = str(props["cinematicInfluence"])
                except:
                    raise TypeError(f"Property cinematicInfluence must be of type str, got {type(props['cinematicInfluence']).__name__}")
    
        # Type check mutualRespect (expected bool)
        if "mutualRespect" in props and props["mutualRespect"] is not None:
            if not isinstance(props["mutualRespect"], bool):
                try:
                    # Attempt to convert
                    props["mutualRespect"] = bool(props["mutualRespect"])
                except:
                    raise TypeError(f"Property mutualRespect must be of type bool, got {type(props['mutualRespect']).__name__}")
    
        # Type check publicStatements (expected int)
        if "publicStatements" in props and props["publicStatements"] is not None:
            if not isinstance(props["publicStatements"], int):
                try:
                    # Attempt to convert
                    props["publicStatements"] = int(props["publicStatements"])
                except:
                    raise TypeError(f"Property publicStatements must be of type int, got {type(props['publicStatements']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="ADMIRED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def celebrates(uuid=None, **props):
        """
        Find relationships of type CELEBRATES matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check recreationsPerformed (expected str)
        if "recreationsPerformed" in props and props["recreationsPerformed"] is not None:
            if not isinstance(props["recreationsPerformed"], str):
                try:
                    # Attempt to convert
                    props["recreationsPerformed"] = str(props["recreationsPerformed"])
                except:
                    raise TypeError(f"Property recreationsPerformed must be of type str, got {type(props['recreationsPerformed']).__name__}")
    
        # Type check yearsActive (expected int)
        if "yearsActive" in props and props["yearsActive"] is not None:
            if not isinstance(props["yearsActive"], int):
                try:
                    # Attempt to convert
                    props["yearsActive"] = int(props["yearsActive"])
                except:
                    raise TypeError(f"Property yearsActive must be of type int, got {type(props['yearsActive']).__name__}")
    
        # Type check culturalPreservation (expected str)
        if "culturalPreservation" in props and props["culturalPreservation"] is not None:
            if not isinstance(props["culturalPreservation"], str):
                try:
                    # Attempt to convert
                    props["culturalPreservation"] = str(props["culturalPreservation"])
                except:
                    raise TypeError(f"Property culturalPreservation must be of type str, got {type(props['culturalPreservation']).__name__}")
    
        # Type check tourLocations (expected object)
        if "tourLocations" in props and props["tourLocations"] is not None:
            if not isinstance(props["tourLocations"], object):
                try:
                    # Attempt to convert
                    props["tourLocations"] = object(props["tourLocations"])
                except:
                    raise TypeError(f"Property tourLocations must be of type object, got {type(props['tourLocations']).__name__}")
    
        # Type check archivalCollections (expected int)
        if "archivalCollections" in props and props["archivalCollections"] is not None:
            if not isinstance(props["archivalCollections"], int):
                try:
                    # Attempt to convert
                    props["archivalCollections"] = int(props["archivalCollections"])
                except:
                    raise TypeError(f"Property archivalCollections must be of type int, got {type(props['archivalCollections']).__name__}")
    
        # Type check songbooksPublished (expected int)
        if "songbooksPublished" in props and props["songbooksPublished"] is not None:
            if not isinstance(props["songbooksPublished"], int):
                try:
                    # Attempt to convert
                    props["songbooksPublished"] = int(props["songbooksPublished"])
                except:
                    raise TypeError(f"Property songbooksPublished must be of type int, got {type(props['songbooksPublished']).__name__}")
    
        # Type check merchandiseSales (expected int)
        if "merchandiseSales" in props and props["merchandiseSales"] is not None:
            if not isinstance(props["merchandiseSales"], int):
                try:
                    # Attempt to convert
                    props["merchandiseSales"] = int(props["merchandiseSales"])
                except:
                    raise TypeError(f"Property merchandiseSales must be of type int, got {type(props['merchandiseSales']).__name__}")
    
        # Type check annualFestivals (expected int)
        if "annualFestivals" in props and props["annualFestivals"] is not None:
            if not isinstance(props["annualFestivals"], int):
                try:
                    # Attempt to convert
                    props["annualFestivals"] = int(props["annualFestivals"])
                except:
                    raise TypeError(f"Property annualFestivals must be of type int, got {type(props['annualFestivals']).__name__}")
    
        # Type check generationalAppeal (expected str)
        if "generationalAppeal" in props and props["generationalAppeal"] is not None:
            if not isinstance(props["generationalAppeal"], str):
                try:
                    # Attempt to convert
                    props["generationalAppeal"] = str(props["generationalAppeal"])
                except:
                    raise TypeError(f"Property generationalAppeal must be of type str, got {type(props['generationalAppeal']).__name__}")
    
        # Type check academicConferences (expected int)
        if "academicConferences" in props and props["academicConferences"] is not None:
            if not isinstance(props["academicConferences"], int):
                try:
                    # Attempt to convert
                    props["academicConferences"] = int(props["academicConferences"])
                except:
                    raise TypeError(f"Property academicConferences must be of type int, got {type(props['academicConferences']).__name__}")
    
        # Type check merchandisingSales (expected int)
        if "merchandisingSales" in props and props["merchandisingSales"] is not None:
            if not isinstance(props["merchandisingSales"], int):
                try:
                    # Attempt to convert
                    props["merchandisingSales"] = int(props["merchandisingSales"])
                except:
                    raise TypeError(f"Property merchandisingSales must be of type int, got {type(props['merchandisingSales']).__name__}")
    
        # Type check dialogueMemorizationLevel (expected str)
        if "dialogueMemorizationLevel" in props and props["dialogueMemorizationLevel"] is not None:
            if not isinstance(props["dialogueMemorizationLevel"], str):
                try:
                    # Attempt to convert
                    props["dialogueMemorizationLevel"] = str(props["dialogueMemorizationLevel"])
                except:
                    raise TypeError(f"Property dialogueMemorizationLevel must be of type str, got {type(props['dialogueMemorizationLevel']).__name__}")
    
        # Type check educationalPrograms (expected object)
        if "educationalPrograms" in props and props["educationalPrograms"] is not None:
            if not isinstance(props["educationalPrograms"], object):
                try:
                    # Attempt to convert
                    props["educationalPrograms"] = object(props["educationalPrograms"])
                except:
                    raise TypeError(f"Property educationalPrograms must be of type object, got {type(props['educationalPrograms']).__name__}")
    
        # Type check commemorationEvents (expected object)
        if "commemorationEvents" in props and props["commemorationEvents"] is not None:
            if not isinstance(props["commemorationEvents"], object):
                try:
                    # Attempt to convert
                    props["commemorationEvents"] = object(props["commemorationEvents"])
                except:
                    raise TypeError(f"Property commemorationEvents must be of type object, got {type(props['commemorationEvents']).__name__}")
    
        # Type check quotationContests (expected bool)
        if "quotationContests" in props and props["quotationContests"] is not None:
            if not isinstance(props["quotationContests"], bool):
                try:
                    # Attempt to convert
                    props["quotationContests"] = bool(props["quotationContests"])
                except:
                    raise TypeError(f"Property quotationContests must be of type bool, got {type(props['quotationContests']).__name__}")
    
        # Type check preservationDonations (expected int)
        if "preservationDonations" in props and props["preservationDonations"] is not None:
            if not isinstance(props["preservationDonations"], int):
                try:
                    # Attempt to convert
                    props["preservationDonations"] = int(props["preservationDonations"])
                except:
                    raise TypeError(f"Property preservationDonations must be of type int, got {type(props['preservationDonations']).__name__}")
    
        # Type check culturalDefenseActivities (expected str)
        if "culturalDefenseActivities" in props and props["culturalDefenseActivities"] is not None:
            if not isinstance(props["culturalDefenseActivities"], str):
                try:
                    # Attempt to convert
                    props["culturalDefenseActivities"] = str(props["culturalDefenseActivities"])
                except:
                    raise TypeError(f"Property culturalDefenseActivities must be of type str, got {type(props['culturalDefenseActivities']).__name__}")
    
        # Type check documentaryProductions (expected int)
        if "documentaryProductions" in props and props["documentaryProductions"] is not None:
            if not isinstance(props["documentaryProductions"], int):
                try:
                    # Attempt to convert
                    props["documentaryProductions"] = int(props["documentaryProductions"])
                except:
                    raise TypeError(f"Property documentaryProductions must be of type int, got {type(props['documentaryProductions']).__name__}")
    
        # Type check memorabiliaValue (expected str)
        if "memorabiliaValue" in props and props["memorabiliaValue"] is not None:
            if not isinstance(props["memorabiliaValue"], str):
                try:
                    # Attempt to convert
                    props["memorabiliaValue"] = str(props["memorabiliaValue"])
                except:
                    raise TypeError(f"Property memorabiliaValue must be of type str, got {type(props['memorabiliaValue']).__name__}")
    
        # Type check anniversaryCelebrations (expected int)
        if "anniversaryCelebrations" in props and props["anniversaryCelebrations"] is not None:
            if not isinstance(props["anniversaryCelebrations"], int):
                try:
                    # Attempt to convert
                    props["anniversaryCelebrations"] = int(props["anniversaryCelebrations"])
                except:
                    raise TypeError(f"Property anniversaryCelebrations must be of type int, got {type(props['anniversaryCelebrations']).__name__}")
    
        # Type check tourismImpact (expected str)
        if "tourismImpact" in props and props["tourismImpact"] is not None:
            if not isinstance(props["tourismImpact"], str):
                try:
                    # Attempt to convert
                    props["tourismImpact"] = str(props["tourismImpact"])
                except:
                    raise TypeError(f"Property tourismImpact must be of type str, got {type(props['tourismImpact']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="CELEBRATES", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def directed_actor(uuid=None, **props):
        """
        Find relationships of type DIRECTED_ACTOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check firstYear (expected int)
        if "firstYear" in props and props["firstYear"] is not None:
            if not isinstance(props["firstYear"], int):
                try:
                    # Attempt to convert
                    props["firstYear"] = int(props["firstYear"])
                except:
                    raise TypeError(f"Property firstYear must be of type int, got {type(props['firstYear']).__name__}")
    
        # Type check conflicts (expected str)
        if "conflicts" in props and props["conflicts"] is not None:
            if not isinstance(props["conflicts"], str):
                try:
                    # Attempt to convert
                    props["conflicts"] = str(props["conflicts"])
                except:
                    raise TypeError(f"Property conflicts must be of type str, got {type(props['conflicts']).__name__}")
    
        # Type check chemistry (expected float)
        if "chemistry" in props and props["chemistry"] is not None:
            if not isinstance(props["chemistry"], float):
                try:
                    # Attempt to convert
                    props["chemistry"] = float(props["chemistry"])
                except:
                    raise TypeError(f"Property chemistry must be of type float, got {type(props['chemistry']).__name__}")
    
        # Type check films (expected int)
        if "films" in props and props["films"] is not None:
            if not isinstance(props["films"], int):
                try:
                    # Attempt to convert
                    props["films"] = int(props["films"])
                except:
                    raise TypeError(f"Property films must be of type int, got {type(props['films']).__name__}")
    
        # Type check futurePlans (expected str)
        if "futurePlans" in props and props["futurePlans"] is not None:
            if not isinstance(props["futurePlans"], str):
                try:
                    # Attempt to convert
                    props["futurePlans"] = str(props["futurePlans"])
                except:
                    raise TypeError(f"Property futurePlans must be of type str, got {type(props['futurePlans']).__name__}")
    
        # Type check reconciliation (expected bool)
        if "reconciliation" in props and props["reconciliation"] is not None:
            if not isinstance(props["reconciliation"], bool):
                try:
                    # Attempt to convert
                    props["reconciliation"] = bool(props["reconciliation"])
                except:
                    raise TypeError(f"Property reconciliation must be of type bool, got {type(props['reconciliation']).__name__}")
    
        # Type check firstFilm (expected str)
        if "firstFilm" in props and props["firstFilm"] is not None:
            if not isinstance(props["firstFilm"], str):
                try:
                    # Attempt to convert
                    props["firstFilm"] = str(props["firstFilm"])
                except:
                    raise TypeError(f"Property firstFilm must be of type str, got {type(props['firstFilm']).__name__}")
    
        # Type check intensityLevel (expected str)
        if "intensityLevel" in props and props["intensityLevel"] is not None:
            if not isinstance(props["intensityLevel"], str):
                try:
                    # Attempt to convert
                    props["intensityLevel"] = str(props["intensityLevel"])
                except:
                    raise TypeError(f"Property intensityLevel must be of type str, got {type(props['intensityLevel']).__name__}")
    
        # Type check collaborationQuotes (expected str)
        if "collaborationQuotes" in props and props["collaborationQuotes"] is not None:
            if not isinstance(props["collaborationQuotes"], str):
                try:
                    # Attempt to convert
                    props["collaborationQuotes"] = str(props["collaborationQuotes"])
                except:
                    raise TypeError(f"Property collaborationQuotes must be of type str, got {type(props['collaborationQuotes']).__name__}")
    
        # Type check artisticPartnership (expected str)
        if "artisticPartnership" in props and props["artisticPartnership"] is not None:
            if not isinstance(props["artisticPartnership"], str):
                try:
                    # Attempt to convert
                    props["artisticPartnership"] = str(props["artisticPartnership"])
                except:
                    raise TypeError(f"Property artisticPartnership must be of type str, got {type(props['artisticPartnership']).__name__}")
    
        # Type check characterCreation (expected str)
        if "characterCreation" in props and props["characterCreation"] is not None:
            if not isinstance(props["characterCreation"], str):
                try:
                    # Attempt to convert
                    props["characterCreation"] = str(props["characterCreation"])
                except:
                    raise TypeError(f"Property characterCreation must be of type str, got {type(props['characterCreation']).__name__}")
    
        # Type check characterOwnership (expected str)
        if "characterOwnership" in props and props["characterOwnership"] is not None:
            if not isinstance(props["characterOwnership"], str):
                try:
                    # Attempt to convert
                    props["characterOwnership"] = str(props["characterOwnership"])
                except:
                    raise TypeError(f"Property characterOwnership must be of type str, got {type(props['characterOwnership']).__name__}")
    
        # Type check respectLevel (expected str)
        if "respectLevel" in props and props["respectLevel"] is not None:
            if not isinstance(props["respectLevel"], str):
                try:
                    # Attempt to convert
                    props["respectLevel"] = str(props["respectLevel"])
                except:
                    raise TypeError(f"Property respectLevel must be of type str, got {type(props['respectLevel']).__name__}")
    
        # Type check inspirationLevel (expected str)
        if "inspirationLevel" in props and props["inspirationLevel"] is not None:
            if not isinstance(props["inspirationLevel"], str):
                try:
                    # Attempt to convert
                    props["inspirationLevel"] = str(props["inspirationLevel"])
                except:
                    raise TypeError(f"Property inspirationLevel must be of type str, got {type(props['inspirationLevel']).__name__}")
    
        # Type check collaborationLongevity (expected str)
        if "collaborationLongevity" in props and props["collaborationLongevity"] is not None:
            if not isinstance(props["collaborationLongevity"], str):
                try:
                    # Attempt to convert
                    props["collaborationLongevity"] = str(props["collaborationLongevity"])
                except:
                    raise TypeError(f"Property collaborationLongevity must be of type str, got {type(props['collaborationLongevity']).__name__}")
    
        # Type check museCategorization (expected bool)
        if "museCategorization" in props and props["museCategorization"] is not None:
            if not isinstance(props["museCategorization"], bool):
                try:
                    # Attempt to convert
                    props["museCategorization"] = bool(props["museCategorization"])
                except:
                    raise TypeError(f"Property museCategorization must be of type bool, got {type(props['museCategorization']).__name__}")
    
        # Type check mutualRespect (expected str)
        if "mutualRespect" in props and props["mutualRespect"] is not None:
            if not isinstance(props["mutualRespect"], str):
                try:
                    # Attempt to convert
                    props["mutualRespect"] = str(props["mutualRespect"])
                except:
                    raise TypeError(f"Property mutualRespect must be of type str, got {type(props['mutualRespect']).__name__}")
    
        # Type check physicalDemands (expected str)
        if "physicalDemands" in props and props["physicalDemands"] is not None:
            if not isinstance(props["physicalDemands"], str):
                try:
                    # Attempt to convert
                    props["physicalDemands"] = str(props["physicalDemands"])
                except:
                    raise TypeError(f"Property physicalDemands must be of type str, got {type(props['physicalDemands']).__name__}")
    
        # Type check languageBarrier (expected str)
        if "languageBarrier" in props and props["languageBarrier"] is not None:
            if not isinstance(props["languageBarrier"], str):
                try:
                    # Attempt to convert
                    props["languageBarrier"] = str(props["languageBarrier"])
                except:
                    raise TypeError(f"Property languageBarrier must be of type str, got {type(props['languageBarrier']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="DIRECTED_ACTOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def defined_by(uuid=None, **props):
        """
        Find relationships of type DEFINED_BY matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check independentFilmIncrease (expected float)
        if "independentFilmIncrease" in props and props["independentFilmIncrease"] is not None:
            if not isinstance(props["independentFilmIncrease"], float):
                try:
                    # Attempt to convert
                    props["independentFilmIncrease"] = float(props["independentFilmIncrease"])
                except:
                    raise TypeError(f"Property independentFilmIncrease must be of type float, got {type(props['independentFilmIncrease']).__name__}")
    
        # Type check dialogueRevolution (expected str)
        if "dialogueRevolution" in props and props["dialogueRevolution"] is not None:
            if not isinstance(props["dialogueRevolution"], str):
                try:
                    # Attempt to convert
                    props["dialogueRevolution"] = str(props["dialogueRevolution"])
                except:
                    raise TypeError(f"Property dialogueRevolution must be of type str, got {type(props['dialogueRevolution']).__name__}")
    
        # Type check narrativeExperimentation (expected str)
        if "narrativeExperimentation" in props and props["narrativeExperimentation"] is not None:
            if not isinstance(props["narrativeExperimentation"], str):
                try:
                    # Attempt to convert
                    props["narrativeExperimentation"] = str(props["narrativeExperimentation"])
                except:
                    raise TypeError(f"Property narrativeExperimentation must be of type str, got {type(props['narrativeExperimentation']).__name__}")
    
        # Type check boxOfficeMultiplierEffect (expected float)
        if "boxOfficeMultiplierEffect" in props and props["boxOfficeMultiplierEffect"] is not None:
            if not isinstance(props["boxOfficeMultiplierEffect"], float):
                try:
                    # Attempt to convert
                    props["boxOfficeMultiplierEffect"] = float(props["boxOfficeMultiplierEffect"])
                except:
                    raise TypeError(f"Property boxOfficeMultiplierEffect must be of type float, got {type(props['boxOfficeMultiplierEffect']).__name__}")
    
        # Type check genreSubversionTechniques (expected str)
        if "genreSubversionTechniques" in props and props["genreSubversionTechniques"] is not None:
            if not isinstance(props["genreSubversionTechniques"], str):
                try:
                    # Attempt to convert
                    props["genreSubversionTechniques"] = str(props["genreSubversionTechniques"])
                except:
                    raise TypeError(f"Property genreSubversionTechniques must be of type str, got {type(props['genreSubversionTechniques']).__name__}")
    
        # Type check filmSchoolAdoption (expected str)
        if "filmSchoolAdoption" in props and props["filmSchoolAdoption"] is not None:
            if not isinstance(props["filmSchoolAdoption"], str):
                try:
                    # Attempt to convert
                    props["filmSchoolAdoption"] = str(props["filmSchoolAdoption"])
                except:
                    raise TypeError(f"Property filmSchoolAdoption must be of type str, got {type(props['filmSchoolAdoption']).__name__}")
    
        # Type check subsequentDistributionDeals (expected int)
        if "subsequentDistributionDeals" in props and props["subsequentDistributionDeals"] is not None:
            if not isinstance(props["subsequentDistributionDeals"], int):
                try:
                    # Attempt to convert
                    props["subsequentDistributionDeals"] = int(props["subsequentDistributionDeals"])
                except:
                    raise TypeError(f"Property subsequentDistributionDeals must be of type int, got {type(props['subsequentDistributionDeals']).__name__}")
    
        # Type check newFilmmakersInspired (expected str)
        if "newFilmmakersInspired" in props and props["newFilmmakersInspired"] is not None:
            if not isinstance(props["newFilmmakersInspired"], str):
                try:
                    # Attempt to convert
                    props["newFilmmakersInspired"] = str(props["newFilmmakersInspired"])
                except:
                    raise TypeError(f"Property newFilmmakersInspired must be of type str, got {type(props['newFilmmakersInspired']).__name__}")
    
        # Type check academicAnalyses (expected int)
        if "academicAnalyses" in props and props["academicAnalyses"] is not None:
            if not isinstance(props["academicAnalyses"], int):
                try:
                    # Attempt to convert
                    props["academicAnalyses"] = int(props["academicAnalyses"])
                except:
                    raise TypeError(f"Property academicAnalyses must be of type int, got {type(props['academicAnalyses']).__name__}")
    
        # Type check significanceRating (expected float)
        if "significanceRating" in props and props["significanceRating"] is not None:
            if not isinstance(props["significanceRating"], float):
                try:
                    # Attempt to convert
                    props["significanceRating"] = float(props["significanceRating"])
                except:
                    raise TypeError(f"Property significanceRating must be of type float, got {type(props['significanceRating']).__name__}")
    
        # Type check globalImpact (expected str)
        if "globalImpact" in props and props["globalImpact"] is not None:
            if not isinstance(props["globalImpact"], str):
                try:
                    # Attempt to convert
                    props["globalImpact"] = str(props["globalImpact"])
                except:
                    raise TypeError(f"Property globalImpact must be of type str, got {type(props['globalImpact']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="DEFINED_BY", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def parent_of(uuid=None, **props):
        """
        Find relationships of type PARENT_OF matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check jointInterviews (expected int)
        if "jointInterviews" in props and props["jointInterviews"] is not None:
            if not isinstance(props["jointInterviews"], int):
                try:
                    # Attempt to convert
                    props["jointInterviews"] = int(props["jointInterviews"])
                except:
                    raise TypeError(f"Property jointInterviews must be of type int, got {type(props['jointInterviews']).__name__}")
    
        # Type check publicDiscussions (expected int)
        if "publicDiscussions" in props and props["publicDiscussions"] is not None:
            if not isinstance(props["publicDiscussions"], int):
                try:
                    # Attempt to convert
                    props["publicDiscussions"] = int(props["publicDiscussions"])
                except:
                    raise TypeError(f"Property publicDiscussions must be of type int, got {type(props['publicDiscussions']).__name__}")
    
        # Type check firstCollaborationYear (expected int)
        if "firstCollaborationYear" in props and props["firstCollaborationYear"] is not None:
            if not isinstance(props["firstCollaborationYear"], int):
                try:
                    # Attempt to convert
                    props["firstCollaborationYear"] = int(props["firstCollaborationYear"])
                except:
                    raise TypeError(f"Property firstCollaborationYear must be of type int, got {type(props['firstCollaborationYear']).__name__}")
    
        # Type check childBorn (expected object)
        if "childBorn" in props and props["childBorn"] is not None:
            if not isinstance(props["childBorn"], object):
                try:
                    # Attempt to convert
                    props["childBorn"] = object(props["childBorn"])
                except:
                    raise TypeError(f"Property childBorn must be of type object, got {type(props['childBorn']).__name__}")
    
        # Type check familyLegacy (expected str)
        if "familyLegacy" in props and props["familyLegacy"] is not None:
            if not isinstance(props["familyLegacy"], str):
                try:
                    # Attempt to convert
                    props["familyLegacy"] = str(props["familyLegacy"])
                except:
                    raise TypeError(f"Property familyLegacy must be of type str, got {type(props['familyLegacy']).__name__}")
    
        # Type check influenceLevel (expected str)
        if "influenceLevel" in props and props["influenceLevel"] is not None:
            if not isinstance(props["influenceLevel"], str):
                try:
                    # Attempt to convert
                    props["influenceLevel"] = str(props["influenceLevel"])
                except:
                    raise TypeError(f"Property influenceLevel must be of type str, got {type(props['influenceLevel']).__name__}")
    
        # Type check firstCollaboration (expected str)
        if "firstCollaboration" in props and props["firstCollaboration"] is not None:
            if not isinstance(props["firstCollaboration"], str):
                try:
                    # Attempt to convert
                    props["firstCollaboration"] = str(props["firstCollaboration"])
                except:
                    raise TypeError(f"Property firstCollaboration must be of type str, got {type(props['firstCollaboration']).__name__}")
    
        # Type check mentorRelationship (expected bool)
        if "mentorRelationship" in props and props["mentorRelationship"] is not None:
            if not isinstance(props["mentorRelationship"], bool):
                try:
                    # Attempt to convert
                    props["mentorRelationship"] = bool(props["mentorRelationship"])
                except:
                    raise TypeError(f"Property mentorRelationship must be of type bool, got {type(props['mentorRelationship']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="PARENT_OF", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def collaborated_with(uuid=None, **props):
        """
        Find relationships of type COLLABORATED_WITH matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check firstProject (expected str)
        if "firstProject" in props and props["firstProject"] is not None:
            if not isinstance(props["firstProject"], str):
                try:
                    # Attempt to convert
                    props["firstProject"] = str(props["firstProject"])
                except:
                    raise TypeError(f"Property firstProject must be of type str, got {type(props['firstProject']).__name__}")
    
        # Type check firstYear (expected int)
        if "firstYear" in props and props["firstYear"] is not None:
            if not isinstance(props["firstYear"], int):
                try:
                    # Attempt to convert
                    props["firstYear"] = int(props["firstYear"])
                except:
                    raise TypeError(f"Property firstYear must be of type int, got {type(props['firstYear']).__name__}")
    
        # Type check projects (expected int)
        if "projects" in props and props["projects"] is not None:
            if not isinstance(props["projects"], int):
                try:
                    # Attempt to convert
                    props["projects"] = int(props["projects"])
                except:
                    raise TypeError(f"Property projects must be of type int, got {type(props['projects']).__name__}")
    
        # Type check publicPerception (expected str)
        if "publicPerception" in props and props["publicPerception"] is not None:
            if not isinstance(props["publicPerception"], str):
                try:
                    # Attempt to convert
                    props["publicPerception"] = str(props["publicPerception"])
                except:
                    raise TypeError(f"Property publicPerception must be of type str, got {type(props['publicPerception']).__name__}")
    
        # Type check genreDefining (expected bool)
        if "genreDefining" in props and props["genreDefining"] is not None:
            if not isinstance(props["genreDefining"], bool):
                try:
                    # Attempt to convert
                    props["genreDefining"] = bool(props["genreDefining"])
                except:
                    raise TypeError(f"Property genreDefining must be of type bool, got {type(props['genreDefining']).__name__}")
    
        # Type check lastProject (expected str)
        if "lastProject" in props and props["lastProject"] is not None:
            if not isinstance(props["lastProject"], str):
                try:
                    # Attempt to convert
                    props["lastProject"] = str(props["lastProject"])
                except:
                    raise TypeError(f"Property lastProject must be of type str, got {type(props['lastProject']).__name__}")
    
        # Type check financialSuccess (expected str)
        if "financialSuccess" in props and props["financialSuccess"] is not None:
            if not isinstance(props["financialSuccess"], str):
                try:
                    # Attempt to convert
                    props["financialSuccess"] = str(props["financialSuccess"])
                except:
                    raise TypeError(f"Property financialSuccess must be of type str, got {type(props['financialSuccess']).__name__}")
    
        # Type check lastYear (expected int)
        if "lastYear" in props and props["lastYear"] is not None:
            if not isinstance(props["lastYear"], int):
                try:
                    # Attempt to convert
                    props["lastYear"] = int(props["lastYear"])
                except:
                    raise TypeError(f"Property lastYear must be of type int, got {type(props['lastYear']).__name__}")
    
        # Type check iconicCharacters (expected int)
        if "iconicCharacters" in props and props["iconicCharacters"] is not None:
            if not isinstance(props["iconicCharacters"], int):
                try:
                    # Attempt to convert
                    props["iconicCharacters"] = int(props["iconicCharacters"])
                except:
                    raise TypeError(f"Property iconicCharacters must be of type int, got {type(props['iconicCharacters']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="COLLABORATED_WITH", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def adapted_into(uuid=None, **props):
        """
        Find relationships of type ADAPTED_INTO matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check contractSigned (expected object)
        if "contractSigned" in props and props["contractSigned"] is not None:
            if not isinstance(props["contractSigned"], object):
                try:
                    # Attempt to convert
                    props["contractSigned"] = object(props["contractSigned"])
                except:
                    raise TypeError(f"Property contractSigned must be of type object, got {type(props['contractSigned']).__name__}")
    
        # Type check adaptationFidelity (expected float)
        if "adaptationFidelity" in props and props["adaptationFidelity"] is not None:
            if not isinstance(props["adaptationFidelity"], float):
                try:
                    # Attempt to convert
                    props["adaptationFidelity"] = float(props["adaptationFidelity"])
                except:
                    raise TypeError(f"Property adaptationFidelity must be of type float, got {type(props['adaptationFidelity']).__name__}")
    
        # Type check authorInvolvement (expected str)
        if "authorInvolvement" in props and props["authorInvolvement"] is not None:
            if not isinstance(props["authorInvolvement"], str):
                try:
                    # Attempt to convert
                    props["authorInvolvement"] = str(props["authorInvolvement"])
                except:
                    raise TypeError(f"Property authorInvolvement must be of type str, got {type(props['authorInvolvement']).__name__}")
    
        # Type check publicReception (expected str)
        if "publicReception" in props and props["publicReception"] is not None:
            if not isinstance(props["publicReception"], str):
                try:
                    # Attempt to convert
                    props["publicReception"] = str(props["publicReception"])
                except:
                    raise TypeError(f"Property publicReception must be of type str, got {type(props['publicReception']).__name__}")
    
        # Type check adaptation_quality (expected str)
        if "adaptation_quality" in props and props["adaptation_quality"] is not None:
            if not isinstance(props["adaptation_quality"], str):
                try:
                    # Attempt to convert
                    props["adaptation_quality"] = str(props["adaptation_quality"])
                except:
                    raise TypeError(f"Property adaptation_quality must be of type str, got {type(props['adaptation_quality']).__name__}")
    
        # Type check adaptationRights (expected int)
        if "adaptationRights" in props and props["adaptationRights"] is not None:
            if not isinstance(props["adaptationRights"], int):
                try:
                    # Attempt to convert
                    props["adaptationRights"] = int(props["adaptationRights"])
                except:
                    raise TypeError(f"Property adaptationRights must be of type int, got {type(props['adaptationRights']).__name__}")
    
        # Type check novelSalesAfterFilm (expected int)
        if "novelSalesAfterFilm" in props and props["novelSalesAfterFilm"] is not None:
            if not isinstance(props["novelSalesAfterFilm"], int):
                try:
                    # Attempt to convert
                    props["novelSalesAfterFilm"] = int(props["novelSalesAfterFilm"])
                except:
                    raise TypeError(f"Property novelSalesAfterFilm must be of type int, got {type(props['novelSalesAfterFilm']).__name__}")
    
        # Type check significantChanges (expected object)
        if "significantChanges" in props and props["significantChanges"] is not None:
            if not isinstance(props["significantChanges"], object):
                try:
                    # Attempt to convert
                    props["significantChanges"] = object(props["significantChanges"])
                except:
                    raise TypeError(f"Property significantChanges must be of type object, got {type(props['significantChanges']).__name__}")
    
        # Type check preservedElements (expected object)
        if "preservedElements" in props and props["preservedElements"] is not None:
            if not isinstance(props["preservedElements"], object):
                try:
                    # Attempt to convert
                    props["preservedElements"] = object(props["preservedElements"])
                except:
                    raise TypeError(f"Property preservedElements must be of type object, got {type(props['preservedElements']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="ADAPTED_INTO", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def authored(uuid=None, **props):
        """
        Find relationships of type AUTHORED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check writingCompletionDate (expected object)
        if "writingCompletionDate" in props and props["writingCompletionDate"] is not None:
            if not isinstance(props["writingCompletionDate"], object):
                try:
                    # Attempt to convert
                    props["writingCompletionDate"] = object(props["writingCompletionDate"])
                except:
                    raise TypeError(f"Property writingCompletionDate must be of type object, got {type(props['writingCompletionDate']).__name__}")
    
        # Type check personalConnection (expected str)
        if "personalConnection" in props and props["personalConnection"] is not None:
            if not isinstance(props["personalConnection"], str):
                try:
                    # Attempt to convert
                    props["personalConnection"] = str(props["personalConnection"])
                except:
                    raise TypeError(f"Property personalConnection must be of type str, got {type(props['personalConnection']).__name__}")
    
        # Type check initialExpectations (expected str)
        if "initialExpectations" in props and props["initialExpectations"] is not None:
            if not isinstance(props["initialExpectations"], str):
                try:
                    # Attempt to convert
                    props["initialExpectations"] = str(props["initialExpectations"])
                except:
                    raise TypeError(f"Property initialExpectations must be of type str, got {type(props['initialExpectations']).__name__}")
    
        # Type check royaltyPercentage (expected float)
        if "royaltyPercentage" in props and props["royaltyPercentage"] is not None:
            if not isinstance(props["royaltyPercentage"], float):
                try:
                    # Attempt to convert
                    props["royaltyPercentage"] = float(props["royaltyPercentage"])
                except:
                    raise TypeError(f"Property royaltyPercentage must be of type float, got {type(props['royaltyPercentage']).__name__}")
    
        # Type check literaryAim (expected str)
        if "literaryAim" in props and props["literaryAim"] is not None:
            if not isinstance(props["literaryAim"], str):
                try:
                    # Attempt to convert
                    props["literaryAim"] = str(props["literaryAim"])
                except:
                    raise TypeError(f"Property literaryAim must be of type str, got {type(props['literaryAim']).__name__}")
    
        # Type check inspirationSources (expected object)
        if "inspirationSources" in props and props["inspirationSources"] is not None:
            if not isinstance(props["inspirationSources"], object):
                try:
                    # Attempt to convert
                    props["inspirationSources"] = object(props["inspirationSources"])
                except:
                    raise TypeError(f"Property inspirationSources must be of type object, got {type(props['inspirationSources']).__name__}")
    
        # Type check writingStartDate (expected object)
        if "writingStartDate" in props and props["writingStartDate"] is not None:
            if not isinstance(props["writingStartDate"], object):
                try:
                    # Attempt to convert
                    props["writingStartDate"] = object(props["writingStartDate"])
                except:
                    raise TypeError(f"Property writingStartDate must be of type object, got {type(props['writingStartDate']).__name__}")
    
        # Type check researchMethods (expected object)
        if "researchMethods" in props and props["researchMethods"] is not None:
            if not isinstance(props["researchMethods"], object):
                try:
                    # Attempt to convert
                    props["researchMethods"] = object(props["researchMethods"])
                except:
                    raise TypeError(f"Property researchMethods must be of type object, got {type(props['researchMethods']).__name__}")
    
        # Type check advance (expected int)
        if "advance" in props and props["advance"] is not None:
            if not isinstance(props["advance"], int):
                try:
                    # Attempt to convert
                    props["advance"] = int(props["advance"])
                except:
                    raise TypeError(f"Property advance must be of type int, got {type(props['advance']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="AUTHORED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def composed(uuid=None, **props):
        """
        Find relationships of type COMPOSED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check originalPieces (expected int)
        if "originalPieces" in props and props["originalPieces"] is not None:
            if not isinstance(props["originalPieces"], int):
                try:
                    # Attempt to convert
                    props["originalPieces"] = int(props["originalPieces"])
                except:
                    raise TypeError(f"Property originalPieces must be of type int, got {type(props['originalPieces']).__name__}")
    
        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Type check themes (expected int)
        if "themes" in props and props["themes"] is not None:
            if not isinstance(props["themes"], int):
                try:
                    # Attempt to convert
                    props["themes"] = int(props["themes"])
                except:
                    raise TypeError(f"Property themes must be of type int, got {type(props['themes']).__name__}")
    
        # Type check compositionPeriod (expected object)
        if "compositionPeriod" in props and props["compositionPeriod"] is not None:
            if not isinstance(props["compositionPeriod"], object):
                try:
                    # Attempt to convert
                    props["compositionPeriod"] = object(props["compositionPeriod"])
                except:
                    raise TypeError(f"Property compositionPeriod must be of type object, got {type(props['compositionPeriod']).__name__}")
    
        # Type check compositionMethod (expected str)
        if "compositionMethod" in props and props["compositionMethod"] is not None:
            if not isinstance(props["compositionMethod"], str):
                try:
                    # Attempt to convert
                    props["compositionMethod"] = str(props["compositionMethod"])
                except:
                    raise TypeError(f"Property compositionMethod must be of type str, got {type(props['compositionMethod']).__name__}")
    
        # Type check recordingSupervision (expected bool)
        if "recordingSupervision" in props and props["recordingSupervision"] is not None:
            if not isinstance(props["recordingSupervision"], bool):
                try:
                    # Attempt to convert
                    props["recordingSupervision"] = bool(props["recordingSupervision"])
                except:
                    raise TypeError(f"Property recordingSupervision must be of type bool, got {type(props['recordingSupervision']).__name__}")
    
        # Type check directorFeedback (expected str)
        if "directorFeedback" in props and props["directorFeedback"] is not None:
            if not isinstance(props["directorFeedback"], str):
                try:
                    # Attempt to convert
                    props["directorFeedback"] = str(props["directorFeedback"])
                except:
                    raise TypeError(f"Property directorFeedback must be of type str, got {type(props['directorFeedback']).__name__}")
    
        # Type check collaborators (expected object)
        if "collaborators" in props and props["collaborators"] is not None:
            if not isinstance(props["collaborators"], object):
                try:
                    # Attempt to convert
                    props["collaborators"] = object(props["collaborators"])
                except:
                    raise TypeError(f"Property collaborators must be of type object, got {type(props['collaborators']).__name__}")
    
        # Type check adaptedPieces (expected int)
        if "adaptedPieces" in props and props["adaptedPieces"] is not None:
            if not isinstance(props["adaptedPieces"], int):
                try:
                    # Attempt to convert
                    props["adaptedPieces"] = int(props["adaptedPieces"])
                except:
                    raise TypeError(f"Property adaptedPieces must be of type int, got {type(props['adaptedPieces']).__name__}")
    
        # Type check themeInspirations (expected object)
        if "themeInspirations" in props and props["themeInspirations"] is not None:
            if not isinstance(props["themeInspirations"], object):
                try:
                    # Attempt to convert
                    props["themeInspirations"] = object(props["themeInspirations"])
                except:
                    raise TypeError(f"Property themeInspirations must be of type object, got {type(props['themeInspirations']).__name__}")
    
        # Type check instrumentsPlayed (expected object)
        if "instrumentsPlayed" in props and props["instrumentsPlayed"] is not None:
            if not isinstance(props["instrumentsPlayed"], object):
                try:
                    # Attempt to convert
                    props["instrumentsPlayed"] = object(props["instrumentsPlayed"])
                except:
                    raise TypeError(f"Property instrumentsPlayed must be of type object, got {type(props['instrumentsPlayed']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="COMPOSED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def consulted_for(uuid=None, **props):
        """
        Find relationships of type CONSULTED_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check publicAcknowledgement (expected bool)
        if "publicAcknowledgement" in props and props["publicAcknowledgement"] is not None:
            if not isinstance(props["publicAcknowledgement"], bool):
                try:
                    # Attempt to convert
                    props["publicAcknowledgement"] = bool(props["publicAcknowledgement"])
                except:
                    raise TypeError(f"Property publicAcknowledgement must be of type bool, got {type(props['publicAcknowledgement']).__name__}")
    
        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Type check laterComments (expected str)
        if "laterComments" in props and props["laterComments"] is not None:
            if not isinstance(props["laterComments"], str):
                try:
                    # Attempt to convert
                    props["laterComments"] = str(props["laterComments"])
                except:
                    raise TypeError(f"Property laterComments must be of type str, got {type(props['laterComments']).__name__}")
    
        # Type check informationFlow (expected str)
        if "informationFlow" in props and props["informationFlow"] is not None:
            if not isinstance(props["informationFlow"], str):
                try:
                    # Attempt to convert
                    props["informationFlow"] = str(props["informationFlow"])
                except:
                    raise TypeError(f"Property informationFlow must be of type str, got {type(props['informationFlow']).__name__}")
    
        # Type check legalDistancing (expected bool)
        if "legalDistancing" in props and props["legalDistancing"] is not None:
            if not isinstance(props["legalDistancing"], bool):
                try:
                    # Attempt to convert
                    props["legalDistancing"] = bool(props["legalDistancing"])
                except:
                    raise TypeError(f"Property legalDistancing must be of type bool, got {type(props['legalDistancing']).__name__}")
    
        # Type check culturalAuthenticity (expected str)
        if "culturalAuthenticity" in props and props["culturalAuthenticity"] is not None:
            if not isinstance(props["culturalAuthenticity"], str):
                try:
                    # Attempt to convert
                    props["culturalAuthenticity"] = str(props["culturalAuthenticity"])
                except:
                    raise TypeError(f"Property culturalAuthenticity must be of type str, got {type(props['culturalAuthenticity']).__name__}")
    
        # Type check accuracyContribution (expected str)
        if "accuracyContribution" in props and props["accuracyContribution"] is not None:
            if not isinstance(props["accuracyContribution"], str):
                try:
                    # Attempt to convert
                    props["accuracyContribution"] = str(props["accuracyContribution"])
                except:
                    raise TypeError(f"Property accuracyContribution must be of type str, got {type(props['accuracyContribution']).__name__}")
    
        # Type check indirectConsultation (expected bool)
        if "indirectConsultation" in props and props["indirectConsultation"] is not None:
            if not isinstance(props["indirectConsultation"], bool):
                try:
                    # Attempt to convert
                    props["indirectConsultation"] = bool(props["indirectConsultation"])
                except:
                    raise TypeError(f"Property indirectConsultation must be of type bool, got {type(props['indirectConsultation']).__name__}")
    
        # Type check areasAdvised (expected object)
        if "areasAdvised" in props and props["areasAdvised"] is not None:
            if not isinstance(props["areasAdvised"], object):
                try:
                    # Attempt to convert
                    props["areasAdvised"] = object(props["areasAdvised"])
                except:
                    raise TypeError(f"Property areasAdvised must be of type object, got {type(props['areasAdvised']).__name__}")
    
        # Type check compensation (expected int)
        if "compensation" in props and props["compensation"] is not None:
            if not isinstance(props["compensation"], int):
                try:
                    # Attempt to convert
                    props["compensation"] = int(props["compensation"])
                except:
                    raise TypeError(f"Property compensation must be of type int, got {type(props['compensation']).__name__}")
    
        # Type check officialCapacity (expected bool)
        if "officialCapacity" in props and props["officialCapacity"] is not None:
            if not isinstance(props["officialCapacity"], bool):
                try:
                    # Attempt to convert
                    props["officialCapacity"] = bool(props["officialCapacity"])
                except:
                    raise TypeError(f"Property officialCapacity must be of type bool, got {type(props['officialCapacity']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="CONSULTED_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def merchandised(uuid=None, **props):
        """
        Find relationships of type MERCHANDISED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check digitalExpansion (expected str)
        if "digitalExpansion" in props and props["digitalExpansion"] is not None:
            if not isinstance(props["digitalExpansion"], str):
                try:
                    # Attempt to convert
                    props["digitalExpansion"] = str(props["digitalExpansion"])
                except:
                    raise TypeError(f"Property digitalExpansion must be of type str, got {type(props['digitalExpansion']).__name__}")
    
        # Type check contractStart (expected object)
        if "contractStart" in props and props["contractStart"] is not None:
            if not isinstance(props["contractStart"], object):
                try:
                    # Attempt to convert
                    props["contractStart"] = object(props["contractStart"])
                except:
                    raise TypeError(f"Property contractStart must be of type object, got {type(props['contractStart']).__name__}")
    
        # Type check productRevenues (expected object)
        if "productRevenues" in props and props["productRevenues"] is not None:
            if not isinstance(props["productRevenues"], object):
                try:
                    # Attempt to convert
                    props["productRevenues"] = object(props["productRevenues"])
                except:
                    raise TypeError(f"Property productRevenues must be of type object, got {type(props['productRevenues']).__name__}")
    
        # Type check highestGrossingProduct (expected str)
        if "highestGrossingProduct" in props and props["highestGrossingProduct"] is not None:
            if not isinstance(props["highestGrossingProduct"], str):
                try:
                    # Attempt to convert
                    props["highestGrossingProduct"] = str(props["highestGrossingProduct"])
                except:
                    raise TypeError(f"Property highestGrossingProduct must be of type str, got {type(props['highestGrossingProduct']).__name__}")
    
        # Type check totalRevenue (expected int)
        if "totalRevenue" in props and props["totalRevenue"] is not None:
            if not isinstance(props["totalRevenue"], int):
                try:
                    # Attempt to convert
                    props["totalRevenue"] = int(props["totalRevenue"])
                except:
                    raise TypeError(f"Property totalRevenue must be of type int, got {type(props['totalRevenue']).__name__}")
    
        # Type check intellectualPropertyRights (expected str)
        if "intellectualPropertyRights" in props and props["intellectualPropertyRights"] is not None:
            if not isinstance(props["intellectualPropertyRights"], str):
                try:
                    # Attempt to convert
                    props["intellectualPropertyRights"] = str(props["intellectualPropertyRights"])
                except:
                    raise TypeError(f"Property intellectualPropertyRights must be of type str, got {type(props['intellectualPropertyRights']).__name__}")
    
        # Type check anniversaryReleases (expected object)
        if "anniversaryReleases" in props and props["anniversaryReleases"] is not None:
            if not isinstance(props["anniversaryReleases"], object):
                try:
                    # Attempt to convert
                    props["anniversaryReleases"] = object(props["anniversaryReleases"])
                except:
                    raise TypeError(f"Property anniversaryReleases must be of type object, got {type(props['anniversaryReleases']).__name__}")
    
        # Type check productCategories (expected object)
        if "productCategories" in props and props["productCategories"] is not None:
            if not isinstance(props["productCategories"], object):
                try:
                    # Attempt to convert
                    props["productCategories"] = object(props["productCategories"])
                except:
                    raise TypeError(f"Property productCategories must be of type object, got {type(props['productCategories']).__name__}")
    
        # Type check globalDistribution (expected str)
        if "globalDistribution" in props and props["globalDistribution"] is not None:
            if not isinstance(props["globalDistribution"], str):
                try:
                    # Attempt to convert
                    props["globalDistribution"] = str(props["globalDistribution"])
                except:
                    raise TypeError(f"Property globalDistribution must be of type str, got {type(props['globalDistribution']).__name__}")
    
        # Type check licensingPartnerships (expected int)
        if "licensingPartnerships" in props and props["licensingPartnerships"] is not None:
            if not isinstance(props["licensingPartnerships"], int):
                try:
                    # Attempt to convert
                    props["licensingPartnerships"] = int(props["licensingPartnerships"])
                except:
                    raise TypeError(f"Property licensingPartnerships must be of type int, got {type(props['licensingPartnerships']).__name__}")
    
        # Type check initialProducts (expected object)
        if "initialProducts" in props and props["initialProducts"] is not None:
            if not isinstance(props["initialProducts"], object):
                try:
                    # Attempt to convert
                    props["initialProducts"] = object(props["initialProducts"])
                except:
                    raise TypeError(f"Property initialProducts must be of type object, got {type(props['initialProducts']).__name__}")
    
        # Type check expandedProducts (expected object)
        if "expandedProducts" in props and props["expandedProducts"] is not None:
            if not isinstance(props["expandedProducts"], object):
                try:
                    # Attempt to convert
                    props["expandedProducts"] = object(props["expandedProducts"])
                except:
                    raise TypeError(f"Property expandedProducts must be of type object, got {type(props['expandedProducts']).__name__}")
    
        # Type check contractEnd (expected object)
        if "contractEnd" in props and props["contractEnd"] is not None:
            if not isinstance(props["contractEnd"], object):
                try:
                    # Attempt to convert
                    props["contractEnd"] = object(props["contractEnd"])
                except:
                    raise TypeError(f"Property contractEnd must be of type object, got {type(props['contractEnd']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="MERCHANDISED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def awarded_to(uuid=None, **props):
        """
        Find relationships of type AWARDED_TO matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check acceptedBy (expected str)
        if "acceptedBy" in props and props["acceptedBy"] is not None:
            if not isinstance(props["acceptedBy"], str):
                try:
                    # Attempt to convert
                    props["acceptedBy"] = str(props["acceptedBy"])
                except:
                    raise TypeError(f"Property acceptedBy must be of type str, got {type(props['acceptedBy']).__name__}")
    
        # Type check controversies (expected str)
        if "controversies" in props and props["controversies"] is not None:
            if not isinstance(props["controversies"], str):
                try:
                    # Attempt to convert
                    props["controversies"] = str(props["controversies"])
                except:
                    raise TypeError(f"Property controversies must be of type str, got {type(props['controversies']).__name__}")
    
        # Type check industryImpact (expected str)
        if "industryImpact" in props and props["industryImpact"] is not None:
            if not isinstance(props["industryImpact"], str):
                try:
                    # Attempt to convert
                    props["industryImpact"] = str(props["industryImpact"])
                except:
                    raise TypeError(f"Property industryImpact must be of type str, got {type(props['industryImpact']).__name__}")
    
        # Type check historicalContext (expected str)
        if "historicalContext" in props and props["historicalContext"] is not None:
            if not isinstance(props["historicalContext"], str):
                try:
                    # Attempt to convert
                    props["historicalContext"] = str(props["historicalContext"])
                except:
                    raise TypeError(f"Property historicalContext must be of type str, got {type(props['historicalContext']).__name__}")
    
        # Type check competitor4 (expected str)
        if "competitor4" in props and props["competitor4"] is not None:
            if not isinstance(props["competitor4"], str):
                try:
                    # Attempt to convert
                    props["competitor4"] = str(props["competitor4"])
                except:
                    raise TypeError(f"Property competitor4 must be of type str, got {type(props['competitor4']).__name__}")
    
        # Type check mediaHeadlines (expected str)
        if "mediaHeadlines" in props and props["mediaHeadlines"] is not None:
            if not isinstance(props["mediaHeadlines"], str):
                try:
                    # Attempt to convert
                    props["mediaHeadlines"] = str(props["mediaHeadlines"])
                except:
                    raise TypeError(f"Property mediaHeadlines must be of type str, got {type(props['mediaHeadlines']).__name__}")
    
        # Type check competitor2 (expected str)
        if "competitor2" in props and props["competitor2"] is not None:
            if not isinstance(props["competitor2"], str):
                try:
                    # Attempt to convert
                    props["competitor2"] = str(props["competitor2"])
                except:
                    raise TypeError(f"Property competitor2 must be of type str, got {type(props['competitor2']).__name__}")
    
        # Type check votingPercentage (expected float)
        if "votingPercentage" in props and props["votingPercentage"] is not None:
            if not isinstance(props["votingPercentage"], float):
                try:
                    # Attempt to convert
                    props["votingPercentage"] = float(props["votingPercentage"])
                except:
                    raise TypeError(f"Property votingPercentage must be of type float, got {type(props['votingPercentage']).__name__}")
    
        # Type check competitor1 (expected str)
        if "competitor1" in props and props["competitor1"] is not None:
            if not isinstance(props["competitor1"], str):
                try:
                    # Attempt to convert
                    props["competitor1"] = str(props["competitor1"])
                except:
                    raise TypeError(f"Property competitor1 must be of type str, got {type(props['competitor1']).__name__}")
    
        # Type check competitor3 (expected str)
        if "competitor3" in props and props["competitor3"] is not None:
            if not isinstance(props["competitor3"], str):
                try:
                    # Attempt to convert
                    props["competitor3"] = str(props["competitor3"])
                except:
                    raise TypeError(f"Property competitor3 must be of type str, got {type(props['competitor3']).__name__}")
    
        # Type check acceptanceSpeechLength (expected object)
        if "acceptanceSpeechLength" in props and props["acceptanceSpeechLength"] is not None:
            if not isinstance(props["acceptanceSpeechLength"], object):
                try:
                    # Attempt to convert
                    props["acceptanceSpeechLength"] = object(props["acceptanceSpeechLength"])
                except:
                    raise TypeError(f"Property acceptanceSpeechLength must be of type object, got {type(props['acceptanceSpeechLength']).__name__}")
    
        # Type check presentedBy (expected str)
        if "presentedBy" in props and props["presentedBy"] is not None:
            if not isinstance(props["presentedBy"], str):
                try:
                    # Attempt to convert
                    props["presentedBy"] = str(props["presentedBy"])
                except:
                    raise TypeError(f"Property presentedBy must be of type str, got {type(props['presentedBy']).__name__}")
    
        # Type check ceremonyNumber (expected int)
        if "ceremonyNumber" in props and props["ceremonyNumber"] is not None:
            if not isinstance(props["ceremonyNumber"], int):
                try:
                    # Attempt to convert
                    props["ceremonyNumber"] = int(props["ceremonyNumber"])
                except:
                    raise TypeError(f"Property ceremonyNumber must be of type int, got {type(props['ceremonyNumber']).__name__}")
    
        # Type check awardDate (expected object)
        if "awardDate" in props and props["awardDate"] is not None:
            if not isinstance(props["awardDate"], object):
                try:
                    # Attempt to convert
                    props["awardDate"] = object(props["awardDate"])
                except:
                    raise TypeError(f"Property awardDate must be of type object, got {type(props['awardDate']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="AWARDED_TO", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def edited(uuid=None, **props):
        """
        Find relationships of type EDITED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check initialCutLength (expected object)
        if "initialCutLength" in props and props["initialCutLength"] is not None:
            if not isinstance(props["initialCutLength"], object):
                try:
                    # Attempt to convert
                    props["initialCutLength"] = object(props["initialCutLength"])
                except:
                    raise TypeError(f"Property initialCutLength must be of type object, got {type(props['initialCutLength']).__name__}")
    
        # Type check directorSessions (expected int)
        if "directorSessions" in props and props["directorSessions"] is not None:
            if not isinstance(props["directorSessions"], int):
                try:
                    # Attempt to convert
                    props["directorSessions"] = int(props["directorSessions"])
                except:
                    raise TypeError(f"Property directorSessions must be of type int, got {type(props['directorSessions']).__name__}")
    
        # Type check footageReviewed (expected int)
        if "footageReviewed" in props and props["footageReviewed"] is not None:
            if not isinstance(props["footageReviewed"], int):
                try:
                    # Attempt to convert
                    props["footageReviewed"] = int(props["footageReviewed"])
                except:
                    raise TypeError(f"Property footageReviewed must be of type int, got {type(props['footageReviewed']).__name__}")
    
        # Type check controversies (expected str)
        if "controversies" in props and props["controversies"] is not None:
            if not isinstance(props["controversies"], str):
                try:
                    # Attempt to convert
                    props["controversies"] = str(props["controversies"])
                except:
                    raise TypeError(f"Property controversies must be of type str, got {type(props['controversies']).__name__}")
    
        # Type check cuttingRatio (expected float)
        if "cuttingRatio" in props and props["cuttingRatio"] is not None:
            if not isinstance(props["cuttingRatio"], float):
                try:
                    # Attempt to convert
                    props["cuttingRatio"] = float(props["cuttingRatio"])
                except:
                    raise TypeError(f"Property cuttingRatio must be of type float, got {type(props['cuttingRatio']).__name__}")
    
        # Type check footageUnit (expected str)
        if "footageUnit" in props and props["footageUnit"] is not None:
            if not isinstance(props["footageUnit"], str):
                try:
                    # Attempt to convert
                    props["footageUnit"] = str(props["footageUnit"])
                except:
                    raise TypeError(f"Property footageUnit must be of type str, got {type(props['footageUnit']).__name__}")
    
        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Type check finalCutLength (expected object)
        if "finalCutLength" in props and props["finalCutLength"] is not None:
            if not isinstance(props["finalCutLength"], object):
                try:
                    # Attempt to convert
                    props["finalCutLength"] = object(props["finalCutLength"])
                except:
                    raise TypeError(f"Property finalCutLength must be of type object, got {type(props['finalCutLength']).__name__}")
    
        # Type check editingSessions (expected int)
        if "editingSessions" in props and props["editingSessions"] is not None:
            if not isinstance(props["editingSessions"], int):
                try:
                    # Attempt to convert
                    props["editingSessions"] = int(props["editingSessions"])
                except:
                    raise TypeError(f"Property editingSessions must be of type int, got {type(props['editingSessions']).__name__}")
    
        # Type check completionDate (expected object)
        if "completionDate" in props and props["completionDate"] is not None:
            if not isinstance(props["completionDate"], object):
                try:
                    # Attempt to convert
                    props["completionDate"] = object(props["completionDate"])
                except:
                    raise TypeError(f"Property completionDate must be of type object, got {type(props['completionDate']).__name__}")
    
        # Type check editingSystems (expected object)
        if "editingSystems" in props and props["editingSystems"] is not None:
            if not isinstance(props["editingSystems"], object):
                try:
                    # Attempt to convert
                    props["editingSystems"] = object(props["editingSystems"])
                except:
                    raise TypeError(f"Property editingSystems must be of type object, got {type(props['editingSystems']).__name__}")
    
        # Type check significantEdits (expected object)
        if "significantEdits" in props and props["significantEdits"] is not None:
            if not isinstance(props["significantEdits"], object):
                try:
                    # Attempt to convert
                    props["significantEdits"] = object(props["significantEdits"])
                except:
                    raise TypeError(f"Property significantEdits must be of type object, got {type(props['significantEdits']).__name__}")
    
        # Type check directorRelationship (expected str)
        if "directorRelationship" in props and props["directorRelationship"] is not None:
            if not isinstance(props["directorRelationship"], str):
                try:
                    # Attempt to convert
                    props["directorRelationship"] = str(props["directorRelationship"])
                except:
                    raise TypeError(f"Property directorRelationship must be of type str, got {type(props['directorRelationship']).__name__}")
    
        # Type check narrativeContributions (expected object)
        if "narrativeContributions" in props and props["narrativeContributions"] is not None:
            if not isinstance(props["narrativeContributions"], object):
                try:
                    # Attempt to convert
                    props["narrativeContributions"] = object(props["narrativeContributions"])
                except:
                    raise TypeError(f"Property narrativeContributions must be of type object, got {type(props['narrativeContributions']).__name__}")
    
        # Type check editingApproach (expected str)
        if "editingApproach" in props and props["editingApproach"] is not None:
            if not isinstance(props["editingApproach"], str):
                try:
                    # Attempt to convert
                    props["editingApproach"] = str(props["editingApproach"])
                except:
                    raise TypeError(f"Property editingApproach must be of type str, got {type(props['editingApproach']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="EDITED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def affected(uuid=None, **props):
        """
        Find relationships of type AFFECTED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check historicalLegacy (expected str)
        if "historicalLegacy" in props and props["historicalLegacy"] is not None:
            if not isinstance(props["historicalLegacy"], str):
                try:
                    # Attempt to convert
                    props["historicalLegacy"] = str(props["historicalLegacy"])
                except:
                    raise TypeError(f"Property historicalLegacy must be of type str, got {type(props['historicalLegacy']).__name__}")
    
        # Type check challengeRatings (expected object)
        if "challengeRatings" in props and props["challengeRatings"] is not None:
            if not isinstance(props["challengeRatings"], object):
                try:
                    # Attempt to convert
                    props["challengeRatings"] = object(props["challengeRatings"])
                except:
                    raise TypeError(f"Property challengeRatings must be of type object, got {type(props['challengeRatings']).__name__}")
    
        # Type check castingBattles (expected object)
        if "castingBattles" in props and props["castingBattles"] is not None:
            if not isinstance(props["castingBattles"], object):
                try:
                    # Attempt to convert
                    props["castingBattles"] = object(props["castingBattles"])
                except:
                    raise TypeError(f"Property castingBattles must be of type object, got {type(props['castingBattles']).__name__}")
    
        # Type check keyAdvocates (expected object)
        if "keyAdvocates" in props and props["keyAdvocates"] is not None:
            if not isinstance(props["keyAdvocates"], object):
                try:
                    # Attempt to convert
                    props["keyAdvocates"] = object(props["keyAdvocates"])
                except:
                    raise TypeError(f"Property keyAdvocates must be of type object, got {type(props['keyAdvocates']).__name__}")
    
        # Type check victoriousDecisions (expected object)
        if "victoriousDecisions" in props and props["victoriousDecisions"] is not None:
            if not isinstance(props["victoriousDecisions"], object):
                try:
                    # Attempt to convert
                    props["victoriousDecisions"] = object(props["victoriousDecisions"])
                except:
                    raise TypeError(f"Property victoriousDecisions must be of type object, got {type(props['victoriousDecisions']).__name__}")
    
        # Type check compromisesMade (expected object)
        if "compromisesMade" in props and props["compromisesMade"] is not None:
            if not isinstance(props["compromisesMade"], object):
                try:
                    # Attempt to convert
                    props["compromisesMade"] = object(props["compromisesMade"])
                except:
                    raise TypeError(f"Property compromisesMade must be of type object, got {type(props['compromisesMade']).__name__}")
    
        # Type check chiefChallenges (expected object)
        if "chiefChallenges" in props and props["chiefChallenges"] is not None:
            if not isinstance(props["chiefChallenges"], object):
                try:
                    # Attempt to convert
                    props["chiefChallenges"] = object(props["chiefChallenges"])
                except:
                    raise TypeError(f"Property chiefChallenges must be of type object, got {type(props['chiefChallenges']).__name__}")
    
        # Type check studioConflicts (expected str)
        if "studioConflicts" in props and props["studioConflicts"] is not None:
            if not isinstance(props["studioConflicts"], str):
                try:
                    # Attempt to convert
                    props["studioConflicts"] = str(props["studioConflicts"])
                except:
                    raise TypeError(f"Property studioConflicts must be of type str, got {type(props['studioConflicts']).__name__}")
    
        # Type check locationProblems (expected object)
        if "locationProblems" in props and props["locationProblems"] is not None:
            if not isinstance(props["locationProblems"], object):
                try:
                    # Attempt to convert
                    props["locationProblems"] = object(props["locationProblems"])
                except:
                    raise TypeError(f"Property locationProblems must be of type object, got {type(props['locationProblems']).__name__}")
    
        # Type check resolutionStrategies (expected object)
        if "resolutionStrategies" in props and props["resolutionStrategies"] is not None:
            if not isinstance(props["resolutionStrategies"], object):
                try:
                    # Attempt to convert
                    props["resolutionStrategies"] = object(props["resolutionStrategies"])
                except:
                    raise TypeError(f"Property resolutionStrategies must be of type object, got {type(props['resolutionStrategies']).__name__}")
    
        # Type check riskedCancellation (expected bool)
        if "riskedCancellation" in props and props["riskedCancellation"] is not None:
            if not isinstance(props["riskedCancellation"], bool):
                try:
                    # Attempt to convert
                    props["riskedCancellation"] = bool(props["riskedCancellation"])
                except:
                    raise TypeError(f"Property riskedCancellation must be of type bool, got {type(props['riskedCancellation']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="AFFECTED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def coached_dialects_for(uuid=None, **props):
        """
        Find relationships of type COACHED_DIALECTS_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check audienceReception (expected str)
        if "audienceReception" in props and props["audienceReception"] is not None:
            if not isinstance(props["audienceReception"], str):
                try:
                    # Attempt to convert
                    props["audienceReception"] = str(props["audienceReception"])
                except:
                    raise TypeError(f"Property audienceReception must be of type str, got {type(props['audienceReception']).__name__}")
    
        # Type check startDate (expected object)
        if "startDate" in props and props["startDate"] is not None:
            if not isinstance(props["startDate"], object):
                try:
                    # Attempt to convert
                    props["startDate"] = object(props["startDate"])
                except:
                    raise TypeError(f"Property startDate must be of type object, got {type(props['startDate']).__name__}")
    
        # Type check culturalContextTeaching (expected str)
        if "culturalContextTeaching" in props and props["culturalContextTeaching"] is not None:
            if not isinstance(props["culturalContextTeaching"], str):
                try:
                    # Attempt to convert
                    props["culturalContextTeaching"] = str(props["culturalContextTeaching"])
                except:
                    raise TypeError(f"Property culturalContextTeaching must be of type str, got {type(props['culturalContextTeaching']).__name__}")
    
        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Type check completionDate (expected object)
        if "completionDate" in props and props["completionDate"] is not None:
            if not isinstance(props["completionDate"], object):
                try:
                    # Attempt to convert
                    props["completionDate"] = object(props["completionDate"])
                except:
                    raise TypeError(f"Property completionDate must be of type object, got {type(props['completionDate']).__name__}")
    
        # Type check trainingHours (expected int)
        if "trainingHours" in props and props["trainingHours"] is not None:
            if not isinstance(props["trainingHours"], int):
                try:
                    # Attempt to convert
                    props["trainingHours"] = int(props["trainingHours"])
                except:
                    raise TypeError(f"Property trainingHours must be of type int, got {type(props['trainingHours']).__name__}")
    
        # Type check actorsTrained (expected object)
        if "actorsTrained" in props and props["actorsTrained"] is not None:
            if not isinstance(props["actorsTrained"], object):
                try:
                    # Attempt to convert
                    props["actorsTrained"] = object(props["actorsTrained"])
                except:
                    raise TypeError(f"Property actorsTrained must be of type object, got {type(props['actorsTrained']).__name__}")
    
        # Type check caseDifferences (expected object)
        if "caseDifferences" in props and props["caseDifferences"] is not None:
            if not isinstance(props["caseDifferences"], object):
                try:
                    # Attempt to convert
                    props["caseDifferences"] = object(props["caseDifferences"])
                except:
                    raise TypeError(f"Property caseDifferences must be of type object, got {type(props['caseDifferences']).__name__}")
    
        # Type check languagesTaught (expected object)
        if "languagesTaught" in props and props["languagesTaught"] is not None:
            if not isinstance(props["languagesTaught"], object):
                try:
                    # Attempt to convert
                    props["languagesTaught"] = object(props["languagesTaught"])
                except:
                    raise TypeError(f"Property languagesTaught must be of type object, got {type(props['languagesTaught']).__name__}")
    
        # Type check dialectSpecifics (expected object)
        if "dialectSpecifics" in props and props["dialectSpecifics"] is not None:
            if not isinstance(props["dialectSpecifics"], object):
                try:
                    # Attempt to convert
                    props["dialectSpecifics"] = object(props["dialectSpecifics"])
                except:
                    raise TypeError(f"Property dialectSpecifics must be of type object, got {type(props['dialectSpecifics']).__name__}")
    
        # Type check pronunciationAccuracy (expected float)
        if "pronunciationAccuracy" in props and props["pronunciationAccuracy"] is not None:
            if not isinstance(props["pronunciationAccuracy"], float):
                try:
                    # Attempt to convert
                    props["pronunciationAccuracy"] = float(props["pronunciationAccuracy"])
                except:
                    raise TypeError(f"Property pronunciationAccuracy must be of type float, got {type(props['pronunciationAccuracy']).__name__}")
    
        # Type check methodsUsed (expected object)
        if "methodsUsed" in props and props["methodsUsed"] is not None:
            if not isinstance(props["methodsUsed"], object):
                try:
                    # Attempt to convert
                    props["methodsUsed"] = object(props["methodsUsed"])
                except:
                    raise TypeError(f"Property methodsUsed must be of type object, got {type(props['methodsUsed']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="COACHED_DIALECTS_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def romantically_involved_with(uuid=None, **props):
        """
        Find relationships of type ROMANTICALLY_INVOLVED_WITH matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check collaboration_years (expected object)
        if "collaboration_years" in props and props["collaboration_years"] is not None:
            if not isinstance(props["collaboration_years"], object):
                try:
                    # Attempt to convert
                    props["collaboration_years"] = object(props["collaboration_years"])
                except:
                    raise TypeError(f"Property collaboration_years must be of type object, got {type(props['collaboration_years']).__name__}")
    
        # Type check endDate (expected object)
        if "endDate" in props and props["endDate"] is not None:
            if not isinstance(props["endDate"], object):
                try:
                    # Attempt to convert
                    props["endDate"] = object(props["endDate"])
                except:
                    raise TypeError(f"Property endDate must be of type object, got {type(props['endDate']).__name__}")
    
        # Type check on_screen_chemistry (expected str)
        if "on_screen_chemistry" in props and props["on_screen_chemistry"] is not None:
            if not isinstance(props["on_screen_chemistry"], str):
                try:
                    # Attempt to convert
                    props["on_screen_chemistry"] = str(props["on_screen_chemistry"])
                except:
                    raise TypeError(f"Property on_screen_chemistry must be of type str, got {type(props['on_screen_chemistry']).__name__}")
    
        # Type check relationship_end (expected str)
        if "relationship_end" in props and props["relationship_end"] is not None:
            if not isinstance(props["relationship_end"], str):
                try:
                    # Attempt to convert
                    props["relationship_end"] = str(props["relationship_end"])
                except:
                    raise TypeError(f"Property relationship_end must be of type str, got {type(props['relationship_end']).__name__}")
    
        # Type check met_on_set (expected str)
        if "met_on_set" in props and props["met_on_set"] is not None:
            if not isinstance(props["met_on_set"], str):
                try:
                    # Attempt to convert
                    props["met_on_set"] = str(props["met_on_set"])
                except:
                    raise TypeError(f"Property met_on_set must be of type str, got {type(props['met_on_set']).__name__}")
    
        # Type check professional_collaborations (expected int)
        if "professional_collaborations" in props and props["professional_collaborations"] is not None:
            if not isinstance(props["professional_collaborations"], int):
                try:
                    # Attempt to convert
                    props["professional_collaborations"] = int(props["professional_collaborations"])
                except:
                    raise TypeError(f"Property professional_collaborations must be of type int, got {type(props['professional_collaborations']).__name__}")
    
        # Type check collaborative_projects (expected object)
        if "collaborative_projects" in props and props["collaborative_projects"] is not None:
            if not isinstance(props["collaborative_projects"], object):
                try:
                    # Attempt to convert
                    props["collaborative_projects"] = object(props["collaborative_projects"])
                except:
                    raise TypeError(f"Property collaborative_projects must be of type object, got {type(props['collaborative_projects']).__name__}")
    
        # Type check relationship_duration (expected object)
        if "relationship_duration" in props and props["relationship_duration"] is not None:
            if not isinstance(props["relationship_duration"], object):
                try:
                    # Attempt to convert
                    props["relationship_duration"] = object(props["relationship_duration"])
                except:
                    raise TypeError(f"Property relationship_duration must be of type object, got {type(props['relationship_duration']).__name__}")
    
        # Type check media_coverage (expected str)
        if "media_coverage" in props and props["media_coverage"] is not None:
            if not isinstance(props["media_coverage"], str):
                try:
                    # Attempt to convert
                    props["media_coverage"] = str(props["media_coverage"])
                except:
                    raise TypeError(f"Property media_coverage must be of type str, got {type(props['media_coverage']).__name__}")
    
        # Type check public_disclosure (expected object)
        if "public_disclosure" in props and props["public_disclosure"] is not None:
            if not isinstance(props["public_disclosure"], object):
                try:
                    # Attempt to convert
                    props["public_disclosure"] = object(props["public_disclosure"])
                except:
                    raise TypeError(f"Property public_disclosure must be of type object, got {type(props['public_disclosure']).__name__}")
    
        # Type check startDate (expected object)
        if "startDate" in props and props["startDate"] is not None:
            if not isinstance(props["startDate"], object):
                try:
                    # Attempt to convert
                    props["startDate"] = object(props["startDate"])
                except:
                    raise TypeError(f"Property startDate must be of type object, got {type(props['startDate']).__name__}")
    
        # Type check relationship_impact (expected str)
        if "relationship_impact" in props and props["relationship_impact"] is not None:
            if not isinstance(props["relationship_impact"], str):
                try:
                    # Attempt to convert
                    props["relationship_impact"] = str(props["relationship_impact"])
                except:
                    raise TypeError(f"Property relationship_impact must be of type str, got {type(props['relationship_impact']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="ROMANTICALLY_INVOLVED_WITH", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def executive_produced(uuid=None, **props):
        """
        Find relationships of type EXECUTIVE_PRODUCED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check corporate_pressure_handling (expected str)
        if "corporate_pressure_handling" in props and props["corporate_pressure_handling"] is not None:
            if not isinstance(props["corporate_pressure_handling"], str):
                try:
                    # Attempt to convert
                    props["corporate_pressure_handling"] = str(props["corporate_pressure_handling"])
                except:
                    raise TypeError(f"Property corporate_pressure_handling must be of type str, got {type(props['corporate_pressure_handling']).__name__}")
    
        # Type check personal_stake (expected str)
        if "personal_stake" in props and props["personal_stake"] is not None:
            if not isinstance(props["personal_stake"], str):
                try:
                    # Attempt to convert
                    props["personal_stake"] = str(props["personal_stake"])
                except:
                    raise TypeError(f"Property personal_stake must be of type str, got {type(props['personal_stake']).__name__}")
    
        # Type check boardroom_battles (expected int)
        if "boardroom_battles" in props and props["boardroom_battles"] is not None:
            if not isinstance(props["boardroom_battles"], int):
                try:
                    # Attempt to convert
                    props["boardroom_battles"] = int(props["boardroom_battles"])
                except:
                    raise TypeError(f"Property boardroom_battles must be of type int, got {type(props['boardroom_battles']).__name__}")
    
        # Type check role (expected str)
        if "role" in props and props["role"] is not None:
            if not isinstance(props["role"], str):
                try:
                    # Attempt to convert
                    props["role"] = str(props["role"])
                except:
                    raise TypeError(f"Property role must be of type str, got {type(props['role']).__name__}")
    
        # Type check retrospective_assessment (expected str)
        if "retrospective_assessment" in props and props["retrospective_assessment"] is not None:
            if not isinstance(props["retrospective_assessment"], str):
                try:
                    # Attempt to convert
                    props["retrospective_assessment"] = str(props["retrospective_assessment"])
                except:
                    raise TypeError(f"Property retrospective_assessment must be of type str, got {type(props['retrospective_assessment']).__name__}")
    
        # Type check budget_approval (expected object)
        if "budget_approval" in props and props["budget_approval"] is not None:
            if not isinstance(props["budget_approval"], object):
                try:
                    # Attempt to convert
                    props["budget_approval"] = object(props["budget_approval"])
                except:
                    raise TypeError(f"Property budget_approval must be of type object, got {type(props['budget_approval']).__name__}")
    
        # Type check authority_level (expected str)
        if "authority_level" in props and props["authority_level"] is not None:
            if not isinstance(props["authority_level"], str):
                try:
                    # Attempt to convert
                    props["authority_level"] = str(props["authority_level"])
                except:
                    raise TypeError(f"Property authority_level must be of type str, got {type(props['authority_level']).__name__}")
    
        # Type check risk_assessment (expected str)
        if "risk_assessment" in props and props["risk_assessment"] is not None:
            if not isinstance(props["risk_assessment"], str):
                try:
                    # Attempt to convert
                    props["risk_assessment"] = str(props["risk_assessment"])
                except:
                    raise TypeError(f"Property risk_assessment must be of type str, got {type(props['risk_assessment']).__name__}")
    
        # Type check key_contributions (expected object)
        if "key_contributions" in props and props["key_contributions"] is not None:
            if not isinstance(props["key_contributions"], object):
                try:
                    # Attempt to convert
                    props["key_contributions"] = object(props["key_contributions"])
                except:
                    raise TypeError(f"Property key_contributions must be of type object, got {type(props['key_contributions']).__name__}")
    
        # Type check studio_opponents (expected object)
        if "studio_opponents" in props and props["studio_opponents"] is not None:
            if not isinstance(props["studio_opponents"], object):
                try:
                    # Attempt to convert
                    props["studio_opponents"] = object(props["studio_opponents"])
                except:
                    raise TypeError(f"Property studio_opponents must be of type object, got {type(props['studio_opponents']).__name__}")
    
        # Type check studio_advocates (expected object)
        if "studio_advocates" in props and props["studio_advocates"] is not None:
            if not isinstance(props["studio_advocates"], object):
                try:
                    # Attempt to convert
                    props["studio_advocates"] = object(props["studio_advocates"])
                except:
                    raise TypeError(f"Property studio_advocates must be of type object, got {type(props['studio_advocates']).__name__}")
    
        # Type check marketing_strategies (expected object)
        if "marketing_strategies" in props and props["marketing_strategies"] is not None:
            if not isinstance(props["marketing_strategies"], object):
                try:
                    # Attempt to convert
                    props["marketing_strategies"] = object(props["marketing_strategies"])
                except:
                    raise TypeError(f"Property marketing_strategies must be of type object, got {type(props['marketing_strategies']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="EXECUTIVE_PRODUCED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def corporate_oversight(uuid=None, **props):
        """
        Find relationships of type CORPORATE_OVERSIGHT matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check financial_analysis_commissioned (expected str)
        if "financial_analysis_commissioned" in props and props["financial_analysis_commissioned"] is not None:
            if not isinstance(props["financial_analysis_commissioned"], str):
                try:
                    # Attempt to convert
                    props["financial_analysis_commissioned"] = str(props["financial_analysis_commissioned"])
                except:
                    raise TypeError(f"Property financial_analysis_commissioned must be of type str, got {type(props['financial_analysis_commissioned']).__name__}")
    
        # Type check quarterly_reports_impact (expected str)
        if "quarterly_reports_impact" in props and props["quarterly_reports_impact"] is not None:
            if not isinstance(props["quarterly_reports_impact"], str):
                try:
                    # Attempt to convert
                    props["quarterly_reports_impact"] = str(props["quarterly_reports_impact"])
                except:
                    raise TypeError(f"Property quarterly_reports_impact must be of type str, got {type(props['quarterly_reports_impact']).__name__}")
    
        # Type check investment_approval (expected bool)
        if "investment_approval" in props and props["investment_approval"] is not None:
            if not isinstance(props["investment_approval"], bool):
                try:
                    # Attempt to convert
                    props["investment_approval"] = bool(props["investment_approval"])
                except:
                    raise TypeError(f"Property investment_approval must be of type bool, got {type(props['investment_approval']).__name__}")
    
        # Type check corporate_interference (expected str)
        if "corporate_interference" in props and props["corporate_interference"] is not None:
            if not isinstance(props["corporate_interference"], str):
                try:
                    # Attempt to convert
                    props["corporate_interference"] = str(props["corporate_interference"])
                except:
                    raise TypeError(f"Property corporate_interference must be of type str, got {type(props['corporate_interference']).__name__}")
    
        # Type check shareholder_communication (expected str)
        if "shareholder_communication" in props and props["shareholder_communication"] is not None:
            if not isinstance(props["shareholder_communication"], str):
                try:
                    # Attempt to convert
                    props["shareholder_communication"] = str(props["shareholder_communication"])
                except:
                    raise TypeError(f"Property shareholder_communication must be of type str, got {type(props['shareholder_communication']).__name__}")
    
        # Type check budget_concerns (expected str)
        if "budget_concerns" in props and props["budget_concerns"] is not None:
            if not isinstance(props["budget_concerns"], str):
                try:
                    # Attempt to convert
                    props["budget_concerns"] = str(props["budget_concerns"])
                except:
                    raise TypeError(f"Property budget_concerns must be of type str, got {type(props['budget_concerns']).__name__}")
    
        # Type check reaction_to_success (expected str)
        if "reaction_to_success" in props and props["reaction_to_success"] is not None:
            if not isinstance(props["reaction_to_success"], str):
                try:
                    # Attempt to convert
                    props["reaction_to_success"] = str(props["reaction_to_success"])
                except:
                    raise TypeError(f"Property reaction_to_success must be of type str, got {type(props['reaction_to_success']).__name__}")
    
        # Type check profit_expectations (expected str)
        if "profit_expectations" in props and props["profit_expectations"] is not None:
            if not isinstance(props["profit_expectations"], str):
                try:
                    # Attempt to convert
                    props["profit_expectations"] = str(props["profit_expectations"])
                except:
                    raise TypeError(f"Property profit_expectations must be of type str, got {type(props['profit_expectations']).__name__}")
    
        # Type check executive_chain (expected str)
        if "executive_chain" in props and props["executive_chain"] is not None:
            if not isinstance(props["executive_chain"], str):
                try:
                    # Attempt to convert
                    props["executive_chain"] = str(props["executive_chain"])
                except:
                    raise TypeError(f"Property executive_chain must be of type str, got {type(props['executive_chain']).__name__}")
    
        # Type check key_interventions (expected object)
        if "key_interventions" in props and props["key_interventions"] is not None:
            if not isinstance(props["key_interventions"], object):
                try:
                    # Attempt to convert
                    props["key_interventions"] = object(props["key_interventions"])
                except:
                    raise TypeError(f"Property key_interventions must be of type object, got {type(props['key_interventions']).__name__}")
    
        # Type check company_role (expected str)
        if "company_role" in props and props["company_role"] is not None:
            if not isinstance(props["company_role"], str):
                try:
                    # Attempt to convert
                    props["company_role"] = str(props["company_role"])
                except:
                    raise TypeError(f"Property company_role must be of type str, got {type(props['company_role']).__name__}")
    
        # Type check corporate_strategy_impact (expected str)
        if "corporate_strategy_impact" in props and props["corporate_strategy_impact"] is not None:
            if not isinstance(props["corporate_strategy_impact"], str):
                try:
                    # Attempt to convert
                    props["corporate_strategy_impact"] = str(props["corporate_strategy_impact"])
                except:
                    raise TypeError(f"Property corporate_strategy_impact must be of type str, got {type(props['corporate_strategy_impact']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="CORPORATE_OVERSIGHT", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def developed(uuid=None, **props):
        """
        Find relationships of type DEVELOPED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check price_currency (expected str)
        if "price_currency" in props and props["price_currency"] is not None:
            if not isinstance(props["price_currency"], str):
                try:
                    # Attempt to convert
                    props["price_currency"] = str(props["price_currency"])
                except:
                    raise TypeError(f"Property price_currency must be of type str, got {type(props['price_currency']).__name__}")
    
        # Type check internal_advocacy (expected str)
        if "internal_advocacy" in props and props["internal_advocacy"] is not None:
            if not isinstance(props["internal_advocacy"], str):
                try:
                    # Attempt to convert
                    props["internal_advocacy"] = str(props["internal_advocacy"])
                except:
                    raise TypeError(f"Property internal_advocacy must be of type str, got {type(props['internal_advocacy']).__name__}")
    
        # Type check development_start (expected object)
        if "development_start" in props and props["development_start"] is not None:
            if not isinstance(props["development_start"], object):
                try:
                    # Attempt to convert
                    props["development_start"] = object(props["development_start"])
                except:
                    raise TypeError(f"Property development_start must be of type object, got {type(props['development_start']).__name__}")
    
        # Type check price_negotiated (expected int)
        if "price_negotiated" in props and props["price_negotiated"] is not None:
            if not isinstance(props["price_negotiated"], int):
                try:
                    # Attempt to convert
                    props["price_negotiated"] = int(props["price_negotiated"])
                except:
                    raise TypeError(f"Property price_negotiated must be of type int, got {type(props['price_negotiated']).__name__}")
    
        # Type check project_champion (expected bool)
        if "project_champion" in props and props["project_champion"] is not None:
            if not isinstance(props["project_champion"], bool):
                try:
                    # Attempt to convert
                    props["project_champion"] = bool(props["project_champion"])
                except:
                    raise TypeError(f"Property project_champion must be of type bool, got {type(props['project_champion']).__name__}")
    
        # Type check script_development_supervision (expected str)
        if "script_development_supervision" in props and props["script_development_supervision"] is not None:
            if not isinstance(props["script_development_supervision"], str):
                try:
                    # Attempt to convert
                    props["script_development_supervision"] = str(props["script_development_supervision"])
                except:
                    raise TypeError(f"Property script_development_supervision must be of type str, got {type(props['script_development_supervision']).__name__}")
    
        # Type check production_notes_provided (expected str)
        if "production_notes_provided" in props and props["production_notes_provided"] is not None:
            if not isinstance(props["production_notes_provided"], str):
                try:
                    # Attempt to convert
                    props["production_notes_provided"] = str(props["production_notes_provided"])
                except:
                    raise TypeError(f"Property production_notes_provided must be of type str, got {type(props['production_notes_provided']).__name__}")
    
        # Type check key_negotiations (expected object)
        if "key_negotiations" in props and props["key_negotiations"] is not None:
            if not isinstance(props["key_negotiations"], object):
                try:
                    # Attempt to convert
                    props["key_negotiations"] = object(props["key_negotiations"])
                except:
                    raise TypeError(f"Property key_negotiations must be of type object, got {type(props['key_negotiations']).__name__}")
    
        # Type check creative_insights (expected str)
        if "creative_insights" in props and props["creative_insights"] is not None:
            if not isinstance(props["creative_insights"], str):
                try:
                    # Attempt to convert
                    props["creative_insights"] = str(props["creative_insights"])
                except:
                    raise TypeError(f"Property creative_insights must be of type str, got {type(props['creative_insights']).__name__}")
    
        # Type check director_selection_influence (expected str)
        if "director_selection_influence" in props and props["director_selection_influence"] is not None:
            if not isinstance(props["director_selection_influence"], str):
                try:
                    # Attempt to convert
                    props["director_selection_influence"] = str(props["director_selection_influence"])
                except:
                    raise TypeError(f"Property director_selection_influence must be of type str, got {type(props['director_selection_influence']).__name__}")
    
        # Type check book_rights_advocate (expected bool)
        if "book_rights_advocate" in props and props["book_rights_advocate"] is not None:
            if not isinstance(props["book_rights_advocate"], bool):
                try:
                    # Attempt to convert
                    props["book_rights_advocate"] = bool(props["book_rights_advocate"])
                except:
                    raise TypeError(f"Property book_rights_advocate must be of type bool, got {type(props['book_rights_advocate']).__name__}")
    
        # Type check novel_acquisition (expected object)
        if "novel_acquisition" in props and props["novel_acquisition"] is not None:
            if not isinstance(props["novel_acquisition"], object):
                try:
                    # Attempt to convert
                    props["novel_acquisition"] = object(props["novel_acquisition"])
                except:
                    raise TypeError(f"Property novel_acquisition must be of type object, got {type(props['novel_acquisition']).__name__}")
    
        # Type check project_timeline_oversight (expected str)
        if "project_timeline_oversight" in props and props["project_timeline_oversight"] is not None:
            if not isinstance(props["project_timeline_oversight"], str):
                try:
                    # Attempt to convert
                    props["project_timeline_oversight"] = str(props["project_timeline_oversight"])
                except:
                    raise TypeError(f"Property project_timeline_oversight must be of type str, got {type(props['project_timeline_oversight']).__name__}")
    
        # Type check executive_role (expected str)
        if "executive_role" in props and props["executive_role"] is not None:
            if not isinstance(props["executive_role"], str):
                try:
                    # Attempt to convert
                    props["executive_role"] = str(props["executive_role"])
                except:
                    raise TypeError(f"Property executive_role must be of type str, got {type(props['executive_role']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="DEVELOPED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def studio_produced(uuid=None, **props):
        """
        Find relationships of type STUDIO_PRODUCED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check corporate_tension (expected str)
        if "corporate_tension" in props and props["corporate_tension"] is not None:
            if not isinstance(props["corporate_tension"], str):
                try:
                    # Attempt to convert
                    props["corporate_tension"] = str(props["corporate_tension"])
                except:
                    raise TypeError(f"Property corporate_tension must be of type str, got {type(props['corporate_tension']).__name__}")
    
        # Type check distribution_commitment (expected str)
        if "distribution_commitment" in props and props["distribution_commitment"] is not None:
            if not isinstance(props["distribution_commitment"], str):
                try:
                    # Attempt to convert
                    props["distribution_commitment"] = str(props["distribution_commitment"])
                except:
                    raise TypeError(f"Property distribution_commitment must be of type str, got {type(props['distribution_commitment']).__name__}")
    
        # Type check theatrical_distribution_strategy (expected str)
        if "theatrical_distribution_strategy" in props and props["theatrical_distribution_strategy"] is not None:
            if not isinstance(props["theatrical_distribution_strategy"], str):
                try:
                    # Attempt to convert
                    props["theatrical_distribution_strategy"] = str(props["theatrical_distribution_strategy"])
                except:
                    raise TypeError(f"Property theatrical_distribution_strategy must be of type str, got {type(props['theatrical_distribution_strategy']).__name__}")
    
        # Type check special_insurance (expected str)
        if "special_insurance" in props and props["special_insurance"] is not None:
            if not isinstance(props["special_insurance"], str):
                try:
                    # Attempt to convert
                    props["special_insurance"] = str(props["special_insurance"])
                except:
                    raise TypeError(f"Property special_insurance must be of type str, got {type(props['special_insurance']).__name__}")
    
        # Type check production_facilities_provided (expected object)
        if "production_facilities_provided" in props and props["production_facilities_provided"] is not None:
            if not isinstance(props["production_facilities_provided"], object):
                try:
                    # Attempt to convert
                    props["production_facilities_provided"] = object(props["production_facilities_provided"])
                except:
                    raise TypeError(f"Property production_facilities_provided must be of type object, got {type(props['production_facilities_provided']).__name__}")
    
        # Type check marketing_budget_initial (expected int)
        if "marketing_budget_initial" in props and props["marketing_budget_initial"] is not None:
            if not isinstance(props["marketing_budget_initial"], int):
                try:
                    # Attempt to convert
                    props["marketing_budget_initial"] = int(props["marketing_budget_initial"])
                except:
                    raise TypeError(f"Property marketing_budget_initial must be of type int, got {type(props['marketing_budget_initial']).__name__}")
    
        # Type check project_greenlight (expected object)
        if "project_greenlight" in props and props["project_greenlight"] is not None:
            if not isinstance(props["project_greenlight"], object):
                try:
                    # Attempt to convert
                    props["project_greenlight"] = object(props["project_greenlight"])
                except:
                    raise TypeError(f"Property project_greenlight must be of type object, got {type(props['project_greenlight']).__name__}")
    
        # Type check profit_participants (expected object)
        if "profit_participants" in props and props["profit_participants"] is not None:
            if not isinstance(props["profit_participants"], object):
                try:
                    # Attempt to convert
                    props["profit_participants"] = object(props["profit_participants"])
                except:
                    raise TypeError(f"Property profit_participants must be of type object, got {type(props['profit_participants']).__name__}")
    
        # Type check production_account (expected str)
        if "production_account" in props and props["production_account"] is not None:
            if not isinstance(props["production_account"], str):
                try:
                    # Attempt to convert
                    props["production_account"] = str(props["production_account"])
                except:
                    raise TypeError(f"Property production_account must be of type str, got {type(props['production_account']).__name__}")
    
        # Type check marketing_budget_expanded (expected int)
        if "marketing_budget_expanded" in props and props["marketing_budget_expanded"] is not None:
            if not isinstance(props["marketing_budget_expanded"], int):
                try:
                    # Attempt to convert
                    props["marketing_budget_expanded"] = int(props["marketing_budget_expanded"])
                except:
                    raise TypeError(f"Property marketing_budget_expanded must be of type int, got {type(props['marketing_budget_expanded']).__name__}")
    
        # Type check completion_guarantor (expected str)
        if "completion_guarantor" in props and props["completion_guarantor"] is not None:
            if not isinstance(props["completion_guarantor"], str):
                try:
                    # Attempt to convert
                    props["completion_guarantor"] = str(props["completion_guarantor"])
                except:
                    raise TypeError(f"Property completion_guarantor must be of type str, got {type(props['completion_guarantor']).__name__}")
    
        # Type check financial_risk_assessment (expected str)
        if "financial_risk_assessment" in props and props["financial_risk_assessment"] is not None:
            if not isinstance(props["financial_risk_assessment"], str):
                try:
                    # Attempt to convert
                    props["financial_risk_assessment"] = str(props["financial_risk_assessment"])
                except:
                    raise TypeError(f"Property financial_risk_assessment must be of type str, got {type(props['financial_risk_assessment']).__name__}")
    
        # Type check insurance_underwriter (expected str)
        if "insurance_underwriter" in props and props["insurance_underwriter"] is not None:
            if not isinstance(props["insurance_underwriter"], str):
                try:
                    # Attempt to convert
                    props["insurance_underwriter"] = str(props["insurance_underwriter"])
                except:
                    raise TypeError(f"Property insurance_underwriter must be of type str, got {type(props['insurance_underwriter']).__name__}")
    
        # Type check total_investment (expected int)
        if "total_investment" in props and props["total_investment"] is not None:
            if not isinstance(props["total_investment"], int):
                try:
                    # Attempt to convert
                    props["total_investment"] = int(props["total_investment"])
                except:
                    raise TypeError(f"Property total_investment must be of type int, got {type(props['total_investment']).__name__}")
    
        # Type check roi (expected float)
        if "roi" in props and props["roi"] is not None:
            if not isinstance(props["roi"], float):
                try:
                    # Attempt to convert
                    props["roi"] = float(props["roi"])
                except:
                    raise TypeError(f"Property roi must be of type float, got {type(props['roi']).__name__}")
    
        # Type check return (expected int)
        if "return" in props and props["return"] is not None:
            if not isinstance(props["return"], int):
                try:
                    # Attempt to convert
                    props["return"] = int(props["return"])
                except:
                    raise TypeError(f"Property return must be of type int, got {type(props['return']).__name__}")
    
        # Type check profit_sharing_tiers (expected object)
        if "profit_sharing_tiers" in props and props["profit_sharing_tiers"] is not None:
            if not isinstance(props["profit_sharing_tiers"], object):
                try:
                    # Attempt to convert
                    props["profit_sharing_tiers"] = object(props["profit_sharing_tiers"])
                except:
                    raise TypeError(f"Property profit_sharing_tiers must be of type object, got {type(props['profit_sharing_tiers']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="STUDIO_PRODUCED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def production_company_for(uuid=None, **props):
        """
        Find relationships of type PRODUCTION_COMPANY_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check signatory_status (expected str)
        if "signatory_status" in props and props["signatory_status"] is not None:
            if not isinstance(props["signatory_status"], str):
                try:
                    # Attempt to convert
                    props["signatory_status"] = str(props["signatory_status"])
                except:
                    raise TypeError(f"Property signatory_status must be of type str, got {type(props['signatory_status']).__name__}")
    
        # Type check company_formed_for_film (expected bool)
        if "company_formed_for_film" in props and props["company_formed_for_film"] is not None:
            if not isinstance(props["company_formed_for_film"], bool):
                try:
                    # Attempt to convert
                    props["company_formed_for_film"] = bool(props["company_formed_for_film"])
                except:
                    raise TypeError(f"Property company_formed_for_film must be of type bool, got {type(props['company_formed_for_film']).__name__}")
    
        # Type check cost_reporting_frequency (expected str)
        if "cost_reporting_frequency" in props and props["cost_reporting_frequency"] is not None:
            if not isinstance(props["cost_reporting_frequency"], str):
                try:
                    # Attempt to convert
                    props["cost_reporting_frequency"] = str(props["cost_reporting_frequency"])
                except:
                    raise TypeError(f"Property cost_reporting_frequency must be of type str, got {type(props['cost_reporting_frequency']).__name__}")
    
        # Type check production_account_number (expected str)
        if "production_account_number" in props and props["production_account_number"] is not None:
            if not isinstance(props["production_account_number"], str):
                try:
                    # Attempt to convert
                    props["production_account_number"] = str(props["production_account_number"])
                except:
                    raise TypeError(f"Property production_account_number must be of type str, got {type(props['production_account_number']).__name__}")
    
        # Type check paramount_deal_terms (expected str)
        if "paramount_deal_terms" in props and props["paramount_deal_terms"] is not None:
            if not isinstance(props["paramount_deal_terms"], str):
                try:
                    # Attempt to convert
                    props["paramount_deal_terms"] = str(props["paramount_deal_terms"])
                except:
                    raise TypeError(f"Property paramount_deal_terms must be of type str, got {type(props['paramount_deal_terms']).__name__}")
    
        # Type check production_bank (expected str)
        if "production_bank" in props and props["production_bank"] is not None:
            if not isinstance(props["production_bank"], str):
                try:
                    # Attempt to convert
                    props["production_bank"] = str(props["production_bank"])
                except:
                    raise TypeError(f"Property production_bank must be of type str, got {type(props['production_bank']).__name__}")
    
        # Type check company_responsibilities (expected object)
        if "company_responsibilities" in props and props["company_responsibilities"] is not None:
            if not isinstance(props["company_responsibilities"], object):
                try:
                    # Attempt to convert
                    props["company_responsibilities"] = object(props["company_responsibilities"])
                except:
                    raise TypeError(f"Property company_responsibilities must be of type object, got {type(props['company_responsibilities']).__name__}")
    
        # Type check completion_bond (expected int)
        if "completion_bond" in props and props["completion_bond"] is not None:
            if not isinstance(props["completion_bond"], int):
                try:
                    # Attempt to convert
                    props["completion_bond"] = int(props["completion_bond"])
                except:
                    raise TypeError(f"Property completion_bond must be of type int, got {type(props['completion_bond']).__name__}")
    
        # Type check legal_entity_type (expected str)
        if "legal_entity_type" in props and props["legal_entity_type"] is not None:
            if not isinstance(props["legal_entity_type"], str):
                try:
                    # Attempt to convert
                    props["legal_entity_type"] = str(props["legal_entity_type"])
                except:
                    raise TypeError(f"Property legal_entity_type must be of type str, got {type(props['legal_entity_type']).__name__}")
    
        # Type check office_location (expected str)
        if "office_location" in props and props["office_location"] is not None:
            if not isinstance(props["office_location"], str):
                try:
                    # Attempt to convert
                    props["office_location"] = str(props["office_location"])
                except:
                    raise TypeError(f"Property office_location must be of type str, got {type(props['office_location']).__name__}")
    
        # Type check overhead_budget (expected int)
        if "overhead_budget" in props and props["overhead_budget"] is not None:
            if not isinstance(props["overhead_budget"], int):
                try:
                    # Attempt to convert
                    props["overhead_budget"] = int(props["overhead_budget"])
                except:
                    raise TypeError(f"Property overhead_budget must be of type int, got {type(props['overhead_budget']).__name__}")
    
        # Type check paramount_oversight_level (expected str)
        if "paramount_oversight_level" in props and props["paramount_oversight_level"] is not None:
            if not isinstance(props["paramount_oversight_level"], str):
                try:
                    # Attempt to convert
                    props["paramount_oversight_level"] = str(props["paramount_oversight_level"])
                except:
                    raise TypeError(f"Property paramount_oversight_level must be of type str, got {type(props['paramount_oversight_level']).__name__}")
    
        # Type check liability_coverage (expected int)
        if "liability_coverage" in props and props["liability_coverage"] is not None:
            if not isinstance(props["liability_coverage"], int):
                try:
                    # Attempt to convert
                    props["liability_coverage"] = int(props["liability_coverage"])
                except:
                    raise TypeError(f"Property liability_coverage must be of type int, got {type(props['liability_coverage']).__name__}")
    
        # Type check contract_signed (expected object)
        if "contract_signed" in props and props["contract_signed"] is not None:
            if not isinstance(props["contract_signed"], object):
                try:
                    # Attempt to convert
                    props["contract_signed"] = object(props["contract_signed"])
                except:
                    raise TypeError(f"Property contract_signed must be of type object, got {type(props['contract_signed']).__name__}")
    
        # Type check production_staff (expected int)
        if "production_staff" in props and props["production_staff"] is not None:
            if not isinstance(props["production_staff"], int):
                try:
                    # Attempt to convert
                    props["production_staff"] = int(props["production_staff"])
                except:
                    raise TypeError(f"Property production_staff must be of type int, got {type(props['production_staff']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="PRODUCTION_COMPANY_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def corporate_parent_of(uuid=None, **props):
        """
        Find relationships of type CORPORATE_PARENT_OF matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check price_currency (expected str)
        if "price_currency" in props and props["price_currency"] is not None:
            if not isinstance(props["price_currency"], str):
                try:
                    # Attempt to convert
                    props["price_currency"] = str(props["price_currency"])
                except:
                    raise TypeError(f"Property price_currency must be of type str, got {type(props['price_currency']).__name__}")
    
        # Type check corporate_synergy_requirements (expected str)
        if "corporate_synergy_requirements" in props and props["corporate_synergy_requirements"] is not None:
            if not isinstance(props["corporate_synergy_requirements"], str):
                try:
                    # Attempt to convert
                    props["corporate_synergy_requirements"] = str(props["corporate_synergy_requirements"])
                except:
                    raise TypeError(f"Property corporate_synergy_requirements must be of type str, got {type(props['corporate_synergy_requirements']).__name__}")
    
        # Type check autonomy_level (expected str)
        if "autonomy_level" in props and props["autonomy_level"] is not None:
            if not isinstance(props["autonomy_level"], str):
                try:
                    # Attempt to convert
                    props["autonomy_level"] = str(props["autonomy_level"])
                except:
                    raise TypeError(f"Property autonomy_level must be of type str, got {type(props['autonomy_level']).__name__}")
    
        # Type check profit_expectation (expected float)
        if "profit_expectation" in props and props["profit_expectation"] is not None:
            if not isinstance(props["profit_expectation"], float):
                try:
                    # Attempt to convert
                    props["profit_expectation"] = float(props["profit_expectation"])
                except:
                    raise TypeError(f"Property profit_expectation must be of type float, got {type(props['profit_expectation']).__name__}")
    
        # Type check ownership_percentage (expected float)
        if "ownership_percentage" in props and props["ownership_percentage"] is not None:
            if not isinstance(props["ownership_percentage"], float):
                try:
                    # Attempt to convert
                    props["ownership_percentage"] = float(props["ownership_percentage"])
                except:
                    raise TypeError(f"Property ownership_percentage must be of type float, got {type(props['ownership_percentage']).__name__}")
    
        # Type check conglomerate_portfolio_position (expected str)
        if "conglomerate_portfolio_position" in props and props["conglomerate_portfolio_position"] is not None:
            if not isinstance(props["conglomerate_portfolio_position"], str):
                try:
                    # Attempt to convert
                    props["conglomerate_portfolio_position"] = str(props["conglomerate_portfolio_position"])
                except:
                    raise TypeError(f"Property conglomerate_portfolio_position must be of type str, got {type(props['conglomerate_portfolio_position']).__name__}")
    
        # Type check board_seats (expected int)
        if "board_seats" in props and props["board_seats"] is not None:
            if not isinstance(props["board_seats"], int):
                try:
                    # Attempt to convert
                    props["board_seats"] = int(props["board_seats"])
                except:
                    raise TypeError(f"Property board_seats must be of type int, got {type(props['board_seats']).__name__}")
    
        # Type check financial_reporting_requirements (expected str)
        if "financial_reporting_requirements" in props and props["financial_reporting_requirements"] is not None:
            if not isinstance(props["financial_reporting_requirements"], str):
                try:
                    # Attempt to convert
                    props["financial_reporting_requirements"] = str(props["financial_reporting_requirements"])
                except:
                    raise TypeError(f"Property financial_reporting_requirements must be of type str, got {type(props['financial_reporting_requirements']).__name__}")
    
        # Type check expectation_unit (expected str)
        if "expectation_unit" in props and props["expectation_unit"] is not None:
            if not isinstance(props["expectation_unit"], str):
                try:
                    # Attempt to convert
                    props["expectation_unit"] = str(props["expectation_unit"])
                except:
                    raise TypeError(f"Property expectation_unit must be of type str, got {type(props['expectation_unit']).__name__}")
    
        # Type check acquisition_price (expected int)
        if "acquisition_price" in props and props["acquisition_price"] is not None:
            if not isinstance(props["acquisition_price"], int):
                try:
                    # Attempt to convert
                    props["acquisition_price"] = int(props["acquisition_price"])
                except:
                    raise TypeError(f"Property acquisition_price must be of type int, got {type(props['acquisition_price']).__name__}")
    
        # Type check acquisition_date (expected object)
        if "acquisition_date" in props and props["acquisition_date"] is not None:
            if not isinstance(props["acquisition_date"], object):
                try:
                    # Attempt to convert
                    props["acquisition_date"] = object(props["acquisition_date"])
                except:
                    raise TypeError(f"Property acquisition_date must be of type object, got {type(props['acquisition_date']).__name__}")
    
        # Type check quarterly_reviews (expected int)
        if "quarterly_reviews" in props and props["quarterly_reviews"] is not None:
            if not isinstance(props["quarterly_reviews"], int):
                try:
                    # Attempt to convert
                    props["quarterly_reviews"] = int(props["quarterly_reviews"])
                except:
                    raise TypeError(f"Property quarterly_reviews must be of type int, got {type(props['quarterly_reviews']).__name__}")
    
        # Type check investment_approval_threshold (expected int)
        if "investment_approval_threshold" in props and props["investment_approval_threshold"] is not None:
            if not isinstance(props["investment_approval_threshold"], int):
                try:
                    # Attempt to convert
                    props["investment_approval_threshold"] = int(props["investment_approval_threshold"])
                except:
                    raise TypeError(f"Property investment_approval_threshold must be of type int, got {type(props['investment_approval_threshold']).__name__}")
    
        # Type check capital_allocation_committee (expected str)
        if "capital_allocation_committee" in props and props["capital_allocation_committee"] is not None:
            if not isinstance(props["capital_allocation_committee"], str):
                try:
                    # Attempt to convert
                    props["capital_allocation_committee"] = str(props["capital_allocation_committee"])
                except:
                    raise TypeError(f"Property capital_allocation_committee must be of type str, got {type(props['capital_allocation_committee']).__name__}")
    
        # Type check annual_investment (expected int)
        if "annual_investment" in props and props["annual_investment"] is not None:
            if not isinstance(props["annual_investment"], int):
                try:
                    # Attempt to convert
                    props["annual_investment"] = int(props["annual_investment"])
                except:
                    raise TypeError(f"Property annual_investment must be of type int, got {type(props['annual_investment']).__name__}")
    
        # Type check corporate_representatives (expected object)
        if "corporate_representatives" in props and props["corporate_representatives"] is not None:
            if not isinstance(props["corporate_representatives"], object):
                try:
                    # Attempt to convert
                    props["corporate_representatives"] = object(props["corporate_representatives"])
                except:
                    raise TypeError(f"Property corporate_representatives must be of type object, got {type(props['corporate_representatives']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="CORPORATE_PARENT_OF", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def ultimate_owner(uuid=None, **props):
        """
        Find relationships of type ULTIMATE_OWNER matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check project_code (expected str)
        if "project_code" in props and props["project_code"] is not None:
            if not isinstance(props["project_code"], str):
                try:
                    # Attempt to convert
                    props["project_code"] = str(props["project_code"])
                except:
                    raise TypeError(f"Property project_code must be of type str, got {type(props['project_code']).__name__}")
    
        # Type check stock_impact (expected str)
        if "stock_impact" in props and props["stock_impact"] is not None:
            if not isinstance(props["stock_impact"], str):
                try:
                    # Attempt to convert
                    props["stock_impact"] = str(props["stock_impact"])
                except:
                    raise TypeError(f"Property stock_impact must be of type str, got {type(props['stock_impact']).__name__}")
    
        # Type check quarterly_reports_mentioned (expected int)
        if "quarterly_reports_mentioned" in props and props["quarterly_reports_mentioned"] is not None:
            if not isinstance(props["quarterly_reports_mentioned"], int):
                try:
                    # Attempt to convert
                    props["quarterly_reports_mentioned"] = int(props["quarterly_reports_mentioned"])
                except:
                    raise TypeError(f"Property quarterly_reports_mentioned must be of type int, got {type(props['quarterly_reports_mentioned']).__name__}")
    
        # Type check shareholder_questions (expected str)
        if "shareholder_questions" in props and props["shareholder_questions"] is not None:
            if not isinstance(props["shareholder_questions"], str):
                try:
                    # Attempt to convert
                    props["shareholder_questions"] = str(props["shareholder_questions"])
                except:
                    raise TypeError(f"Property shareholder_questions must be of type str, got {type(props['shareholder_questions']).__name__}")
    
        # Type check annual_report_highlight (expected str)
        if "annual_report_highlight" in props and props["annual_report_highlight"] is not None:
            if not isinstance(props["annual_report_highlight"], str):
                try:
                    # Attempt to convert
                    props["annual_report_highlight"] = str(props["annual_report_highlight"])
                except:
                    raise TypeError(f"Property annual_report_highlight must be of type str, got {type(props['annual_report_highlight']).__name__}")
    
        # Type check financial_oversight (expected str)
        if "financial_oversight" in props and props["financial_oversight"] is not None:
            if not isinstance(props["financial_oversight"], str):
                try:
                    # Attempt to convert
                    props["financial_oversight"] = str(props["financial_oversight"])
                except:
                    raise TypeError(f"Property financial_oversight must be of type str, got {type(props['financial_oversight']).__name__}")
    
        # Type check board_approval (expected object)
        if "board_approval" in props and props["board_approval"] is not None:
            if not isinstance(props["board_approval"], object):
                try:
                    # Attempt to convert
                    props["board_approval"] = object(props["board_approval"])
                except:
                    raise TypeError(f"Property board_approval must be of type object, got {type(props['board_approval']).__name__}")
    
        # Type check corporate_prestige_factor (expected str)
        if "corporate_prestige_factor" in props and props["corporate_prestige_factor"] is not None:
            if not isinstance(props["corporate_prestige_factor"], str):
                try:
                    # Attempt to convert
                    props["corporate_prestige_factor"] = str(props["corporate_prestige_factor"])
                except:
                    raise TypeError(f"Property corporate_prestige_factor must be of type str, got {type(props['corporate_prestige_factor']).__name__}")
    
        # Type check conglomerate_synergy_attempts (expected str)
        if "conglomerate_synergy_attempts" in props and props["conglomerate_synergy_attempts"] is not None:
            if not isinstance(props["conglomerate_synergy_attempts"], str):
                try:
                    # Attempt to convert
                    props["conglomerate_synergy_attempts"] = str(props["conglomerate_synergy_attempts"])
                except:
                    raise TypeError(f"Property conglomerate_synergy_attempts must be of type str, got {type(props['conglomerate_synergy_attempts']).__name__}")
    
        # Type check risk_assessment (expected str)
        if "risk_assessment" in props and props["risk_assessment"] is not None:
            if not isinstance(props["risk_assessment"], str):
                try:
                    # Attempt to convert
                    props["risk_assessment"] = str(props["risk_assessment"])
                except:
                    raise TypeError(f"Property risk_assessment must be of type str, got {type(props['risk_assessment']).__name__}")
    
        # Type check executive_visits (expected int)
        if "executive_visits" in props and props["executive_visits"] is not None:
            if not isinstance(props["executive_visits"], int):
                try:
                    # Attempt to convert
                    props["executive_visits"] = int(props["executive_visits"])
                except:
                    raise TypeError(f"Property executive_visits must be of type int, got {type(props['executive_visits']).__name__}")
    
        # Type check corporate_resources_allocated (expected str)
        if "corporate_resources_allocated" in props and props["corporate_resources_allocated"] is not None:
            if not isinstance(props["corporate_resources_allocated"], str):
                try:
                    # Attempt to convert
                    props["corporate_resources_allocated"] = str(props["corporate_resources_allocated"])
                except:
                    raise TypeError(f"Property corporate_resources_allocated must be of type str, got {type(props['corporate_resources_allocated']).__name__}")
    
        # Type check financial_impact_rating (expected str)
        if "financial_impact_rating" in props and props["financial_impact_rating"] is not None:
            if not isinstance(props["financial_impact_rating"], str):
                try:
                    # Attempt to convert
                    props["financial_impact_rating"] = str(props["financial_impact_rating"])
                except:
                    raise TypeError(f"Property financial_impact_rating must be of type str, got {type(props['financial_impact_rating']).__name__}")
    
        # Type check investment_category (expected str)
        if "investment_category" in props and props["investment_category"] is not None:
            if not isinstance(props["investment_category"], str):
                try:
                    # Attempt to convert
                    props["investment_category"] = str(props["investment_category"])
                except:
                    raise TypeError(f"Property investment_category must be of type str, got {type(props['investment_category']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="ULTIMATE_OWNER", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def financial_plan_for(uuid=None, **props):
        """
        Find relationships of type FINANCIAL_PLAN_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check distribution_advance (expected int)
        if "distribution_advance" in props and props["distribution_advance"] is not None:
            if not isinstance(props["distribution_advance"], int):
                try:
                    # Attempt to convert
                    props["distribution_advance"] = int(props["distribution_advance"])
                except:
                    raise TypeError(f"Property distribution_advance must be of type int, got {type(props['distribution_advance']).__name__}")
    
        # Type check cost_categories (expected object)
        if "cost_categories" in props and props["cost_categories"] is not None:
            if not isinstance(props["cost_categories"], object):
                try:
                    # Attempt to convert
                    props["cost_categories"] = object(props["cost_categories"])
                except:
                    raise TypeError(f"Property cost_categories must be of type object, got {type(props['cost_categories']).__name__}")
    
        # Type check actual_spend (expected int)
        if "actual_spend" in props and props["actual_spend"] is not None:
            if not isinstance(props["actual_spend"], int):
                try:
                    # Attempt to convert
                    props["actual_spend"] = int(props["actual_spend"])
                except:
                    raise TypeError(f"Property actual_spend must be of type int, got {type(props['actual_spend']).__name__}")
    
        # Type check cost_overrun_approval (expected object)
        if "cost_overrun_approval" in props and props["cost_overrun_approval"] is not None:
            if not isinstance(props["cost_overrun_approval"], object):
                try:
                    # Attempt to convert
                    props["cost_overrun_approval"] = object(props["cost_overrun_approval"])
                except:
                    raise TypeError(f"Property cost_overrun_approval must be of type object, got {type(props['cost_overrun_approval']).__name__}")
    
        # Type check authorized_by (expected str)
        if "authorized_by" in props and props["authorized_by"] is not None:
            if not isinstance(props["authorized_by"], str):
                try:
                    # Attempt to convert
                    props["authorized_by"] = str(props["authorized_by"])
                except:
                    raise TypeError(f"Property authorized_by must be of type str, got {type(props['authorized_by']).__name__}")
    
        # Type check initial_budget (expected int)
        if "initial_budget" in props and props["initial_budget"] is not None:
            if not isinstance(props["initial_budget"], int):
                try:
                    # Attempt to convert
                    props["initial_budget"] = int(props["initial_budget"])
                except:
                    raise TypeError(f"Property initial_budget must be of type int, got {type(props['initial_budget']).__name__}")
    
        # Type check daily_shooting_costs (expected int)
        if "daily_shooting_costs" in props and props["daily_shooting_costs"] is not None:
            if not isinstance(props["daily_shooting_costs"], int):
                try:
                    # Attempt to convert
                    props["daily_shooting_costs"] = int(props["daily_shooting_costs"])
                except:
                    raise TypeError(f"Property daily_shooting_costs must be of type int, got {type(props['daily_shooting_costs']).__name__}")
    
        # Type check set_construction_costs (expected int)
        if "set_construction_costs" in props and props["set_construction_costs"] is not None:
            if not isinstance(props["set_construction_costs"], int):
                try:
                    # Attempt to convert
                    props["set_construction_costs"] = int(props["set_construction_costs"])
                except:
                    raise TypeError(f"Property set_construction_costs must be of type int, got {type(props['set_construction_costs']).__name__}")
    
        # Type check key_talent_costs (expected object)
        if "key_talent_costs" in props and props["key_talent_costs"] is not None:
            if not isinstance(props["key_talent_costs"], object):
                try:
                    # Attempt to convert
                    props["key_talent_costs"] = object(props["key_talent_costs"])
                except:
                    raise TypeError(f"Property key_talent_costs must be of type object, got {type(props['key_talent_costs']).__name__}")
    
        # Type check financial_reporting_cycle (expected str)
        if "financial_reporting_cycle" in props and props["financial_reporting_cycle"] is not None:
            if not isinstance(props["financial_reporting_cycle"], str):
                try:
                    # Attempt to convert
                    props["financial_reporting_cycle"] = str(props["financial_reporting_cycle"])
                except:
                    raise TypeError(f"Property financial_reporting_cycle must be of type str, got {type(props['financial_reporting_cycle']).__name__}")
    
        # Type check accounting_code (expected str)
        if "accounting_code" in props and props["accounting_code"] is not None:
            if not isinstance(props["accounting_code"], str):
                try:
                    # Attempt to convert
                    props["accounting_code"] = str(props["accounting_code"])
                except:
                    raise TypeError(f"Property accounting_code must be of type str, got {type(props['accounting_code']).__name__}")
    
        # Type check studio_overhead_allocation (expected int)
        if "studio_overhead_allocation" in props and props["studio_overhead_allocation"] is not None:
            if not isinstance(props["studio_overhead_allocation"], int):
                try:
                    # Attempt to convert
                    props["studio_overhead_allocation"] = int(props["studio_overhead_allocation"])
                except:
                    raise TypeError(f"Property studio_overhead_allocation must be of type int, got {type(props['studio_overhead_allocation']).__name__}")
    
        # Type check prepared_by (expected str)
        if "prepared_by" in props and props["prepared_by"] is not None:
            if not isinstance(props["prepared_by"], str):
                try:
                    # Attempt to convert
                    props["prepared_by"] = str(props["prepared_by"])
                except:
                    raise TypeError(f"Property prepared_by must be of type str, got {type(props['prepared_by']).__name__}")
    
        # Type check category_allocations (expected object)
        if "category_allocations" in props and props["category_allocations"] is not None:
            if not isinstance(props["category_allocations"], object):
                try:
                    # Attempt to convert
                    props["category_allocations"] = object(props["category_allocations"])
                except:
                    raise TypeError(f"Property category_allocations must be of type object, got {type(props['category_allocations']).__name__}")
    
        # Type check final_budget (expected int)
        if "final_budget" in props and props["final_budget"] is not None:
            if not isinstance(props["final_budget"], int):
                try:
                    # Attempt to convert
                    props["final_budget"] = int(props["final_budget"])
                except:
                    raise TypeError(f"Property final_budget must be of type int, got {type(props['final_budget']).__name__}")
    
        # Type check variance_percentage (expected float)
        if "variance_percentage" in props and props["variance_percentage"] is not None:
            if not isinstance(props["variance_percentage"], float):
                try:
                    # Attempt to convert
                    props["variance_percentage"] = float(props["variance_percentage"])
                except:
                    raise TypeError(f"Property variance_percentage must be of type float, got {type(props['variance_percentage']).__name__}")
    
        # Type check transportation_logistics (expected int)
        if "transportation_logistics" in props and props["transportation_logistics"] is not None:
            if not isinstance(props["transportation_logistics"], int):
                try:
                    # Attempt to convert
                    props["transportation_logistics"] = int(props["transportation_logistics"])
                except:
                    raise TypeError(f"Property transportation_logistics must be of type int, got {type(props['transportation_logistics']).__name__}")
    
        # Type check location_fees (expected int)
        if "location_fees" in props and props["location_fees"] is not None:
            if not isinstance(props["location_fees"], int):
                try:
                    # Attempt to convert
                    props["location_fees"] = int(props["location_fees"])
                except:
                    raise TypeError(f"Property location_fees must be of type int, got {type(props['location_fees']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="FINANCIAL_PLAN_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def financial_performance_of(uuid=None, **props):
        """
        Find relationships of type FINANCIAL_PERFORMANCE_OF matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check platform_release (expected bool)
        if "platform_release" in props and props["platform_release"] is not None:
            if not isinstance(props["platform_release"], bool):
                try:
                    # Attempt to convert
                    props["platform_release"] = bool(props["platform_release"])
                except:
                    raise TypeError(f"Property platform_release must be of type bool, got {type(props['platform_release']).__name__}")
    
        # Type check profit_participants (expected object)
        if "profit_participants" in props and props["profit_participants"] is not None:
            if not isinstance(props["profit_participants"], object):
                try:
                    # Attempt to convert
                    props["profit_participants"] = object(props["profit_participants"])
                except:
                    raise TypeError(f"Property profit_participants must be of type object, got {type(props['profit_participants']).__name__}")
    
        # Type check exhibitor_split_percentage (expected int)
        if "exhibitor_split_percentage" in props and props["exhibitor_split_percentage"] is not None:
            if not isinstance(props["exhibitor_split_percentage"], int):
                try:
                    # Attempt to convert
                    props["exhibitor_split_percentage"] = int(props["exhibitor_split_percentage"])
                except:
                    raise TypeError(f"Property exhibitor_split_percentage must be of type int, got {type(props['exhibitor_split_percentage']).__name__}")
    
        # Type check opening_theaters (expected int)
        if "opening_theaters" in props and props["opening_theaters"] is not None:
            if not isinstance(props["opening_theaters"], int):
                try:
                    # Attempt to convert
                    props["opening_theaters"] = int(props["opening_theaters"])
                except:
                    raise TypeError(f"Property opening_theaters must be of type int, got {type(props['opening_theaters']).__name__}")
    
        # Type check profit_tiers (expected object)
        if "profit_tiers" in props and props["profit_tiers"] is not None:
            if not isinstance(props["profit_tiers"], object):
                try:
                    # Attempt to convert
                    props["profit_tiers"] = object(props["profit_tiers"])
                except:
                    raise TypeError(f"Property profit_tiers must be of type object, got {type(props['profit_tiers']).__name__}")
    
        # Type check tracking_start (expected object)
        if "tracking_start" in props and props["tracking_start"] is not None:
            if not isinstance(props["tracking_start"], object):
                try:
                    # Attempt to convert
                    props["tracking_start"] = object(props["tracking_start"])
                except:
                    raise TypeError(f"Property tracking_start must be of type object, got {type(props['tracking_start']).__name__}")
    
        # Type check profit_calculation_method (expected str)
        if "profit_calculation_method" in props and props["profit_calculation_method"] is not None:
            if not isinstance(props["profit_calculation_method"], str):
                try:
                    # Attempt to convert
                    props["profit_calculation_method"] = str(props["profit_calculation_method"])
                except:
                    raise TypeError(f"Property profit_calculation_method must be of type str, got {type(props['profit_calculation_method']).__name__}")
    
        # Type check profit_participation_payments (expected int)
        if "profit_participation_payments" in props and props["profit_participation_payments"] is not None:
            if not isinstance(props["profit_participation_payments"], int):
                try:
                    # Attempt to convert
                    props["profit_participation_payments"] = int(props["profit_participation_payments"])
                except:
                    raise TypeError(f"Property profit_participation_payments must be of type int, got {type(props['profit_participation_payments']).__name__}")
    
        # Type check weeks_at_number_one (expected int)
        if "weeks_at_number_one" in props and props["weeks_at_number_one"] is not None:
            if not isinstance(props["weeks_at_number_one"], int):
                try:
                    # Attempt to convert
                    props["weeks_at_number_one"] = int(props["weeks_at_number_one"])
                except:
                    raise TypeError(f"Property weeks_at_number_one must be of type int, got {type(props['weeks_at_number_one']).__name__}")
    
        # Type check breakeven_date (expected object)
        if "breakeven_date" in props and props["breakeven_date"] is not None:
            if not isinstance(props["breakeven_date"], object):
                try:
                    # Attempt to convert
                    props["breakeven_date"] = object(props["breakeven_date"])
                except:
                    raise TypeError(f"Property breakeven_date must be of type object, got {type(props['breakeven_date']).__name__}")
    
        # Type check studio_net_profit (expected int)
        if "studio_net_profit" in props and props["studio_net_profit"] is not None:
            if not isinstance(props["studio_net_profit"], int):
                try:
                    # Attempt to convert
                    props["studio_net_profit"] = int(props["studio_net_profit"])
                except:
                    raise TypeError(f"Property studio_net_profit must be of type int, got {type(props['studio_net_profit']).__name__}")
    
        # Type check tracking_end (expected object)
        if "tracking_end" in props and props["tracking_end"] is not None:
            if not isinstance(props["tracking_end"], object):
                try:
                    # Attempt to convert
                    props["tracking_end"] = object(props["tracking_end"])
                except:
                    raise TypeError(f"Property tracking_end must be of type object, got {type(props['tracking_end']).__name__}")
    
        # Type check distribution_fee_percentage (expected int)
        if "distribution_fee_percentage" in props and props["distribution_fee_percentage"] is not None:
            if not isinstance(props["distribution_fee_percentage"], int):
                try:
                    # Attempt to convert
                    props["distribution_fee_percentage"] = int(props["distribution_fee_percentage"])
                except:
                    raise TypeError(f"Property distribution_fee_percentage must be of type int, got {type(props['distribution_fee_percentage']).__name__}")
    
        # Type check domestic_total (expected int)
        if "domestic_total" in props and props["domestic_total"] is not None:
            if not isinstance(props["domestic_total"], int):
                try:
                    # Attempt to convert
                    props["domestic_total"] = int(props["domestic_total"])
                except:
                    raise TypeError(f"Property domestic_total must be of type int, got {type(props['domestic_total']).__name__}")
    
        # Type check wide_release_theaters (expected int)
        if "wide_release_theaters" in props and props["wide_release_theaters"] is not None:
            if not isinstance(props["wide_release_theaters"], int):
                try:
                    # Attempt to convert
                    props["wide_release_theaters"] = int(props["wide_release_theaters"])
                except:
                    raise TypeError(f"Property wide_release_theaters must be of type int, got {type(props['wide_release_theaters']).__name__}")
    
        # Type check wide_release_date (expected object)
        if "wide_release_date" in props and props["wide_release_date"] is not None:
            if not isinstance(props["wide_release_date"], object):
                try:
                    # Attempt to convert
                    props["wide_release_date"] = object(props["wide_release_date"])
                except:
                    raise TypeError(f"Property wide_release_date must be of type object, got {type(props['wide_release_date']).__name__}")
    
        # Type check peak_weekly_gross (expected int)
        if "peak_weekly_gross" in props and props["peak_weekly_gross"] is not None:
            if not isinstance(props["peak_weekly_gross"], int):
                try:
                    # Attempt to convert
                    props["peak_weekly_gross"] = int(props["peak_weekly_gross"])
                except:
                    raise TypeError(f"Property peak_weekly_gross must be of type int, got {type(props['peak_weekly_gross']).__name__}")
    
        # Type check international_total (expected int)
        if "international_total" in props and props["international_total"] is not None:
            if not isinstance(props["international_total"], int):
                try:
                    # Attempt to convert
                    props["international_total"] = int(props["international_total"])
                except:
                    raise TypeError(f"Property international_total must be of type int, got {type(props['international_total']).__name__}")
    
        # Type check opening_weekend (expected int)
        if "opening_weekend" in props and props["opening_weekend"] is not None:
            if not isinstance(props["opening_weekend"], int):
                try:
                    # Attempt to convert
                    props["opening_weekend"] = int(props["opening_weekend"])
                except:
                    raise TypeError(f"Property opening_weekend must be of type int, got {type(props['opening_weekend']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="FINANCIAL_PERFORMANCE_OF", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def distribution_strategy_for(uuid=None, **props):
        """
        Find relationships of type DISTRIBUTION_STRATEGY_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check nationwide_date (expected object)
        if "nationwide_date" in props and props["nationwide_date"] is not None:
            if not isinstance(props["nationwide_date"], object):
                try:
                    # Attempt to convert
                    props["nationwide_date"] = object(props["nationwide_date"])
                except:
                    raise TypeError(f"Property nationwide_date must be of type object, got {type(props['nationwide_date']).__name__}")
    
        # Type check run_length_guarantee (expected str)
        if "run_length_guarantee" in props and props["run_length_guarantee"] is not None:
            if not isinstance(props["run_length_guarantee"], str):
                try:
                    # Attempt to convert
                    props["run_length_guarantee"] = str(props["run_length_guarantee"])
                except:
                    raise TypeError(f"Property run_length_guarantee must be of type str, got {type(props['run_length_guarantee']).__name__}")
    
        # Type check exhibition_terms (expected str)
        if "exhibition_terms" in props and props["exhibition_terms"] is not None:
            if not isinstance(props["exhibition_terms"], str):
                try:
                    # Attempt to convert
                    props["exhibition_terms"] = str(props["exhibition_terms"])
                except:
                    raise TypeError(f"Property exhibition_terms must be of type str, got {type(props['exhibition_terms']).__name__}")
    
        # Type check release_pattern (expected str)
        if "release_pattern" in props and props["release_pattern"] is not None:
            if not isinstance(props["release_pattern"], str):
                try:
                    # Attempt to convert
                    props["release_pattern"] = str(props["release_pattern"])
                except:
                    raise TypeError(f"Property release_pattern must be of type str, got {type(props['release_pattern']).__name__}")
    
        # Type check censorship_negotiations (expected str)
        if "censorship_negotiations" in props and props["censorship_negotiations"] is not None:
            if not isinstance(props["censorship_negotiations"], str):
                try:
                    # Attempt to convert
                    props["censorship_negotiations"] = str(props["censorship_negotiations"])
                except:
                    raise TypeError(f"Property censorship_negotiations must be of type str, got {type(props['censorship_negotiations']).__name__}")
    
        # Type check booking_approach (expected str)
        if "booking_approach" in props and props["booking_approach"] is not None:
            if not isinstance(props["booking_approach"], str):
                try:
                    # Attempt to convert
                    props["booking_approach"] = str(props["booking_approach"])
                except:
                    raise TypeError(f"Property booking_approach must be of type str, got {type(props['booking_approach']).__name__}")
    
        # Type check initial_markets (expected object)
        if "initial_markets" in props and props["initial_markets"] is not None:
            if not isinstance(props["initial_markets"], object):
                try:
                    # Attempt to convert
                    props["initial_markets"] = object(props["initial_markets"])
                except:
                    raise TypeError(f"Property initial_markets must be of type object, got {type(props['initial_markets']).__name__}")
    
        # Type check plan_architect (expected str)
        if "plan_architect" in props and props["plan_architect"] is not None:
            if not isinstance(props["plan_architect"], str):
                try:
                    # Attempt to convert
                    props["plan_architect"] = str(props["plan_architect"])
                except:
                    raise TypeError(f"Property plan_architect must be of type str, got {type(props['plan_architect']).__name__}")
    
        # Type check release_pattern_success_metrics (expected str)
        if "release_pattern_success_metrics" in props and props["release_pattern_success_metrics"] is not None:
            if not isinstance(props["release_pattern_success_metrics"], str):
                try:
                    # Attempt to convert
                    props["release_pattern_success_metrics"] = str(props["release_pattern_success_metrics"])
                except:
                    raise TypeError(f"Property release_pattern_success_metrics must be of type str, got {type(props['release_pattern_success_metrics']).__name__}")
    
        # Type check logistics_base (expected str)
        if "logistics_base" in props and props["logistics_base"] is not None:
            if not isinstance(props["logistics_base"], str):
                try:
                    # Attempt to convert
                    props["logistics_base"] = str(props["logistics_base"])
                except:
                    raise TypeError(f"Property logistics_base must be of type str, got {type(props['logistics_base']).__name__}")
    
        # Type check expansion_timeline (expected str)
        if "expansion_timeline" in props and props["expansion_timeline"] is not None:
            if not isinstance(props["expansion_timeline"], str):
                try:
                    # Attempt to convert
                    props["expansion_timeline"] = str(props["expansion_timeline"])
                except:
                    raise TypeError(f"Property expansion_timeline must be of type str, got {type(props['expansion_timeline']).__name__}")
    
        # Type check distribution_team_size (expected int)
        if "distribution_team_size" in props and props["distribution_team_size"] is not None:
            if not isinstance(props["distribution_team_size"], int):
                try:
                    # Attempt to convert
                    props["distribution_team_size"] = int(props["distribution_team_size"])
                except:
                    raise TypeError(f"Property distribution_team_size must be of type int, got {type(props['distribution_team_size']).__name__}")
    
        # Type check print_strategy (expected str)
        if "print_strategy" in props and props["print_strategy"] is not None:
            if not isinstance(props["print_strategy"], str):
                try:
                    # Attempt to convert
                    props["print_strategy"] = str(props["print_strategy"])
                except:
                    raise TypeError(f"Property print_strategy must be of type str, got {type(props['print_strategy']).__name__}")
    
        # Type check international_strategy (expected str)
        if "international_strategy" in props and props["international_strategy"] is not None:
            if not isinstance(props["international_strategy"], str):
                try:
                    # Attempt to convert
                    props["international_strategy"] = str(props["international_strategy"])
                except:
                    raise TypeError(f"Property international_strategy must be of type str, got {type(props['international_strategy']).__name__}")
    
        # Type check theaters_targeted (expected str)
        if "theaters_targeted" in props and props["theaters_targeted"] is not None:
            if not isinstance(props["theaters_targeted"], str):
                try:
                    # Attempt to convert
                    props["theaters_targeted"] = str(props["theaters_targeted"])
                except:
                    raise TypeError(f"Property theaters_targeted must be of type str, got {type(props['theaters_targeted']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="DISTRIBUTION_STRATEGY_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def marketed(uuid=None, **props):
        """
        Find relationships of type MARKETED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check promotional_partnerships (expected str)
        if "promotional_partnerships" in props and props["promotional_partnerships"] is not None:
            if not isinstance(props["promotional_partnerships"], str):
                try:
                    # Attempt to convert
                    props["promotional_partnerships"] = str(props["promotional_partnerships"])
                except:
                    raise TypeError(f"Property promotional_partnerships must be of type str, got {type(props['promotional_partnerships']).__name__}")
    
        # Type check publicity_focus (expected str)
        if "publicity_focus" in props and props["publicity_focus"] is not None:
            if not isinstance(props["publicity_focus"], str):
                try:
                    # Attempt to convert
                    props["publicity_focus"] = str(props["publicity_focus"])
                except:
                    raise TypeError(f"Property publicity_focus must be of type str, got {type(props['publicity_focus']).__name__}")
    
        # Type check preview_screenings (expected int)
        if "preview_screenings" in props and props["preview_screenings"] is not None:
            if not isinstance(props["preview_screenings"], int):
                try:
                    # Attempt to convert
                    props["preview_screenings"] = int(props["preview_screenings"])
                except:
                    raise TypeError(f"Property preview_screenings must be of type int, got {type(props['preview_screenings']).__name__}")
    
        # Type check campaign_director (expected str)
        if "campaign_director" in props and props["campaign_director"] is not None:
            if not isinstance(props["campaign_director"], str):
                try:
                    # Attempt to convert
                    props["campaign_director"] = str(props["campaign_director"])
                except:
                    raise TypeError(f"Property campaign_director must be of type str, got {type(props['campaign_director']).__name__}")
    
        # Type check media_strategy (expected str)
        if "media_strategy" in props and props["media_strategy"] is not None:
            if not isinstance(props["media_strategy"], str):
                try:
                    # Attempt to convert
                    props["media_strategy"] = str(props["media_strategy"])
                except:
                    raise TypeError(f"Property media_strategy must be of type str, got {type(props['media_strategy']).__name__}")
    
        # Type check controversy_management (expected str)
        if "controversy_management" in props and props["controversy_management"] is not None:
            if not isinstance(props["controversy_management"], str):
                try:
                    # Attempt to convert
                    props["controversy_management"] = str(props["controversy_management"])
                except:
                    raise TypeError(f"Property controversy_management must be of type str, got {type(props['controversy_management']).__name__}")
    
        # Type check magazine_insertions (expected int)
        if "magazine_insertions" in props and props["magazine_insertions"] is not None:
            if not isinstance(props["magazine_insertions"], int):
                try:
                    # Attempt to convert
                    props["magazine_insertions"] = int(props["magazine_insertions"])
                except:
                    raise TypeError(f"Property magazine_insertions must be of type int, got {type(props['magazine_insertions']).__name__}")
    
        # Type check billboard_locations (expected int)
        if "billboard_locations" in props and props["billboard_locations"] is not None:
            if not isinstance(props["billboard_locations"], int):
                try:
                    # Attempt to convert
                    props["billboard_locations"] = int(props["billboard_locations"])
                except:
                    raise TypeError(f"Property billboard_locations must be of type int, got {type(props['billboard_locations']).__name__}")
    
        # Type check secondary_tagline (expected str)
        if "secondary_tagline" in props and props["secondary_tagline"] is not None:
            if not isinstance(props["secondary_tagline"], str):
                try:
                    # Attempt to convert
                    props["secondary_tagline"] = str(props["secondary_tagline"])
                except:
                    raise TypeError(f"Property secondary_tagline must be of type str, got {type(props['secondary_tagline']).__name__}")
    
        # Type check radio_spot_count (expected int)
        if "radio_spot_count" in props and props["radio_spot_count"] is not None:
            if not isinstance(props["radio_spot_count"], int):
                try:
                    # Attempt to convert
                    props["radio_spot_count"] = int(props["radio_spot_count"])
                except:
                    raise TypeError(f"Property radio_spot_count must be of type int, got {type(props['radio_spot_count']).__name__}")
    
        # Type check merchandising_limited (expected str)
        if "merchandising_limited" in props and props["merchandising_limited"] is not None:
            if not isinstance(props["merchandising_limited"], str):
                try:
                    # Attempt to convert
                    props["merchandising_limited"] = str(props["merchandising_limited"])
                except:
                    raise TypeError(f"Property merchandising_limited must be of type str, got {type(props['merchandising_limited']).__name__}")
    
        # Type check campaign_concept (expected str)
        if "campaign_concept" in props and props["campaign_concept"] is not None:
            if not isinstance(props["campaign_concept"], str):
                try:
                    # Attempt to convert
                    props["campaign_concept"] = str(props["campaign_concept"])
                except:
                    raise TypeError(f"Property campaign_concept must be of type str, got {type(props['campaign_concept']).__name__}")
    
        # Type check tv_spot_count (expected int)
        if "tv_spot_count" in props and props["tv_spot_count"] is not None:
            if not isinstance(props["tv_spot_count"], int):
                try:
                    # Attempt to convert
                    props["tv_spot_count"] = int(props["tv_spot_count"])
                except:
                    raise TypeError(f"Property tv_spot_count must be of type int, got {type(props['tv_spot_count']).__name__}")
    
        # Type check primary_tagline (expected str)
        if "primary_tagline" in props and props["primary_tagline"] is not None:
            if not isinstance(props["primary_tagline"], str):
                try:
                    # Attempt to convert
                    props["primary_tagline"] = str(props["primary_tagline"])
                except:
                    raise TypeError(f"Property primary_tagline must be of type str, got {type(props['primary_tagline']).__name__}")
    
        # Type check media_impressions (expected int)
        if "media_impressions" in props and props["media_impressions"] is not None:
            if not isinstance(props["media_impressions"], int):
                try:
                    # Attempt to convert
                    props["media_impressions"] = int(props["media_impressions"])
                except:
                    raise TypeError(f"Property media_impressions must be of type int, got {type(props['media_impressions']).__name__}")
    
        # Type check press_coverage_inches (expected int)
        if "press_coverage_inches" in props and props["press_coverage_inches"] is not None:
            if not isinstance(props["press_coverage_inches"], int):
                try:
                    # Attempt to convert
                    props["press_coverage_inches"] = int(props["press_coverage_inches"])
                except:
                    raise TypeError(f"Property press_coverage_inches must be of type int, got {type(props['press_coverage_inches']).__name__}")
    
        # Type check key_art_development (expected str)
        if "key_art_development" in props and props["key_art_development"] is not None:
            if not isinstance(props["key_art_development"], str):
                try:
                    # Attempt to convert
                    props["key_art_development"] = str(props["key_art_development"])
                except:
                    raise TypeError(f"Property key_art_development must be of type str, got {type(props['key_art_development']).__name__}")
    
        # Type check newspaper_insertions (expected int)
        if "newspaper_insertions" in props and props["newspaper_insertions"] is not None:
            if not isinstance(props["newspaper_insertions"], int):
                try:
                    # Attempt to convert
                    props["newspaper_insertions"] = int(props["newspaper_insertions"])
                except:
                    raise TypeError(f"Property newspaper_insertions must be of type int, got {type(props['newspaper_insertions']).__name__}")
    
        # Type check premiere_strategy (expected str)
        if "premiere_strategy" in props and props["premiere_strategy"] is not None:
            if not isinstance(props["premiere_strategy"], str):
                try:
                    # Attempt to convert
                    props["premiere_strategy"] = str(props["premiere_strategy"])
                except:
                    raise TypeError(f"Property premiere_strategy must be of type str, got {type(props['premiere_strategy']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="MARKETED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def legal_framework_for(uuid=None, **props):
        """
        Find relationships of type LEGAL_FRAMEWORK_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check novel_rights_acquired (expected object)
        if "novel_rights_acquired" in props and props["novel_rights_acquired"] is not None:
            if not isinstance(props["novel_rights_acquired"], object):
                try:
                    # Attempt to convert
                    props["novel_rights_acquired"] = object(props["novel_rights_acquired"])
                except:
                    raise TypeError(f"Property novel_rights_acquired must be of type object, got {type(props['novel_rights_acquired']).__name__}")
    
        # Type check pacino_final_terms (expected str)
        if "pacino_final_terms" in props and props["pacino_final_terms"] is not None:
            if not isinstance(props["pacino_final_terms"], str):
                try:
                    # Attempt to convert
                    props["pacino_final_terms"] = str(props["pacino_final_terms"])
                except:
                    raise TypeError(f"Property pacino_final_terms must be of type str, got {type(props['pacino_final_terms']).__name__}")
    
        # Type check contract_execution_timeline (expected str)
        if "contract_execution_timeline" in props and props["contract_execution_timeline"] is not None:
            if not isinstance(props["contract_execution_timeline"], str):
                try:
                    # Attempt to convert
                    props["contract_execution_timeline"] = str(props["contract_execution_timeline"])
                except:
                    raise TypeError(f"Property contract_execution_timeline must be of type str, got {type(props['contract_execution_timeline']).__name__}")
    
        # Type check brando_contract_special_terms (expected str)
        if "brando_contract_special_terms" in props and props["brando_contract_special_terms"] is not None:
            if not isinstance(props["brando_contract_special_terms"], str):
                try:
                    # Attempt to convert
                    props["brando_contract_special_terms"] = str(props["brando_contract_special_terms"])
                except:
                    raise TypeError(f"Property brando_contract_special_terms must be of type str, got {type(props['brando_contract_special_terms']).__name__}")
    
        # Type check rights_purchase_price (expected int)
        if "rights_purchase_price" in props and props["rights_purchase_price"] is not None:
            if not isinstance(props["rights_purchase_price"], int):
                try:
                    # Attempt to convert
                    props["rights_purchase_price"] = int(props["rights_purchase_price"])
                except:
                    raise TypeError(f"Property rights_purchase_price must be of type int, got {type(props['rights_purchase_price']).__name__}")
    
        # Type check rights_additional_terms (expected str)
        if "rights_additional_terms" in props and props["rights_additional_terms"] is not None:
            if not isinstance(props["rights_additional_terms"], str):
                try:
                    # Attempt to convert
                    props["rights_additional_terms"] = str(props["rights_additional_terms"])
                except:
                    raise TypeError(f"Property rights_additional_terms must be of type str, got {type(props['rights_additional_terms']).__name__}")
    
        # Type check chief_counsel (expected str)
        if "chief_counsel" in props and props["chief_counsel"] is not None:
            if not isinstance(props["chief_counsel"], str):
                try:
                    # Attempt to convert
                    props["chief_counsel"] = str(props["chief_counsel"])
                except:
                    raise TypeError(f"Property chief_counsel must be of type str, got {type(props['chief_counsel']).__name__}")
    
        # Type check legal_department_staffing (expected str)
        if "legal_department_staffing" in props and props["legal_department_staffing"] is not None:
            if not isinstance(props["legal_department_staffing"], str):
                try:
                    # Attempt to convert
                    props["legal_department_staffing"] = str(props["legal_department_staffing"])
                except:
                    raise TypeError(f"Property legal_department_staffing must be of type str, got {type(props['legal_department_staffing']).__name__}")
    
        # Type check rights_chain_documentation (expected str)
        if "rights_chain_documentation" in props and props["rights_chain_documentation"] is not None:
            if not isinstance(props["rights_chain_documentation"], str):
                try:
                    # Attempt to convert
                    props["rights_chain_documentation"] = str(props["rights_chain_documentation"])
                except:
                    raise TypeError(f"Property rights_chain_documentation must be of type str, got {type(props['rights_chain_documentation']).__name__}")
    
        # Type check director_compensation (expected str)
        if "director_compensation" in props and props["director_compensation"] is not None:
            if not isinstance(props["director_compensation"], str):
                try:
                    # Attempt to convert
                    props["director_compensation"] = str(props["director_compensation"])
                except:
                    raise TypeError(f"Property director_compensation must be of type str, got {type(props['director_compensation']).__name__}")
    
        # Type check guild_agreements (expected str)
        if "guild_agreements" in props and props["guild_agreements"] is not None:
            if not isinstance(props["guild_agreements"], str):
                try:
                    # Attempt to convert
                    props["guild_agreements"] = str(props["guild_agreements"])
                except:
                    raise TypeError(f"Property guild_agreements must be of type str, got {type(props['guild_agreements']).__name__}")
    
        # Type check music_rights_clearances (expected str)
        if "music_rights_clearances" in props and props["music_rights_clearances"] is not None:
            if not isinstance(props["music_rights_clearances"], str):
                try:
                    # Attempt to convert
                    props["music_rights_clearances"] = str(props["music_rights_clearances"])
                except:
                    raise TypeError(f"Property music_rights_clearances must be of type str, got {type(props['music_rights_clearances']).__name__}")
    
        # Type check completion_guarantor_contract (expected str)
        if "completion_guarantor_contract" in props and props["completion_guarantor_contract"] is not None:
            if not isinstance(props["completion_guarantor_contract"], str):
                try:
                    # Attempt to convert
                    props["completion_guarantor_contract"] = str(props["completion_guarantor_contract"])
                except:
                    raise TypeError(f"Property completion_guarantor_contract must be of type str, got {type(props['completion_guarantor_contract']).__name__}")
    
        # Type check director_contract_executed (expected object)
        if "director_contract_executed" in props and props["director_contract_executed"] is not None:
            if not isinstance(props["director_contract_executed"], object):
                try:
                    # Attempt to convert
                    props["director_contract_executed"] = object(props["director_contract_executed"])
                except:
                    raise TypeError(f"Property director_contract_executed must be of type object, got {type(props['director_contract_executed']).__name__}")
    
        # Type check pacino_contract_negotiations (expected str)
        if "pacino_contract_negotiations" in props and props["pacino_contract_negotiations"] is not None:
            if not isinstance(props["pacino_contract_negotiations"], str):
                try:
                    # Attempt to convert
                    props["pacino_contract_negotiations"] = str(props["pacino_contract_negotiations"])
                except:
                    raise TypeError(f"Property pacino_contract_negotiations must be of type str, got {type(props['pacino_contract_negotiations']).__name__}")
    
        # Type check key_agreements (expected object)
        if "key_agreements" in props and props["key_agreements"] is not None:
            if not isinstance(props["key_agreements"], object):
                try:
                    # Attempt to convert
                    props["key_agreements"] = object(props["key_agreements"])
                except:
                    raise TypeError(f"Property key_agreements must be of type object, got {type(props['key_agreements']).__name__}")
    
        # Type check location_agreement_challenges (expected str)
        if "location_agreement_challenges" in props and props["location_agreement_challenges"] is not None:
            if not isinstance(props["location_agreement_challenges"], str):
                try:
                    # Attempt to convert
                    props["location_agreement_challenges"] = str(props["location_agreement_challenges"])
                except:
                    raise TypeError(f"Property location_agreement_challenges must be of type str, got {type(props['location_agreement_challenges']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="LEGAL_FRAMEWORK_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def operations_for(uuid=None, **props):
        """
        Find relationships of type OPERATIONS_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check first_assistant_director (expected str)
        if "first_assistant_director" in props and props["first_assistant_director"] is not None:
            if not isinstance(props["first_assistant_director"], str):
                try:
                    # Attempt to convert
                    props["first_assistant_director"] = str(props["first_assistant_director"])
                except:
                    raise TypeError(f"Property first_assistant_director must be of type str, got {type(props['first_assistant_director']).__name__}")
    
        # Type check production_office_locations (expected object)
        if "production_office_locations" in props and props["production_office_locations"] is not None:
            if not isinstance(props["production_office_locations"], object):
                try:
                    # Attempt to convert
                    props["production_office_locations"] = object(props["production_office_locations"])
                except:
                    raise TypeError(f"Property production_office_locations must be of type object, got {type(props['production_office_locations']).__name__}")
    
        # Type check equipment_package (expected str)
        if "equipment_package" in props and props["equipment_package"] is not None:
            if not isinstance(props["equipment_package"], str):
                try:
                    # Attempt to convert
                    props["equipment_package"] = str(props["equipment_package"])
                except:
                    raise TypeError(f"Property equipment_package must be of type str, got {type(props['equipment_package']).__name__}")
    
        # Type check average_wrap_time (expected str)
        if "average_wrap_time" in props and props["average_wrap_time"] is not None:
            if not isinstance(props["average_wrap_time"], str):
                try:
                    # Attempt to convert
                    props["average_wrap_time"] = str(props["average_wrap_time"])
                except:
                    raise TypeError(f"Property average_wrap_time must be of type str, got {type(props['average_wrap_time']).__name__}")
    
        # Type check dailies_review (expected str)
        if "dailies_review" in props and props["dailies_review"] is not None:
            if not isinstance(props["dailies_review"], str):
                try:
                    # Attempt to convert
                    props["dailies_review"] = str(props["dailies_review"])
                except:
                    raise TypeError(f"Property dailies_review must be of type str, got {type(props['dailies_review']).__name__}")
    
        # Type check company_moves (expected int)
        if "company_moves" in props and props["company_moves"] is not None:
            if not isinstance(props["company_moves"], int):
                try:
                    # Attempt to convert
                    props["company_moves"] = int(props["company_moves"])
                except:
                    raise TypeError(f"Property company_moves must be of type int, got {type(props['company_moves']).__name__}")
    
        # Type check permit_challenges (expected str)
        if "permit_challenges" in props and props["permit_challenges"] is not None:
            if not isinstance(props["permit_challenges"], str):
                try:
                    # Attempt to convert
                    props["permit_challenges"] = str(props["permit_challenges"])
                except:
                    raise TypeError(f"Property permit_challenges must be of type str, got {type(props['permit_challenges']).__name__}")
    
        # Type check overtime_frequency (expected str)
        if "overtime_frequency" in props and props["overtime_frequency"] is not None:
            if not isinstance(props["overtime_frequency"], str):
                try:
                    # Attempt to convert
                    props["overtime_frequency"] = str(props["overtime_frequency"])
                except:
                    raise TypeError(f"Property overtime_frequency must be of type str, got {type(props['overtime_frequency']).__name__}")
    
        # Type check shooting_order (expected str)
        if "shooting_order" in props and props["shooting_order"] is not None:
            if not isinstance(props["shooting_order"], str):
                try:
                    # Attempt to convert
                    props["shooting_order"] = str(props["shooting_order"])
                except:
                    raise TypeError(f"Property shooting_order must be of type str, got {type(props['shooting_order']).__name__}")
    
        # Type check accommodation_strategy (expected str)
        if "accommodation_strategy" in props and props["accommodation_strategy"] is not None:
            if not isinstance(props["accommodation_strategy"], str):
                try:
                    # Attempt to convert
                    props["accommodation_strategy"] = str(props["accommodation_strategy"])
                except:
                    raise TypeError(f"Property accommodation_strategy must be of type str, got {type(props['accommodation_strategy']).__name__}")
    
        # Type check production_manager (expected str)
        if "production_manager" in props and props["production_manager"] is not None:
            if not isinstance(props["production_manager"], str):
                try:
                    # Attempt to convert
                    props["production_manager"] = str(props["production_manager"])
                except:
                    raise TypeError(f"Property production_manager must be of type str, got {type(props['production_manager']).__name__}")
    
        # Type check safety_incidents (expected str)
        if "safety_incidents" in props and props["safety_incidents"] is not None:
            if not isinstance(props["safety_incidents"], str):
                try:
                    # Attempt to convert
                    props["safety_incidents"] = str(props["safety_incidents"])
                except:
                    raise TypeError(f"Property safety_incidents must be of type str, got {type(props['safety_incidents']).__name__}")
    
        # Type check crew_composition (expected str)
        if "crew_composition" in props and props["crew_composition"] is not None:
            if not isinstance(props["crew_composition"], str):
                try:
                    # Attempt to convert
                    props["crew_composition"] = str(props["crew_composition"])
                except:
                    raise TypeError(f"Property crew_composition must be of type str, got {type(props['crew_composition']).__name__}")
    
        # Type check daily_call_times (expected str)
        if "daily_call_times" in props and props["daily_call_times"] is not None:
            if not isinstance(props["daily_call_times"], str):
                try:
                    # Attempt to convert
                    props["daily_call_times"] = str(props["daily_call_times"])
                except:
                    raise TypeError(f"Property daily_call_times must be of type str, got {type(props['daily_call_times']).__name__}")
    
        # Type check shooting_schedule (expected str)
        if "shooting_schedule" in props and props["shooting_schedule"] is not None:
            if not isinstance(props["shooting_schedule"], str):
                try:
                    # Attempt to convert
                    props["shooting_schedule"] = str(props["shooting_schedule"])
                except:
                    raise TypeError(f"Property shooting_schedule must be of type str, got {type(props['shooting_schedule']).__name__}")
    
        # Type check catering_approach (expected str)
        if "catering_approach" in props and props["catering_approach"] is not None:
            if not isinstance(props["catering_approach"], str):
                try:
                    # Attempt to convert
                    props["catering_approach"] = str(props["catering_approach"])
                except:
                    raise TypeError(f"Property catering_approach must be of type str, got {type(props['catering_approach']).__name__}")
    
        # Type check mafia_interactions (expected str)
        if "mafia_interactions" in props and props["mafia_interactions"] is not None:
            if not isinstance(props["mafia_interactions"], str):
                try:
                    # Attempt to convert
                    props["mafia_interactions"] = str(props["mafia_interactions"])
                except:
                    raise TypeError(f"Property mafia_interactions must be of type str, got {type(props['mafia_interactions']).__name__}")
    
        # Type check location_manager (expected str)
        if "location_manager" in props and props["location_manager"] is not None:
            if not isinstance(props["location_manager"], str):
                try:
                    # Attempt to convert
                    props["location_manager"] = str(props["location_manager"])
                except:
                    raise TypeError(f"Property location_manager must be of type str, got {type(props['location_manager']).__name__}")
    
        # Type check insurance_claims (expected int)
        if "insurance_claims" in props and props["insurance_claims"] is not None:
            if not isinstance(props["insurance_claims"], int):
                try:
                    # Attempt to convert
                    props["insurance_claims"] = int(props["insurance_claims"])
                except:
                    raise TypeError(f"Property insurance_claims must be of type int, got {type(props['insurance_claims']).__name__}")
    
        # Type check security_concerns (expected str)
        if "security_concerns" in props and props["security_concerns"] is not None:
            if not isinstance(props["security_concerns"], str):
                try:
                    # Attempt to convert
                    props["security_concerns"] = str(props["security_concerns"])
                except:
                    raise TypeError(f"Property security_concerns must be of type str, got {type(props['security_concerns']).__name__}")
    
        # Type check sicily_logistics (expected str)
        if "sicily_logistics" in props and props["sicily_logistics"] is not None:
            if not isinstance(props["sicily_logistics"], str):
                try:
                    # Attempt to convert
                    props["sicily_logistics"] = str(props["sicily_logistics"])
                except:
                    raise TypeError(f"Property sicily_logistics must be of type str, got {type(props['sicily_logistics']).__name__}")
    
        # Type check weather_delays (expected int)
        if "weather_delays" in props and props["weather_delays"] is not None:
            if not isinstance(props["weather_delays"], int):
                try:
                    # Attempt to convert
                    props["weather_delays"] = int(props["weather_delays"])
                except:
                    raise TypeError(f"Property weather_delays must be of type int, got {type(props['weather_delays']).__name__}")
    
        # Type check communication_systems (expected str)
        if "communication_systems" in props and props["communication_systems"] is not None:
            if not isinstance(props["communication_systems"], str):
                try:
                    # Attempt to convert
                    props["communication_systems"] = str(props["communication_systems"])
                except:
                    raise TypeError(f"Property communication_systems must be of type str, got {type(props['communication_systems']).__name__}")
    
        # Type check transportation_coordination (expected str)
        if "transportation_coordination" in props and props["transportation_coordination"] is not None:
            if not isinstance(props["transportation_coordination"], str):
                try:
                    # Attempt to convert
                    props["transportation_coordination"] = str(props["transportation_coordination"])
                except:
                    raise TypeError(f"Property transportation_coordination must be of type str, got {type(props['transportation_coordination']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="OPERATIONS_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def insured(uuid=None, **props):
        """
        Find relationships of type INSURED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check script_breakdown_analysis (expected str)
        if "script_breakdown_analysis" in props and props["script_breakdown_analysis"] is not None:
            if not isinstance(props["script_breakdown_analysis"], str):
                try:
                    # Attempt to convert
                    props["script_breakdown_analysis"] = str(props["script_breakdown_analysis"])
                except:
                    raise TypeError(f"Property script_breakdown_analysis must be of type str, got {type(props['script_breakdown_analysis']).__name__}")
    
        # Type check stunt_coordination_review (expected str)
        if "stunt_coordination_review" in props and props["stunt_coordination_review"] is not None:
            if not isinstance(props["stunt_coordination_review"], str):
                try:
                    # Attempt to convert
                    props["stunt_coordination_review"] = str(props["stunt_coordination_review"])
                except:
                    raise TypeError(f"Property stunt_coordination_review must be of type str, got {type(props['stunt_coordination_review']).__name__}")
    
        # Type check location_risk_surveys (expected str)
        if "location_risk_surveys" in props and props["location_risk_surveys"] is not None:
            if not isinstance(props["location_risk_surveys"], str):
                try:
                    # Attempt to convert
                    props["location_risk_surveys"] = str(props["location_risk_surveys"])
                except:
                    raise TypeError(f"Property location_risk_surveys must be of type str, got {type(props['location_risk_surveys']).__name__}")
    
        # Type check international_coverage_extensions (expected str)
        if "international_coverage_extensions" in props and props["international_coverage_extensions"] is not None:
            if not isinstance(props["international_coverage_extensions"], str):
                try:
                    # Attempt to convert
                    props["international_coverage_extensions"] = str(props["international_coverage_extensions"])
                except:
                    raise TypeError(f"Property international_coverage_extensions must be of type str, got {type(props['international_coverage_extensions']).__name__}")
    
        # Type check special_risk_assessment (expected str)
        if "special_risk_assessment" in props and props["special_risk_assessment"] is not None:
            if not isinstance(props["special_risk_assessment"], str):
                try:
                    # Attempt to convert
                    props["special_risk_assessment"] = str(props["special_risk_assessment"])
                except:
                    raise TypeError(f"Property special_risk_assessment must be of type str, got {type(props['special_risk_assessment']).__name__}")
    
        # Type check policy_adjustments (expected str)
        if "policy_adjustments" in props and props["policy_adjustments"] is not None:
            if not isinstance(props["policy_adjustments"], str):
                try:
                    # Attempt to convert
                    props["policy_adjustments"] = str(props["policy_adjustments"])
                except:
                    raise TypeError(f"Property policy_adjustments must be of type str, got {type(props['policy_adjustments']).__name__}")
    
        # Type check claim_incidents (expected object)
        if "claim_incidents" in props and props["claim_incidents"] is not None:
            if not isinstance(props["claim_incidents"], object):
                try:
                    # Attempt to convert
                    props["claim_incidents"] = object(props["claim_incidents"])
                except:
                    raise TypeError(f"Property claim_incidents must be of type object, got {type(props['claim_incidents']).__name__}")
    
        # Type check claim_resolutions (expected object)
        if "claim_resolutions" in props and props["claim_resolutions"] is not None:
            if not isinstance(props["claim_resolutions"], object):
                try:
                    # Attempt to convert
                    props["claim_resolutions"] = object(props["claim_resolutions"])
                except:
                    raise TypeError(f"Property claim_resolutions must be of type object, got {type(props['claim_resolutions']).__name__}")
    
        # Type check completion_bond_integration (expected str)
        if "completion_bond_integration" in props and props["completion_bond_integration"] is not None:
            if not isinstance(props["completion_bond_integration"], str):
                try:
                    # Attempt to convert
                    props["completion_bond_integration"] = str(props["completion_bond_integration"])
                except:
                    raise TypeError(f"Property completion_bond_integration must be of type str, got {type(props['completion_bond_integration']).__name__}")
    
        # Type check policy_holder (expected str)
        if "policy_holder" in props and props["policy_holder"] is not None:
            if not isinstance(props["policy_holder"], str):
                try:
                    # Attempt to convert
                    props["policy_holder"] = str(props["policy_holder"])
                except:
                    raise TypeError(f"Property policy_holder must be of type str, got {type(props['policy_holder']).__name__}")
    
        # Type check premium_payment_schedule (expected str)
        if "premium_payment_schedule" in props and props["premium_payment_schedule"] is not None:
            if not isinstance(props["premium_payment_schedule"], str):
                try:
                    # Attempt to convert
                    props["premium_payment_schedule"] = str(props["premium_payment_schedule"])
                except:
                    raise TypeError(f"Property premium_payment_schedule must be of type str, got {type(props['premium_payment_schedule']).__name__}")
    
        # Type check risk_management_program (expected str)
        if "risk_management_program" in props and props["risk_management_program"] is not None:
            if not isinstance(props["risk_management_program"], str):
                try:
                    # Attempt to convert
                    props["risk_management_program"] = str(props["risk_management_program"])
                except:
                    raise TypeError(f"Property risk_management_program must be of type str, got {type(props['risk_management_program']).__name__}")
    
        # Type check certificate_holders (expected int)
        if "certificate_holders" in props and props["certificate_holders"] is not None:
            if not isinstance(props["certificate_holders"], int):
                try:
                    # Attempt to convert
                    props["certificate_holders"] = int(props["certificate_holders"])
                except:
                    raise TypeError(f"Property certificate_holders must be of type int, got {type(props['certificate_holders']).__name__}")
    
        # Type check brando_medical_examination (expected object)
        if "brando_medical_examination" in props and props["brando_medical_examination"] is not None:
            if not isinstance(props["brando_medical_examination"], object):
                try:
                    # Attempt to convert
                    props["brando_medical_examination"] = object(props["brando_medical_examination"])
                except:
                    raise TypeError(f"Property brando_medical_examination must be of type object, got {type(props['brando_medical_examination']).__name__}")
    
        # Type check additional_insureds (expected object)
        if "additional_insureds" in props and props["additional_insureds"] is not None:
            if not isinstance(props["additional_insureds"], object):
                try:
                    # Attempt to convert
                    props["additional_insureds"] = object(props["additional_insureds"])
                except:
                    raise TypeError(f"Property additional_insureds must be of type object, got {type(props['additional_insureds']).__name__}")
    
        # Type check coverage_territories (expected str)
        if "coverage_territories" in props and props["coverage_territories"] is not None:
            if not isinstance(props["coverage_territories"], str):
                try:
                    # Attempt to convert
                    props["coverage_territories"] = str(props["coverage_territories"])
                except:
                    raise TypeError(f"Property coverage_territories must be of type str, got {type(props['coverage_territories']).__name__}")
    
        # Type check medical_underwriting (expected str)
        if "medical_underwriting" in props and props["medical_underwriting"] is not None:
            if not isinstance(props["medical_underwriting"], str):
                try:
                    # Attempt to convert
                    props["medical_underwriting"] = str(props["medical_underwriting"])
                except:
                    raise TypeError(f"Property medical_underwriting must be of type str, got {type(props['medical_underwriting']).__name__}")
    
        # Type check exclusions_negotiated (expected str)
        if "exclusions_negotiated" in props and props["exclusions_negotiated"] is not None:
            if not isinstance(props["exclusions_negotiated"], str):
                try:
                    # Attempt to convert
                    props["exclusions_negotiated"] = str(props["exclusions_negotiated"])
                except:
                    raise TypeError(f"Property exclusions_negotiated must be of type str, got {type(props['exclusions_negotiated']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="INSURED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def preserves(uuid=None, **props):
        """
        Find relationships of type PRESERVES matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check preservation_status (expected str)
        if "preservation_status" in props and props["preservation_status"] is not None:
            if not isinstance(props["preservation_status"], str):
                try:
                    # Attempt to convert
                    props["preservation_status"] = str(props["preservation_status"])
                except:
                    raise TypeError(f"Property preservation_status must be of type str, got {type(props['preservation_status']).__name__}")
    
        # Type check digital_scan_resolution (expected str)
        if "digital_scan_resolution" in props and props["digital_scan_resolution"] is not None:
            if not isinstance(props["digital_scan_resolution"], str):
                try:
                    # Attempt to convert
                    props["digital_scan_resolution"] = str(props["digital_scan_resolution"])
                except:
                    raise TypeError(f"Property digital_scan_resolution must be of type str, got {type(props['digital_scan_resolution']).__name__}")
    
        # Type check preservation_elements_created (expected str)
        if "preservation_elements_created" in props and props["preservation_elements_created"] is not None:
            if not isinstance(props["preservation_elements_created"], str):
                try:
                    # Attempt to convert
                    props["preservation_elements_created"] = str(props["preservation_elements_created"])
                except:
                    raise TypeError(f"Property preservation_elements_created must be of type str, got {type(props['preservation_elements_created']).__name__}")
    
        # Type check audio_preservation (expected str)
        if "audio_preservation" in props and props["audio_preservation"] is not None:
            if not isinstance(props["audio_preservation"], str):
                try:
                    # Attempt to convert
                    props["audio_preservation"] = str(props["audio_preservation"])
                except:
                    raise TypeError(f"Property audio_preservation must be of type str, got {type(props['audio_preservation']).__name__}")
    
        # Type check color_timing_reference (expected str)
        if "color_timing_reference" in props and props["color_timing_reference"] is not None:
            if not isinstance(props["color_timing_reference"], str):
                try:
                    # Attempt to convert
                    props["color_timing_reference"] = str(props["color_timing_reference"])
                except:
                    raise TypeError(f"Property color_timing_reference must be of type str, got {type(props['color_timing_reference']).__name__}")
    
        # Type check cultural_significance_documentation (expected str)
        if "cultural_significance_documentation" in props and props["cultural_significance_documentation"] is not None:
            if not isinstance(props["cultural_significance_documentation"], str):
                try:
                    # Attempt to convert
                    props["cultural_significance_documentation"] = str(props["cultural_significance_documentation"])
                except:
                    raise TypeError(f"Property cultural_significance_documentation must be of type str, got {type(props['cultural_significance_documentation']).__name__}")
    
        # Type check preservation_partners (expected str)
        if "preservation_partners" in props and props["preservation_partners"] is not None:
            if not isinstance(props["preservation_partners"], str):
                try:
                    # Attempt to convert
                    props["preservation_partners"] = str(props["preservation_partners"])
                except:
                    raise TypeError(f"Property preservation_partners must be of type str, got {type(props['preservation_partners']).__name__}")
    
        # Type check original_negative_condition (expected str)
        if "original_negative_condition" in props and props["original_negative_condition"] is not None:
            if not isinstance(props["original_negative_condition"], str):
                try:
                    # Attempt to convert
                    props["original_negative_condition"] = str(props["original_negative_condition"])
                except:
                    raise TypeError(f"Property original_negative_condition must be of type str, got {type(props['original_negative_condition']).__name__}")
    
        # Type check technical_history_documentation (expected str)
        if "technical_history_documentation" in props and props["technical_history_documentation"] is not None:
            if not isinstance(props["technical_history_documentation"], str):
                try:
                    # Attempt to convert
                    props["technical_history_documentation"] = str(props["technical_history_documentation"])
                except:
                    raise TypeError(f"Property technical_history_documentation must be of type str, got {type(props['technical_history_documentation']).__name__}")
    
        # Type check cinematographer_consultation (expected str)
        if "cinematographer_consultation" in props and props["cinematographer_consultation"] is not None:
            if not isinstance(props["cinematographer_consultation"], str):
                try:
                    # Attempt to convert
                    props["cinematographer_consultation"] = str(props["cinematographer_consultation"])
                except:
                    raise TypeError(f"Property cinematographer_consultation must be of type str, got {type(props['cinematographer_consultation']).__name__}")
    
        # Type check access_copies_available (expected str)
        if "access_copies_available" in props and props["access_copies_available"] is not None:
            if not isinstance(props["access_copies_available"], str):
                try:
                    # Attempt to convert
                    props["access_copies_available"] = str(props["access_copies_available"])
                except:
                    raise TypeError(f"Property access_copies_available must be of type str, got {type(props['access_copies_available']).__name__}")
    
        # Type check registered_cultural_heritage (expected str)
        if "registered_cultural_heritage" in props and props["registered_cultural_heritage"] is not None:
            if not isinstance(props["registered_cultural_heritage"], str):
                try:
                    # Attempt to convert
                    props["registered_cultural_heritage"] = str(props["registered_cultural_heritage"])
                except:
                    raise TypeError(f"Property registered_cultural_heritage must be of type str, got {type(props['registered_cultural_heritage']).__name__}")
    
        # Type check restoration_philosophy (expected str)
        if "restoration_philosophy" in props and props["restoration_philosophy"] is not None:
            if not isinstance(props["restoration_philosophy"], str):
                try:
                    # Attempt to convert
                    props["restoration_philosophy"] = str(props["restoration_philosophy"])
                except:
                    raise TypeError(f"Property restoration_philosophy must be of type str, got {type(props['restoration_philosophy']).__name__}")
    
        # Type check rights_documentation (expected str)
        if "rights_documentation" in props and props["rights_documentation"] is not None:
            if not isinstance(props["rights_documentation"], str):
                try:
                    # Attempt to convert
                    props["rights_documentation"] = str(props["rights_documentation"])
                except:
                    raise TypeError(f"Property rights_documentation must be of type str, got {type(props['rights_documentation']).__name__}")
    
        # Type check future_preservation_plan (expected str)
        if "future_preservation_plan" in props and props["future_preservation_plan"] is not None:
            if not isinstance(props["future_preservation_plan"], str):
                try:
                    # Attempt to convert
                    props["future_preservation_plan"] = str(props["future_preservation_plan"])
                except:
                    raise TypeError(f"Property future_preservation_plan must be of type str, got {type(props['future_preservation_plan']).__name__}")
    
        # Type check conservation_treatments (expected str)
        if "conservation_treatments" in props and props["conservation_treatments"] is not None:
            if not isinstance(props["conservation_treatments"], str):
                try:
                    # Attempt to convert
                    props["conservation_treatments"] = str(props["conservation_treatments"])
                except:
                    raise TypeError(f"Property conservation_treatments must be of type str, got {type(props['conservation_treatments']).__name__}")
    
        # Type check director_involvement (expected str)
        if "director_involvement" in props and props["director_involvement"] is not None:
            if not isinstance(props["director_involvement"], str):
                try:
                    # Attempt to convert
                    props["director_involvement"] = str(props["director_involvement"])
                except:
                    raise TypeError(f"Property director_involvement must be of type str, got {type(props['director_involvement']).__name__}")
    
        # Type check paper_materials_digitization (expected str)
        if "paper_materials_digitization" in props and props["paper_materials_digitization"] is not None:
            if not isinstance(props["paper_materials_digitization"], str):
                try:
                    # Attempt to convert
                    props["paper_materials_digitization"] = str(props["paper_materials_digitization"])
                except:
                    raise TypeError(f"Property paper_materials_digitization must be of type str, got {type(props['paper_materials_digitization']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="PRESERVES", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def labor_framework_for(uuid=None, **props):
        """
        Find relationships of type LABOR_FRAMEWORK_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check compliance_documentation (expected str)
        if "compliance_documentation" in props and props["compliance_documentation"] is not None:
            if not isinstance(props["compliance_documentation"], str):
                try:
                    # Attempt to convert
                    props["compliance_documentation"] = str(props["compliance_documentation"])
                except:
                    raise TypeError(f"Property compliance_documentation must be of type str, got {type(props['compliance_documentation']).__name__}")
    
        # Type check residual_structure (expected str)
        if "residual_structure" in props and props["residual_structure"] is not None:
            if not isinstance(props["residual_structure"], str):
                try:
                    # Attempt to convert
                    props["residual_structure"] = str(props["residual_structure"])
                except:
                    raise TypeError(f"Property residual_structure must be of type str, got {type(props['residual_structure']).__name__}")
    
        # Type check payroll_processing (expected str)
        if "payroll_processing" in props and props["payroll_processing"] is not None:
            if not isinstance(props["payroll_processing"], str):
                try:
                    # Attempt to convert
                    props["payroll_processing"] = str(props["payroll_processing"])
                except:
                    raise TypeError(f"Property payroll_processing must be of type str, got {type(props['payroll_processing']).__name__}")
    
        # Type check union_business_representatives (expected object)
        if "union_business_representatives" in props and props["union_business_representatives"] is not None:
            if not isinstance(props["union_business_representatives"], object):
                try:
                    # Attempt to convert
                    props["union_business_representatives"] = object(props["union_business_representatives"])
                except:
                    raise TypeError(f"Property union_business_representatives must be of type object, got {type(props['union_business_representatives']).__name__}")
    
        # Type check work_rules_modifications (expected str)
        if "work_rules_modifications" in props and props["work_rules_modifications"] is not None:
            if not isinstance(props["work_rules_modifications"], str):
                try:
                    # Attempt to convert
                    props["work_rules_modifications"] = str(props["work_rules_modifications"])
                except:
                    raise TypeError(f"Property work_rules_modifications must be of type str, got {type(props['work_rules_modifications']).__name__}")
    
        # Type check special_conditions_negotiated (expected object)
        if "special_conditions_negotiated" in props and props["special_conditions_negotiated"] is not None:
            if not isinstance(props["special_conditions_negotiated"], object):
                try:
                    # Attempt to convert
                    props["special_conditions_negotiated"] = object(props["special_conditions_negotiated"])
                except:
                    raise TypeError(f"Property special_conditions_negotiated must be of type object, got {type(props['special_conditions_negotiated']).__name__}")
    
        # Type check credit_requirements (expected str)
        if "credit_requirements" in props and props["credit_requirements"] is not None:
            if not isinstance(props["credit_requirements"], str):
                try:
                    # Attempt to convert
                    props["credit_requirements"] = str(props["credit_requirements"])
                except:
                    raise TypeError(f"Property credit_requirements must be of type str, got {type(props['credit_requirements']).__name__}")
    
        # Type check jurisdictional_agreements (expected str)
        if "jurisdictional_agreements" in props and props["jurisdictional_agreements"] is not None:
            if not isinstance(props["jurisdictional_agreements"], str):
                try:
                    # Attempt to convert
                    props["jurisdictional_agreements"] = str(props["jurisdictional_agreements"])
                except:
                    raise TypeError(f"Property jurisdictional_agreements must be of type str, got {type(props['jurisdictional_agreements']).__name__}")
    
        # Type check foreign_levies (expected str)
        if "foreign_levies" in props and props["foreign_levies"] is not None:
            if not isinstance(props["foreign_levies"], str):
                try:
                    # Attempt to convert
                    props["foreign_levies"] = str(props["foreign_levies"])
                except:
                    raise TypeError(f"Property foreign_levies must be of type str, got {type(props['foreign_levies']).__name__}")
    
        # Type check guarantor (expected str)
        if "guarantor" in props and props["guarantor"] is not None:
            if not isinstance(props["guarantor"], str):
                try:
                    # Attempt to convert
                    props["guarantor"] = str(props["guarantor"])
                except:
                    raise TypeError(f"Property guarantor must be of type str, got {type(props['guarantor']).__name__}")
    
        # Type check grievance_procedure (expected str)
        if "grievance_procedure" in props and props["grievance_procedure"] is not None:
            if not isinstance(props["grievance_procedure"], str):
                try:
                    # Attempt to convert
                    props["grievance_procedure"] = str(props["grievance_procedure"])
                except:
                    raise TypeError(f"Property grievance_procedure must be of type str, got {type(props['grievance_procedure']).__name__}")
    
        # Type check international_travel_accommodations (expected str)
        if "international_travel_accommodations" in props and props["international_travel_accommodations"] is not None:
            if not isinstance(props["international_travel_accommodations"], str):
                try:
                    # Attempt to convert
                    props["international_travel_accommodations"] = str(props["international_travel_accommodations"])
                except:
                    raise TypeError(f"Property international_travel_accommodations must be of type str, got {type(props['international_travel_accommodations']).__name__}")
    
        # Type check per_diem_rates (expected str)
        if "per_diem_rates" in props and props["per_diem_rates"] is not None:
            if not isinstance(props["per_diem_rates"], str):
                try:
                    # Attempt to convert
                    props["per_diem_rates"] = str(props["per_diem_rates"])
                except:
                    raise TypeError(f"Property per_diem_rates must be of type str, got {type(props['per_diem_rates']).__name__}")
    
        # Type check labor_relations_director (expected str)
        if "labor_relations_director" in props and props["labor_relations_director"] is not None:
            if not isinstance(props["labor_relations_director"], str):
                try:
                    # Attempt to convert
                    props["labor_relations_director"] = str(props["labor_relations_director"])
                except:
                    raise TypeError(f"Property labor_relations_director must be of type str, got {type(props['labor_relations_director']).__name__}")
    
        # Type check signatory_production_company (expected str)
        if "signatory_production_company" in props and props["signatory_production_company"] is not None:
            if not isinstance(props["signatory_production_company"], str):
                try:
                    # Attempt to convert
                    props["signatory_production_company"] = str(props["signatory_production_company"])
                except:
                    raise TypeError(f"Property signatory_production_company must be of type str, got {type(props['signatory_production_company']).__name__}")
    
        # Type check labor_peace_commitment (expected str)
        if "labor_peace_commitment" in props and props["labor_peace_commitment"] is not None:
            if not isinstance(props["labor_peace_commitment"], str):
                try:
                    # Attempt to convert
                    props["labor_peace_commitment"] = str(props["labor_peace_commitment"])
                except:
                    raise TypeError(f"Property labor_peace_commitment must be of type str, got {type(props['labor_peace_commitment']).__name__}")
    
        # Type check pension_and_health_calculations (expected str)
        if "pension_and_health_calculations" in props and props["pension_and_health_calculations"] is not None:
            if not isinstance(props["pension_and_health_calculations"], str):
                try:
                    # Attempt to convert
                    props["pension_and_health_calculations"] = str(props["pension_and_health_calculations"])
                except:
                    raise TypeError(f"Property pension_and_health_calculations must be of type str, got {type(props['pension_and_health_calculations']).__name__}")
    
        # Type check working_condition_provisions (expected str)
        if "working_condition_provisions" in props and props["working_condition_provisions"] is not None:
            if not isinstance(props["working_condition_provisions"], str):
                try:
                    # Attempt to convert
                    props["working_condition_provisions"] = str(props["working_condition_provisions"])
                except:
                    raise TypeError(f"Property working_condition_provisions must be of type str, got {type(props['working_condition_provisions']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="LABOR_FRAMEWORK_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def merchandise_rights_for(uuid=None, **props):
        """
        Find relationships of type MERCHANDISE_RIGHTS_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check royalty_collection (expected str)
        if "royalty_collection" in props and props["royalty_collection"] is not None:
            if not isinstance(props["royalty_collection"], str):
                try:
                    # Attempt to convert
                    props["royalty_collection"] = str(props["royalty_collection"])
                except:
                    raise TypeError(f"Property royalty_collection must be of type str, got {type(props['royalty_collection']).__name__}")
    
        # Type check minimum_guarantees_structure (expected str)
        if "minimum_guarantees_structure" in props and props["minimum_guarantees_structure"] is not None:
            if not isinstance(props["minimum_guarantees_structure"], str):
                try:
                    # Attempt to convert
                    props["minimum_guarantees_structure"] = str(props["minimum_guarantees_structure"])
                except:
                    raise TypeError(f"Property minimum_guarantees_structure must be of type str, got {type(props['minimum_guarantees_structure']).__name__}")
    
        # Type check program_evolution (expected str)
        if "program_evolution" in props and props["program_evolution"] is not None:
            if not isinstance(props["program_evolution"], str):
                try:
                    # Attempt to convert
                    props["program_evolution"] = str(props["program_evolution"])
                except:
                    raise TypeError(f"Property program_evolution must be of type str, got {type(props['program_evolution']).__name__}")
    
        # Type check program_approach (expected str)
        if "program_approach" in props and props["program_approach"] is not None:
            if not isinstance(props["program_approach"], str):
                try:
                    # Attempt to convert
                    props["program_approach"] = str(props["program_approach"])
                except:
                    raise TypeError(f"Property program_approach must be of type str, got {type(props['program_approach']).__name__}")
    
        # Type check licensing_director (expected str)
        if "licensing_director" in props and props["licensing_director"] is not None:
            if not isinstance(props["licensing_director"], str):
                try:
                    # Attempt to convert
                    props["licensing_director"] = str(props["licensing_director"])
                except:
                    raise TypeError(f"Property licensing_director must be of type str, got {type(props['licensing_director']).__name__}")
    
        # Type check international_adaptation (expected str)
        if "international_adaptation" in props and props["international_adaptation"] is not None:
            if not isinstance(props["international_adaptation"], str):
                try:
                    # Attempt to convert
                    props["international_adaptation"] = str(props["international_adaptation"])
                except:
                    raise TypeError(f"Property international_adaptation must be of type str, got {type(props['international_adaptation']).__name__}")
    
        # Type check top_performing_licensee (expected str)
        if "top_performing_licensee" in props and props["top_performing_licensee"] is not None:
            if not isinstance(props["top_performing_licensee"], str):
                try:
                    # Attempt to convert
                    props["top_performing_licensee"] = str(props["top_performing_licensee"])
                except:
                    raise TypeError(f"Property top_performing_licensee must be of type str, got {type(props['top_performing_licensee']).__name__}")
    
        # Type check second_phase_activation (expected str)
        if "second_phase_activation" in props and props["second_phase_activation"] is not None:
            if not isinstance(props["second_phase_activation"], str):
                try:
                    # Attempt to convert
                    props["second_phase_activation"] = str(props["second_phase_activation"])
                except:
                    raise TypeError(f"Property second_phase_activation must be of type str, got {type(props['second_phase_activation']).__name__}")
    
        # Type check quality_control_process (expected str)
        if "quality_control_process" in props and props["quality_control_process"] is not None:
            if not isinstance(props["quality_control_process"], str):
                try:
                    # Attempt to convert
                    props["quality_control_process"] = str(props["quality_control_process"])
                except:
                    raise TypeError(f"Property quality_control_process must be of type str, got {type(props['quality_control_process']).__name__}")
    
        # Type check key_licensed_categories (expected object)
        if "key_licensed_categories" in props and props["key_licensed_categories"] is not None:
            if not isinstance(props["key_licensed_categories"], object):
                try:
                    # Attempt to convert
                    props["key_licensed_categories"] = object(props["key_licensed_categories"])
                except:
                    raise TypeError(f"Property key_licensed_categories must be of type object, got {type(props['key_licensed_categories']).__name__}")
    
        # Type check marketing_coordination (expected str)
        if "marketing_coordination" in props and props["marketing_coordination"] is not None:
            if not isinstance(props["marketing_coordination"], str):
                try:
                    # Attempt to convert
                    props["marketing_coordination"] = str(props["marketing_coordination"])
                except:
                    raise TypeError(f"Property marketing_coordination must be of type str, got {type(props['marketing_coordination']).__name__}")
    
        # Type check contract_term (expected str)
        if "contract_term" in props and props["contract_term"] is not None:
            if not isinstance(props["contract_term"], str):
                try:
                    # Attempt to convert
                    props["contract_term"] = str(props["contract_term"])
                except:
                    raise TypeError(f"Property contract_term must be of type str, got {type(props['contract_term']).__name__}")
    
        # Type check retail_distribution_channels (expected str)
        if "retail_distribution_channels" in props and props["retail_distribution_channels"] is not None:
            if not isinstance(props["retail_distribution_channels"], str):
                try:
                    # Attempt to convert
                    props["retail_distribution_channels"] = str(props["retail_distribution_channels"])
                except:
                    raise TypeError(f"Property retail_distribution_channels must be of type str, got {type(props['retail_distribution_channels']).__name__}")
    
        # Type check legacy_program_development (expected str)
        if "legacy_program_development" in props and props["legacy_program_development"] is not None:
            if not isinstance(props["legacy_program_development"], str):
                try:
                    # Attempt to convert
                    props["legacy_program_development"] = str(props["legacy_program_development"])
                except:
                    raise TypeError(f"Property legacy_program_development must be of type str, got {type(props['legacy_program_development']).__name__}")
    
        # Type check prohibited_categories (expected object)
        if "prohibited_categories" in props and props["prohibited_categories"] is not None:
            if not isinstance(props["prohibited_categories"], object):
                try:
                    # Attempt to convert
                    props["prohibited_categories"] = object(props["prohibited_categories"])
                except:
                    raise TypeError(f"Property prohibited_categories must be of type object, got {type(props['prohibited_categories']).__name__}")
    
        # Type check rights_restrictions (expected str)
        if "rights_restrictions" in props and props["rights_restrictions"] is not None:
            if not isinstance(props["rights_restrictions"], str):
                try:
                    # Attempt to convert
                    props["rights_restrictions"] = str(props["rights_restrictions"])
                except:
                    raise TypeError(f"Property rights_restrictions must be of type str, got {type(props['rights_restrictions']).__name__}")
    
        # Type check intellectual_property_elements (expected object)
        if "intellectual_property_elements" in props and props["intellectual_property_elements"] is not None:
            if not isinstance(props["intellectual_property_elements"], object):
                try:
                    # Attempt to convert
                    props["intellectual_property_elements"] = object(props["intellectual_property_elements"])
                except:
                    raise TypeError(f"Property intellectual_property_elements must be of type object, got {type(props['intellectual_property_elements']).__name__}")
    
        # Type check approval_chain (expected str)
        if "approval_chain" in props and props["approval_chain"] is not None:
            if not isinstance(props["approval_chain"], str):
                try:
                    # Attempt to convert
                    props["approval_chain"] = str(props["approval_chain"])
                except:
                    raise TypeError(f"Property approval_chain must be of type str, got {type(props['approval_chain']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="MERCHANDISE_RIGHTS_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def brand_integration_for(uuid=None, **props):
        """
        Find relationships of type BRAND_INTEGRATION_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check integration_director (expected str)
        if "integration_director" in props and props["integration_director"] is not None:
            if not isinstance(props["integration_director"], str):
                try:
                    # Attempt to convert
                    props["integration_director"] = str(props["integration_director"])
                except:
                    raise TypeError(f"Property integration_director must be of type str, got {type(props['integration_director']).__name__}")
    
        # Type check negotiation_priority (expected str)
        if "negotiation_priority" in props and props["negotiation_priority"] is not None:
            if not isinstance(props["negotiation_priority"], str):
                try:
                    # Attempt to convert
                    props["negotiation_priority"] = str(props["negotiation_priority"])
                except:
                    raise TypeError(f"Property negotiation_priority must be of type str, got {type(props['negotiation_priority']).__name__}")
    
        # Type check brand_approval_restrictions (expected str)
        if "brand_approval_restrictions" in props and props["brand_approval_restrictions"] is not None:
            if not isinstance(props["brand_approval_restrictions"], str):
                try:
                    # Attempt to convert
                    props["brand_approval_restrictions"] = str(props["brand_approval_restrictions"])
                except:
                    raise TypeError(f"Property brand_approval_restrictions must be of type str, got {type(props['brand_approval_restrictions']).__name__}")
    
        # Type check beverage_integration_parameters (expected str)
        if "beverage_integration_parameters" in props and props["beverage_integration_parameters"] is not None:
            if not isinstance(props["beverage_integration_parameters"], str):
                try:
                    # Attempt to convert
                    props["beverage_integration_parameters"] = str(props["beverage_integration_parameters"])
                except:
                    raise TypeError(f"Property beverage_integration_parameters must be of type str, got {type(props['beverage_integration_parameters']).__name__}")
    
        # Type check deal_structure_innovation (expected str)
        if "deal_structure_innovation" in props and props["deal_structure_innovation"] is not None:
            if not isinstance(props["deal_structure_innovation"], str):
                try:
                    # Attempt to convert
                    props["deal_structure_innovation"] = str(props["deal_structure_innovation"])
                except:
                    raise TypeError(f"Property deal_structure_innovation must be of type str, got {type(props['deal_structure_innovation']).__name__}")
    
        # Type check product_supply_logistics (expected str)
        if "product_supply_logistics" in props and props["product_supply_logistics"] is not None:
            if not isinstance(props["product_supply_logistics"], str):
                try:
                    # Attempt to convert
                    props["product_supply_logistics"] = str(props["product_supply_logistics"])
                except:
                    raise TypeError(f"Property product_supply_logistics must be of type str, got {type(props['product_supply_logistics']).__name__}")
    
        # Type check legal_clearance_process (expected str)
        if "legal_clearance_process" in props and props["legal_clearance_process"] is not None:
            if not isinstance(props["legal_clearance_process"], str):
                try:
                    # Attempt to convert
                    props["legal_clearance_process"] = str(props["legal_clearance_process"])
                except:
                    raise TypeError(f"Property legal_clearance_process must be of type str, got {type(props['legal_clearance_process']).__name__}")
    
        # Type check additional_consideration (expected str)
        if "additional_consideration" in props and props["additional_consideration"] is not None:
            if not isinstance(props["additional_consideration"], str):
                try:
                    # Attempt to convert
                    props["additional_consideration"] = str(props["additional_consideration"])
                except:
                    raise TypeError(f"Property additional_consideration must be of type str, got {type(props['additional_consideration']).__name__}")
    
        # Type check clothing_supplier_arrangement (expected str)
        if "clothing_supplier_arrangement" in props and props["clothing_supplier_arrangement"] is not None:
            if not isinstance(props["clothing_supplier_arrangement"], str):
                try:
                    # Attempt to convert
                    props["clothing_supplier_arrangement"] = str(props["clothing_supplier_arrangement"])
                except:
                    raise TypeError(f"Property clothing_supplier_arrangement must be of type str, got {type(props['clothing_supplier_arrangement']).__name__}")
    
        # Type check historical_consistency_review (expected str)
        if "historical_consistency_review" in props and props["historical_consistency_review"] is not None:
            if not isinstance(props["historical_consistency_review"], str):
                try:
                    # Attempt to convert
                    props["historical_consistency_review"] = str(props["historical_consistency_review"])
                except:
                    raise TypeError(f"Property historical_consistency_review must be of type str, got {type(props['historical_consistency_review']).__name__}")
    
        # Type check contemporaneous_promotion_prohibition (expected str)
        if "contemporaneous_promotion_prohibition" in props and props["contemporaneous_promotion_prohibition"] is not None:
            if not isinstance(props["contemporaneous_promotion_prohibition"], str):
                try:
                    # Attempt to convert
                    props["contemporaneous_promotion_prohibition"] = str(props["contemporaneous_promotion_prohibition"])
                except:
                    raise TypeError(f"Property contemporaneous_promotion_prohibition must be of type str, got {type(props['contemporaneous_promotion_prohibition']).__name__}")
    
        # Type check screen_credit_provisions (expected str)
        if "screen_credit_provisions" in props and props["screen_credit_provisions"] is not None:
            if not isinstance(props["screen_credit_provisions"], str):
                try:
                    # Attempt to convert
                    props["screen_credit_provisions"] = str(props["screen_credit_provisions"])
                except:
                    raise TypeError(f"Property screen_credit_provisions must be of type str, got {type(props['screen_credit_provisions']).__name__}")
    
        # Type check placement_philosophy (expected str)
        if "placement_philosophy" in props and props["placement_philosophy"] is not None:
            if not isinstance(props["placement_philosophy"], str):
                try:
                    # Attempt to convert
                    props["placement_philosophy"] = str(props["placement_philosophy"])
                except:
                    raise TypeError(f"Property placement_philosophy must be of type str, got {type(props['placement_philosophy']).__name__}")
    
        # Type check integration_subtlety_requirement (expected str)
        if "integration_subtlety_requirement" in props and props["integration_subtlety_requirement"] is not None:
            if not isinstance(props["integration_subtlety_requirement"], str):
                try:
                    # Attempt to convert
                    props["integration_subtlety_requirement"] = str(props["integration_subtlety_requirement"])
                except:
                    raise TypeError(f"Property integration_subtlety_requirement must be of type str, got {type(props['integration_subtlety_requirement']).__name__}")
    
        # Type check period_authenticity_requirement (expected str)
        if "period_authenticity_requirement" in props and props["period_authenticity_requirement"] is not None:
            if not isinstance(props["period_authenticity_requirement"], str):
                try:
                    # Attempt to convert
                    props["period_authenticity_requirement"] = str(props["period_authenticity_requirement"])
                except:
                    raise TypeError(f"Property period_authenticity_requirement must be of type str, got {type(props['period_authenticity_requirement']).__name__}")
    
        # Type check future_rights_limitations (expected str)
        if "future_rights_limitations" in props and props["future_rights_limitations"] is not None:
            if not isinstance(props["future_rights_limitations"], str):
                try:
                    # Attempt to convert
                    props["future_rights_limitations"] = str(props["future_rights_limitations"])
                except:
                    raise TypeError(f"Property future_rights_limitations must be of type str, got {type(props['future_rights_limitations']).__name__}")
    
        # Type check automobile_supplier_agreement (expected str)
        if "automobile_supplier_agreement" in props and props["automobile_supplier_agreement"] is not None:
            if not isinstance(props["automobile_supplier_agreement"], str):
                try:
                    # Attempt to convert
                    props["automobile_supplier_agreement"] = str(props["automobile_supplier_agreement"])
                except:
                    raise TypeError(f"Property automobile_supplier_agreement must be of type str, got {type(props['automobile_supplier_agreement']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="BRAND_INTEGRATION_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def post_produced(uuid=None, **props):
        """
        Find relationships of type POST_PRODUCED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check delivery_requirements (expected str)
        if "delivery_requirements" in props and props["delivery_requirements"] is not None:
            if not isinstance(props["delivery_requirements"], str):
                try:
                    # Attempt to convert
                    props["delivery_requirements"] = str(props["delivery_requirements"])
                except:
                    raise TypeError(f"Property delivery_requirements must be of type str, got {type(props['delivery_requirements']).__name__}")
    
        # Type check post_supervisor (expected str)
        if "post_supervisor" in props and props["post_supervisor"] is not None:
            if not isinstance(props["post_supervisor"], str):
                try:
                    # Attempt to convert
                    props["post_supervisor"] = str(props["post_supervisor"])
                except:
                    raise TypeError(f"Property post_supervisor must be of type str, got {type(props['post_supervisor']).__name__}")
    
        # Type check editor_collaboration_approach (expected str)
        if "editor_collaboration_approach" in props and props["editor_collaboration_approach"] is not None:
            if not isinstance(props["editor_collaboration_approach"], str):
                try:
                    # Attempt to convert
                    props["editor_collaboration_approach"] = str(props["editor_collaboration_approach"])
                except:
                    raise TypeError(f"Property editor_collaboration_approach must be of type str, got {type(props['editor_collaboration_approach']).__name__}")
    
        # Type check post_schedule_adherence (expected str)
        if "post_schedule_adherence" in props and props["post_schedule_adherence"] is not None:
            if not isinstance(props["post_schedule_adherence"], str):
                try:
                    # Attempt to convert
                    props["post_schedule_adherence"] = str(props["post_schedule_adherence"])
                except:
                    raise TypeError(f"Property post_schedule_adherence must be of type str, got {type(props['post_schedule_adherence']).__name__}")
    
        # Type check editorial_process (expected str)
        if "editorial_process" in props and props["editorial_process"] is not None:
            if not isinstance(props["editorial_process"], str):
                try:
                    # Attempt to convert
                    props["editorial_process"] = str(props["editorial_process"])
                except:
                    raise TypeError(f"Property editorial_process must be of type str, got {type(props['editorial_process']).__name__}")
    
        # Type check foley_recording (expected str)
        if "foley_recording" in props and props["foley_recording"] is not None:
            if not isinstance(props["foley_recording"], str):
                try:
                    # Attempt to convert
                    props["foley_recording"] = str(props["foley_recording"])
                except:
                    raise TypeError(f"Property foley_recording must be of type str, got {type(props['foley_recording']).__name__}")
    
        # Type check primary_editing_location (expected str)
        if "primary_editing_location" in props and props["primary_editing_location"] is not None:
            if not isinstance(props["primary_editing_location"], str):
                try:
                    # Attempt to convert
                    props["primary_editing_location"] = str(props["primary_editing_location"])
                except:
                    raise TypeError(f"Property primary_editing_location must be of type str, got {type(props['primary_editing_location']).__name__}")
    
        # Type check workprint_creation (expected str)
        if "workprint_creation" in props and props["workprint_creation"] is not None:
            if not isinstance(props["workprint_creation"], str):
                try:
                    # Attempt to convert
                    props["workprint_creation"] = str(props["workprint_creation"])
                except:
                    raise TypeError(f"Property workprint_creation must be of type str, got {type(props['workprint_creation']).__name__}")
    
        # Type check optical_effects_house (expected str)
        if "optical_effects_house" in props and props["optical_effects_house"] is not None:
            if not isinstance(props["optical_effects_house"], str):
                try:
                    # Attempt to convert
                    props["optical_effects_house"] = str(props["optical_effects_house"])
                except:
                    raise TypeError(f"Property optical_effects_house must be of type str, got {type(props['optical_effects_house']).__name__}")
    
        # Type check orchestra_size (expected int)
        if "orchestra_size" in props and props["orchestra_size"] is not None:
            if not isinstance(props["orchestra_size"], int):
                try:
                    # Attempt to convert
                    props["orchestra_size"] = int(props["orchestra_size"])
                except:
                    raise TypeError(f"Property orchestra_size must be of type int, got {type(props['orchestra_size']).__name__}")
    
        # Type check music_recording_studio (expected str)
        if "music_recording_studio" in props and props["music_recording_studio"] is not None:
            if not isinstance(props["music_recording_studio"], str):
                try:
                    # Attempt to convert
                    props["music_recording_studio"] = str(props["music_recording_studio"])
                except:
                    raise TypeError(f"Property music_recording_studio must be of type str, got {type(props['music_recording_studio']).__name__}")
    
        # Type check screening_schedule (expected str)
        if "screening_schedule" in props and props["screening_schedule"] is not None:
            if not isinstance(props["screening_schedule"], str):
                try:
                    # Attempt to convert
                    props["screening_schedule"] = str(props["screening_schedule"])
                except:
                    raise TypeError(f"Property screening_schedule must be of type str, got {type(props['screening_schedule']).__name__}")
    
        # Type check dailies_processing (expected str)
        if "dailies_processing" in props and props["dailies_processing"] is not None:
            if not isinstance(props["dailies_processing"], str):
                try:
                    # Attempt to convert
                    props["dailies_processing"] = str(props["dailies_processing"])
                except:
                    raise TypeError(f"Property dailies_processing must be of type str, got {type(props['dailies_processing']).__name__}")
    
        # Type check sound_design_facility (expected str)
        if "sound_design_facility" in props and props["sound_design_facility"] is not None:
            if not isinstance(props["sound_design_facility"], str):
                try:
                    # Attempt to convert
                    props["sound_design_facility"] = str(props["sound_design_facility"])
                except:
                    raise TypeError(f"Property sound_design_facility must be of type str, got {type(props['sound_design_facility']).__name__}")
    
        # Type check edit_decision_workflow (expected str)
        if "edit_decision_workflow" in props and props["edit_decision_workflow"] is not None:
            if not isinstance(props["edit_decision_workflow"], str):
                try:
                    # Attempt to convert
                    props["edit_decision_workflow"] = str(props["edit_decision_workflow"])
                except:
                    raise TypeError(f"Property edit_decision_workflow must be of type str, got {type(props['edit_decision_workflow']).__name__}")
    
        # Type check sound_mixing_approach (expected str)
        if "sound_mixing_approach" in props and props["sound_mixing_approach"] is not None:
            if not isinstance(props["sound_mixing_approach"], str):
                try:
                    # Attempt to convert
                    props["sound_mixing_approach"] = str(props["sound_mixing_approach"])
                except:
                    raise TypeError(f"Property sound_mixing_approach must be of type str, got {type(props['sound_mixing_approach']).__name__}")
    
        # Type check title_design_process (expected str)
        if "title_design_process" in props and props["title_design_process"] is not None:
            if not isinstance(props["title_design_process"], str):
                try:
                    # Attempt to convert
                    props["title_design_process"] = str(props["title_design_process"])
                except:
                    raise TypeError(f"Property title_design_process must be of type str, got {type(props['title_design_process']).__name__}")
    
        # Type check color_timing_supervision (expected str)
        if "color_timing_supervision" in props and props["color_timing_supervision"] is not None:
            if not isinstance(props["color_timing_supervision"], str):
                try:
                    # Attempt to convert
                    props["color_timing_supervision"] = str(props["color_timing_supervision"])
                except:
                    raise TypeError(f"Property color_timing_supervision must be of type str, got {type(props['color_timing_supervision']).__name__}")
    
        # Type check lab_processing (expected str)
        if "lab_processing" in props and props["lab_processing"] is not None:
            if not isinstance(props["lab_processing"], str):
                try:
                    # Attempt to convert
                    props["lab_processing"] = str(props["lab_processing"])
                except:
                    raise TypeError(f"Property lab_processing must be of type str, got {type(props['lab_processing']).__name__}")
    
        # Type check technical_challenges (expected str)
        if "technical_challenges" in props and props["technical_challenges"] is not None:
            if not isinstance(props["technical_challenges"], str):
                try:
                    # Attempt to convert
                    props["technical_challenges"] = str(props["technical_challenges"])
                except:
                    raise TypeError(f"Property technical_challenges must be of type str, got {type(props['technical_challenges']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="POST_PRODUCED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def voiced_in(uuid=None, **props):
        """
        Find relationships of type VOICED_IN matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check endDate (expected object)
        if "endDate" in props and props["endDate"] is not None:
            if not isinstance(props["endDate"], object):
                try:
                    # Attempt to convert
                    props["endDate"] = object(props["endDate"])
                except:
                    raise TypeError(f"Property endDate must be of type object, got {type(props['endDate']).__name__}")
    
        # Type check performanceRating (expected float)
        if "performanceRating" in props and props["performanceRating"] is not None:
            if not isinstance(props["performanceRating"], float):
                try:
                    # Attempt to convert
                    props["performanceRating"] = float(props["performanceRating"])
                except:
                    raise TypeError(f"Property performanceRating must be of type float, got {type(props['performanceRating']).__name__}")
    
        # Type check recordingDays (expected int)
        if "recordingDays" in props and props["recordingDays"] is not None:
            if not isinstance(props["recordingDays"], int):
                try:
                    # Attempt to convert
                    props["recordingDays"] = int(props["recordingDays"])
                except:
                    raise TypeError(f"Property recordingDays must be of type int, got {type(props['recordingDays']).__name__}")
    
        # Type check recordingSessions (expected int)
        if "recordingSessions" in props and props["recordingSessions"] is not None:
            if not isinstance(props["recordingSessions"], int):
                try:
                    # Attempt to convert
                    props["recordingSessions"] = int(props["recordingSessions"])
                except:
                    raise TypeError(f"Property recordingSessions must be of type int, got {type(props['recordingSessions']).__name__}")
    
        # Type check linesCount (expected int)
        if "linesCount" in props and props["linesCount"] is not None:
            if not isinstance(props["linesCount"], int):
                try:
                    # Attempt to convert
                    props["linesCount"] = int(props["linesCount"])
                except:
                    raise TypeError(f"Property linesCount must be of type int, got {type(props['linesCount']).__name__}")
    
        # Type check roles (expected object)
        if "roles" in props and props["roles"] is not None:
            if not isinstance(props["roles"], object):
                try:
                    # Attempt to convert
                    props["roles"] = object(props["roles"])
                except:
                    raise TypeError(f"Property roles must be of type object, got {type(props['roles']).__name__}")
    
        # Type check salary (expected int)
        if "salary" in props and props["salary"] is not None:
            if not isinstance(props["salary"], int):
                try:
                    # Attempt to convert
                    props["salary"] = int(props["salary"])
                except:
                    raise TypeError(f"Property salary must be of type int, got {type(props['salary']).__name__}")
    
        # Type check startDate (expected object)
        if "startDate" in props and props["startDate"] is not None:
            if not isinstance(props["startDate"], object):
                try:
                    # Attempt to convert
                    props["startDate"] = object(props["startDate"])
                except:
                    raise TypeError(f"Property startDate must be of type object, got {type(props['startDate']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="VOICED_IN", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def co_produced(uuid=None, **props):
        """
        Find relationships of type CO_PRODUCED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check marketingContribution (expected int)
        if "marketingContribution" in props and props["marketingContribution"] is not None:
            if not isinstance(props["marketingContribution"], int):
                try:
                    # Attempt to convert
                    props["marketingContribution"] = int(props["marketingContribution"])
                except:
                    raise TypeError(f"Property marketingContribution must be of type int, got {type(props['marketingContribution']).__name__}")
    
        # Type check roi (expected float)
        if "roi" in props and props["roi"] is not None:
            if not isinstance(props["roi"], float):
                try:
                    # Attempt to convert
                    props["roi"] = float(props["roi"])
                except:
                    raise TypeError(f"Property roi must be of type float, got {type(props['roi']).__name__}")
    
        # Type check return (expected int)
        if "return" in props and props["return"] is not None:
            if not isinstance(props["return"], int):
                try:
                    # Attempt to convert
                    props["return"] = int(props["return"])
                except:
                    raise TypeError(f"Property return must be of type int, got {type(props['return']).__name__}")
    
        # Type check profitDate (expected object)
        if "profitDate" in props and props["profitDate"] is not None:
            if not isinstance(props["profitDate"], object):
                try:
                    # Attempt to convert
                    props["profitDate"] = object(props["profitDate"])
                except:
                    raise TypeError(f"Property profitDate must be of type object, got {type(props['profitDate']).__name__}")
    
        # Type check investment (expected int)
        if "investment" in props and props["investment"] is not None:
            if not isinstance(props["investment"], int):
                try:
                    # Attempt to convert
                    props["investment"] = int(props["investment"])
                except:
                    raise TypeError(f"Property investment must be of type int, got {type(props['investment']).__name__}")
    
        # Type check marketingStart (expected object)
        if "marketingStart" in props and props["marketingStart"] is not None:
            if not isinstance(props["marketingStart"], object):
                try:
                    # Attempt to convert
                    props["marketingStart"] = object(props["marketingStart"])
                except:
                    raise TypeError(f"Property marketingStart must be of type object, got {type(props['marketingStart']).__name__}")
    
        # Type check contractSigned (expected object)
        if "contractSigned" in props and props["contractSigned"] is not None:
            if not isinstance(props["contractSigned"], object):
                try:
                    # Attempt to convert
                    props["contractSigned"] = object(props["contractSigned"])
                except:
                    raise TypeError(f"Property contractSigned must be of type object, got {type(props['contractSigned']).__name__}")
    
        # Type check studioShare (expected float)
        if "studioShare" in props and props["studioShare"] is not None:
            if not isinstance(props["studioShare"], float):
                try:
                    # Attempt to convert
                    props["studioShare"] = float(props["studioShare"])
                except:
                    raise TypeError(f"Property studioShare must be of type float, got {type(props['studioShare']).__name__}")
    
        # Type check isProfitable (expected bool)
        if "isProfitable" in props and props["isProfitable"] is not None:
            if not isinstance(props["isProfitable"], bool):
                try:
                    # Attempt to convert
                    props["isProfitable"] = bool(props["isProfitable"])
                except:
                    raise TypeError(f"Property isProfitable must be of type bool, got {type(props['isProfitable']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="CO_PRODUCED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def animated(uuid=None, **props):
        """
        Find relationships of type ANIMATED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check totalFrames (expected int)
        if "totalFrames" in props and props["totalFrames"] is not None:
            if not isinstance(props["totalFrames"], int):
                try:
                    # Attempt to convert
                    props["totalFrames"] = int(props["totalFrames"])
                except:
                    raise TypeError(f"Property totalFrames must be of type int, got {type(props['totalFrames']).__name__}")
    
        # Type check startDate (expected object)
        if "startDate" in props and props["startDate"] is not None:
            if not isinstance(props["startDate"], object):
                try:
                    # Attempt to convert
                    props["startDate"] = object(props["startDate"])
                except:
                    raise TypeError(f"Property startDate must be of type object, got {type(props['startDate']).__name__}")
    
        # Type check endDate (expected object)
        if "endDate" in props and props["endDate"] is not None:
            if not isinstance(props["endDate"], object):
                try:
                    # Attempt to convert
                    props["endDate"] = object(props["endDate"])
                except:
                    raise TypeError(f"Property endDate must be of type object, got {type(props['endDate']).__name__}")
    
        # Type check renderingHours (expected int)
        if "renderingHours" in props and props["renderingHours"] is not None:
            if not isinstance(props["renderingHours"], int):
                try:
                    # Attempt to convert
                    props["renderingHours"] = int(props["renderingHours"])
                except:
                    raise TypeError(f"Property renderingHours must be of type int, got {type(props['renderingHours']).__name__}")
    
        # Type check teamSize (expected int)
        if "teamSize" in props and props["teamSize"] is not None:
            if not isinstance(props["teamSize"], int):
                try:
                    # Attempt to convert
                    props["teamSize"] = int(props["teamSize"])
                except:
                    raise TypeError(f"Property teamSize must be of type int, got {type(props['teamSize']).__name__}")
    
        # Type check technicalInnovations (expected object)
        if "technicalInnovations" in props and props["technicalInnovations"] is not None:
            if not isinstance(props["technicalInnovations"], object):
                try:
                    # Attempt to convert
                    props["technicalInnovations"] = object(props["technicalInnovations"])
                except:
                    raise TypeError(f"Property technicalInnovations must be of type object, got {type(props['technicalInnovations']).__name__}")
    
        # Type check softwareUsed (expected object)
        if "softwareUsed" in props and props["softwareUsed"] is not None:
            if not isinstance(props["softwareUsed"], object):
                try:
                    # Attempt to convert
                    props["softwareUsed"] = object(props["softwareUsed"])
                except:
                    raise TypeError(f"Property softwareUsed must be of type object, got {type(props['softwareUsed']).__name__}")
    
        # Type check leadAnimators (expected int)
        if "leadAnimators" in props and props["leadAnimators"] is not None:
            if not isinstance(props["leadAnimators"], int):
                try:
                    # Attempt to convert
                    props["leadAnimators"] = int(props["leadAnimators"])
                except:
                    raise TypeError(f"Property leadAnimators must be of type int, got {type(props['leadAnimators']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="ANIMATED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def co_directed(uuid=None, **props):
        """
        Find relationships of type CO_DIRECTED matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check satisfaction (expected float)
        if "satisfaction" in props and props["satisfaction"] is not None:
            if not isinstance(props["satisfaction"], float):
                try:
                    # Attempt to convert
                    props["satisfaction"] = float(props["satisfaction"])
                except:
                    raise TypeError(f"Property satisfaction must be of type float, got {type(props['satisfaction']).__name__}")
    
        # Type check awardWins (expected int)
        if "awardWins" in props and props["awardWins"] is not None:
            if not isinstance(props["awardWins"], int):
                try:
                    # Attempt to convert
                    props["awardWins"] = int(props["awardWins"])
                except:
                    raise TypeError(f"Property awardWins must be of type int, got {type(props['awardWins']).__name__}")
    
        # Type check premiereEvent (expected object)
        if "premiereEvent" in props and props["premiereEvent"] is not None:
            if not isinstance(props["premiereEvent"], object):
                try:
                    # Attempt to convert
                    props["premiereEvent"] = object(props["premiereEvent"])
                except:
                    raise TypeError(f"Property premiereEvent must be of type object, got {type(props['premiereEvent']).__name__}")
    
        # Type check completionDate (expected object)
        if "completionDate" in props and props["completionDate"] is not None:
            if not isinstance(props["completionDate"], object):
                try:
                    # Attempt to convert
                    props["completionDate"] = object(props["completionDate"])
                except:
                    raise TypeError(f"Property completionDate must be of type object, got {type(props['completionDate']).__name__}")
    
        # Type check daysOnProject (expected int)
        if "daysOnProject" in props and props["daysOnProject"] is not None:
            if not isinstance(props["daysOnProject"], int):
                try:
                    # Attempt to convert
                    props["daysOnProject"] = int(props["daysOnProject"])
                except:
                    raise TypeError(f"Property daysOnProject must be of type int, got {type(props['daysOnProject']).__name__}")
    
        # Type check durationMonths (expected int)
        if "durationMonths" in props and props["durationMonths"] is not None:
            if not isinstance(props["durationMonths"], int):
                try:
                    # Attempt to convert
                    props["durationMonths"] = int(props["durationMonths"])
                except:
                    raise TypeError(f"Property durationMonths must be of type int, got {type(props['durationMonths']).__name__}")
    
        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Type check awardNominations (expected int)
        if "awardNominations" in props and props["awardNominations"] is not None:
            if not isinstance(props["awardNominations"], int):
                try:
                    # Attempt to convert
                    props["awardNominations"] = int(props["awardNominations"])
                except:
                    raise TypeError(f"Property awardNominations must be of type int, got {type(props['awardNominations']).__name__}")
    
        # Type check responsibility (expected str)
        if "responsibility" in props and props["responsibility"] is not None:
            if not isinstance(props["responsibility"], str):
                try:
                    # Attempt to convert
                    props["responsibility"] = str(props["responsibility"])
                except:
                    raise TypeError(f"Property responsibility must be of type str, got {type(props['responsibility']).__name__}")
    
        # Type check isFirstDirectingRole (expected bool)
        if "isFirstDirectingRole" in props and props["isFirstDirectingRole"] is not None:
            if not isinstance(props["isFirstDirectingRole"], bool):
                try:
                    # Attempt to convert
                    props["isFirstDirectingRole"] = bool(props["isFirstDirectingRole"])
                except:
                    raise TypeError(f"Property isFirstDirectingRole must be of type bool, got {type(props['isFirstDirectingRole']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="CO_DIRECTED", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def composed_music_for(uuid=None, **props):
        """
        Find relationships of type COMPOSED_MUSIC_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check completionDate (expected object)
        if "completionDate" in props and props["completionDate"] is not None:
            if not isinstance(props["completionDate"], object):
                try:
                    # Attempt to convert
                    props["completionDate"] = object(props["completionDate"])
                except:
                    raise TypeError(f"Property completionDate must be of type object, got {type(props['completionDate']).__name__}")
    
        # Type check instrumentsUsed (expected int)
        if "instrumentsUsed" in props and props["instrumentsUsed"] is not None:
            if not isinstance(props["instrumentsUsed"], int):
                try:
                    # Attempt to convert
                    props["instrumentsUsed"] = int(props["instrumentsUsed"])
                except:
                    raise TypeError(f"Property instrumentsUsed must be of type int, got {type(props['instrumentsUsed']).__name__}")
    
        # Type check year (expected int)
        if "year" in props and props["year"] is not None:
            if not isinstance(props["year"], int):
                try:
                    # Attempt to convert
                    props["year"] = int(props["year"])
                except:
                    raise TypeError(f"Property year must be of type int, got {type(props['year']).__name__}")
    
        # Type check tracksComposed (expected int)
        if "tracksComposed" in props and props["tracksComposed"] is not None:
            if not isinstance(props["tracksComposed"], int):
                try:
                    # Attempt to convert
                    props["tracksComposed"] = int(props["tracksComposed"])
                except:
                    raise TypeError(f"Property tracksComposed must be of type int, got {type(props['tracksComposed']).__name__}")
    
        # Type check recording_studios (expected int)
        if "recording_studios" in props and props["recording_studios"] is not None:
            if not isinstance(props["recording_studios"], int):
                try:
                    # Attempt to convert
                    props["recording_studios"] = int(props["recording_studios"])
                except:
                    raise TypeError(f"Property recording_studios must be of type int, got {type(props['recording_studios']).__name__}")
    
        # Type check collaboratingArtists (expected int)
        if "collaboratingArtists" in props and props["collaboratingArtists"] is not None:
            if not isinstance(props["collaboratingArtists"], int):
                try:
                    # Attempt to convert
                    props["collaboratingArtists"] = int(props["collaboratingArtists"])
                except:
                    raise TypeError(f"Property collaboratingArtists must be of type int, got {type(props['collaboratingArtists']).__name__}")
    
        # Type check electronicallyProduced (expected bool)
        if "electronicallyProduced" in props and props["electronicallyProduced"] is not None:
            if not isinstance(props["electronicallyProduced"], bool):
                try:
                    # Attempt to convert
                    props["electronicallyProduced"] = bool(props["electronicallyProduced"])
                except:
                    raise TypeError(f"Property electronicallyProduced must be of type bool, got {type(props['electronicallyProduced']).__name__}")
    
        # Type check signature_themes (expected object)
        if "signature_themes" in props and props["signature_themes"] is not None:
            if not isinstance(props["signature_themes"], object):
                try:
                    # Attempt to convert
                    props["signature_themes"] = object(props["signature_themes"])
                except:
                    raise TypeError(f"Property signature_themes must be of type object, got {type(props['signature_themes']).__name__}")
    
        # Type check startDate (expected object)
        if "startDate" in props and props["startDate"] is not None:
            if not isinstance(props["startDate"], object):
                try:
                    # Attempt to convert
                    props["startDate"] = object(props["startDate"])
                except:
                    raise TypeError(f"Property startDate must be of type object, got {type(props['startDate']).__name__}")
    
        # Type check recordingDays (expected int)
        if "recordingDays" in props and props["recordingDays"] is not None:
            if not isinstance(props["recordingDays"], int):
                try:
                    # Attempt to convert
                    props["recordingDays"] = int(props["recordingDays"])
                except:
                    raise TypeError(f"Property recordingDays must be of type int, got {type(props['recordingDays']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="COMPOSED_MUSIC_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def laboratory_services_for(uuid=None, **props):
        """
        Find relationships of type LABORATORY_SERVICES_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check processing_schedule (expected str)
        if "processing_schedule" in props and props["processing_schedule"] is not None:
            if not isinstance(props["processing_schedule"], str):
                try:
                    # Attempt to convert
                    props["processing_schedule"] = str(props["processing_schedule"])
                except:
                    raise TypeError(f"Property processing_schedule must be of type str, got {type(props['processing_schedule']).__name__}")
    
        # Type check release_print_order (expected int)
        if "release_print_order" in props and props["release_print_order"] is not None:
            if not isinstance(props["release_print_order"], int):
                try:
                    # Attempt to convert
                    props["release_print_order"] = int(props["release_print_order"])
                except:
                    raise TypeError(f"Property release_print_order must be of type int, got {type(props['release_print_order']).__name__}")
    
        # Type check print_runs (expected str)
        if "print_runs" in props and props["print_runs"] is not None:
            if not isinstance(props["print_runs"], str):
                try:
                    # Attempt to convert
                    props["print_runs"] = str(props["print_runs"])
                except:
                    raise TypeError(f"Property print_runs must be of type str, got {type(props['print_runs']).__name__}")
    
        # Type check services_contracted (expected object)
        if "services_contracted" in props and props["services_contracted"] is not None:
            if not isinstance(props["services_contracted"], object):
                try:
                    # Attempt to convert
                    props["services_contracted"] = object(props["services_contracted"])
                except:
                    raise TypeError(f"Property services_contracted must be of type object, got {type(props['services_contracted']).__name__}")
    
        # Type check negative_developing_process (expected str)
        if "negative_developing_process" in props and props["negative_developing_process"] is not None:
            if not isinstance(props["negative_developing_process"], str):
                try:
                    # Attempt to convert
                    props["negative_developing_process"] = str(props["negative_developing_process"])
                except:
                    raise TypeError(f"Property negative_developing_process must be of type str, got {type(props['negative_developing_process']).__name__}")
    
        # Type check special_processing_instructions (expected str)
        if "special_processing_instructions" in props and props["special_processing_instructions"] is not None:
            if not isinstance(props["special_processing_instructions"], str):
                try:
                    # Attempt to convert
                    props["special_processing_instructions"] = str(props["special_processing_instructions"])
                except:
                    raise TypeError(f"Property special_processing_instructions must be of type str, got {type(props['special_processing_instructions']).__name__}")
    
        # Type check amber_tone_development (expected str)
        if "amber_tone_development" in props and props["amber_tone_development"] is not None:
            if not isinstance(props["amber_tone_development"], str):
                try:
                    # Attempt to convert
                    props["amber_tone_development"] = str(props["amber_tone_development"])
                except:
                    raise TypeError(f"Property amber_tone_development must be of type str, got {type(props['amber_tone_development']).__name__}")
    
        # Type check technical_challenges (expected str)
        if "technical_challenges" in props and props["technical_challenges"] is not None:
            if not isinstance(props["technical_challenges"], str):
                try:
                    # Attempt to convert
                    props["technical_challenges"] = str(props["technical_challenges"])
                except:
                    raise TypeError(f"Property technical_challenges must be of type str, got {type(props['technical_challenges']).__name__}")
    
        # Type check process_innovations (expected str)
        if "process_innovations" in props and props["process_innovations"] is not None:
            if not isinstance(props["process_innovations"], str):
                try:
                    # Attempt to convert
                    props["process_innovations"] = str(props["process_innovations"])
                except:
                    raise TypeError(f"Property process_innovations must be of type str, got {type(props['process_innovations']).__name__}")
    
        # Type check technical_documentation (expected str)
        if "technical_documentation" in props and props["technical_documentation"] is not None:
            if not isinstance(props["technical_documentation"], str):
                try:
                    # Attempt to convert
                    props["technical_documentation"] = str(props["technical_documentation"])
                except:
                    raise TypeError(f"Property technical_documentation must be of type str, got {type(props['technical_documentation']).__name__}")
    
        # Type check archival_elements_created (expected str)
        if "archival_elements_created" in props and props["archival_elements_created"] is not None:
            if not isinstance(props["archival_elements_created"], str):
                try:
                    # Attempt to convert
                    props["archival_elements_created"] = str(props["archival_elements_created"])
                except:
                    raise TypeError(f"Property archival_elements_created must be of type str, got {type(props['archival_elements_created']).__name__}")
    
        # Type check print_specification (expected str)
        if "print_specification" in props and props["print_specification"] is not None:
            if not isinstance(props["print_specification"], str):
                try:
                    # Attempt to convert
                    props["print_specification"] = str(props["print_specification"])
                except:
                    raise TypeError(f"Property print_specification must be of type str, got {type(props['print_specification']).__name__}")
    
        # Type check dailies_turnaround (expected str)
        if "dailies_turnaround" in props and props["dailies_turnaround"] is not None:
            if not isinstance(props["dailies_turnaround"], str):
                try:
                    # Attempt to convert
                    props["dailies_turnaround"] = str(props["dailies_turnaround"])
                except:
                    raise TypeError(f"Property dailies_turnaround must be of type str, got {type(props['dailies_turnaround']).__name__}")
    
        # Type check lab-studio_relationship (expected str)
        if "lab-studio_relationship" in props and props["lab-studio_relationship"] is not None:
            if not isinstance(props["lab-studio_relationship"], str):
                try:
                    # Attempt to convert
                    props["lab-studio_relationship"] = str(props["lab-studio_relationship"])
                except:
                    raise TypeError(f"Property lab-studio_relationship must be of type str, got {type(props['lab-studio_relationship']).__name__}")
    
        # Type check print_quality_control (expected str)
        if "print_quality_control" in props and props["print_quality_control"] is not None:
            if not isinstance(props["print_quality_control"], str):
                try:
                    # Attempt to convert
                    props["print_quality_control"] = str(props["print_quality_control"])
                except:
                    raise TypeError(f"Property print_quality_control must be of type str, got {type(props['print_quality_control']).__name__}")
    
        # Type check lab_contact (expected str)
        if "lab_contact" in props and props["lab_contact"] is not None:
            if not isinstance(props["lab_contact"], str):
                try:
                    # Attempt to convert
                    props["lab_contact"] = str(props["lab_contact"])
                except:
                    raise TypeError(f"Property lab_contact must be of type str, got {type(props['lab_contact']).__name__}")
    
        # Type check quality_control_process (expected str)
        if "quality_control_process" in props and props["quality_control_process"] is not None:
            if not isinstance(props["quality_control_process"], str):
                try:
                    # Attempt to convert
                    props["quality_control_process"] = str(props["quality_control_process"])
                except:
                    raise TypeError(f"Property quality_control_process must be of type str, got {type(props['quality_control_process']).__name__}")
    
        # Type check confidentiality_protocols (expected str)
        if "confidentiality_protocols" in props and props["confidentiality_protocols"] is not None:
            if not isinstance(props["confidentiality_protocols"], str):
                try:
                    # Attempt to convert
                    props["confidentiality_protocols"] = str(props["confidentiality_protocols"])
                except:
                    raise TypeError(f"Property confidentiality_protocols must be of type str, got {type(props['confidentiality_protocols']).__name__}")
    
        # Type check color_timing_approach (expected str)
        if "color_timing_approach" in props and props["color_timing_approach"] is not None:
            if not isinstance(props["color_timing_approach"], str):
                try:
                    # Attempt to convert
                    props["color_timing_approach"] = str(props["color_timing_approach"])
                except:
                    raise TypeError(f"Property color_timing_approach must be of type str, got {type(props['color_timing_approach']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="LABORATORY_SERVICES_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]


    def financial_services_for(uuid=None, **props):
        """
        Find relationships of type FINANCIAL_SERVICES_FOR matching the given properties.
        
        Parameters
        ----------
        uuid: str, optional
            The UUID of the relationship to find
        **props: Dict
            Additional properties to search for
            
        Returns
        -------
        List[Tuple[Dict, Dict, Dict]]:
            A list of tuples containing (source_node, relationship, target_node)
        """
        search_props = props.copy()
        if uuid is not None:
            search_props['uuid'] = uuid
            
        # Type checking for known properties

        # Type check daily_cost_reporting (expected str)
        if "daily_cost_reporting" in props and props["daily_cost_reporting"] is not None:
            if not isinstance(props["daily_cost_reporting"], str):
                try:
                    # Attempt to convert
                    props["daily_cost_reporting"] = str(props["daily_cost_reporting"])
                except:
                    raise TypeError(f"Property daily_cost_reporting must be of type str, got {type(props['daily_cost_reporting']).__name__}")
    
        # Type check accounting_team_structure (expected str)
        if "accounting_team_structure" in props and props["accounting_team_structure"] is not None:
            if not isinstance(props["accounting_team_structure"], str):
                try:
                    # Attempt to convert
                    props["accounting_team_structure"] = str(props["accounting_team_structure"])
                except:
                    raise TypeError(f"Property accounting_team_structure must be of type str, got {type(props['accounting_team_structure']).__name__}")
    
        # Type check cash_flow_management (expected str)
        if "cash_flow_management" in props and props["cash_flow_management"] is not None:
            if not isinstance(props["cash_flow_management"], str):
                try:
                    # Attempt to convert
                    props["cash_flow_management"] = str(props["cash_flow_management"])
                except:
                    raise TypeError(f"Property cash_flow_management must be of type str, got {type(props['cash_flow_management']).__name__}")
    
        # Type check purchase_order_system (expected str)
        if "purchase_order_system" in props and props["purchase_order_system"] is not None:
            if not isinstance(props["purchase_order_system"], str):
                try:
                    # Attempt to convert
                    props["purchase_order_system"] = str(props["purchase_order_system"])
                except:
                    raise TypeError(f"Property purchase_order_system must be of type str, got {type(props['purchase_order_system']).__name__}")
    
        # Type check vendor_payment_terms (expected str)
        if "vendor_payment_terms" in props and props["vendor_payment_terms"] is not None:
            if not isinstance(props["vendor_payment_terms"], str):
                try:
                    # Attempt to convert
                    props["vendor_payment_terms"] = str(props["vendor_payment_terms"])
                except:
                    raise TypeError(f"Property vendor_payment_terms must be of type str, got {type(props['vendor_payment_terms']).__name__}")
    
        # Type check petty_cash_controls (expected str)
        if "petty_cash_controls" in props and props["petty_cash_controls"] is not None:
            if not isinstance(props["petty_cash_controls"], str):
                try:
                    # Attempt to convert
                    props["petty_cash_controls"] = str(props["petty_cash_controls"])
                except:
                    raise TypeError(f"Property petty_cash_controls must be of type str, got {type(props['petty_cash_controls']).__name__}")
    
        # Type check financial_controls_implementation (expected str)
        if "financial_controls_implementation" in props and props["financial_controls_implementation"] is not None:
            if not isinstance(props["financial_controls_implementation"], str):
                try:
                    # Attempt to convert
                    props["financial_controls_implementation"] = str(props["financial_controls_implementation"])
                except:
                    raise TypeError(f"Property financial_controls_implementation must be of type str, got {type(props['financial_controls_implementation']).__name__}")
    
        # Type check payroll_processing (expected str)
        if "payroll_processing" in props and props["payroll_processing"] is not None:
            if not isinstance(props["payroll_processing"], str):
                try:
                    # Attempt to convert
                    props["payroll_processing"] = str(props["payroll_processing"])
                except:
                    raise TypeError(f"Property payroll_processing must be of type str, got {type(props['payroll_processing']).__name__}")
    
        # Type check audit_trails_maintenance (expected str)
        if "audit_trails_maintenance" in props and props["audit_trails_maintenance"] is not None:
            if not isinstance(props["audit_trails_maintenance"], str):
                try:
                    # Attempt to convert
                    props["audit_trails_maintenance"] = str(props["audit_trails_maintenance"])
                except:
                    raise TypeError(f"Property audit_trails_maintenance must be of type str, got {type(props['audit_trails_maintenance']).__name__}")
    
        # Type check profit_participation_accounting (expected str)
        if "profit_participation_accounting" in props and props["profit_participation_accounting"] is not None:
            if not isinstance(props["profit_participation_accounting"], str):
                try:
                    # Attempt to convert
                    props["profit_participation_accounting"] = str(props["profit_participation_accounting"])
                except:
                    raise TypeError(f"Property profit_participation_accounting must be of type str, got {type(props['profit_participation_accounting']).__name__}")
    
        # Type check monthly_financial_review (expected str)
        if "monthly_financial_review" in props and props["monthly_financial_review"] is not None:
            if not isinstance(props["monthly_financial_review"], str):
                try:
                    # Attempt to convert
                    props["monthly_financial_review"] = str(props["monthly_financial_review"])
                except:
                    raise TypeError(f"Property monthly_financial_review must be of type str, got {type(props['monthly_financial_review']).__name__}")
    
        # Type check completion_bond_reporting (expected str)
        if "completion_bond_reporting" in props and props["completion_bond_reporting"] is not None:
            if not isinstance(props["completion_bond_reporting"], str):
                try:
                    # Attempt to convert
                    props["completion_bond_reporting"] = str(props["completion_bond_reporting"])
                except:
                    raise TypeError(f"Property completion_bond_reporting must be of type str, got {type(props['completion_bond_reporting']).__name__}")
    
        # Type check cost_containment_measures (expected str)
        if "cost_containment_measures" in props and props["cost_containment_measures"] is not None:
            if not isinstance(props["cost_containment_measures"], str):
                try:
                    # Attempt to convert
                    props["cost_containment_measures"] = str(props["cost_containment_measures"])
                except:
                    raise TypeError(f"Property cost_containment_measures must be of type str, got {type(props['cost_containment_measures']).__name__}")
    
        # Type check final_cost_reporting (expected str)
        if "final_cost_reporting" in props and props["final_cost_reporting"] is not None:
            if not isinstance(props["final_cost_reporting"], str):
                try:
                    # Attempt to convert
                    props["final_cost_reporting"] = str(props["final_cost_reporting"])
                except:
                    raise TypeError(f"Property final_cost_reporting must be of type str, got {type(props['final_cost_reporting']).__name__}")
    
        # Type check weekly_financial_meetings (expected str)
        if "weekly_financial_meetings" in props and props["weekly_financial_meetings"] is not None:
            if not isinstance(props["weekly_financial_meetings"], str):
                try:
                    # Attempt to convert
                    props["weekly_financial_meetings"] = str(props["weekly_financial_meetings"])
                except:
                    raise TypeError(f"Property weekly_financial_meetings must be of type str, got {type(props['weekly_financial_meetings']).__name__}")
    
        # Type check production_accountant (expected str)
        if "production_accountant" in props and props["production_accountant"] is not None:
            if not isinstance(props["production_accountant"], str):
                try:
                    # Attempt to convert
                    props["production_accountant"] = str(props["production_accountant"])
                except:
                    raise TypeError(f"Property production_accountant must be of type str, got {type(props['production_accountant']).__name__}")
    
        # Type check banking_structure (expected str)
        if "banking_structure" in props and props["banking_structure"] is not None:
            if not isinstance(props["banking_structure"], str):
                try:
                    # Attempt to convert
                    props["banking_structure"] = str(props["banking_structure"])
                except:
                    raise TypeError(f"Property banking_structure must be of type str, got {type(props['banking_structure']).__name__}")
    
        # Type check chart_of_accounts_customization (expected str)
        if "chart_of_accounts_customization" in props and props["chart_of_accounts_customization"] is not None:
            if not isinstance(props["chart_of_accounts_customization"], str):
                try:
                    # Attempt to convert
                    props["chart_of_accounts_customization"] = str(props["chart_of_accounts_customization"])
                except:
                    raise TypeError(f"Property chart_of_accounts_customization must be of type str, got {type(props['chart_of_accounts_customization']).__name__}")
    
        # Type check accounting_system_implementation (expected str)
        if "accounting_system_implementation" in props and props["accounting_system_implementation"] is not None:
            if not isinstance(props["accounting_system_implementation"], str):
                try:
                    # Attempt to convert
                    props["accounting_system_implementation"] = str(props["accounting_system_implementation"])
                except:
                    raise TypeError(f"Property accounting_system_implementation must be of type str, got {type(props['accounting_system_implementation']).__name__}")
    
        # Type check tax_withholding_management (expected str)
        if "tax_withholding_management" in props and props["tax_withholding_management"] is not None:
            if not isinstance(props["tax_withholding_management"], str):
                try:
                    # Attempt to convert
                    props["tax_withholding_management"] = str(props["tax_withholding_management"])
                except:
                    raise TypeError(f"Property tax_withholding_management must be of type str, got {type(props['tax_withholding_management']).__name__}")
    
        # Construct and execute the query
        query, params = Queries.edge(type="FINANCIAL_SERVICES_FOR", **search_props)
        results = _query(query, params)
        return [(_neo4j_node_to_dict(r['source']), 
                 _neo4j_relationship_to_dict(r['r']), 
                 _neo4j_node_to_dict(r['target'])) for r in results]



# Create the interface instances
nodes = Nodes()
edges = Edges()

def connect():
    """
    Create a new authenticated driver connection to the Neo4j database.
    
    Returns
    -------
    neo4j.Driver:
        A connected Neo4j driver instance
    """
    return _authenticated_driver(NEO4J_URI, NEO4J_USERNAME, NEO4J_PASSWORD)

def execute_query(query, params=None):
    """
    Execute a raw Cypher query against the Neo4j database.
    
    Parameters
    ----------
    query: str
        The Cypher query to execute
    params: Dict, optional
        Parameters for the query
        
    Returns
    -------
    List[Dict]:
        Results from the query
    """
    return _query(query, params)

def server_timestamp():
    """
    Get the current timestamp from the Neo4j server.
    
    Returns
    -------
    str:
        ISO-formatted timestamp
    """
    return _server_timestamp()

