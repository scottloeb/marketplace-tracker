"""
Coastal Explorer - Shallow Water Graph Navigation and Exploration

This application implements the "Anchor" and "Navigator" patterns for graph exploration:
- "Anchor": Schema-based entry points (starting from what you know about the data structure)
- "Navigator": Node-to-node navigation (exploring connections by navigating between nodes)

The application is designed to be simple, easy to learn, and focused on functionality.
It serves as a practical implementation of concepts from the module generator.

Dependencies:
- Flask
- A middleware module generated by the module generator (imported as 'graph_middleware')

Author: H.A.R.B.O.R. Project Team
Version: 1.0
"""

import os
import csv
import json
import time
import datetime
import functools
from urllib.parse import quote, unquote
from flask import Flask, request, render_template_string, redirect, url_for, session, flash, Response, g

# Import the middleware generated by the module generator
# This middleware provides a Python interface to your Neo4j database
# Note: You'll need to replace 'graph_middleware' with the actual name of your generated module
try:
    import newgraph as gm
except ImportError:
    print("ERROR: Could not import graph middleware. Make sure you've generated it using the module generator.")
    print("Example: python modulegenerator-claude.py -u 'bolt://localhost:7687' -n 'neo4j' -p 'password' -g 'graph_middleware'")
    raise

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

# Application configuration
# These values can be modified to suit your specific environment
config = {
    # Basic application settings
    'app_name': 'G.A.R.D.E.N. Explorer',
    'app_version': '1.0',
    'debug_mode': True,  # Set to False in production!
    
    # Session settings
    'session_secret_key': os.environ.get('SECRET_KEY', os.urandom(24).hex()),
    'session_lifetime': 60 * 60,  # 1 hour in seconds
    
    # Logging configuration
    'enable_logging': True,
    'log_format': 'text',  # Options: 'text', 'csv', 'json'
    'log_fields': [
        'timestamp',
        'username',
        'ip_address',
        'method',
        'endpoint',
        'node_id',
        'node_label'
    ],
    'log_file': 'garden_activity.log',
    
    # Authentication settings
    'login_attempts_limit': 5,
    'lockout_time': 15 * 60,  # 15 minutes in seconds
    
    # Display settings
    'items_per_page': 20,
    'max_properties_shown': 10,
    'truncate_property_length': 100,
    
    # User accounts - REPLACE THIS WITH A PROPER DATABASE IN PRODUCTION
    # This is just for demonstration and easy setup
    'users': {
        'demo': {
            'password': 'demo123',  # NEVER store plaintext passwords in production!
            'full_name': 'Demo User',
            'department': 'Training',
            'failed_attempts': 0,
            'locked_until': None
        },
        'admin': {
            'password': 'admin123',  # NEVER store plaintext passwords in production!
            'full_name': 'Administrator',
            'department': 'IT',
            'failed_attempts': 0,
            'locked_until': None
        }
    }
}

# -----------------------------------------------------------------------------
# Flask Application Setup
# -----------------------------------------------------------------------------

app = Flask(__name__)
app.secret_key = config['session_secret_key']
app.config['PERMANENT_SESSION_LIFETIME'] = config['session_lifetime']
app.config['TEMPLATES_AUTO_RELOAD'] = config['debug_mode']

# -----------------------------------------------------------------------------
# Logging Functionality
# -----------------------------------------------------------------------------

def log_activity(activity_type, node_id=None, node_label=None, additional_data=None):
    """
    Log user activity to a file based on configured format.
    
    This function writes log entries according to the format specified in the config:
    - text: Simple line-based log with pipe separators
    - csv: CSV formatted log (easier to import into spreadsheets)
    - json: JSON formatted log (easier to parse programmatically)
    
    Args:
        activity_type (str): The type of activity (e.g., 'view_node', 'list_nodes')
        node_id (str, optional): The ID of the node being accessed
        node_label (str, optional): The label of the node being accessed
        additional_data (dict, optional): Any additional data to log
    
    Returns:
        bool: True if logging succeeded, False otherwise
    """
    if not config['enable_logging']:
        return True
    
    # Prepare log data dictionary with all possible fields
    log_data = {
        'timestamp': datetime.datetime.now().isoformat(),
        'username': session.get('username', 'anonymous'),
        'ip_address': request.remote_addr,
        'method': request.method,
        'endpoint': request.path,
        'activity_type': activity_type,
        'node_id': node_id or '',
        'node_label': node_label or '',
        'user_agent': request.user_agent.string,
        'referer': request.referrer or ''
    }
    
    # Add any additional data
    if additional_data:
        log_data.update(additional_data)
    
    # Filter to only include configured fields
    filtered_data = {k: v for k, v in log_data.items() if k in config['log_fields']}
    
    try:
        log_format = config['log_format'].lower()
        
        with open(config['log_file'], 'a', encoding='utf-8') as f:
            if log_format == 'json':
                # JSON format (one object per line)
                f.write(json.dumps(filtered_data) + '\n')
                
            elif log_format == 'csv':
                # CSV format
                writer = csv.DictWriter(f, fieldnames=config['log_fields'])
                # Write header if file is empty
                if f.tell() == 0:
                    writer.writeheader()
                writer.writerow(filtered_data)
                
            else:
                # Default text format
                values = [str(filtered_data.get(field, '')) for field in config['log_fields']]
                f.write('|'.join(values) + '\n')
                
        return True
    except Exception as e:
        # In a production environment, you might want to log this error elsewhere
        print(f"Logging error: {e}")
        return False

# -----------------------------------------------------------------------------
# Authentication & Authorization
# -----------------------------------------------------------------------------

def login_required(f):
    """
    Decorator to require login for specific routes.
    
    This decorator checks if the user is logged in before allowing access to a route.
    If not logged in, the user is redirected to the login page.
    
    Args:
        f (function): The route function to decorate
        
    Returns:
        function: The decorated function
    """
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        if 'username' not in session:
            # Log the unauthorized access attempt
            log_activity('unauthorized_access')
            # Store the original URL for redirect after login
            session['next_url'] = request.url
            flash('Please log in to access this page.', 'warning')
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['GET', 'POST'])
def login():
    """
    Handle user login.
    
    GET: Display the login form
    POST: Process the login form submission
    
    Returns:
        Response: Rendered login page or redirect to destination
    """
    error = None
    
    if request.method == 'POST':
        username = request.form.get('username', '')
        password = request.form.get('password', '')
        
        # Check if user exists
        if username in config['users']:
            user = config['users'][username]
            
            # Check if account is locked
            if user['locked_until'] and user['locked_until'] > time.time():
                remaining_time = int((user['locked_until'] - time.time()) / 60)
                error = f"This account is temporarily locked. Please try again in {remaining_time} minutes."
                log_activity('login_failed', additional_data={'reason': 'account_locked'})
            
            # Verify password (in production, use proper password hashing!)
            elif user['password'] == password:
                # Reset failed attempts on successful login
                user['failed_attempts'] = 0
                user['locked_until'] = None
                
                # Create session
                session['username'] = username
                session['full_name'] = user['full_name']
                session['department'] = user['department']
                session.permanent = True
                
                # Log successful login
                log_activity('login_successful')
                
                # Redirect to the original URL or dashboard
                next_url = session.pop('next_url', url_for('index'))
                return redirect(next_url)
            else:
                # Increment failed attempts
                user['failed_attempts'] += 1
                
                # Lock account if too many failed attempts
                if user['failed_attempts'] >= config['login_attempts_limit']:
                    user['locked_until'] = time.time() + config['lockout_time']
                    error = f"Too many failed login attempts. Account locked for {config['lockout_time'] // 60} minutes."
                    log_activity('account_locked')
                else:
                    error = "Invalid username or password."
                    log_activity('login_failed', additional_data={'reason': 'invalid_credentials'})
        else:
            # User doesn't exist, but don't reveal this information
            error = "Invalid username or password."
            log_activity('login_failed', additional_data={'reason': 'user_not_found'})
    
    # Render the login template
    return render_template_string("""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Login - {{ config.app_name }}</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }
                .container { max-width: 400px; margin: 40px auto; padding: 20px; background-color: white; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
                .form-group { margin-bottom: 15px; }
                label { display: block; margin-bottom: 5px; font-weight: bold; }
                input[type="text"], input[type="password"] { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ddd; border-radius: 4px; }
                button { background-color: #4CAF50; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; }
                .error { color: #f44336; margin-bottom: 15px; }
                .flash { padding: 10px; margin-bottom: 15px; border-radius: 4px; }
                .flash.error, .flash.danger { background-color: #FFEBEE; color: #B71C1C; }
                .flash.success { background-color: #E8F5E9; color: #1B5E20; }
                .flash.warning { background-color: #FFF8E1; color: #F57F17; }
                .flash.info { background-color: #E3F2FD; color: #0D47A1; }
                .header { text-align: center; margin-bottom: 20px; }
                .app-title { font-size: 24px; margin-bottom: 5px; color: #2E7D32; }
                .app-subtitle { font-size: 14px; color: #555; }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <div class="app-title">{{ config.app_name }}</div>
                    <div class="app-subtitle">Explore your data with ease</div>
                </div>
                
                {% if error %}
                <div class="error">{{ error }}</div>
                {% endif %}
                
                {% with messages = get_flashed_messages(with_categories=true) %}
                  {% if messages %}
                    {% for category, message in messages %}
                      <div class="flash {{ category }}">{{ message }}</div>
                    {% endfor %}
                  {% endif %}
                {% endwith %}
                
                <form method="post">
                    <div class="form-group">
                        <label for="username">Username:</label>
                        <input type="text" id="username" name="username" required autofocus>
                    </div>
                    <div class="form-group">
                        <label for="password">Password:</label>
                        <input type="password" id="password" name="password" required>
                    </div>
                    <button type="submit">Login</button>
                </form>
                
                <p style="margin-top: 20px; font-size: 12px; color: #777; text-align: center;">
                    Demo credentials: username "demo", password "demo123"
                </p>
            </div>
        </body>
        </html>
    """, error=error, config=config)

@app.route('/logout')
def logout():
    """
    Handle user logout.
    
    Removes the user from the session and redirects to the login page.
    
    Returns:
        Response: Redirect to login page
    """
    # Log the logout
    if 'username' in session:
        log_activity('logout')
    
    # Clear the session
    session.clear()
    
    flash('You have been logged out.', 'info')
    return redirect(url_for('login'))

# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

def get_node_by_id(node_id, label=None):
    """
    Retrieve a node by its ID, optionally with a specific label.
    
    This function demonstrates how to use the middleware to fetch node data.
    It handles the different ways nodes might be identified based on the database schema.
    
    Args:
        node_id (str): The ID of the node to retrieve
        label (str, optional): The label of the node, if known
    
    Returns:
        dict: The node data if found, None otherwise
    """
    try:
        # If we know the label, we can use the specific node retrieval function
        if label:
            # Convert label to function name (lowercase, replace special chars)
            func_name = label.lower().replace(':', '_').replace('-', '_')
            
            # Get the corresponding function from the nodes interface
            node_func = getattr(gm.nodes, func_name, None)
            
            if node_func:
                # Call the function with the UUID parameter
                results = node_func(uuid=node_id)
                return results[0] if results else None
        
        # If we don't know the label or the specific function doesn't exist,
        # we need to try a more generic approach
        
        # Option 1: If the middleware provides a generic find_node function
        if hasattr(gm, 'find_node'):
            return gm.find_node(node_id)
        
        # Option 2: Try each node type until we find a match
        for label_name in gm.METADATA['node_labels']:
            func_name = label_name.lower().replace(':', '_').replace('-', '_')
            node_func = getattr(gm.nodes, func_name, None)
            
            if node_func:
                results = node_func(uuid=node_id)
                if results:
                    return results[0]
        
        # Node not found with any available method
        return None
    
    except Exception as e:
        print(f"Error retrieving node: {e}")
        return None

def format_property_value(value, max_length=100):
    """
    Format a property value for display, truncating if necessary.
    
    Args:
        value: The property value to format
        max_length (int): Maximum length before truncation
    
    Returns:
        str: The formatted value
    """
    if value is None:
        return "<empty>"
    
    # Convert to string
    str_value = str(value)
    
    # Truncate if too long
    if len(str_value) > max_length:
        return str_value[:max_length] + "..."
    
    return str_value

def get_relationship_label(rel_type, start_label, end_label):
    """
    Generate a human-readable label for a relationship.
    
    Args:
        rel_type (str): The relationship type
        start_label (str): The label of the start node
        end_label (str): The label of the end node
    
    Returns:
        str: A human-readable relationship description
    """
    # Convert relationship type to a readable format
    readable_type = rel_type.replace('_', ' ').title()
    
    return f"{start_label} {readable_type} {end_label}"

def get_label_count(label):
    """Safe function to count nodes with a specific label."""
    try:
        # Convert label to function name
        func_name = label.lower().replace(':', '_').replace('-', '_')
        # Get the corresponding function
        func = getattr(gm.nodes, func_name, None)
        if func is None:
            return "0"
        # Execute a count query instead of fetching all nodes
        query = f"MATCH (n:{label}) RETURN count(n) AS count"
        result = gm.execute_query(query)
        return str(result[0]['count']) if result else "0"
    except Exception as e:
        print(f"Error counting {label} nodes: {e}")
        return "?"

# -----------------------------------------------------------------------------
# Routes: Core Application
# -----------------------------------------------------------------------------

@app.route('/')
@login_required
def index():
    """
    Main dashboard that serves as the entry point for both Anchor and Navigator approaches.
    Displays links to the anchor entry points.
    """
    log_activity('view_dashboard')
    
    # Get the schema information for the Anchor approach
    node_labels = gm.METADATA.get('node_labels', [])
    
    # For the Navigator approach, we'll prepare curated entry points
    # These are examples from the movie graph
    featured_movies = []
    featured_people = []
    
    try:
        # Get some featured movies
        movies = gm.get_nodes_by_label('Movie')
        if movies:
            featured_movies = movies[:5]  # First 5 movies
        
        # Get some featured people
        people = gm.get_nodes_by_label('Person')
        if people:
            featured_people = people[:5]  # First 5 people
    except Exception as e:
        flash(f"Error loading featured content: {str(e)}", "error")
    
    return render_template_string('''
        <!DOCTYPE html>
        <html>
        <head>
            <title>Coastal Explorer - Dashboard</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .card { border: 1px solid #ddd; padding: 20px; margin: 10px 0; border-radius: 5px; }
                .navigation { background: #f8f9fa; padding: 10px; margin-bottom: 20px; }
                .navigation a { margin-right: 15px; text-decoration: none; color: #007bff; }
                .navigation a:hover { text-decoration: underline; }
                ul { list-style-type: none; padding: 0; }
                li { padding: 5px 0; }
                a { color: #007bff; text-decoration: none; }
                a:hover { text-decoration: underline; }
                .flex { display: flex; gap: 20px; }
                .flex > div { flex: 1; }
            </style>
        </head>
        <body>
            <div class="navigation">
                <a href="{{ url_for('index') }}">Dashboard</a> |
                <a href="{{ url_for('schema_overview') }}">Schema</a> |
                <a href="{{ url_for('search') }}">Search</a>
            </div>
            
            <h2>Welcome to Coastal Explorer</h2>
            
            <div class="card">
                <h3>About This Explorer</h3>
                <p>
                    This application provides two complementary ways to explore your graph data:
                </p>
                <ul>
                    <li><strong>Anchor</strong>: Start with the schema (labels, relationships) and drill down to specific instances</li>
                    <li><strong>Navigator</strong>: Start with specific entities and "navigate" between connected entities</li>
                </ul>
                <p>
                    Use the navigation links at the top, or choose one of the entry points below to get started.
                </p>
            </div>
            
            <div class="flex">
                <!-- Anchor (Schema-First) Section -->
                <div>
                    <h3>Anchor Exploration</h3>
                    <p>Start by exploring the schema structure:</p>
                    
                    <div class="card">
                        <h4>Node Labels</h4>
                        <ul>
                            {% for label in node_labels %}
                            <li><a href="{{ url_for('list_nodes', label=label) }}">{{ label }}</a></li>
                            {% endfor %}
                        </ul>
                        
                        <a href="{{ url_for('schema_overview') }}">View full schema</a>
                    </div>
                </div>
                
                <!-- Navigator (Entity-First) Section -->
                <div>
                    <h3>Navigator Exploration</h3>
                    <p>Start by exploring specific entities:</p>
                    
                    <div class="card">
                        <h4>Featured Movies</h4>
                        <ul>
                            {% for movie in featured_movies %}
                            <li>
                                <a href="{{ url_for('view_node', label='Movie', node_id=movie.uuid) }}">
                                    {{ get_node_display_name(movie) }}
                                </a>
                            </li>
                            {% endfor %}
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>Featured People</h4>
                        <ul>
                            {% for person in featured_people %}
                            <li>
                                <a href="{{ url_for('view_node', label='Person', node_id=person.uuid) }}">
                                    {{ get_node_display_name(person) }}
                                </a>
                            </li>
                            {% endfor %}
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h3>Search</h3>
                <p>Find specific entities in your graph:</p>
                
                <form method="GET" action="{{ url_for('search') }}">
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text" name="q" placeholder="Search for movies, people, etc..." 
                               style="flex: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                        <button type="submit" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px;">
                            Search
                        </button>
                    </div>
                </form>
            </div>
        </body>
        </html>
    ''', node_labels=node_labels, featured_movies=featured_movies, featured_people=featured_people, get_node_display_name=lambda node: node['props'].get('name', node['props'].get('title', node['uuid'][:8] + '...')))

@app.route('/schema')
@login_required
def schema_overview():
    """
    Provide an overview of the database schema (Anchor entry point).
    Shows all node labels and relationship types.
    """
    log_activity('view_schema')
    
    node_labels = gm.METADATA.get('node_labels', [])
    relationship_types = gm.METADATA.get('edge_types', [])
    
    # Count instances of each label
    label_counts = {}
    for label in node_labels:
        try:
            nodes = gm.get_nodes_by_label(label)
            label_counts[label] = len(nodes)
        except Exception:
            label_counts[label] = "Error"
    
    return render_template_string('''
        <!DOCTYPE html>
        <html>
        <head>
            <title>Schema Overview - Coastal Explorer</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .card { border: 1px solid #ddd; padding: 20px; margin: 10px 0; border-radius: 5px; }
                .navigation { background: #f8f9fa; padding: 10px; margin-bottom: 20px; }
                .navigation a { margin-right: 15px; text-decoration: none; color: #007bff; }
                .navigation a:hover { text-decoration: underline; }
                table { width: 100%; border-collapse: collapse; margin: 10px 0; }
                th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                th { background-color: #f2f2f2; }
                a { color: #007bff; text-decoration: none; }
                a:hover { text-decoration: underline; }
            </style>
        </head>
        <body>
            <div class="navigation">
                <a href="{{ url_for('index') }}">Dashboard</a> |
                <a href="{{ url_for('schema_overview') }}">Schema</a> |
                <a href="{{ url_for('search') }}">Search</a>
            </div>
            
            <h2>Anchor: Schema-Based Entry Points</h2>
            
            <div class="card">
                <h3>Node Labels</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Label</th>
                            <th>Count</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for label in node_labels %}
                        <tr>
                            <td>{{ label }}</td>
                            <td>{{ label_counts.get(label, 'Unknown') }}</td>
                            <td><a href="{{ url_for('list_nodes', label=label) }}">View Nodes</a></td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
            
            <div class="card">
                <h3>Relationship Types</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Relationship Type</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for rel_type in relationship_types %}
                        <tr>
                            <td>{{ rel_type }}</td>
                            <td><a href="{{ url_for('list_relationships', rel_type=rel_type) }}">View Relationships</a></td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </body>
        </html>
    ''', node_labels=node_labels, relationship_types=relationship_types, label_counts=label_counts)

@app.route('/labels/<label>')
@login_required
def list_nodes(label):
    """
    List all nodes with a specific label (Anchor entry point).
    """
    log_activity('list_nodes', {'label': label})
    
    try:
        nodes = gm.get_nodes_by_label(label)
        
        # Get properties for display
        if nodes:
            # Use the first node to determine which properties to show
            display_properties = list(nodes[0]['props'].keys())[:5]  # First 5 properties
        else:
            display_properties = []
        
        return render_template_string('''
            <!DOCTYPE html>
            <html>
            <head>
                <title>{{ label }} Nodes - Coastal Explorer</title>
                <style>
                    body { font-family: Arial, sans-serif; margin: 20px; }
                    .card { border: 1px solid #ddd; padding: 20px; margin: 10px 0; border-radius: 5px; }
                    .navigation { background: #f8f9fa; padding: 10px; margin-bottom: 20px; }
                    .navigation a { margin-right: 15px; text-decoration: none; color: #007bff; }
                    .navigation a:hover { text-decoration: underline; }
                    table { width: 100%; border-collapse: collapse; margin: 10px 0; }
                    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                    th { background-color: #f2f2f2; }
                    a { color: #007bff; text-decoration: none; }
                    a:hover { text-decoration: underline; }
                </style>
            </head>
            <body>
                <div class="navigation">
                    <a href="{{ url_for('index') }}">Dashboard</a> |
                    <a href="{{ url_for('schema_overview') }}">Schema</a> |
                    <a href="{{ url_for('search') }}">Search</a>
                </div>
                
                <h2>{{ label }} Nodes</h2>
                
                {% if nodes %}
                <div class="card">
                    <table>
                        <thead>
                            <tr>
                                <th>Name</th>
                                {% for prop in display_properties %}
                                <th>{{ prop }}</th>
                                {% endfor %}
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for node in nodes %}
                            <tr>
                                <td>{{ get_node_display_name(node) }}</td>
                                {% for prop in display_properties %}
                                <td>{{ format_property_value(node.props.get(prop)) }}</td>
                                {% endfor %}
                                <td>
                                    <a href="{{ url_for('view_node', label=label, node_id=node.uuid) }}">View Details</a>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                {% else %}
                <p>No nodes found with this label.</p>
                {% endif %}
            </body>
            </html>
        ''', label=label, nodes=nodes, display_properties=display_properties, get_node_display_name=lambda node: node['props'].get('name', node['props'].get('title', node['uuid'][:8] + '...')), format_property_value=format_property_value)
    except Exception as e:
        flash(f"Error listing nodes: {str(e)}", "error")
        return redirect(url_for('index'))

@app.route('/relationships/<rel_type>')
@login_required
def list_relationships(rel_type):
    """
    List all relationships of a specific type (Anchor entry point).
    """
    log_activity('list_relationships', {'rel_type': rel_type})
    
    try:
        relationships = gm.get_relationships_by_type(rel_type)
        
        return render_template_string('''
            <!DOCTYPE html>
            <html>
            <head>
                <title>{{ rel_type }} Relationships - Coastal Explorer</title>
                <style>
                    body { font-family: Arial, sans-serif; margin: 20px; }
                    .card { border: 1px solid #ddd; padding: 20px; margin: 10px 0; border-radius: 5px; }
                    .navigation { background: #f8f9fa; padding: 10px; margin-bottom: 20px; }
                    .navigation a { margin-right: 15px; text-decoration: none; color: #007bff; }
                    .navigation a:hover { text-decoration: underline; }
                    table { width: 100%; border-collapse: collapse; margin: 10px 0; }
                    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                    th { background-color: #f2f2f2; }
                    a { color: #007bff; text-decoration: none; }
                    a:hover { text-decoration: underline; }
                </style>
            </head>
            <body>
                <div class="navigation">
                    <a href="{{ url_for('index') }}">Dashboard</a> |
                    <a href="{{ url_for('schema_overview') }}">Schema</a> |
                    <a href="{{ url_for('search') }}">Search</a>
                </div>
                
                <h2>{{ rel_type }} Relationships</h2>
                
                {% if relationships %}
                <div class="card">
                    <table>
                        <thead>
                            <tr>
                                <th>From Node</th>
                                <th>To Node</th>
                                <th>Properties</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for rel in relationships %}
                            <tr>
                                <td>
                                    <a href="{{ url_for('view_node', label=rel.start_node_label, node_id=rel.start_node_id) }}">
                                        {{ get_node_display_name(rel.start_node) }}
                                    </a>
                                </td>
                                <td>
                                    <a href="{{ url_for('view_node', label=rel.end_node_label, node_id=rel.end_node_id) }}">
                                        {{ get_node_display_name(rel.end_node) }}
                                    </a>
                                </td>
                                <td>{{ format_property_value(rel.props) }}</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                {% else %}
                <p>No relationships found with this type.</p>
                {% endif %}
            </body>
            </html>
        ''', rel_type=rel_type, relationships=relationships, get_node_display_name=lambda node: node['props'].get('name', node['props'].get('title', node['uuid'][:8] + '...')), format_property_value=format_property_value)
    except Exception as e:
        flash(f"Error listing relationships: {str(e)}", "error")
        return redirect(url_for('index'))

@app.route('/nodes/<label>/<node_id>')
@login_required
def view_node(label, node_id):
    """
    View a single node and its connections (Navigator pattern).
    """
    log_activity('view_node', {'label': label, 'node_id': node_id})
    
    try:
        # Find the specific node by ID
        node = gm.get_node_by_id(label, node_id)
        
        if not node:
            flash(f"Node not found: {node_id}", "error")
            return redirect(url_for('index'))
        
        # Find all relationships connected to this node
        incoming_relationships = gm.get_incoming_relationships(node_id)
        outgoing_relationships = gm.get_outgoing_relationships(node_id)
        
        return render_template_string('''
            <!DOCTYPE html>
            <html>
            <head>
                <title>{{ get_node_display_name(node) }} - Coastal Explorer</title>
                <style>
                    body { font-family: Arial, sans-serif; margin: 20px; }
                    .card { border: 1px solid #ddd; padding: 20px; margin: 10px 0; border-radius: 5px; }
                    .navigation { background: #f8f9fa; padding: 10px; margin-bottom: 20px; }
                    .navigation a { margin-right: 15px; text-decoration: none; color: #007bff; }
                    .navigation a:hover { text-decoration: underline; }
                    table { width: 100%; border-collapse: collapse; margin: 10px 0; }
                    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                    th { background-color: #f2f2f2; }
                    a { color: #007bff; text-decoration: none; }
                    a:hover { text-decoration: underline; }
                    .flex { display: flex; gap: 20px; }
                    .flex > div { flex: 1; }
                </style>
            </head>
            <body>
                <div class="navigation">
                    <a href="{{ url_for('index') }}">Dashboard</a> |
                    <a href="{{ url_for('list_nodes', label=label) }}">Back to {{ label }} Nodes</a> |
                    <a href="{{ url_for('schema_overview') }}">Schema</a> |
                    <a href="{{ url_for('search') }}">Search</a>
                </div>
                
                <h2>{{ get_node_display_name(node) }}</h2>
                
                <div class="card">
                    <h3>Properties</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Property</th>
                                <th>Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for key, value in node.props.items() %}
                            <tr>
                                <td>{{ key }}</td>
                                <td>{{ format_property_value(value) }}</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                
                <div class="flex">
                    <div class="card">
                        <h3>Incoming Relationships</h3>
                        {% if incoming_relationships %}
                        <table>
                            <thead>
                                <tr>
                                    <th>Type</th>
                                    <th>From Node</th>
                                    <th>Properties</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for rel in incoming_relationships %}
                                <tr>
                                    <td>{{ rel.type }}</td>
                                    <td>
                                        <a href="{{ url_for('view_node', label=rel.start_node_label, node_id=rel.start_node_id) }}">
                                            {{ get_node_display_name(rel.start_node) }}
                                        </a>
                                    </td>
                                    <td>{{ format_property_value(rel.props) }}</td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                        {% else %}
                        <p>No incoming relationships.</p>
                        {% endif %}
                    </div>
                    
                    <div class="card">
                        <h3>Outgoing Relationships</h3>
                        {% if outgoing_relationships %}
                        <table>
                            <thead>
                                <tr>
                                    <th>Type</th>
                                    <th>To Node</th>
                                    <th>Properties</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for rel in outgoing_relationships %}
                                <tr>
                                    <td>{{ rel.type }}</td>
                                    <td>
                                        <a href="{{ url_for('view_node', label=rel.end_node_label, node_id=rel.end_node_id) }}">
                                            {{ get_node_display_name(rel.end_node) }}
                                        </a>
                                    </td>
                                    <td>{{ format_property_value(rel.props) }}</td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                        {% else %}
                        <p>No outgoing relationships.</p>
                        {% endif %}
                    </div>
                </div>
            </body>
            </html>
        ''', node=node, label=label, incoming_relationships=incoming_relationships, outgoing_relationships=outgoing_relationships, get_node_display_name=lambda node: node['props'].get('name', node['props'].get('title', node['uuid'][:8] + '...')), format_property_value=format_property_value)
    
    except Exception as e:
        flash(f"Error viewing node: {str(e)}", "error")
        return redirect(url_for('index'))

# -----------------------------------------------------------------------------
# Error Handlers
# -----------------------------------------------------------------------------

@app.errorhandler(404)
def page_not_found(e):
    """
    Handle 404 Not Found errors.
    
    Args:
        e: The error
    
    Returns:
        Response: Error page
    """
    return render_template_string("""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Page Not Found - {{ config.app_name }}</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }
                .container { max-width: 600px; margin: 40px auto; padding: 20px; background-color: white; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; }
                h1 { color: #2E7D32; }
                .error-code { font-size: 72px; margin: 0; color: #ccc; }
                .button { display: inline-block; margin-top: 20px; padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none; border-radius: 4px; }
                .button:hover { background-color: #45a049; }
            </style>
        </head>
        <body>
            <div class="container">
                <p class="error-code">404</p>
                <h1>Page Not Found</h1>
                <p>The page you're looking for doesn't exist or was moved.</p>
                <a href="{{ url_for('index') }}" class="button">Return to Dashboard</a>
            </div>
        </body>
        </html>
    """, config=config), 404

@app.errorhandler(500)
def server_error(e):
    """
    Handle 500 Internal Server Error.
    
    Args:
        e: The error
    
    Returns:
        Response: Error page
    """
    # Log the error
    log_activity('server_error', additional_data={'error': str(e)})
    
    return render_template_string("""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Server Error - {{ config.app_name }}</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }
                .container { max-width: 600px; margin: 40px auto; padding: 20px; background-color: white; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; }
                h1 { color: #2E7D32; }
                .error-code { font-size: 72px; margin: 0; color: #ccc; }
                .button { display: inline-block; margin-top: 20px; padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none; border-radius: 4px; }
                .button:hover { background-color: #45a049; }
            </style>
        </head>
        <body>
            <div class="container">
                <p class="error-code">500</p>
                <h1>Server Error</h1>
                <p>Something went wrong on our end. Please try again later.</p>
                <a href="{{ url_for('index') }}" class="button">Return to Dashboard</a>
            </div>
        </body>
        </html>
    """, config=config), 500

# -----------------------------------------------------------------------------
# Application Entry Point
# -----------------------------------------------------------------------------

@app.before_request
def before_request():
    """
    Execute code before each request is processed.
    
    This function sets up request-specific variables and performs logging.
    """
    # Start timer for request duration
    g.start_time = time.time()
    
    # Add trailing slash for ping tracking, but only for non-static resources
    if config['enable_logging'] and not request.path.startswith('/static/'):
        # Check if this is a browser ping for tracking
        if request.args.get('ping') == '1':
            log_activity('link_click', additional_data={'referrer': request.referrer})

@app.after_request
def after_request(response):
    """
    Execute code after each request is processed.
    
    This function finalizes request processing and can modify the response.
    
    Args:
        response: The response object
        
    Returns:
        Response: The modified response
    """
    # Calculate request duration
    if hasattr(g, 'start_time'):
        duration = time.time() - g.start_time
        # Add timing header for debugging
        if config['debug_mode']:
            response.headers['X-Request-Duration'] = str(duration)
    
    return response

@app.template_filter('urlencode')
def urlencode_filter(s):
    """
    Template filter to URL-encode a string.
    
    Args:
        s: The string to encode
        
    Returns:
        str: The URL-encoded string
    """
    if isinstance(s, str):
        s = s.encode('utf-8')
    return quote(s)

@app.template_filter('truncate')
def truncate_filter(s, length=50, end='...'):
    """
    Template filter to truncate a string.
    
    Args:
        s: The string to truncate
        length (int): Maximum length
        end (str): String to append if truncated
        
    Returns:
        str: The truncated string
    """
    if not s:
        return ''
    
    s = str(s)
    if len(s) <= length:
        return s
    else:
        return s[:length] + end

# Start the application when run directly
if __name__ == '__main__':
    # Create log file if logging is enabled and file doesn't exist
    if config['enable_logging'] and not os.path.exists(config['log_file']):
        log_format = config['log_format'].lower()
        
        with open(config['log_file'], 'w', encoding='utf-8') as f:
            if log_format == 'csv':
                # Write CSV header
                writer = csv.DictWriter(f, fieldnames=config['log_fields'])
                writer.writeheader()
            elif log_format == 'json':
                # For JSON, we don't need a header
                pass
            else:
                # For text format, write a header comment
                f.write('# ' + '|'.join(config['log_fields']) + '\n')
    
    print(f"Starting {config['app_name']} v{config['app_version']}...")
    print(f"Debug mode: {'Enabled' if config['debug_mode'] else 'Disabled'}")
    print(f"Open your browser and navigate to http://localhost:5000")
    
    app.run(debug=config['debug_mode'])
